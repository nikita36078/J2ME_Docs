<!--
    Copyright (c) 2008 Sun Microsystems, Inc. All rights reserved.
    Use is subject to license terms.
-->

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_05) on Tue May 23 10:55:40 EEST 2006 -->
<TITLE>
Overview (JSR-135)
</TITLE><meta name="collection" content="api">

<META NAME="keywords" CONTENT="Overview">

<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Overview (JSR-135)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A><small><b>Use is subject to <a href="http://java.sun.com/javame/reference/apis/license.html" target="_top">License Terms</a>.</b> Your use of this web site or any of its contents or software indicates your agreement to be bound by these License Terms.<br><br>Copyright &copy; 2002-2006 Sun Microsystems, Inc.; Nokia Corporation. All rights reserved. See the <a href="copyright.html">Copyright Notice and Specification License</a> for more details.</small><hr>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Overview</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
MMAPI 1.2</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?overview-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="overview-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>

Mobile Media API (JSR-135)
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#overview_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Packages</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="javax/microedition/media/package-summary.html">javax.microedition.media</A></B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="javax/microedition/media/control/package-summary.html">javax.microedition.media.control</A></B></TD>
<TD>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="javax/microedition/media/protocol/package-summary.html">javax.microedition.media.protocol</A></B></TD>
<TD>&nbsp;</TD>
</TR>
</TABLE>

<P>
&nbsp;<A NAME="overview_description"><!-- --></A>
<P>
<h1>
Mobile Media API (JSR-135)</h1>

<h2>
JCP Specification</h2>

<hr>
<h2>
Preface</h2>

<div>
<blockquote>This document, <i>Mobile Media API (JSR-135) Specification</i>,
defines the Multimedia API for the Java <sup><font size=-2>TM</font></sup> 
2 Platform, Micro Edition (J2ME<sup><font size=-2>TM</font></sup>).
</blockquote>
</div>

<h2 class="SectionTitle">
Revision History</h2>

<blockquote>
<table BORDER CELLPADDING=3 class="Table" >

<tr>
<th>
<div class="TableHead">Date</div>
</th>

<th>
<div class="TableHead">Version</div>
</th>

<th>
<div class="TableHead">Description</div>
</th>
</tr>

<tr>
<td>
<div class="TableText">18-August-2001</div>
</td>

<td>
<div class="TableText">MMAPI, 1st Draft</div>
</td>

<td>
<div class="TableText">Initial MMAPI draft proposed for the Aug. 30-31
Expert Group meeting</div>
</td>
</tr>

<tr>
<td>
<div class="TableText">2-October-2001</div>
</td>

<td>
<div class="TableText">MMAPI, 1st EG Draft</div>
</td>

<td>
<div class="TableText">Incorporated changes agreed during the Aug. 30-31
Expert Group meeting</div>
</td>
</tr>

<tr>
<td>
<div class="TableText">5-October-2001</div>
</td>

<td>
<div class="TableText">MMAPI, Community Draft, v. 0.8</div>
</td>

<td>
<div class="TableText">MMAPI Community review draft version</div>
</td>
</tr>

<tr>
<td>
<div class="TableText">16-November-2001</div>
</td>

<td>
<div class="TableText">MMAPI, EG Draft v. 0.85</div>
</td>

<td>
<div class="TableText">Incorporated changes agreed during the Nov. 5-6
Expert Group meeting</div>
</td>
</tr>

<tr>
<td>
<div class="TableText">10-December-2001</div>
</td>

<td>
<div class="TableText">MMAPI, EG Draft v. 0.86</div>
</td>

<td>
<div class="TableText">Incorporated changes made in the EG mailing list
discussion</div>
</td>
</tr>

<tr>
<td>28-January-2002</td>

<td>
<div class="TableText">MMAPI, Public Draft, v. 0.9</div>
</td>

<td>
<div class="TableText">MMAPI Public review draft version</div>
</td>
</tr>

<tr>
<td>11-March-2002</td>

<td>MMAPI, Revised Public Draft, v. 0.95</td>

<td>MMAPI Revised&nbsp; Public draft version</td>
</tr>

<tr>
<td>26-April-2002</td>

<td>MMAPI, EG Draft v.0.96</td>

<td>Incorporated changes agreed in the EG meeting &amp; proposed in public
review</td>
</tr>

<tr>
<td>02-May-2002</td>

<td>MMAPI, EG Draft v.0.97</td>

<td>Incorporated changes agreed in the EG meeting 30.04.2002</td>
</tr>

<tr>
<td>09-May-2002</td>

<td>MMAPI, EG Draft v. 0.98</td>

<td>Incorporated changes agreed in the EG meeting 07.05.2002</td>
</tr>

<tr>
<td>23-May-2002</td>

<td>MMAPI, Proposed Final Draft, v. 1.0</td>

<td>MMAPI Proposed Final Draft Version</td>
</tr>

<tr>
<td>24-June-2002</td>

<td>MMAPI, v. 1.0</td>

<td>MMAPI Final Version</td>
</tr>

<tr>
<td>9-April-2003</td>

<td>MMAPI, Draft a, v.1.1</td>

<td>MMAPI Draft a of Version 1.1</td>
</tr>

<tr>

<td>24-April-2003</td>

<td>MMAPI, Draft b, v.1.1</td>

<td>MMAPI Draft b of Version 1.1</td>
</tr>
<tr>

<td>4-June-2003</td>

<td>MMAPI, v.1.1</td>

<td>MMAPI 1.1 Final Version</td>
</tr>
<tr>

<td>13-March-2006</td>

<td>MMAPI, Draft a, v.1.2</td>

<td>MMAPI Draft a of Version 1.2</td>
</tr>

<tr>

<td>13-April-2006</td>

<td>MMAPI, Draft b, v.1.2</td>

<td>MMAPI Draft b of Version 1.2</td>
</tr>

<tr>
<td>11-May-2006</td>

<td>MMAPI, Draft c, v.1.2</td>

<td>MMAPI Draft c of Version 1.2</td>
</tr>

<tr>

<td>22-May-2006</td>

<td>MMAPI, v.1.2</td>

<td>MMAPI 1.2 Final Version</td>
</tr>

</table>
</blockquote>


<h2 class="SectionTitle">
Who Should Use This Specification</h2>

<div class="Paragraph">
<blockquote>The audience for this document is the public Java community
reviewing this specification and the Java Community Process (JCP) expert group
defining this specification, implementors of the Multimedia API, and application
developers targeting the J2ME platform.</blockquote>
</div>

<div class="Paragraph">
<blockquote>The MMAPI specification is an <i>optional package. </i>An
optional package can be adopted to existing J2ME <i>profiles</i>. A profile
of J2ME defines device-type-specific sets of APIs for a particular vertical
market or industry. Profiles are more exactly defined in the related publication,
<i>Configurations and Profiles Architecture Specification</i>, Sun Microsystems,
Inc.</blockquote>
</div>

<h2 class="SectionTitle">
Related Literature</h2>

<div class="Paragraph">
<blockquote><i>The Java Language Specification</i> by James Gosling, Bill
Joy, and Guy L. Steele. Addison-Wesley, 1996, ISBN 0-201-63451-1
<br><a href="http://java.sun.com/products/cldc/">Connected, Limited Device
Configuration (JSR-30), Sun Microsystems, Inc.</a>
<br><a href="http://java.sun.com/products/cdc/">Connected Device Configuration
(JSR-36), Sun Microsystems, Inc.</a>
<br><a href="http://java.sun.com/products/midp/">Mobile Information Device
Profile (JSR-37), Sun Microsystems, Inc.</a>
<br><a href="http://jcp.org/jsr/detail/118.jsp">Mobile Information Device
Profile 2.0 (JSR-118), Sun Microsystems, Inc.</a>
<br><a href="http://java.sun.com/products/java-media/jmf/">Java Media Framework,
Sun Microsystems, Inc.</a></blockquote>
</div>

<h2>
Introduction</h2>

<blockquote>Many multimedia types and formats exist in today's market, and
new types and formats are being introduced all the time. There are also
many, diverse methods to store and deliver these various media types. For
example, there are traditional storage devices (such as disk file systems,
CDs, and DVDs), wired protocols (UDP, HTTP, etc.) and wireless protocols
(WAP, etc.).
<p>J2ME<sup><font size=-2>TM</font></sup> devices range from cell phones
with simple tone generation to PDAs and web tablets with advanced audio
and video rendering capabilities. To accommodate diverse configurations
and multimedia processing capabilities, an API with a high level of 
abstraction is needed.
<p>The MMAPI Expert Group has also contributed to the ongoing JSR-118
(Mobile Information Device Profile 2.0) JCP specification,
and the target is to make MMAPI a direct superset
of the JSR-118 MIDP 2.0 Media API.
<p>MMAPI v1.2 introduces security definitions for CDC based implementations.

</blockquote>

<h2>
Expert Group</h2>

<blockquote>The MMAPI Expert Group consists of the following companies:
<ul>
<li>
Nokia (Specification Lead)</li>

<li>
Aplix Corporation</li>

<li>
Beatnik, Inc.</li>

<li>
France Telecom</li>

<li>
Insignia Solutions</li>

<li>
Mitsubishi Electric Corp.</li>

<li>
Motorola</li>

<li>
Netdecisions Holdings United</li>

<li>
NTT DoCoMo, Inc.</li>

<li>
Openwave Systems Inc.</li>

<li>
PacketVideo Corporation</li>

<li>
Philips</li>

<li>
Siemens AG ICM MP TI</li>

<li>
Smart Fusion</li>

<li>
Sun Microsystems, Inc.</li>

<li>
Symbian Ltd</li>

<li>
Texas Instruments Inc.</li>

<li>
Vodafone</li>

<li>
Yamaha Corporation</li>

<li>
Zucotto Wireless</li>
</ul>
</blockquote>

<h2>
Features</h2>

<blockquote>MMAPI features the following:</blockquote>

<blockquote>
<table BORDER CELLPADDING=3 class="Table">

<tr>
<th>
Feature
</th>
<th>
Description
</th>
</tr>

<tr>
<td>
Support for Tone Generation, Playback and Recording of Time Based Media
</td>
<td>
The API supports any time-based audio and video content by offering
tools to control the flow of the media stream. Tone generation is a special
media type that is characterized by frequency and duration.
</td>
</tr>

<tr>
<td>
CLDC Target
</td>
<td>
The main target for the API is a CLDC based device. Other environments
(e.g. CDC) are not excluded, but CLDC is the lowest common denominator.
<p>
<font size=-1>
Note: MMAPI references <code>IllegalStateException</code> which is
not present in CLDC 1.0.  As such, it is required that the underlying
platform (configuration/profile), such as CLDC1.0/MIDP1.0, includes that 
exception.
</font>
</td>
</tr>

<tr>
<td>
Small Footprint
</td>
<td>
CLDC as the target configuration sets strict limits for memory consumption.
Design of the API emphasizes that as much as possible.
</td>
</tr>

<tr>
<td>
Protocol and Content Agnostic
</tr>
</td>
<td>
The design of the API is not biased towards any specific protocol or
content type.
</td>
</tr>

<tr>
<td>
Subsettable: Audio-only vs. General Multimedia
</td>
<td>
It is possible to separate a subset of the API in order to provide
support for only some type of content (e.g. for basic audio). 
It allows profiles that cannot support all the features of the 
full API to only take the parts that are needed.
</td>
</tr>

<tr>
<td>
Extensible
</td>
<td>
<br>The API is designed in a way that allows new features to be added later
without breaking the old functionality.
</td>
</tr>

<tr>
<td>
Optionality for Implementation
</td>
<td>
The API offers a wide range of features for different purposes. Design of
the API allows implementations that can't provide real support for all
the features to leave some of them unimplemented.
</td>
</tr>
</table>
</blockquote>

<h2>
Overview of MMAPI</h2>

<blockquote>This section provides a high-level overview of MMAPI.
Short code examples in the 
<a href="#scenarios">Usage Scenarios</a> section illustrate 
practical use 
of the API.  
<h3>
Basic Concepts: Protocol and Content Handling</h3>

<blockquote>
Basically, multimedia processing can be broken into two parts:
<ol>
<li>
Handling the data delivery protocol
</li>
<li>
Handling the data content
</li>
</ol>

<i>Protocol handling</i> refers to reading data from a source (such as
a file, capture device, or streaming server) into a media processing system.
<i>Content handling</i> usually requires processing the media data 
(parsing or decoding, for example) and rendering the media to output devices 
such as an audio speaker or video display.
<p>
Two high-level objects are used in this API: <tt>DataSource</tt> and
<tt>Player</tt>.  Each object encapsulates the two parts of multimedia 
processing:
<p>

<blockquote>
<img SRC="1-ds-player.gif" ALT="DataSource and Player" >
</blockquote>

<ol>
<li>
<tt>DataSource</tt> for protocol handling
</li>
<li>
<tt>Player</tt> for content handling
</li>
</ol>

A <tt>DataSource</tt> encapsulates protocol handling. It hides the
details of how the data is read from its source, whether the data is coming
from a file, streaming server, or proprietary delivery mechanism. 
<tt>DataSource</tt>
provides a set of methods to allow a <tt>Player</tt> to read data from
it for processing.
<p>
A <tt>Player</tt> reads from the <tt>DataSource</tt>, processes the
data, and renders the media to the output device.  It provides a set
of methods to control media playback and basic synchronization. 
<tt>Player</tt>s also provide some type-specific controls to access 
features for specific media types.
<p>
A factory mechanism, the <tt>Manager</tt>, creates
<tt>Player</tt>s from <tt>DataSource</tt>s.  For convenience,
<tt>Manager</tt> also provides methods to create <tt>Player</tt>s
from locators and <tt>InputStream</tt>s.
<blockquote>
<img SRC="2-ds-player-mngr.gif" ALT="DataSource, Player and Manager" >
</blockquote>
</blockquote>

<h3>API Details</h3>

<blockquote>
The <tt>createPlayer</tt> method is the top-level entry point to the API:
<blockquote>
<pre><tt>Player Manager.createPlayer(String urlString)</tt></pre>
</blockquote>
The <tt>urlString</tt> fully specifies the protocol and the content of
the data:
<blockquote>
<pre><tt>&lt;protocol>:&lt;content location></tt></pre>
</blockquote>
The <tt>Manager</tt> parses the URL and creates a <tt>DataSource</tt> to
handle the specified data delivery protocol.
The <tt>DataSource</tt> derives the content type from the data. 
The <tt>Manager</tt> then takes
this content type and creates a <tt>Player</tt> to handle the presentation
of the data. The resulting <tt>Player</tt> is returned for use by 
the application.
<p>
The <tt>Player</tt> provides general methods to control data flow
and presentation, for example:
<blockquote>
<pre>
Player.realize()
Player.prefetch()
Player.start()
Player.setMediaTime(long time)
</pre>
</blockquote>
Fine-grained control is an important feature of the API.  Therefore, each
<tt>Player</tt> also provides type-specific controls with the 
<tt>getControls </tt>and<tt> getControl</tt> methods:
<blockquote>
<pre>
Control[] Player.getControls()
Control Player.getControl(String controlType)
</pre>
</blockquote>
Since each type of media will yield different types of controls from
its corresponding <tt>Player</tt>, the <tt>getControls and getControl</tt>
methods expose features that are unique to a particular media type.
For example, for the MIDI type, you can receive a <tt>MIDIControl</tt>
from the <tt>Player</tt>'s <tt>getControl</tt> method.</blockquote>

<h3>System Properties</h3>

<blockquote>
MMAPI has some properties that can be queried by 
<tt>System.getProperty(String key)</tt>. Currently, the following keys 
are defined:
<p>
<table BORDER CELLPADDING=3 class="Table">

<tr>
<th>
Key
</th>
<th>
Description
</th>
</tr>

<tr>
<td>
<tt>microedition.media.version</tt> 
</td>
<td>
The string returned designates the version of the MMAPI
specification that is implemented.
For implementations on configurations and profiles that contain <code>java.security.Permission</code>
 the value MUST be "1.2", otherwise the value MUST be either "1.1" or "1.2".
</td>
</tr>

<tr>
<td>
<tt>supports.mixing</tt>
</td>
<td>
Query for whether audio mixing is supported.
The string returned is either <tt>"true"</tt> or <tt>"false"</tt>.
If mixing is supported, the following conditions are true:
<ul>
<li>
At least two tones can be played with <code>Manager.playTone</code> 
simultaneously.
<li>
<code>Manager.playTone</code> can be used at the same time when at 
least one <code>Player</code> is playing back audio.
<li>
At least two <code>Players</code> can be used to play back audio 
simultaneously.
</ul>
</td>
</tr>

<tr>
<td>
<tt>supports.audio.capture</tt> 
</td>
<td>
Query for whether audio capture is supported. 
The string returned is either <tt>true</tt> or <tt>false</tt>.
If <tt>supports.audio.capture</tt> is true, <tt>audio.encoding</tt>
must not be <code>null</code> or empty.
</td>
</tr>

<tr>
<td>
<tt>supports.video.capture</tt> 
</td>
<td>
Query for whether video capture is supported. 
The string returned is either <tt>true</tt> or <tt>false</tt>.
If <tt>supports.video.capture</tt> is true, <tt>video.encoding</tt>
must not be <code>null</code> or empty.
</td>
</tr>

<tr>
<td>
<tt>supports.recording</tt> 
</td>
<td>
Query for whether recording is supported.
The string returned is either <tt>true</tt> or <tt>false</tt>.
If supports.recording is true, at least one <tt>Player</tt>
type supports recording.
</td>
</tr>

<tr>
<td>
<tt>audio.encodings</tt> 
</td>
<td>
The string returned specifies the supported capture
audio formats.  Each format is specified in the
<a href="javax/microedition/media/Manager.html#audio_encodings">audio
encoding syntax</a>. The formats are delimited by at least one space.
If audio capture is not supported, <code>audio.encoding</code> 
returns <code>null</code>.
</td>
</tr>

<tr>
<td>
<tt>video.encodings</tt> 
</td>
<td>
The string returned specifies the supported capture
video formats.  Each format is specified in the
<a href="javax/microedition/media/Manager.html#video_encodings">video
encoding syntax</a>. The formats are delimited by at least one space.
If video capture is not supported, <code>video.encoding</code> 
returns <code>null</code>.
</td>
</tr>

<tr>
<td>
<a name="video.snapshot.encodings"></a>
<tt>video.snapshot.encodings</tt> 
</td>
<td>
Supported video snapshot formats for the
<a href="javax/microedition/media/control/VideoControl.html#getSnapshot(java.lang.String)">getSnapshot</a>
method in VideoControl. The string returned specifies the supported capture
image formats. Each format is specified in the 
<a href="javax/microedition/media/Manager.html#video_encodings">image encoding
syntax</a>. The formats are delimited by at least one space.  The first
format returned is the default.
If video snapshot is not supported, <code>video.snapshot.encoding</code> 
returns <code>null</code>.
</td>
</tr>

<tr>
<td>
<tt>streamable.contents</tt> 
</td>
<td>
The string returned specifies the supported streamable content types.
Media of these content types will be handled by the <code>Player</code>
as streamable media -- media that is played as the data is received
by the <code>Player</code>.  Playing back media of this type does not
require the <code>Player</code> to buffer the entire content.  The
content types are given in the MIME syntax as specified in
<a href="javax/microedition/media/Manager.html#content-type">
content types</a>, each delimited by at least one space.
</td>
</tr>

</table>
</blockquote>

<h3>
Tone Generation</h3>

<blockquote>Tone generation is important for games and other audio applications.
On very small devices, it is particularly important since it is likely
to be the only form of multimedia capability.
In its simplest form, tone generation reduces to a single buzzer or some simple
monophonic tone generation.  The <tt>Manager</tt> class provides a
top level method to handle this simple form of single tone generation:
<blockquote>
<tt>Manager.playTone(int note, int duration, int volume)</tt>
</blockquote>
The implementation of this method can be mapped directly to a device's
hardware tone generator to provide the most responsive sound generation.
<p>
In addition, the API provides a way to create a specific type of
<tt>Player</tt> for synthesizing tone sequences:
<blockquote>
<tt>Player p = Manager.createPlayer(Manager.TONE_DEVICE_LOCATOR)</tt>
</blockquote>
The <tt>Player</tt> created provides a special type of <tt>Control</tt>,
nbsp;<tt>ToneControl</tt>
which can be used for programming a tone sequence. This enables more
sophisticated applications written for slightly more powerful devices.
<p>
The <code>ToneControl</code> interface specifies a
<a href="javax/microedition/media/control/ToneControl.html#tone_sequence_format">
tone sequence format</a> to be used for
programming a tone sequence.  In addition, this tone sequence format
can also be used as a file format for specifying tone sequences.
A file with the ".jts" extension must be used to store tone sequences
in this format.  <code>"audio/x-tone-seq"</code> designates the MIME 
type for this format.
</blockquote>

<h3>
Camera</h3>
<blockquote>
MMAPI provides support for a camera. From the API point of view,
a camera attached to a device doesn't really differ from any other 
video content. Camera has a special locator <tt>"capture://video"</tt> 
that is used to create its <tt>Player</tt>. An application uses 
<tt>VideoControl</tt> to display the view finder on the screen and 
take pictures.
<p>
<tt>VideoControl.getSnapshot(String imageType)</tt> is used to capture a 
camera's picture.  The <code>imageType</code> parameter specifies
the format of the snapshot. 
The <tt>video.snapshot.encodings</tt> key
can be used to query the supported snapshot formats from the system.
<p>
<a href="#scenario-11">Scenario 11</a> shows how to use the camera, and
<a href="javax/microedition/media/Manager.html#media-locator">Manager</a> 
documents different locators for creating the camera's <tt>Player</tt>.

</blockquote>
</blockquote>

<h2>
Optionality and Implementation Requirements</h2>

<blockquote>
Not all implementations of MMAPI support all multimedia types
and input protocols.  Some implementations may support only a few
selected types and protocols.  For example, some may support only playback 
of local audio files.  The design of MMAPI allows 
implementations to provide optional support for different
media types and protocols.
<p>
<tt>Manager</tt> provides <tt>getSupportedContentTypes</tt> and 
<tt>getSupportedProtocols</tt> to query for supported media types 
and protocols.
An application can also attempt to create a <tt>Player</tt>
from <tt>Manager</tt> given the media input.  If the content type
or the protocol specified is not supported, the <tt>Player</tt> creation
methods throw an <tt>Exception</tt>.
<p>
Since MMAPI is an optional package, it does not mandate any particular
media types or protocols.  Required types and protocols are to be
determined by the appropriate profiles adopting MMAPI (e.g. JSR 118).
However, an implementation must guarantee support of at least one media 
type and protocol.
<p>
MMAPI also allows implementations to support optional features.
For example, some implementations may support only media playback,
but not recording.
Or some devices may support volume control while others may not.
MMAPI allows implementations to expose these optional features as applicable.
<p>
Optional features are organized as <tt>Control</tt>s.
A <tt>Player</tt> can be queried for all of its supported <tt>Control</tt>s
by using <tt>getControls</tt> or a particular type of <tt>Control</tt> by using
<tt>getControl</tt>.
<p>
MMAPI mandates support of some features for some media types.
Other features are recommended while others are entirely optional.
This guarantees some uniformity across different implementations.
Feature sets are organized as described below.  For the
purpose of this discussion, the following definitions are used:

<h3 class="SectionTitle">Definitions</h3>

<blockquote>
<div class="Paragraph">
This document uses definitions based upon those specified in RFC 2119 
(See <a href="http:// www.ietf.org">http://www.ietf.org</a>).
</div>
<p>
<table BORDER CELLPADDING=3 class="Table" >

<tr>
<th>
<div class="TableHead">Term</div>
</th>

<th>
<div class="TableHead">Definition</div>
</th>
</tr>

<tr>
<td>
<div class="TableText">MUST</div>
</td>
<td>
<div class="TableText">The associated definition is an absolute requirement
of this specification.</div>
</td>
</tr>

<tr>
<td>
<div class="TableText">MUST NOT</div>
</td>
<td>
<div class="TableText">The definition is an absolute prohibition of this
specification.</div>
</td>
</tr>

<tr>
<td>
<div class="TableText">SHOULD</div>
</td>
<td>
<div class="TableText">Indicates a recommended practice. There may exist
valid reasons in particular circumstances to ignore this recommendation,
but the full implications must be understood and carefully weighed before
choosing a different course.</div>
</td>
</tr>

<tr>
<td>
<div class="TableText">SHOULD NOT</div>
</td>
<td>
<div class="TableText">Indicates a non-recommended practice. There may
exist valid reasons in particular circumstances when the particular behavior
is acceptable or even useful, but the full implications should be understood
and the case carefully weighed before implementing any behavior described
with this label.</div>
</td>
</tr>

<tr>
<td>
<div class="TableText">MAY</div>
</td>
<td>
<div class="TableText">Indicates that an item is truly optional.</div>
</td>
</tr>
</table>
</blockquote>


<h3>Feature Sets</h3>

<blockquote>
The following feature sets are defined for five different types of
media.  When a <tt>Player</tt> is created for a particular type, it
<i>must</i> follow these guidelines and implement the appropriate 
<tt>Control</tt> types:
<p>
<table BORDER CELLPADDING=3 class="Table">

<tr>
<th>
Feature Set
</th>
<th>
Implementation Requirements
</th>
</tr>

<tr>
<td>
Sampled Audio 
</td>
<td>
<ul>
<li>
<i>Should</i> implement <tt>VolumeControl</tt>, <tt>StopTimeControl.</tt></li>
</ul>
</td>
</tr>

<tr>
<td>
MIDI 
</td>
<td>
<ul>
<li>
<i>Should</i> implement <tt>VolumeControl</tt>, <tt>MIDIControl</tt>, 
<tt>TempoControl</tt>, <tt>PitchControl</tt>, <tt>StopTimeControl.</tt></li>
</ul>
</td>
</tr>

<tr>
<td>
Tone Sequence (<tt>Player</tt> for <tt>TONE_DEVICE_LOCATOR</tt>) 
</td>
<td>
<ul>
<li>
<i>Must</i> implement <tt>ToneControl.</tt></li>
<li>
<i>Should</i> implement <tt>VolumeControl</tt>, <tt>StopTimeControl.</tt></li>
</ul>
</td>
</tr>

<tr>
<td>
Interactive MIDI (<tt>Player</tt> for <tt>MIDI_DEVICE_LOCATOR</tt>) 
</td>
<td>
<ul>
<li>
<i>Must</i> implement <tt>MIDIControl</tt>.</li>
</ul>
</td>
</tr>

<tr>
<td>
Video
</td>
<td>
<ul>
<li>
<i>Must</i> implement <tt>VideoControl</tt>.</li>
<li>
<i>Should</i> implement <tt>FramePositioningControl</tt>, 
<tt>StopTimeControl</tt>, <tt>VolumeControl</tt> 
(if audio is also available).</li>
</ul>
</td>
</tr>

</table>
</blockquote>

<blockquote>
The following controls belong to none of the above feature sets.
Implementations <i>may</i> implement them when applicable: 
<tt>GUIControl</tt>,
<tt>MetaDataControl</tt>,
<tt>RateControl</tt>,
<tt>RecordControl</tt>.
</blockquote>

</blockquote>

<h2>Testing and Runtime Requirements</h2>

<blockquote>
A <code>Player</code> has five states:
<i>UNREALIZED</i>,
<i>REALIZED</i>,
<i>PREFETCHED</i>,
<i>STARTED</i> and
<i>CLOSED</i>.
A <code>Player</code> implementation must allow successful
state transition to each of these states using the six 
state-transition methods: 
<ul>
<li><code>realize</code>
<li><code>prefetch</code>
<li><code>start</code>
<li><code>stop</code>
<li><code>deallocate</code>
<li><code>close</code>
</ul>
This means that the implementation must guarantee that these methods 
succeed under normal runtime conditions. This is to ensure that an
implementation provides <code>Player</code>s that are functional.
</blockquote>

<h2>Security Considerations</h2>
<blockquote>
The <a href="jsr135_rp.html">
Multimedia Security Addendum</a> defines the security requirements
for MMAPI.
</blockquote>

<h2>The MIDP 2.0 Sound Subset</h2>

<blockquote>Some J2ME<sup><font size=-2>TM</font></sup> devices are very
resource constrained. It may not be feasible for a device to support a
full range of multimedia types, such as video, on some cell phones. 
As a result, not all devices are required to support the full generality of
a multimedia API, such as extensibility to support custom protocols and
content types.
<p>
For the MID profile, version 2.0 (JSR 118), the size of the API is another
determining factor.  A special subset of MMAPI has been derived to address 
the specific needs of MIDP. This proposed subset fulfills the requirements 
set by the MIDP 2.0 Expert Group.  These include:
<ul>
<li>
Low footprint audio playback</li>
<li>
Protocol and content format agnostic</li>
<li>
Support for tone generation</li>
<li>
Support for general media flow controls: start, stop, seek etc.</li>
<li>
Support for media-specific type controls: volume etc.</li>
<li>
Support for capability query</li>
</ul>

This subset differs from the general multimedia API in the following ways:

<ul>
<li>
It is audio-only.  It excludes all <tt>Control</tt>s specific to video
or graphics.</li>

<li>
It does not support synchronizing simultaneous playback of
multiple <code>Player</code>s using a common time base.</li>

<li>
It does not support custom protocols at the application level.  The
<tt>javax.microedition.media.protocol
</tt>package
(<tt>DataSource</tt>) is excluded.</li>

<li>
A simplified version of <tt>Manager</tt> is used.</li>
</ul>
It is important to note that the MIDP 2.0 subset is a proper subset of
the full MMAPI specification and is fully forward compatible with MMAPI.
</blockquote>

<h2>
Future Extensions</h2>

<blockquote>Currently, MMAPI targets general media playback.
As such, it does not cover the following areas of multimedia:
<ul>
<li>
3D graphics and animation</li>

<li>
General media transcoding</li>

<li>
Editing</li>

<li>
Server-side streaming: transmission</li>
</ul>
It is our intent that by staying with a high level of abstraction, we will
be able to extend the API to support the above features.This has
been demonstrated by the Java<sup><font size=-2>TM</font></sup> Media Framework
which employs a similar paradigm. 
</blockquote>

<h2>
<a name="scenarios"></a>
Usage Scenarios</h2>

<blockquote>
This section provides some common scenarios of how the API could be used.

<h4>Scenario 1: Single-Tone Generation</h4>

<blockquote>
<pre>
try {
    Manager.playTone(ToneControl.C4, 5000 /* millisec */, 100 /* max vol */);
} catch (MediaException e) { }
</pre>
</blockquote>

<h4>Scenario 2: Simple Media Playback with Looping</h4>

<blockquote>
<pre>
try {
    Player p = Manager.createPlayer("http://webserver/music.mp3");
    p.setLoopCount(5);
    p.start();
} catch (IOException ioe) {
} catch (MediaException me) { }
</pre>
</blockquote>

<h4>Scenario 3: Fine-Grained Playback Control</h4>

<blockquote>
<pre>
static final long SECS_TO_MICROSECS = 1000000L;

Player p;
VolumeControl vc;

try {
    p = Manager.createPlayer("http://webserver/music.mp3");
    p.realize();

   // Set a listener.
   p.addPlayerListener(new Listener());
   // Grab volume control for the player.
   // Set Volume to max.
   vc = (VolumeControl)p.getControl("VolumeControl");
   if (vc != null)
      vc.setLevel(100);

   // Set a start time.
   p.setMediaTime(5 * SECS_TO_MICROSECS);

   // Guarantee that the player can start with the smallest latency.
   p.prefetch();

   // Non-blocking start
   p.start();
} catch (IOException ioe) {
} catch (MediaException me) { }

class Listener implements PlayerListener {

    public void playerUpdate(Player p, String event, Object eventData) {

        if (event == END_OF_MEDIA || event == STOP_AT_TIME) {
            System.out.println("Done processing");
            try {
                p.setMediaTime(5 * SECS_TO_MICROSECS);
                p.start();
            } catch (MediaException me) { }
            break;
        }
    }
}</pre>
</pre>
</blockquote>

<h4>Scenario 4: MIDI Playback with Some Fine-Grained Control</h4>

<blockquote>
<pre>
Player p;
TempoControl tc;

try {
    p = Manager.createPlayer("http://webserver/tune.mid");
    p.realize();

    // Grab the tempo control.
    tc = (TempoControl)p.getControl("TempoControl");
    tc.setTempo(120000); // 120 beats/min
    p.start();

} catch (IOException ioe) {
} catch (MediaException me) { }
</pre>
</blockquote>

<h4>Scenario 5: Video Playback</h4>

<blockquote>
<pre>
Player p;
VideoControl vc;

try {
    p = Manager.createPlayer("http://webserver/movie.mpg");
    p.realize();

    // Grab the video control and set it to the current display.
    vc = (VideoControl)p.getControl("VideoControl");
    if (vc != null) {
        Form form = new Form("video");
        form.append((Item)vc.initDisplayMode(vc.USE_GUI_PRIMITIVE, null));
        Display.getDisplay(midlet).setCurrent(form);
    }

    p.start();

} catch (IOException ioe) {
} catch (MediaException me) { }
</pre>
</blockquote>

<h4>
Scenario 6: Playing Back from Media Stored in RMS</h4>

<blockquote>
<pre>
RecordStore rs;
int recordID;
   :  // code to set up the record store.

try {
    InputStream is = new
    ByteArrayInputStream(rs.getRecord(recordID));
    Player p = Manager.createPlayer(is, "audio/X-wav");
    p.start();
} catch (IOException ioe) {
} catch (MediaException me) { }
</pre>
</blockquote>

<h4>
Scenario 7: Playing Back from Media Stored in JAR</h4>

<blockquote>
<pre>
/** Notice that in MIDP 2.0, the wav format is mandatory only */
/** in the case that the device supports sampled audio.       */

try {
    InputStream is = getClass().getResourceAsStream("audio.wav");
    Player p = Manager.createPlayer(is, "audio/X-wav");
    p.start();
} catch (IOException ioe) {
} catch (MediaException me) { }
</pre>
</blockquote>

<h4>Scenario 8: Synchronization of Different Players</h4>

<blockquote>
<pre>
Player p1, p2;

try {
    p1 = Manager.createPlayer("http://webserver/tune.mid");
    p1.realize();
    p2 = Manager.createPlayer("http://webserver/movie.mpg");
    p2.realize();
    p2.setTimeBase(p1.getTimeBase());
    p1.prefetch();
    p2.prefetch();
    p1.start();
    p2.start();
} catch (IOException ioe) {
} catch (MediaException me) { }
</pre>
</blockquote>

<h4>Scenario 9: Tone Sequence Generation</h4>

<blockquote>
<pre>
/**
 * "Mary Had A Little Lamb" has "ABAC" structure.
 * Use block to repeat "A" section. 
 */
byte tempo = 30; // set tempo to 120 bpm 
byte d = 8;      // eighth-note 

byte C4 = ToneControl.C4;; 
byte D4 = (byte)(C4 + 2); // a whole step 
byte E4 = (byte)(C4 + 4); // a major third 
byte G4 = (byte)(C4 + 7); // a fifth 
byte rest = ToneControl.SILENCE; // rest 

byte[] mySequence = {
    ToneControl.VERSION, 1,   // version 1
    ToneControl.TEMPO, tempo, // set tempo
    ToneControl.BLOCK_START, 0,   // start define "A" section
    E4,d, D4,d, C4,d, E4,d,       // content of "A" section
    E4,d, E4,d, E4,d, rest,d,           
    ToneControl.BLOCK_END, 0,     // end define "A" section
    ToneControl.PLAY_BLOCK, 0,    // play "A" section
    D4,d, D4,d, D4,d, rest,d,     // play "B" section
    E4,d, G4,d, G4,d, rest,d,
    ToneControl.PLAY_BLOCK, 0,    // repeat "A" section
    D4,d, D4,d, E4,d, D4,d, C4,d  // play "C" section
}; 

try{ 
    Player p = Manager.createPlayer(Manager.TONE_DEVICE_LOCATOR); 
    p.realize(); 
    ToneControl c = (ToneControl)p.getControl("ToneControl"); 
    c.setSequence(mySequence); 
    p.start(); 
} catch (IOException ioe) { 
} catch (MediaException me) { }
</pre>
</blockquote>

<h4>Scenario 10: Capture and Recording</h4>

<blockquote>
<pre>
try {
    // Create a DataSource that captures live audio.
    Player p = Manager.createPlayer("capture://audio");
    p.realize();
    // Get the RecordControl, set the record location, and 
    // start the Player and record for 5 seconds.
    RecordControl rc = (RecordControl)p.getControl("RecordControl");
    rc.setRecordLocation("file:/tmp/audio.wav");
    rc.startRecord();
    p.start();
    Thread.currentThread().sleep(5000);
    p.stop();
    rc.stopRecord();
    rc.commit();
} catch (IOException ioe) {
} catch (MediaException me) {
} catch (InterruptedException e) { }
</pre>
</blockquote>

<a name="scenario-11">
<h4>Scenario 11: Camera</h4>
</a>

<blockquote>
<pre>
Player p;
VideoControl vc;

// initialize camera 
try {
    p = Manager.createPlayer("capture://video");
    p.realize();

    // Grab the video control and set it to the current display.
    vc = (VideoControl)p.getControl("VideoControl");
    if (vc != null) {
        Form form = new Form("video");
        form.append((Item)vc.initDisplayMode(vc.USE_GUI_PRIMITIVE, null));
        Display.getDisplay(midlet).setCurrent(form);
    }

    p.start();

    byte[] image = vc.getSnapshot(null);

    // do something with the image ...

} catch (IOException ioe) {
} catch (MediaException me) { }

</pre>
</blockquote>

</blockquote>
<P>

<P>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Overview</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
MMAPI 1.2</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?overview-summary.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="overview-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<small>Copyright &copy; 2002-2006 Sun Microsystems, Inc.; Nokia Corporation. All rights reserved. See the <a href="copyright.html">Copyright Notice and Specification License</a> for more details.<br><br><b>Use is subject to <a href="http://java.sun.com/javame/reference/apis/license.html" target="_top">License Terms</a>.</b> Your use of this web site or any of its content or software indicates your agreement to be bound by these License Terms.<br><br>For more information, please consult the <a href="http://jcp.org/en/jsr/detail?id=135" target="_top">JSR 135 specification.</a></small>
</BODY>
</HTML>
