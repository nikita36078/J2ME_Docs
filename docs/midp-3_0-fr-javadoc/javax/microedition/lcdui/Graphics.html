<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_20) on Mon Nov 02 17:27:39 PST 2009 -->
<TITLE>
Graphics (Mobile Information Device Profile 3.0)
</TITLE>

<META NAME="keywords" CONTENT="javax.microedition.lcdui.Graphics class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Graphics (Mobile Information Device Profile 3.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Graphics.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<strong>MIDP3.0</strong></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/lcdui/Gauge.html" title="class in javax.microedition.lcdui"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/lcdui/IdleItem.html" title="class in javax.microedition.lcdui"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/microedition/lcdui/Graphics.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Graphics.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.microedition.lcdui</FONT>
<BR>
Class Graphics</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>javax.microedition.lcdui.Graphics</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Graphics</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Provides simple 2D geometric rendering capability.
 <p>
 All implementations MUST support double-buffered graphics.
 Graphics may be rendered to the display's off-screen buffer or to an
 off-screen image buffer. The destination of rendered graphics depends on
 the provenance of the graphics object. A graphics object for rendering
 to the display is passed to the <code>Canvas</code> object's
 <A HREF="../../../javax/microedition/lcdui/Canvas.html#paint(javax.microedition.lcdui.Graphics)"><CODE>paint()</CODE></A>
 method. This is the only means by which a graphics object may be obtained
 whose destination is the display. Furthermore, applications may draw using
 this graphics object only for the duration of the <code>paint()</code>
 method.
 </p>
 <p>
 A graphics object for rendering to an off-screen image buffer may be obtained
 by calling the <A HREF="../../../javax/microedition/lcdui/Image.html#getGraphics()"><CODE>getGraphics()</CODE></A> method on the
 desired image. A graphics object so obtained may be held indefinitely by the
 application, and requests may be issued on this graphics object at any time.
 </p>
 <p>
 In drawing methods that take an Image as a parameter: if the Image is
 an instance of ScalableImage, it MUST be rasterized before drawing. If
 the scalable image does not define an initial viewport size, the default
 viewport of 100 by 100 pixels MUST be used. If the scalable image
 contains animation, the rasterized starting frame of the animation
 MUST be used when drawing.
 </p>

 <h3>Coordinate System</h3>
 <p>
 The default coordinate system's origin is at the upper left-hand corner of
 the destination. The X-axis direction is positive towards the right, and the
 Y-axis direction is positive downwards. Applications may assume that
 horizontal and vertical distances in the coordinate system represent equal
 distances on the actual device display, that is, pixels are square. A
 facility is provided for translating the origin of the coordinate system. All
 coordinates are specified as integers.
 </p>
 <p>
 The coordinate system represents locations between pixels, not the pixels
 themselves. Therefore, the first pixel in the upper left corner of the
 display lies in the square bounded by coordinates
 <code>(0,0) , (1,0) , (0,1) , (1,1)</code>.
 </p>
 <p>
 Under this definition, the semantics for fill operations are clear. Since
 coordinate grid lines lie between pixels, fill operations affect pixels that
 lie entirely within the region bounded by the coordinates of the operation.
 For example, the operation
 </P>

 <pre>
 g.fillRect(0, 0, 3, 2);
 </pre>

 <P>
 paints exactly six pixels. (In this example, and in all subsequent examples,
 the variable <code>g</code> is assumed to contain a reference to a
 <code>Graphics</code> object.)
 </p>

 <p>
 An artifact of the coordinate system is that the area affected by a fill
 operation differs slightly from the area affected by a draw operation given
 the same coordinates. For example, consider the operations
 </P>

 <pre>
 g.fillRect(x, y, w, h); // 1
 g.drawRect(x, y, w, h); // 2
 </pre>

 <P>
 Statement (1) fills a rectangle <code>w</code> pixels wide and
 <code>h</code> pixels high. Statement (2) draws a rectangle whose left and
 top edges are within the area filled by statement (1). However, the bottom
 and right edges lie one pixel outside the filled area. This is
 counterintuitive, but it preserves the invariant that
 </P>

 <pre>
 g.drawLine(x, y, x + w, y);
 g.drawLine(x + w, y, x + w, y + h);
 g.drawLine(x + w, y + h, x, y + h);
 g.drawLine(x, y + h, x, y);
 </pre>

 <P>
 has an effect identical to statement (2) above.
 </p>
 <p>
 The exact pixels painted by <code>drawLine()</code> and
 <code>drawArc()</code> are not specified. Pixels touched by a fill
 operation must either exactly overlap or directly abut pixels touched by the
 corresponding draw operation. A fill operation must never leave a gap between
 the filled area and the pixels touched by the corresponding draw operation,
 nor may the fill operation touch pixels outside the area bounded by the
 corresponding draw operation.
 </p>

 <p>
 <a name="clip"></a>
 <h3>Clipping</h3>
 <p>

 <p>
 The clip is the set of pixels in the destination of the <code>Graphics</code>
 object that may be modified by graphics rendering operations.

 <p>
 There is a single clip per <code>Graphics</code> object. The only pixels
 modified by graphics operations are those that lie within the clip. Pixels
 outside the clip are not modified by any graphics operations.

 <p>
 Operations are provided for intersecting the current clip with a given
 rectangle and for setting the current clip outright. The application may
 specify the clip by supplying a clip rectangle using coordinates relative to
 the current coordinate system.

 <p>
 It is legal to specify a clip rectangle whose width or height is zero or
 negative. In this case the clip is considered to be empty, that is, no pixels
 are contained within it. Therefore, if any graphics operations are issued
 under such a clip, no pixels will be modified.

 <p>
 It is legal to specify a clip rectangle that extends beyond or resides
 entirely beyond the bounds of the destination. No pixels exist outside the
 bounds of the destination, and the area of the clip rectangle that is outside
 the destination is ignored. Only the pixels that lie both within the
 destination and within the specified clip rectangle are considered to be part
 of the clip.

 <p>
 Operations on the coordinate system, such as
 <A HREF="../../../javax/microedition/lcdui/Graphics.html#translate(int, int)"><CODE>translate()</CODE></A>, do not modify the clip.
 The methods <A HREF="../../../javax/microedition/lcdui/Graphics.html#getClipX()"><CODE>getClipX()</CODE></A>,
 <A HREF="../../../javax/microedition/lcdui/Graphics.html#getClipY()"><CODE>getClipY()</CODE></A>,
 <A HREF="../../../javax/microedition/lcdui/Graphics.html#getClipWidth()"><CODE>getClipWidth()</CODE></A> and
 <A HREF="../../../javax/microedition/lcdui/Graphics.html#getClipHeight()"><CODE>getClipHeight()</CODE></A> must return a rectangle
 that, if passed to <code>setClip</code> without an intervening change to
 the <code>Graphics</code> object's coordinate system, must result in the
 identical set of pixels in the clip. The rectangle returned from the
 <code>getClip</code> family of methods may differ from the clip rectangle
 that was requested in <A HREF="../../../javax/microedition/lcdui/Graphics.html#setClip(int, int, int, int)"><CODE>setClip()</CODE></A>.
 This can occur if the coordinate system has been changed or if the
 implementation has chosen to intersect the clip rectangle with the bounds of
 the destination of the <code>Graphics</code> object.

 <p>
 If a graphics operation is affected by the clip, the pixels touched by that
 operation must be the same ones that would be touched as if the clip did not
 affect the operation. For example, consider a clip represented by the
 rectangle <code>(cx, cy, cw, ch)</code> and a point <code>(x1, y1)</code>
 that lies outside this rectangle and a point <code>(x2, y2)</code> that
 lies within this rectangle. In the following code fragment,
 </P>

 <pre>
 g.setClip(0, 0, canvas.getWidth(), canvas.getHeight());
 g.drawLine(x1, y1, x2, y2); // 3
 g.setClip(cx, cy, cw, ch);
 g.drawLine(x1, y1, x2, y2); // 4
 </pre>

 <P>
 The pixels touched by statement (4) must be identical to the pixels within
 <code>(cx, cy, cw, ch)</code> touched by statement (3).
 </p>

 <h3>Color Model</h3>
 <p>
 The API supports a <a href="#32ARGB">32-bit ARGB</a> color model, with 8
 bits for the alpha, red, green, and blue components of a color.  Given its
 pervasive use for internet applications and adoption by the W3C, MIDP
 devices should conform to the sRGB color space as closely as possible when
 interpreting RGB color values.
 </p>

 <p>
 Not all devices support a full 32 bits' worth of color and
 thus they will map colors requested by the application into colors available
 on the device.   The color depth of off-screen images must not be lower than
 that of any display that is an integral part of the device. Auxiliary displays
 that the device connects to may have higher color depths, in which case
 colors are converted accordingly.
 </p>

 <p>
 Facilities are provided in the <A HREF="../../../javax/microedition/lcdui/Display.html" title="class in javax.microedition.lcdui"><CODE>Display</CODE></A> class for obtaining a
 specific display's characteristics, such as whether color is available and
 how many distinct gray levels are available. Applications may also use
 <A HREF="../../../javax/microedition/lcdui/Graphics.html#getDisplayColor(int)"><CODE>getDisplayColor()</CODE></A> to obtain the actual
 color that would be displayed for a requested color. This enables
 applications to adapt their behavior to a device without compromising device
 independence.
 </p>


 <h3>Alpha Level and Blending Modes</h3>
 <p>
 In addition to a drawing color, each Graphics object also has an alpha value
 that controls the overall opacity of the rendered pixels. As with color
 values, not all devices will support a full 8 bits of alpha channel
 information. However, all implementations must support at least 4-bit alpha
 values regardless of their display bit depths.
 </p>

 <p>
 For the text, line, rectangle, and arc drawing and filling primitives, the
 source pixel is a pixel having the current color and alpha value of the
 graphics object.
 </p>

 <p>
 However, the <A HREF="../../../javax/microedition/lcdui/Graphics.html#drawImage(javax.microedition.lcdui.Image, int, int, int)"><CODE>drawImage()</CODE></A>,
 <A HREF="../../../javax/microedition/lcdui/Graphics.html#drawRegion(javax.microedition.lcdui.Image, int, int, int, int, int, int, int, int)"><CODE>drawRegion()</CODE></A>, and <A HREF="../../../javax/microedition/lcdui/Graphics.html#drawRGB(int[], int, int, int, int, int, int, boolean)"><CODE>drawRGB()</CODE></A> methods use
 an image or array of pixel values as the source for rendering operations
 instead of the current color of the graphics object. For these operations,
 the alpha value of a given source pixel is multiplied by the alpha value of
 the Graphics object to determine its overall opacity when rendered to the
 destination. Hence, a fully opaque pixel in the source will adopt the alpha
 level of the Graphics object. Similarly, the alpha values of the source
 pixels will be rendered as-is if the alpha value of the graphics object is
 fully opaque.
 </p>

 <p>
 Rendered pixels are combined with the destination pixels according to the
 Graphics object's current blending mode. Two of the Porter-Duff blending
 modes are supported: <A HREF="../../../javax/microedition/lcdui/Graphics.html#SRC_OVER"><CODE>SRC_OVER</CODE></A>, and <A HREF="../../../javax/microedition/lcdui/Graphics.html#SRC"><CODE>SRC</CODE></A>.

 <p>
 <code>SRC_OVER</code> is the default blending mode and blends the source
 pixel on top of the destination pixel. If the source pixel is fully opaque,
 the destination pixel is effectively replaced with the source pixel. If the
 source pixel is fully transparent, the destination pixel is unchanged. If the
 source pixel is partially transparent, its color is blended with the color of
 the destination pixel. The opacity of the destination pixel cannot be reduced
 using this blending mode, and thus it may be used on images and surfaces that
 do not support alpha channels as their pixels are already fully opaque.
 </p>

 <p>
 The <code>SRC_OVER</code> mode computes the destination pixel's red, green,
 blue, and alpha values according to the follow equations:
 </p>
 <pre>
    R(dest) = (R(src) * A(src)) + (R(dest) * (1 - A(src)))
    G(dest) = (G(src) * A(src)) + (G(dest) * (1 - A(src)))
    B(dest) = (B(src) * A(src)) + (B(dest) * (1 - A(src)))
  A(dest) = A(src) + A(dest) - (A(src) * A(dest))

 </pre>
 <p>
 where the alpha value A has a value between 0 and 1.0
 </p>
 <p>
 The <code>SRC</code> blending mode replaces the destination pixel with the
 source pixel, regardless of the source pixel's opacity. Both the color and
 the alpha value of the destination pixel are replaced, thus allowing the
 opacity of the destination pixel to be decreased as well as increased. For
 this reason, the Source blending mode can only be used for Graphics objects
 that render to an Image with an alpha channel.
 </p>
 <p>
 The <code>SRC</code> mode computes the destination pixel's red, green,
 blue, and alpha values according to the follow equations:
 </p>
 <pre>
    R(dest) = R(src)
    G(dest) = G(src)
    B(dest) = B(src)
  A(dest) = A(src)

 </pre>

 <h3>Stroke Styles</h3>
 <p>
 Lines, arcs, rectangles, and rounded rectangles are drawn with either a
 <code>SOLID</code> or a <code>DOTTED</code> stroke style, as set by the
 <A HREF="../../../javax/microedition/lcdui/Graphics.html#setStrokeStyle(int)"><CODE>setStrokeStyle()</CODE></A> method. The stroke style does not
 affect fill, text, and image operations.
 </p>
 <p>
 For the <code>SOLID</code> stroke style, drawing operations are performed
 with a one-pixel wide pen that fills the pixel immediately below and to the
 right of the specified coordinate. Drawn lines touch pixels at both
 endpoints. Thus, the operation
 </P>

 <pre>
 g.drawLine(0, 0, 0, 0);
 </pre>

 <p>
 paints exactly one pixel, the first pixel in the upper left corner of the
 display.
 </p>
 <p>
 Drawing operations under the <code>DOTTED</code> stroke style will touch a
 subset of pixels that would have been touched under the <code>SOLID</code>
 stroke style. The frequency and length of dots is implementation-dependent.
 The endpoints of lines and arcs are not guaranteed to be drawn, nor are the
 corner points of rectangles guaranteed to be drawn. Dots are drawn by
 painting with the current color and alpha level; spaces between dots are left
 untouched.
 </p>
 <p>

 <h3>Rendering Text</h3>
 <p>
 For a given font, each character is represented by a glyph. The glyph acts as
 an alpha channel mask containing pixels that form the shape of the character.
 </p>

 <p>
 Basic font engines provide monochrome glyphs in which a pixel is either fully
 opaque (that is, part of the character to be drawn) or fully transparent.
 More sophisticated font engines provide graymap glyphs in which pixels may
 also be partially opaque to varying degrees, thereby allowing character edges
 to appear smoother.
 </p>

 <p>
 When a character is painted, the opacity of a rendered pixel is determined
 by multiplying the alpha value of the glyph's pixel with that of the Graphics
 object. The color of the rendered pixel will be the color the Graphics
 object. Hence, pixels that are fully opaque in the glyph will be rendered
 with the Graphics object's opacity and color, and pixels that are fully
 transparent in the glyph will be rendered as fully transparent pixels.
 </p>

 <p>
 The text drawing calls <A HREF="../../../javax/microedition/lcdui/Graphics.html#drawChar(char, int, int, int)"><CODE>drawChar()</CODE></A>,
 <A HREF="../../../javax/microedition/lcdui/Graphics.html#drawChars(char[], int, int, int, int, int)"><CODE>drawChars()</CODE></A>, <A HREF="../../../javax/microedition/lcdui/Graphics.html#drawString(java.lang.String, int, int, int)"><CODE>drawString()</CODE></A>,
 <A HREF="../../../javax/microedition/lcdui/Graphics.html#drawSubstring(java.lang.String, int, int, int, int, int)"><CODE>drawSubstring()</CODE></A> <A HREF="../../../javax/microedition/lcdui/Graphics.html#drawText(javax.microedition.lcdui.Text, int, int)"><CODE>drawText()</CODE></A> all draw
 text in this manner.
 </p>

 <p>
 The text drawing calls <A HREF="../../../javax/microedition/lcdui/Graphics.html#drawChars(char[], int, int, int, int, int)"><CODE>drawChars()</CODE></A>, <A HREF="../../../javax/microedition/lcdui/Graphics.html#drawString(java.lang.String, int, int, int)"><CODE>drawString()</CODE></A>,
 and <A HREF="../../../javax/microedition/lcdui/Graphics.html#drawSubstring(java.lang.String, int, int, int, int, int)"><CODE>drawSubstring()</CODE></A> all render characters in their exact order.
 In other words, no bi-directional processing is applied and the order of the characters is
 preserved.  If bi-directional text is required, the String or character data should be
 pre-processed using a suitable library or the <code>Text</code> class should be used instead.
 </p>

 <h3>Anchor Points</h3>
 The drawing of text is based on &quot;anchor points&quot;. Anchor points are
 used to minimize the amount of computation required when placing text. For
 example, in order to center a piece of text, an application needs to call
 <code>stringWidth()</code> or <code>charWidth()</code> to get the width
 and then perform a combination of subtraction and division to compute the
 proper location. The method to draw text is defined as follows:

 <pre>
 public void drawString(String text, int x, int y, int anchor);
 </pre>

 This method draws text in the current color, using the current font with its
 anchor point at <code>(x,y)</code>. The definition of the anchor point
 must be one of the horizontal constants <code>(LEFT, HCENTER, RIGHT)</code>
 combined with one of the vertical constants
 <code>(TOP, BASELINE, BOTTOM)</code> using the bit-wise <code>OR</code>
 operator. Zero may also be used as the value of an anchor point. Using zero
 for the anchor point value gives results identical to using
 <code>TOP | LEFT</code>.
 </p>

 <p>
 Vertical centering of the text is not specified since it is not considered
 useful, it is hard to specify, and it is burdensome to implement. Thus, the
 <code>VCENTER</code> value is not allowed in the anchor point parameter of
 text drawing calls.
 </p>
 <p>
 The actual position of the bounding box of the text relative to the
 <code>(x, y)</code> location is determined by the anchor point. These
 anchor points occur at named locations along the outer edge of the bounding
 box. Thus, if <code>f</code> is <code>g</code>'s current font (as
 returned by <code>g.getFont()</code>, the following calls will all have
 identical results:
 </P>

 <pre>
 g.drawString(str, x, y, TOP | LEFT);
 g.drawString(str, x + f.stringWidth(str) / 2, y, TOP | HCENTER);
 g.drawString(str, x + f.stringWidth(str), y, TOP | RIGHT);

 g.drawString(str, x, y + f.getBaselinePosition(), BASELINE | LEFT);
 g.drawString(str, x + f.stringWidth(str) / 2, y + f.getBaselinePosition(),
                 BASELINE | HCENTER);
 g.drawString(str, x + f.stringWidth(str), y + f.getBaselinePosition(), BASELINE
                 | RIGHT);

 drawString(str, x, y + f.getHeight(), BOTTOM | LEFT);
 drawString(str, x + f.stringWidth(str) / 2, y + f.getHeight(), BOTTOM | HCENTER);
 drawString(str, x + f.stringWidth(str), y + f.getHeight(), BOTTOM | RIGHT);
 </pre>

 <p>
 For text drawing, the inter-character and inter-line spacing (leading)
 specified by the font designer are included as part of the values returned in
 the <A HREF="../../../javax/microedition/lcdui/Font.html#stringWidth(java.lang.String)"><CODE>stringWidth()</CODE></A> and
 <A HREF="../../../javax/microedition/lcdui/Font.html#getHeight()"><CODE>getHeight()</CODE></A> calls of class <A HREF="../../../javax/microedition/lcdui/Font.html" title="class in javax.microedition.lcdui"><CODE>Font</CODE></A>. For
 example, given the following code:
 </P>

 <pre>
 // (5)
 g.drawString(string1 + string2, x, y, TOP | LEFT);

 // (6)
 g.drawString(string1, x, y, TOP | LEFT);
 g.drawString(string2, x + f.stringWidth(string1), y, TOP | LEFT);
 </pre>

 </P>
 <P>
 Code fragments (5) and (6) behave similarly if not identically. This occurs
 because <code>f.stringWidth()</code> includes the inter-character spacing.
 The exact spacing may differ between these calls if the system supports
 font kerning and support for bi-directional text rendering.
 </p>

 <p>
 Similarly, reasonable vertical spacing may be achieved simply by adding the
 font height to the Y-position of subsequent lines. For example:
 </P>

 <pre>
 g.drawString(string1, x, y, TOP | LEFT);
 g.drawString(string2, x, y + f.fontHeight(), TOP | LEFT);
 </pre>

 <P>
 draws <code>string1</code> and <code>string2</code> on separate lines
 with an appropriate amount of inter-line spacing.
 </p>
 <p>
 The <code>stringWidth()</code> of the string and the
 <code>fontHeight()</code> of the font in which it is drawn define the size
 of the bounding box of a piece of text. As described above, this box includes
 inter-line and inter-character spacing. The implementation is required to put
 this space below and to right of the pixels actually belonging to the
 characters drawn. Applications that wish to position graphics closely with
 respect to text (for example, to paint a rectangle around a string of text)
 may assume that there is space below and to the right of a string and that
 there is <em>no</em> space above and to the left of the string.
 </p>
 <p>

 Anchor points are also used for positioning of images. Similar to text
 drawing, the anchor point for an image specifies the point on the bounding
 rectangle of the destination that is to positioned at the <code>(x,y)</code>
 location given in the graphics request. Unlike text, vertical centering of
 images is well-defined, and thus the <code>VCENTER</code> value may be used
 within the anchor point parameter of image drawing requests. Because images
 have no notion of a baseline, the <code>BASELINE</code> value may not be
 used within the anchor point parameter of image drawing requests.
 </p>

 <h3>Pixel Formats</h3>
 The Graphics and Image classes include APIs that support the rendering and
 retrieval of specific pixel values. To maximize the portability of
 applications, the pixel values are represented using a set of four pixel
 formats. While the device may use other pixel formats natively, only these
 formats are supported via the MIDP APIs.

 <p>
 The use of 16-bit formats reduces memory consumption since only two bytes are
 needed per pixel, but due to the lower number of distinct levels, a smaller
 set of unique pixel values can be represented. This shortcoming will be most
 noticeable on displays that support higher color depths. Conversely, 32-bit
 formats require twice as much memory since four bytes are needed per pixel,
 but the resulting color depth exceeds that of most mobile device displays.
 </p>

 <p>
 Unless the device happens to use the same pixel format natively, some
 conversion will occur when rendering or retrieving pixel values; the
 computing overhead associated with this conversion will depend on specific
 formats involved.
 </p>

 <a name="32ARGB"></a>
 <h4>32-bit ARGB</h4>
 <img src="doc-files/32ARGB.png" width="995" height="73">
 <p>
 This format uses the <code>int</code> type to encode both color and
 opacity information for a single pixel. Eight bits are used to encode the
 alpha value, red component, green component, and blue component. For each
 color component, a value of 0xFF represents maximum intensity and a value of
 0x00 represents minimum intensity. For the alpha value, a value of 0xFF
 represents full opacity and a value of 0x00 represents full transparency.
 </p>
 <a name="24RGB"></a>
 <h4>24-bit RGB</h4>
 <p>
 This format is encoded exactly the same at the 32-bit ARGB, with the exception
 of the alpha value. Full opacity is assumed since this format does not include an
 alpha value, and the contents of the upper byte are ignored.
 </p>
 <a name="16ARGB"></a>
 <h4>16-bit ARGB</h4>
 <img src="doc-files/16ARGB.png" width="506" height="73">
 <p>
 This format uses the <code>char</code> type to encode both color and
 opacity information for a single pixel. Four bits are used to encode the
 alpha value, red component, green component, and blue component. For each
 color component, a value of 0xF represents maximum intensity and a value of
 0x00 represents minimum intensity. For the alpha value, a value of 0xF
 represents full opacity and a value of 0x00 represents full transparency.
 </p>
 <a name="16RGB"></a>
 <h4>16-bit RGB</h4>
 <img src="doc-files/16RGB.png" width="505" height="73">
 <p>
 This format uses the <code>char</code> type to encode color information
 for a single pixel. 5 bits are used to encode the red component and blue
 component, for which a value of 0x1F represents maximum intensity and a value
 of 0x00 represents minimum intensity. 6 bits are used to encode the green
 component, for which a value of 0x3F represents maximum intensity and a value
 of 0x00 represents minimum intensity. Full opacity is assumed since this
 format does not include an alpha value.
 </p>

 <h3>Reference</h3>

 <dl>
 <dt>Porter-Duff
 <dd>Porter, T., and T. Duff. &quot;Compositing Digital Images.&quot;
 <em>Computer Graphics V18 N3 (SIGGRAPH 1984)</em>, p. 253-259.
 </dl>
<P>

<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>MIDP 1.0</DD>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#BASELINE">BASELINE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for positioning the anchor point at the baseline of text.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#BOTTOM">BOTTOM</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for positioning the anchor point of text and images below the
 text or image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#DOTTED">DOTTED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for the <code>DOTTED</code> stroke style.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#HCENTER">HCENTER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for centering text and images horizontally around the anchor
 point</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#LEFT">LEFT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for positioning the anchor point of text and images to the left
 of the text or image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#RIGHT">RIGHT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for positioning the anchor point of text and images to the right
 of the text or image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#SOLID">SOLID</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for the <code>SOLID</code> stroke style.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#SRC">SRC</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for the <code>SRC</code> blending mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#SRC_OVER">SRC_OVER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for the <code>SRC_OVER</code> blending mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#TOP">TOP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for positioning the anchor point of text and images above the
 text or image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#VCENTER">VCENTER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for centering images vertically around the anchor point.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#clipRect(int, int, int, int)">clipRect</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Intersects the current clip with the specified rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#copyArea(int, int, int, int, int, int, int)">copyArea</A></B>(int&nbsp;x_src,
         int&nbsp;y_src,
         int&nbsp;width,
         int&nbsp;height,
         int&nbsp;x_dest,
         int&nbsp;y_dest,
         int&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies the contents of a rectangular area
 <code>(x_src, y_src, width, height)</code> to a destination area, whose
 anchor point identified by anchor is located at
 <code>(x_dest, y_dest)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawArc(int, int, int, int, int, int)">drawArc</A></B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height,
        int&nbsp;startAngle,
        int&nbsp;arcAngle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the outline of a circular or elliptical arc covering the specified
 rectangle, using the current color, alpha, and stroke style.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawARGB16(short[], int, int, int, int, int, int)">drawARGB16</A></B>(short[]&nbsp;argbData,
           int&nbsp;offset,
           int&nbsp;scanlength,
           int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders a series of device-independent ARGB values in a specified region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawChar(char, int, int, int)">drawChar</A></B>(char&nbsp;character,
         int&nbsp;x,
         int&nbsp;y,
         int&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the specified character using the current font, color, and alpha.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawChars(char[], int, int, int, int, int)">drawChars</A></B>(char[]&nbsp;data,
          int&nbsp;offset,
          int&nbsp;length,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the specified characters using the current font, color, and alpha.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawImage(javax.microedition.lcdui.Image, int, int, int)">drawImage</A></B>(<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A>&nbsp;img,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the specified image by using the anchor point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawLine(int, int, int, int)">drawLine</A></B>(int&nbsp;x1,
         int&nbsp;y1,
         int&nbsp;x2,
         int&nbsp;y2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a line between the coordinates <code>(x1,y1)</code> and
 <code>(x2,y2)</code> using the current color, alpha, and stroke style.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawRect(int, int, int, int)">drawRect</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the outline of the specified rectangle using the current color,
 alpha, and stroke style.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawRegion(javax.microedition.lcdui.Image, int, int, int, int, int, int, int, int)">drawRegion</A></B>(<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A>&nbsp;src,
           int&nbsp;x_src,
           int&nbsp;y_src,
           int&nbsp;width,
           int&nbsp;height,
           int&nbsp;transform,
           int&nbsp;x_dest,
           int&nbsp;y_dest,
           int&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies a region of the specified source image to a location within the
 destination, possibly transforming (rotating and reflecting) the image
 data using the chosen transform function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawRegion(javax.microedition.lcdui.Image, int, int, int, int, int, int, int, int, int, int)">drawRegion</A></B>(<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A>&nbsp;src,
           int&nbsp;x_src,
           int&nbsp;y_src,
           int&nbsp;width,
           int&nbsp;height,
           int&nbsp;transform,
           int&nbsp;x_dest,
           int&nbsp;y_dest,
           int&nbsp;anchor,
           int&nbsp;width_dest,
           int&nbsp;height_dest)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scales and transforms a region of the specified source image to a region within the
 destination, possibly transforming (rotating and reflecting) the image
 data using the chosen transform function and scaling the pixels to fit
 the destination region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawRGB(int[], int, int, int, int, int, int, boolean)">drawRGB</A></B>(int[]&nbsp;rgbData,
        int&nbsp;offset,
        int&nbsp;scanlength,
        int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height,
        boolean&nbsp;processAlpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders a series of device-independent ARGB values in a specified region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawRGB16(short[], int, int, int, int, int, int)">drawRGB16</A></B>(short[]&nbsp;rgbData,
          int&nbsp;offset,
          int&nbsp;scanlength,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Renders a series of device-independent RGB values in a specified region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawRoundRect(int, int, int, int, int, int)">drawRoundRect</A></B>(int&nbsp;x,
              int&nbsp;y,
              int&nbsp;width,
              int&nbsp;height,
              int&nbsp;arcWidth,
              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the outline of the specified rounded corner rectangle using the
 current color, alpha, and stroke style.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawString(java.lang.String, int, int, int)">drawString</A></B>(java.lang.String&nbsp;str,
           int&nbsp;x,
           int&nbsp;y,
           int&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the specified <code>String</code> using the current font, color,
 and alpha.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawSubstring(java.lang.String, int, int, int, int, int)">drawSubstring</A></B>(java.lang.String&nbsp;str,
              int&nbsp;offset,
              int&nbsp;len,
              int&nbsp;x,
              int&nbsp;y,
              int&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the specified <code>String</code> using the current font, color,
 and alpha.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawText(javax.microedition.lcdui.Text, int, int)">drawText</A></B>(<A HREF="../../../javax/microedition/lcdui/Text.html" title="class in javax.microedition.lcdui">Text</A>&nbsp;text,
         int&nbsp;x,
         int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draw a Text object to the Graphics context at the requested location.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#fillArc(int, int, int, int, int, int)">fillArc</A></B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height,
        int&nbsp;startAngle,
        int&nbsp;arcAngle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills a circular or elliptical arc covering the specified rectangle using
 the current color and alpha.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#fillRect(int, int, int, int)">fillRect</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills the specified rectangle with the current color and alpha.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#fillRoundRect(int, int, int, int, int, int)">fillRoundRect</A></B>(int&nbsp;x,
              int&nbsp;y,
              int&nbsp;width,
              int&nbsp;height,
              int&nbsp;arcWidth,
              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills the specified rounded corner rectangle with the current color and
 alpha.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#fillTriangle(int, int, int, int, int, int)">fillTriangle</A></B>(int&nbsp;x1,
             int&nbsp;y1,
             int&nbsp;x2,
             int&nbsp;y2,
             int&nbsp;x3,
             int&nbsp;y3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills the specified triangle will the current color and alpha level.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getAlpha()">getAlpha</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current alpha value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getAlphaColor()">getAlphaColor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current drawing color and alpha value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getBlendingMode()">getBlendingMode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current blending mode for this Graphics object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getBlueComponent()">getBlueComponent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the blue component of the current color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getClipHeight()">getClipHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the height of the current clipping area.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getClipWidth()">getClipWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the width of the current clipping area.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getClipX()">getClipX</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the X offset of the current clipping area, relative to the
 coordinate system origin of this graphics context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getClipY()">getClipY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the Y offset of the current clipping area, relative to the
 coordinate system origin of this graphics context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getColor()">getColor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current drawing color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getDisplayColor(int)">getDisplayColor</A></B>(int&nbsp;color)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the color that will be displayed if the specified color is
 requested.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/microedition/lcdui/Font.html" title="class in javax.microedition.lcdui">Font</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getFont()">getFont</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current font.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getGrayScale()">getGrayScale</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the current grayscale value of the color being used for rendering
 operations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getGreenComponent()">getGreenComponent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the green component of the current color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getRedComponent()">getRedComponent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the red component of the current color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getStrokeStyle()">getStrokeStyle</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the stroke style used for drawing operations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getTranslateX()">getTranslateX</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the X coordinate of the translated origin of this graphics context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#getTranslateY()">getTranslateY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the Y coordinate of the translated origin of this graphics context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#setAlpha(int)">setAlpha</A></B>(int&nbsp;alpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the alpha value for this Graphics object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#setAlphaColor(int)">setAlphaColor</A></B>(int&nbsp;ARGB)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current color and alpha to the specified
 <a href="#32ARGB">32-bit ARGB</a> value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#setAlphaColor(int, int, int, int)">setAlphaColor</A></B>(int&nbsp;alpha,
              int&nbsp;red,
              int&nbsp;green,
              int&nbsp;blue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current color and alpha to the specified values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#setBlendingMode(int)">setBlendingMode</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current blending mode for this Graphics object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#setClip(int, int, int, int)">setClip</A></B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current clip to the rectangle specified by the given
 coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#setColor(int)">setColor</A></B>(int&nbsp;RGB)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current color to the specified <a href="#24RGB">24-bit RGB</a>
 value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#setColor(int, int, int)">setColor</A></B>(int&nbsp;red,
         int&nbsp;green,
         int&nbsp;blue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current color to the specified RGB values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#setFont(javax.microedition.lcdui.Font)">setFont</A></B>(<A HREF="../../../javax/microedition/lcdui/Font.html" title="class in javax.microedition.lcdui">Font</A>&nbsp;font)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the font for all subsequent text rendering operations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#setGrayScale(int)">setGrayScale</A></B>(int&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current grayscale to be used for all subsequent rendering
 operations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#setStrokeStyle(int)">setStrokeStyle</A></B>(int&nbsp;style)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the stroke style used for drawing lines, arcs, rectangles, and
 rounded rectangles.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/lcdui/Graphics.html#translate(int, int)">translate</A></B>(int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translates the origin of the graphics context to the point
 <code>(x, y)</code> in the current coordinate system.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="HCENTER"><!-- --></A><H3>
HCENTER</H3>
<PRE>
public static final int <B>HCENTER</B></PRE>
<DL>
<DD>Constant for centering text and images horizontally around the anchor
 point

 <P>
 Value <code>1</code> is assigned to <code>HCENTER</code>.
 </P>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.lcdui.Graphics.HCENTER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="VCENTER"><!-- --></A><H3>
VCENTER</H3>
<PRE>
public static final int <B>VCENTER</B></PRE>
<DL>
<DD>Constant for centering images vertically around the anchor point.

 <P>
 Value <code>2</code> is assigned to <code>VCENTER</code>.
 </P>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.lcdui.Graphics.VCENTER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="LEFT"><!-- --></A><H3>
LEFT</H3>
<PRE>
public static final int <B>LEFT</B></PRE>
<DL>
<DD>Constant for positioning the anchor point of text and images to the left
 of the text or image.

 <P>
 Value <code>4</code> is assigned to <code>LEFT</code>.
 </P>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.lcdui.Graphics.LEFT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="RIGHT"><!-- --></A><H3>
RIGHT</H3>
<PRE>
public static final int <B>RIGHT</B></PRE>
<DL>
<DD>Constant for positioning the anchor point of text and images to the right
 of the text or image.

 <P>
 Value <code>8</code> is assigned to <code>RIGHT</code>.
 </P>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.lcdui.Graphics.RIGHT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TOP"><!-- --></A><H3>
TOP</H3>
<PRE>
public static final int <B>TOP</B></PRE>
<DL>
<DD>Constant for positioning the anchor point of text and images above the
 text or image.

 <P>
 Value <code>16</code> is assigned to <code>TOP</code>.
 </P>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.lcdui.Graphics.TOP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BOTTOM"><!-- --></A><H3>
BOTTOM</H3>
<PRE>
public static final int <B>BOTTOM</B></PRE>
<DL>
<DD>Constant for positioning the anchor point of text and images below the
 text or image.

 <P>
 Value <code>32</code> is assigned to <code>BOTTOM</code>.
 </P>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.lcdui.Graphics.BOTTOM">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BASELINE"><!-- --></A><H3>
BASELINE</H3>
<PRE>
public static final int <B>BASELINE</B></PRE>
<DL>
<DD>Constant for positioning the anchor point at the baseline of text.

 <P>
 Value <code>64</code> is assigned to <code>BASELINE</code>.
 </P>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.lcdui.Graphics.BASELINE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SOLID"><!-- --></A><H3>
SOLID</H3>
<PRE>
public static final int <B>SOLID</B></PRE>
<DL>
<DD>Constant for the <code>SOLID</code> stroke style.

 <P>
 Value <code>0</code> is assigned to <code>SOLID</code>.
 </P>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.lcdui.Graphics.SOLID">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="DOTTED"><!-- --></A><H3>
DOTTED</H3>
<PRE>
public static final int <B>DOTTED</B></PRE>
<DL>
<DD>Constant for the <code>DOTTED</code> stroke style.

 <P>
 Value <code>1</code> is assigned to <code>DOTTED</code>.
 </P>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.lcdui.Graphics.DOTTED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SRC_OVER"><!-- --></A><H3>
SRC_OVER</H3>
<PRE>
public static final int <B>SRC_OVER</B></PRE>
<DL>
<DD>Constant for the <code>SRC_OVER</code> blending mode. The source is
 composited over the destination.

 <P>
 Value <code>0</code> is assigned to <code>SRC_OVER</code>.
 </P>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.lcdui.Graphics.SRC_OVER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SRC"><!-- --></A><H3>
SRC</H3>
<PRE>
public static final int <B>SRC</B></PRE>
<DL>
<DD>Constant for the <code>SRC</code> blending mode. The destination's
 color and alpha value are replaced with those of the source.

 <P>
 Value <code>1</code> is assigned to <code>SRC</code>.
 </P>
<P>
<DL>
<DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.lcdui.Graphics.SRC">Constant Field Values</A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="translate(int, int)"><!-- --></A><H3>
translate</H3>
<PRE>
public void <B>translate</B>(int&nbsp;x,
                      int&nbsp;y)</PRE>
<DL>
<DD>Translates the origin of the graphics context to the point
 <code>(x, y)</code> in the current coordinate system. All coordinates
 used in subsequent rendering operations on this graphics context will be
 relative to this new origin.

 <p>The coordinates passed to this method are interpreted relative to the
 current translated origin, and thus the effect of calls to
 <code>translate()</code> are cumulative. For
 example, calling <code>translate(1, 2)</code> and then
 <code>translate(3, 4)</code> has the same effect as calling
 <code>translate(4, 6)</code>.
 </p>

 <p>The application can set the origin in terms of absolute coordinates
 <code>(ax, ay)</code> using the following technique:
 </p>
 <code>
 g.translate(ax - g.getTranslateX(), ay - g.getTranslateY())
 </code>
 <p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the new translation origin<DD><CODE>y</CODE> - the y coordinate of the new translation origin<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#getTranslateX()"><CODE>getTranslateX()</CODE></A>, 
<A HREF="../../../javax/microedition/lcdui/Graphics.html#getTranslateY()"><CODE>getTranslateY()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getTranslateX()"><!-- --></A><H3>
getTranslateX</H3>
<PRE>
public int <B>getTranslateX</B>()</PRE>
<DL>
<DD>Gets the X coordinate of the translated origin of this graphics context.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>X of current origin</DL>
</DD>
</DL>
<HR>

<A NAME="getTranslateY()"><!-- --></A><H3>
getTranslateY</H3>
<PRE>
public int <B>getTranslateY</B>()</PRE>
<DL>
<DD>Gets the Y coordinate of the translated origin of this graphics context.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Y of current origin</DL>
</DD>
</DL>
<HR>

<A NAME="getColor()"><!-- --></A><H3>
getColor</H3>
<PRE>
public int <B>getColor</B>()</PRE>
<DL>
<DD>Gets the current drawing color.  This method does not return the
 alpha value of the Graphics object, and the upper byte of the return
 value will always contain a value of 0x00.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current color encoded using the
          <a href="#24RGB">24-bit RGB</a> format<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#setColor(int, int, int)"><CODE>setColor(int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAlphaColor()"><!-- --></A><H3>
getAlphaColor</H3>
<PRE>
public int <B>getAlphaColor</B>()</PRE>
<DL>
<DD>Gets the current drawing color and alpha value.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current color and alpha value encoded using the
          <a href="#32ARGB">32-bit ARGB</a> format<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#setColor(int, int, int)"><CODE>setColor(int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getRedComponent()"><!-- --></A><H3>
getRedComponent</H3>
<PRE>
public int <B>getRedComponent</B>()</PRE>
<DL>
<DD>Gets the red component of the current color.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>integer value in range <code>0-255</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#setColor(int, int, int)"><CODE>setColor(int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getGreenComponent()"><!-- --></A><H3>
getGreenComponent</H3>
<PRE>
public int <B>getGreenComponent</B>()</PRE>
<DL>
<DD>Gets the green component of the current color.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>integer value in range <code>0-255</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#setColor(int, int, int)"><CODE>setColor(int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getBlueComponent()"><!-- --></A><H3>
getBlueComponent</H3>
<PRE>
public int <B>getBlueComponent</B>()</PRE>
<DL>
<DD>Gets the blue component of the current color.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>integer value in range <code>0-255</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#setColor(int, int, int)"><CODE>setColor(int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getGrayScale()"><!-- --></A><H3>
getGrayScale</H3>
<PRE>
public int <B>getGrayScale</B>()</PRE>
<DL>
<DD>Gets the current grayscale value of the color being used for rendering
 operations. If the color was set by <code>setGrayScale()</code>, that
 value is simply returned. If the color was set by one of the methods that
 allows setting of the red, green, and blue components, the value returned
 is computed from the RGB color components (possibly in a device-specific
 fashion) that best approximates the brightness of that color.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>integer value in range <code>0-255</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#setGrayScale(int)"><CODE>setGrayScale(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setColor(int, int, int)"><!-- --></A><H3>
setColor</H3>
<PRE>
public void <B>setColor</B>(int&nbsp;red,
                     int&nbsp;green,
                     int&nbsp;blue)</PRE>
<DL>
<DD>Sets the current color to the specified RGB values. All subsequent
 rendering operations will use this specified color.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>red</CODE> - the red component of the color being set in range
            <code>0-255</code><DD><CODE>green</CODE> - the green component of the color being set in range
            <code>0-255</code><DD><CODE>blue</CODE> - the blue component of the color being set in range
            <code>0-255</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if any of the color components are outside of range
             <code>0-255</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#getColor()"><CODE>getColor()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setColor(int)"><!-- --></A><H3>
setColor</H3>
<PRE>
public void <B>setColor</B>(int&nbsp;RGB)</PRE>
<DL>
<DD>Sets the current color to the specified <a href="#24RGB">24-bit RGB</a>
 value. All subsequent rendering operations will use this specified color.

 <p>Note that this method only changes the drawing <em>color</em>.  The
 upper byte of the RGB value is ignored and the alpha value of the
 Graphics object is unaffected by this method.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>RGB</CODE> - the new drawing color encoded using the
                <a href="#24RGB">24-bit RGB</a> format<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#getColor()"><CODE>getColor()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setGrayScale(int)"><!-- --></A><H3>
setGrayScale</H3>
<PRE>
public void <B>setGrayScale</B>(int&nbsp;value)</PRE>
<DL>
<DD>Sets the current grayscale to be used for all subsequent rendering
 operations. For monochrome displays, the behavior is clear. For color
 displays, this sets the color for all subsequent drawing operations to be
 a gray color equivalent to the value passed in. The value must be in the
 range <code>0-255</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - the desired grayscale value
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the gray value is out of range<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#getGrayScale()"><CODE>getGrayScale()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setAlpha(int)"><!-- --></A><H3>
setAlpha</H3>
<PRE>
public void <B>setAlpha</B>(int&nbsp;alpha)</PRE>
<DL>
<DD>Sets the alpha value for this Graphics object. All operations performed
 using this Graphics object will be rendered with the current alpha level
 using the selected blending mode. The red, green, and blue components of
 the current color are unaffected.

 <p>
 An alpha value of 255 is fully opaque, and a value of 0 is fully
 transparent. The alpha value is 255 (fully opaque) by default.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>alpha</CODE> - the new alpha value for this Graphics object
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the alpha value is outside of range <code>0-255</code><DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setAlphaColor(int)"><!-- --></A><H3>
setAlphaColor</H3>
<PRE>
public void <B>setAlphaColor</B>(int&nbsp;ARGB)</PRE>
<DL>
<DD>Sets the current color and alpha to the specified
 <a href="#32ARGB">32-bit ARGB</a> value. All subsequent
 rendering operations will use this specified color and alpha value.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ARGB</CODE> - the new drawing color and alpha value encoded using the
                <a href="#32ARGB">32-bit ARGB</a> format<DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#getColor()"><CODE>getColor()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setAlphaColor(int, int, int, int)"><!-- --></A><H3>
setAlphaColor</H3>
<PRE>
public void <B>setAlphaColor</B>(int&nbsp;alpha,
                          int&nbsp;red,
                          int&nbsp;green,
                          int&nbsp;blue)</PRE>
<DL>
<DD>Sets the current color and alpha to the specified values. All subsequent
 rendering operations will use this specified color and alpha value.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>alpha</CODE> - the alpha component of the color being set in range
            <code>0-255</code><DD><CODE>red</CODE> - the red component of the color being set in range
            <code>0-255</code><DD><CODE>green</CODE> - the green component of the color being set in range
            <code>0-255</code><DD><CODE>blue</CODE> - the blue component of the color being set in range
            <code>0-255</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if any parameter is outside of the range <code>0-255</code><DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#getColor()"><CODE>getColor()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAlpha()"><!-- --></A><H3>
getAlpha</H3>
<PRE>
public int <B>getAlpha</B>()</PRE>
<DL>
<DD>Gets the current alpha value.
 <p>
 An alpha value of 255 is fully opaque, and a value of 0 is fully
 transparent. The alpha value is 255 (fully opaque) by default.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the alpha value (0-255)<DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setBlendingMode(int)"><!-- --></A><H3>
setBlendingMode</H3>
<PRE>
public void <B>setBlendingMode</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Sets the current blending mode for this Graphics object. The blending
 mode dictates how rendered pixels are combined with the destination
 pixels.

 <p>
 If <code>SRC_OVER</code> is used, the source pixel is blended on top of
 the destination pixel.
 </p>

 <p>
 If <code>SRC</code> is used, the destination pixel is fully replaced
 with the source pixel, including the source pixel's alpha value. This
 mode can only be used on a Graphics object that renders to an Image with
 an alpha channel, as determined by calling
 <A HREF="../../../javax/microedition/lcdui/Image.html#hasAlpha()"><CODE>Image.hasAlpha</CODE></A>
 </p>

 <p>
 The <code>SRC_OVER</code> blending mode is used by default.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - the desired blending mode (<A HREF="../../../javax/microedition/lcdui/Graphics.html#SRC"><CODE>SRC</CODE></A> or
            <A HREF="../../../javax/microedition/lcdui/Graphics.html#SRC_OVER"><CODE>SRC_OVER</CODE></A>)
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if mode is not a valid value
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the SRC mode is requested on a Graphics object that
             renders to a surface without an alpha channel<DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#getBlendingMode()"><CODE>getBlendingMode()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getBlendingMode()"><!-- --></A><H3>
getBlendingMode</H3>
<PRE>
public int <B>getBlendingMode</B>()</PRE>
<DL>
<DD>Gets the current blending mode for this Graphics object.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current blending mode (<A HREF="../../../javax/microedition/lcdui/Graphics.html#SRC"><CODE>SRC</CODE></A> or
         <A HREF="../../../javax/microedition/lcdui/Graphics.html#SRC_OVER"><CODE>SRC_OVER</CODE></A>)<DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#setBlendingMode(int)"><CODE>setBlendingMode(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getFont()"><!-- --></A><H3>
getFont</H3>
<PRE>
public <A HREF="../../../javax/microedition/lcdui/Font.html" title="class in javax.microedition.lcdui">Font</A> <B>getFont</B>()</PRE>
<DL>
<DD>Gets the current font.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>current font<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Font.html" title="class in javax.microedition.lcdui"><CODE>Font</CODE></A>, 
<A HREF="../../../javax/microedition/lcdui/Graphics.html#setFont(javax.microedition.lcdui.Font)"><CODE>setFont(javax.microedition.lcdui.Font)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setStrokeStyle(int)"><!-- --></A><H3>
setStrokeStyle</H3>
<PRE>
public void <B>setStrokeStyle</B>(int&nbsp;style)</PRE>
<DL>
<DD>Sets the stroke style used for drawing lines, arcs, rectangles, and
 rounded rectangles. This does not affect fill, text, and image
 operations.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>style</CODE> - can be <code>SOLID</code> or <code>DOTTED</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the <code>style</code> is illegal<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#getStrokeStyle()"><CODE>getStrokeStyle()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getStrokeStyle()"><!-- --></A><H3>
getStrokeStyle</H3>
<PRE>
public int <B>getStrokeStyle</B>()</PRE>
<DL>
<DD>Gets the stroke style used for drawing operations.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>stroke style, <code>SOLID</code> or <code>DOTTED</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#setStrokeStyle(int)"><CODE>setStrokeStyle(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setFont(javax.microedition.lcdui.Font)"><!-- --></A><H3>
setFont</H3>
<PRE>
public void <B>setFont</B>(<A HREF="../../../javax/microedition/lcdui/Font.html" title="class in javax.microedition.lcdui">Font</A>&nbsp;font)</PRE>
<DL>
<DD>Sets the font for all subsequent text rendering operations. If font is
 <code>null</code>, it is equivalent to
 <code>setFont(Font.getDefaultFont())</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>font</CODE> - the specified font<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Font.html" title="class in javax.microedition.lcdui"><CODE>Font</CODE></A>, 
<A HREF="../../../javax/microedition/lcdui/Graphics.html#getFont()"><CODE>getFont()</CODE></A>, 
<A HREF="../../../javax/microedition/lcdui/Graphics.html#drawString(java.lang.String, int, int, int)"><CODE>drawString(java.lang.String, int, int, int)</CODE></A>, 
<A HREF="../../../javax/microedition/lcdui/Graphics.html#drawChars(char[], int, int, int, int, int)"><CODE>drawChars(char[], int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getClipX()"><!-- --></A><H3>
getClipX</H3>
<PRE>
public int <B>getClipX</B>()</PRE>
<DL>
<DD>Gets the X offset of the current clipping area, relative to the
 coordinate system origin of this graphics context. Separating the
 <code>getClip</code> operation into two methods returning integers is
 more performance and memory efficient than one <code>getClip()</code>
 call returning an object.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>X offset of the current clipping area<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A>, 
<A HREF="../../../javax/microedition/lcdui/Graphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getClipY()"><!-- --></A><H3>
getClipY</H3>
<PRE>
public int <B>getClipY</B>()</PRE>
<DL>
<DD>Gets the Y offset of the current clipping area, relative to the
 coordinate system origin of this graphics context. Separating the
 <code>getClip</code> operation into two methods returning integers is
 more performance and memory efficient than one <code>getClip()</code>
 call returning an object.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Y offset of the current clipping area<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A>, 
<A HREF="../../../javax/microedition/lcdui/Graphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getClipWidth()"><!-- --></A><H3>
getClipWidth</H3>
<PRE>
public int <B>getClipWidth</B>()</PRE>
<DL>
<DD>Gets the width of the current clipping area.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>width of the current clipping area.<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A>, 
<A HREF="../../../javax/microedition/lcdui/Graphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getClipHeight()"><!-- --></A><H3>
getClipHeight</H3>
<PRE>
public int <B>getClipHeight</B>()</PRE>
<DL>
<DD>Gets the height of the current clipping area.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>height of the current clipping area.<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A>, 
<A HREF="../../../javax/microedition/lcdui/Graphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="clipRect(int, int, int, int)"><!-- --></A><H3>
clipRect</H3>
<PRE>
public void <B>clipRect</B>(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height)</PRE>
<DL>
<DD>Intersects the current clip with the specified rectangle. The resulting
 clipping area is the intersection of the current clipping area and the
 specified rectangle. This method can only be used to make the current
 clip smaller. To set the current clip larger, use the
 <code>setClip</code> method. Rendering operations have no effect
 outside of the clipping area.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the rectangle to intersect the clip with<DD><CODE>y</CODE> - the y coordinate of the rectangle to intersect the clip with<DD><CODE>width</CODE> - the width of the rectangle to intersect the clip with<DD><CODE>height</CODE> - the height of the rectangle to intersect the clip with<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setClip(int, int, int, int)"><!-- --></A><H3>
setClip</H3>
<PRE>
public void <B>setClip</B>(int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;width,
                    int&nbsp;height)</PRE>
<DL>
<DD>Sets the current clip to the rectangle specified by the given
 coordinates. Rendering operations have no effect outside of the clipping
 area.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the new clip rectangle<DD><CODE>y</CODE> - the y coordinate of the new clip rectangle<DD><CODE>width</CODE> - the width of the new clip rectangle<DD><CODE>height</CODE> - the height of the new clip rectangle<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="drawLine(int, int, int, int)"><!-- --></A><H3>
drawLine</H3>
<PRE>
public void <B>drawLine</B>(int&nbsp;x1,
                     int&nbsp;y1,
                     int&nbsp;x2,
                     int&nbsp;y2)</PRE>
<DL>
<DD>Draws a line between the coordinates <code>(x1,y1)</code> and
 <code>(x2,y2)</code> using the current color, alpha, and stroke style.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x1</CODE> - the x coordinate of the start of the line<DD><CODE>y1</CODE> - the y coordinate of the start of the line<DD><CODE>x2</CODE> - the x coordinate of the end of the line<DD><CODE>y2</CODE> - the y coordinate of the end of the line</DL>
</DD>
</DL>
<HR>

<A NAME="fillRect(int, int, int, int)"><!-- --></A><H3>
fillRect</H3>
<PRE>
public void <B>fillRect</B>(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height)</PRE>
<DL>
<DD>Fills the specified rectangle with the current color and alpha. Nothing
 is drawn if either width or height is zero or less.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the rectangle to be filled<DD><CODE>y</CODE> - the y coordinate of the rectangle to be filled<DD><CODE>width</CODE> - the width of the rectangle to be filled<DD><CODE>height</CODE> - the height of the rectangle to be filled<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawRect(int, int, int, int)"><CODE>drawRect(int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="drawRect(int, int, int, int)"><!-- --></A><H3>
drawRect</H3>
<PRE>
public void <B>drawRect</B>(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height)</PRE>
<DL>
<DD>Draws the outline of the specified rectangle using the current color,
 alpha, and stroke style. The resulting rectangle will cover an area
 <code>(width + 1)</code> pixels wide by <code>(height + 1)</code>
 pixels tall. If either width or height is less than zero, nothing is
 drawn.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the rectangle to be drawn<DD><CODE>y</CODE> - the y coordinate of the rectangle to be drawn<DD><CODE>width</CODE> - the width of the rectangle to be drawn<DD><CODE>height</CODE> - the height of the rectangle to be drawn<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#fillRect(int, int, int, int)"><CODE>fillRect(int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="drawRoundRect(int, int, int, int, int, int)"><!-- --></A><H3>
drawRoundRect</H3>
<PRE>
public void <B>drawRoundRect</B>(int&nbsp;x,
                          int&nbsp;y,
                          int&nbsp;width,
                          int&nbsp;height,
                          int&nbsp;arcWidth,
                          int&nbsp;arcHeight)</PRE>
<DL>
<DD>Draws the outline of the specified rounded corner rectangle using the
 current color, alpha, and stroke style. The resulting rectangle will
 cover an area <code>(width +
 1)</code> pixels wide by
 <code>(height + 1)</code> pixels tall. If either <code>width</code>
 or <code>height</code> is less than zero, nothing is drawn.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the rectangle to be drawn<DD><CODE>y</CODE> - the y coordinate of the rectangle to be drawn<DD><CODE>width</CODE> - the width of the rectangle to be drawn<DD><CODE>height</CODE> - the height of the rectangle to be drawn<DD><CODE>arcWidth</CODE> - the horizontal diameter of the arc at the four corners<DD><CODE>arcHeight</CODE> - the vertical diameter of the arc at the four corners<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#fillRoundRect(int, int, int, int, int, int)"><CODE>fillRoundRect(int, int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="fillRoundRect(int, int, int, int, int, int)"><!-- --></A><H3>
fillRoundRect</H3>
<PRE>
public void <B>fillRoundRect</B>(int&nbsp;x,
                          int&nbsp;y,
                          int&nbsp;width,
                          int&nbsp;height,
                          int&nbsp;arcWidth,
                          int&nbsp;arcHeight)</PRE>
<DL>
<DD>Fills the specified rounded corner rectangle with the current color and
 alpha. If either <code>width</code> or <code>height</code> is zero or
 less, nothing is drawn.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the rectangle to be filled<DD><CODE>y</CODE> - the y coordinate of the rectangle to be filled<DD><CODE>width</CODE> - the width of the rectangle to be filled<DD><CODE>height</CODE> - the height of the rectangle to be filled<DD><CODE>arcWidth</CODE> - the horizontal diameter of the arc at the four corners<DD><CODE>arcHeight</CODE> - the vertical diameter of the arc at the four corners<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawRoundRect(int, int, int, int, int, int)"><CODE>drawRoundRect(int, int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="fillArc(int, int, int, int, int, int)"><!-- --></A><H3>
fillArc</H3>
<PRE>
public void <B>fillArc</B>(int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;width,
                    int&nbsp;height,
                    int&nbsp;startAngle,
                    int&nbsp;arcAngle)</PRE>
<DL>
<DD>Fills a circular or elliptical arc covering the specified rectangle using
 the current color and alpha.
 <p>
 The resulting arc begins at <code>startAngle</code> and extends for
 <code>arcAngle</code> degrees. Angles are interpreted such that
 <code>0</code> degrees is at the <code>3</code> o'clock position. A
 positive value indicates a counter-clockwise rotation while a negative
 value indicates a clockwise rotation.
 <p>
 The center of the arc is the center of the rectangle whose origin is (<em>x</em>,&nbsp;<em>y</em>)
 and whose size is specified by the <code>width</code> and
 <code>height</code> arguments.
 <p>
 If either <code>width</code> or <code>height</code> is zero or less,
 nothing is drawn.

 <p>
 The filled region consists of the &quot;pie wedge&quot; region bounded by
 the arc segment as if drawn by <code>drawArc()</code>, the radius
 extending from the center to this arc at <code>startAngle</code>
 degrees, and radius extending from the center to this arc at
 <code>startAngle + arcAngle</code> degrees.
 </p>

 <p>
 The angles are specified relative to the non-square extents of the
 bounding rectangle such that <code>45</code> degrees always falls on
 the line from the center of the ellipse to the upper right corner of the
 bounding rectangle. As a result, if the bounding rectangle is noticeably
 longer in one axis than the other, the angles to the start and end of the
 arc segment will be skewed farther along the longer axis of the bounds.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the <em>x</em> coordinate of the upper-left corner of the
            arc to be filled.<DD><CODE>y</CODE> - the <em>y</em> coordinate of the upper-left corner of the
            arc to be filled.<DD><CODE>width</CODE> - the width of the arc to be filled<DD><CODE>height</CODE> - the height of the arc to be filled<DD><CODE>startAngle</CODE> - the beginning angle.<DD><CODE>arcAngle</CODE> - the angular extent of the arc, relative to the start angle.<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawArc(int, int, int, int, int, int)"><CODE>drawArc(int, int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="drawArc(int, int, int, int, int, int)"><!-- --></A><H3>
drawArc</H3>
<PRE>
public void <B>drawArc</B>(int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;width,
                    int&nbsp;height,
                    int&nbsp;startAngle,
                    int&nbsp;arcAngle)</PRE>
<DL>
<DD>Draws the outline of a circular or elliptical arc covering the specified
 rectangle, using the current color, alpha, and stroke style.
 <p>
 The resulting arc begins at <code>startAngle</code> and extends for
 <code>arcAngle</code> degrees, using the current color and alpha.
 Angles are interpreted such that <code>0</code>&nbsp;degrees is at the
 <code>3</code>&nbsp;o'clock position. A positive value indicates a
 counter-clockwise rotation while a negative value indicates a clockwise
 rotation.
 <p>
 The center of the arc is the center of the rectangle whose origin is (<em>x</em>,&nbsp;<em>y</em>)
 and whose size is specified by the <code>width</code> and
 <code>height</code> arguments.
 <p>
 The resulting arc covers an area <code>width&nbsp;+&nbsp;1</code>
 pixels wide by <code>height&nbsp;+&nbsp;1</code> pixels tall. If either
 <code>width</code> or <code>height</code> is less than zero, nothing
 is drawn.

 <p>
 The angles are specified relative to the non-square extents of the
 bounding rectangle such that <code>45</code> degrees always falls on
 the line from the center of the ellipse to the upper right corner of the
 bounding rectangle. As a result, if the bounding rectangle is noticeably
 longer in one axis than the other, the angles to the start and end of the
 arc segment will be skewed farther along the longer axis of the bounds.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the <em>x</em> coordinate of the upper-left corner of the
            arc to be drawn<DD><CODE>y</CODE> - the <em>y</em> coordinate of the upper-left corner of the
            arc to be drawn<DD><CODE>width</CODE> - the width of the arc to be drawn<DD><CODE>height</CODE> - the height of the arc to be drawn<DD><CODE>startAngle</CODE> - the beginning angle<DD><CODE>arcAngle</CODE> - the angular extent of the arc, relative to the start angle<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#fillArc(int, int, int, int, int, int)"><CODE>fillArc(int, int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.lang.String, int, int, int)"><!-- --></A><H3>
drawString</H3>
<PRE>
public void <B>drawString</B>(java.lang.String&nbsp;str,
                       int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;anchor)</PRE>
<DL>
<DD>Draws the specified <code>String</code> using the current font, color,
 and alpha. The <code>x,y</code> position is the position of the anchor
 point. See <a href="#anchor">anchor points</a>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>str</CODE> - the <code>String</code> to be drawn<DD><CODE>x</CODE> - the x coordinate of the anchor point<DD><CODE>y</CODE> - the y coordinate of the anchor point<DD><CODE>anchor</CODE> - the anchor point for positioning the text
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>str</code> is <code>null</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if anchor is not a legal value<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawChars(char[], int, int, int, int, int)"><CODE>drawChars(char[], int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="drawSubstring(java.lang.String, int, int, int, int, int)"><!-- --></A><H3>
drawSubstring</H3>
<PRE>
public void <B>drawSubstring</B>(java.lang.String&nbsp;str,
                          int&nbsp;offset,
                          int&nbsp;len,
                          int&nbsp;x,
                          int&nbsp;y,
                          int&nbsp;anchor)</PRE>
<DL>
<DD>Draws the specified <code>String</code> using the current font, color,
 and alpha. The <code>x,y</code> position is the position of the anchor
 point. See <a href="#anchor">anchor points</a>.

 <p>
 The <code>offset</code> and <code>len</code> parameters must specify
 a valid range of characters within the string <code>str</code>. The
 <code>offset</code> parameter must be within the range
 <code>[0..(str.length())]</code>, inclusive. The <code>len</code>
 parameter must be a non-negative integer such that
 <code>(offset + len) &lt;= str.length()</code>.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>str</CODE> - the <code>String</code> to be drawn<DD><CODE>offset</CODE> - zero-based index of first character in the substring<DD><CODE>len</CODE> - length of the substring<DD><CODE>x</CODE> - the x coordinate of the anchor point<DD><CODE>y</CODE> - the y coordinate of the anchor point<DD><CODE>anchor</CODE> - the anchor point for positioning the text
<DT><B>Throws:</B>
<DD><CODE>java.lang.StringIndexOutOfBoundsException</CODE> - if <code>offset</code> and <code>length</code> do not
             specify a valid range within the
             <code>String</code> <code>str</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>anchor</code> is not a legal value
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>str</code> is <code>null</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawString(java.lang.String, int, int, int)"><CODE>drawString(String, int, int, int).</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="drawChar(char, int, int, int)"><!-- --></A><H3>
drawChar</H3>
<PRE>
public void <B>drawChar</B>(char&nbsp;character,
                     int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;anchor)</PRE>
<DL>
<DD>Draws the specified character using the current font, color, and alpha.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>character</CODE> - the character to be drawn<DD><CODE>x</CODE> - the x coordinate of the anchor point<DD><CODE>y</CODE> - the y coordinate of the anchor point<DD><CODE>anchor</CODE> - the anchor point for positioning the text; see <a
            href="#anchor">anchor points</a>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>anchor</code> is not a legal value<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawString(java.lang.String, int, int, int)"><CODE>drawString(java.lang.String, int, int, int)</CODE></A>, 
<A HREF="../../../javax/microedition/lcdui/Graphics.html#drawChars(char[], int, int, int, int, int)"><CODE>drawChars(char[], int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="drawChars(char[], int, int, int, int, int)"><!-- --></A><H3>
drawChars</H3>
<PRE>
public void <B>drawChars</B>(char[]&nbsp;data,
                      int&nbsp;offset,
                      int&nbsp;length,
                      int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;anchor)</PRE>
<DL>
<DD>Draws the specified characters using the current font, color, and alpha.

 <p>
 The <code>offset</code> and <code>length</code> parameters must
 specify a valid range of characters within the character array
 <code>data</code>. The <code>offset</code> parameter must be within
 the range <code>[0..(data.length)]</code>, inclusive. The
 <code>length</code> parameter must be a non-negative integer such that
 <code>(offset + length) &lt;= data.length</code>.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - the array of characters to be drawn<DD><CODE>offset</CODE> - the start offset in the data<DD><CODE>length</CODE> - the number of characters to be drawn<DD><CODE>x</CODE> - the x coordinate of the anchor point<DD><CODE>y</CODE> - the y coordinate of the anchor point<DD><CODE>anchor</CODE> - the anchor point for positioning the text; see <a
            href="#anchor">anchor points</a>
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <code>offset</code> and <code>length</code> do not
             specify a valid range within the data array
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if anchor is not a legal value
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>data</code> is <code>null</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Graphics.html#drawString(java.lang.String, int, int, int)"><CODE>drawString(java.lang.String, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(javax.microedition.lcdui.Image, int, int, int)"><!-- --></A><H3>
drawImage</H3>
<PRE>
public void <B>drawImage</B>(<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A>&nbsp;img,
                      int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;anchor)</PRE>
<DL>
<DD>Draws the specified image by using the anchor point. The image can be
 drawn in different positions relative to the anchor point by passing the
 appropriate position constants. See <a href="#anchor">anchor points</a>.


 <p>
 If <code>img</code> is the same as the destination of this Graphics
 object, the result is undefined. For copying areas within an
 <code>Image</code>, <A HREF="../../../javax/microedition/lcdui/Graphics.html#copyArea(int, int, int, int, int, int, int)"><CODE>copyArea</CODE></A> should be used instead.
 </p>

 <p>
 The alpha value of each pixel in the image is multiplied by the alpha
 value of the Graphics object to determine its effective opacity when
 rendered.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - the specified image to be drawn<DD><CODE>x</CODE> - the x coordinate of the anchor point<DD><CODE>y</CODE> - the y coordinate of the anchor point<DD><CODE>anchor</CODE> - the anchor point for positioning the image
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>anchor</code> is not a legal value
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>img</code> is <code>null</code><DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui"><CODE>Image</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="drawRegion(javax.microedition.lcdui.Image, int, int, int, int, int, int, int, int)"><!-- --></A><H3>
drawRegion</H3>
<PRE>
public void <B>drawRegion</B>(<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A>&nbsp;src,
                       int&nbsp;x_src,
                       int&nbsp;y_src,
                       int&nbsp;width,
                       int&nbsp;height,
                       int&nbsp;transform,
                       int&nbsp;x_dest,
                       int&nbsp;y_dest,
                       int&nbsp;anchor)</PRE>
<DL>
<DD>Copies a region of the specified source image to a location within the
 destination, possibly transforming (rotating and reflecting) the image
 data using the chosen transform function.

 <p>
 The destination, if it is an image, must not be the same image as the
 source image. If it is, an exception is thrown. This restriction is
 present in order to avoid ill-defined behaviors that might occur if
 overlapped, transformed copies were permitted.
 </p>

 <p>
 The transform function used must be one of the following, as defined in
 the <A HREF="../../../javax/microedition/lcdui/game/Sprite.html" title="class in javax.microedition.lcdui.game"><CODE>Sprite</CODE></A> class:<br>

 <code>Sprite.TRANS_NONE</code> - causes the specified image region to
 be copied unchanged<br>
 <code>Sprite.TRANS_ROT90</code> - causes the specified image region to
 be rotated clockwise by 90 degrees.<br>
 <code>Sprite.TRANS_ROT180</code> - causes the specified image region to
 be rotated clockwise by 180 degrees.<br>
 <code>Sprite.TRANS_ROT270</code> - causes the specified image region to
 be rotated clockwise by 270 degrees.<br>
 <code>Sprite.TRANS_MIRROR</code> - causes the specified image region to
 be reflected about its vertical center.<br>
 <code>Sprite.TRANS_MIRROR_ROT90</code> - causes the specified image
 region to be reflected about its vertical center and then rotated
 clockwise by 90 degrees.<br>
 <code>Sprite.TRANS_MIRROR_ROT180</code> - causes the specified image
 region to be reflected about its vertical center and then rotated
 clockwise by 180 degrees.<br>
 <code>Sprite.TRANS_MIRROR_ROT270</code> - causes the specified image
 region to be reflected about its vertical center and then rotated
 clockwise by 270 degrees.<br>
 </p>

 <p>
 The <code>(x_src, y_src)</code> coordinates are relative to the upper
 left corner of the source image. The <code>x_src</code>,
 <code>y_src</code>, <code>width</code>, and <code>height</code>
 parameters specify a rectangular region of the source image. It is
 illegal for this region to extend beyond the bounds of the source image.
 This requires that:
 </P>

 <pre>
  x_src &gt;= 0
  y_src &gt;= 0
  x_src + width &lt;= source width
  y_src + height &lt;= source height
 </pre>

 <P>
 The <code>(x_dest, y_dest)</code> coordinates are relative to the
 coordinate system of this Graphics object. It is legal for the
 destination area to extend beyond the bounds of the <code>Graphics</code>
 object. Pixels outside of the bounds of the <code>Graphics</code>
 object will not be drawn.
 </p>

 <p>
 The transform is applied to the image data from the region of the source
 image, and the result is rendered with its anchor point positioned at
 location <code>(x_dest, y_dest)</code> in the destination.
 </p>

 <p>
 The alpha value of each pixel in the image is multiplied by the alpha
 value of the Graphics object to determine its effective opacity when
 rendered.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - the source image to copy from<DD><CODE>x_src</CODE> - the x coordinate of the upper left corner of the region within
            the source image to copy<DD><CODE>y_src</CODE> - the y coordinate of the upper left corner of the region within
            the source image to copy<DD><CODE>width</CODE> - the width of the region to copy<DD><CODE>height</CODE> - the height of the region to copy<DD><CODE>transform</CODE> - the desired transformation for the selected region being
            copied<DD><CODE>x_dest</CODE> - the x coordinate of the anchor point in the destination
            drawing area<DD><CODE>y_dest</CODE> - the y coordinate of the anchor point in the destination
            drawing area<DD><CODE>anchor</CODE> - the anchor point for positioning the region within the
            destination image
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>src</code> is the same image as the destination of
             this <code>Graphics</code> object
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>src</code> is <code>null</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>transform</code> is invalid
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>anchor</code> is invalid
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the region to be copied exceeds the bounds of the source
             image<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawRegion(javax.microedition.lcdui.Image, int, int, int, int, int, int, int, int, int, int)"><!-- --></A><H3>
drawRegion</H3>
<PRE>
public void <B>drawRegion</B>(<A HREF="../../../javax/microedition/lcdui/Image.html" title="class in javax.microedition.lcdui">Image</A>&nbsp;src,
                       int&nbsp;x_src,
                       int&nbsp;y_src,
                       int&nbsp;width,
                       int&nbsp;height,
                       int&nbsp;transform,
                       int&nbsp;x_dest,
                       int&nbsp;y_dest,
                       int&nbsp;anchor,
                       int&nbsp;width_dest,
                       int&nbsp;height_dest)</PRE>
<DL>
<DD>Scales and transforms a region of the specified source image to a region within the
 destination, possibly transforming (rotating and reflecting) the image
 data using the chosen transform function and scaling the pixels to fit
 the destination region.
 <p>
 The destination, if it is an image, must not be the same image as the
 source image. If it is, an exception is thrown. This restriction is
 present in order to avoid ill-defined behaviors that might occur if
 overlapped, transformed copies were permitted.
 If either <code>width_dest</code> or <code>height_dest</code> is zero or
 less, nothing is drawn.
 </p>
 <p>
 The transform function used must be one of the following, as defined in
 the <A HREF="../../../javax/microedition/lcdui/game/Sprite.html" title="class in javax.microedition.lcdui.game"><CODE>Sprite</CODE></A>class: <br>
 <code>Sprite.TRANS_NONE</code>- causes the specified image region to
 be copied unchanged <br>
 <code>Sprite.TRANS_ROT90</code>- causes the specified image region to
 be rotated clockwise by 90 degrees. <br>
 <code>Sprite.TRANS_ROT180</code>- causes the specified image region to
 be rotated clockwise by 180 degrees. <br>
 <code>Sprite.TRANS_ROT270</code>- causes the specified image region to
 be rotated clockwise by 270 degrees. <br>
 <code>Sprite.TRANS_MIRROR</code>- causes the specified image region to
 be reflected about its vertical center. <br>
 <code>Sprite.TRANS_MIRROR_ROT90</code>- causes the specified image
 region to be reflected about its vertical center and then rotated
 clockwise by 90 degrees. <br>
 <code>Sprite.TRANS_MIRROR_ROT180</code>- causes the specified image
 region to be reflected about its vertical center and then rotated
 clockwise by 180 degrees. <br>
 <code>Sprite.TRANS_MIRROR_ROT270</code>- causes the specified image
 region to be reflected about its vertical center and then rotated
 clockwise by 270 degrees. <br>
 </p>

 <p>
 The <code>(x_src, y_src)</code> coordinates are relative to the upper
 left corner of the source image. The <code>x_src</code>,
 <code>y_src</code>,<code>width</code>, and <code>height</code>
 parameters specify a rectangular region of the source image. It is
 illegal for this region to extend beyond the bounds of the source image.
 This requires that:
 </P>

 <TABLE BORDER="2">

 <TR>

 <TD ROWSPAN="1" COLSPAN="1">

 <pre><code>
     x_src &gt;= 0
     y_src &gt;= 0
     x_src + width &lt;= source width
     y_src + height &lt;= source height
 </code></pre>

 </TD>

 </TR>

 </TABLE>

 <P>

 The <code>(x_dest, y_dest)</code> coordinates are relative to the
 coordinate system of this Graphics object. It is legal for the
 destination area to extend beyond the bounds of the <code>Graphics</code>
 object. Pixels outside of the bounds of the <code>Graphics</code>
 object will not be drawn.
 </p>
 <p>
 The scaling and transform is applied to the image data from the region of the source
 image, and the result is rendered with its anchor point positioned at
 location <code>(x_dest, y_dest)</code> in the destination.
 </p>

 <p>
 The alpha value of each pixel in the image is multiplied by the alpha
 value of the Graphics object to determine its effective opacity when
 rendered.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - the source image to copy from<DD><CODE>x_src</CODE> - the x coordinate of the upper left corner of the region within
            the source image to copy<DD><CODE>y_src</CODE> - the y coordinate of the upper left corner of the region within
            the source image to copy<DD><CODE>width</CODE> - the width of the source region<DD><CODE>height</CODE> - the height of the source region<DD><CODE>transform</CODE> - the desired transformation for the selected region being
            copied<DD><CODE>x_dest</CODE> - the x coordinate of the anchor point in the destination
            drawing area<DD><CODE>y_dest</CODE> - the y coordinate of the anchor point in the destination
            drawing area<DD><CODE>anchor</CODE> - the anchor point for positioning the region within the
            destination image<DD><CODE>width_dest</CODE> - the width of the region in the destination drawing area<DD><CODE>height_dest</CODE> - the height of the region in the destination drawing area
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>src</code> is the same image as the destination of
             this <code>Graphics</code> object
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>src</code> is <code>null</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>transform</code> is invalid
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>anchor</code> is invalid
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the region to be copied exceeds the bounds of the source
             image<DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="copyArea(int, int, int, int, int, int, int)"><!-- --></A><H3>
copyArea</H3>
<PRE>
public void <B>copyArea</B>(int&nbsp;x_src,
                     int&nbsp;y_src,
                     int&nbsp;width,
                     int&nbsp;height,
                     int&nbsp;x_dest,
                     int&nbsp;y_dest,
                     int&nbsp;anchor)</PRE>
<DL>
<DD>Copies the contents of a rectangular area
 <code>(x_src, y_src, width, height)</code> to a destination area, whose
 anchor point identified by anchor is located at
 <code>(x_dest, y_dest)</code>. The effect must be that the destination
 area contains an exact copy of the contents of the source area
 immediately prior to the invocation of this method. This result must
 occur even if the source and destination areas overlap.

 <p>
 The points <code>(x_src, y_src)</code> and <code>(x_dest,
 y_dest)</code>
 are both specified relative to the coordinate system of the
 <code>Graphics</code> object. It is illegal for the source region to
 extend beyond the bounds of the graphic object. This requires that:
 </P>

 <pre>
  x_src + tx &gt;= 0
  y_src + ty &gt;= 0
  x_src + tx + width &lt;= width of Graphics object's destination
  y_src + ty + height &lt;= height of Graphics object's destination
 </pre>

 <p>
 where <code>tx</code> and <code>ty</code> represent the X and Y
 coordinates of the translated origin of this graphics object, as returned
 by <code>getTranslateX()</code> and <code>getTranslateY()</code>,
 respectively.
 </p>

 <P>
 However, it is legal for the destination area to extend beyond the bounds
 of the <code>Graphics</code> object. Pixels outside of the bounds of
 the <code>Graphics</code> object will not be drawn.
 </p>

 <p>
 The <code>copyArea</code> method is allowed on all
 <code>Graphics</code> objects except those whose destination is an
 actual display device. This restriction is necessary because allowing a
 <code>copyArea</code> method on the display would adversely impact
 certain techniques for implementing double-buffering.
 </p>

 <p>
 Copying is performed using direct pixel replacement. That is, both the
 color and the alpha value of the destination pixel are replaced with
 those of the source pixel. The color and alpha value of the Graphics
 object have no impact on the copy operation.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x_src</CODE> - the x coordinate of upper left corner of source area<DD><CODE>y_src</CODE> - the y coordinate of upper left corner of source area<DD><CODE>width</CODE> - the width of the source area<DD><CODE>height</CODE> - the height of the source area<DD><CODE>x_dest</CODE> - the x coordinate of the destination anchor point<DD><CODE>y_dest</CODE> - the y coordinate of the destination anchor point<DD><CODE>anchor</CODE> - the anchor point for positioning the region within the
            destination image
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if the destination of this <code>Graphics</code> object is
             a display device
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the region to be copied exceeds the bounds of the source
             image<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="fillTriangle(int, int, int, int, int, int)"><!-- --></A><H3>
fillTriangle</H3>
<PRE>
public void <B>fillTriangle</B>(int&nbsp;x1,
                         int&nbsp;y1,
                         int&nbsp;x2,
                         int&nbsp;y2,
                         int&nbsp;x3,
                         int&nbsp;y3)</PRE>
<DL>
<DD>Fills the specified triangle will the current color and alpha level. The
 lines connecting each pair of points are included in the filled triangle.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x1</CODE> - the x coordinate of the first vertex of the triangle<DD><CODE>y1</CODE> - the y coordinate of the first vertex of the triangle<DD><CODE>x2</CODE> - the x coordinate of the second vertex of the triangle<DD><CODE>y2</CODE> - the y coordinate of the second vertex of the triangle<DD><CODE>x3</CODE> - the x coordinate of the third vertex of the triangle<DD><CODE>y3</CODE> - the y coordinate of the third vertex of the triangle<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawRGB(int[], int, int, int, int, int, int, boolean)"><!-- --></A><H3>
drawRGB</H3>
<PRE>
public void <B>drawRGB</B>(int[]&nbsp;rgbData,
                    int&nbsp;offset,
                    int&nbsp;scanlength,
                    int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;width,
                    int&nbsp;height,
                    boolean&nbsp;processAlpha)</PRE>
<DL>
<DD>Renders a series of device-independent ARGB values in a specified region.
 The values are stored in the <code>rgbData</code> int array using the
 <a href="#32ARGB"> 32-bit ARGB </a> or <a href="#24RGB"> 24-bit RGB</a>
 format. The <code>scanlength</code> specifies the relative offset
 within the array between the corresponding pixels of consecutive rows.
 Any value for <code>scanlength</code> is acceptable (even negative
 values) provided that all resulting references are within the bounds of
 the <code>rgbData</code> array. The ARGB data is rasterized
 horizontally from left to right within each row. The ARGB values are
 rendered in the region specified by <code>x</code>, <code>y</code>,
 <code>width</code> and <code>height</code>, and the operation is
 subject to the current clip region and translation for this
 <code>Graphics</code> object.

 <p>
 Consider <code>P(a,b)</code> to be the value of the pixel located at
 column <code>a</code> and row <code>b</code> of the Image, where rows
 and columns are numbered downward from the top starting at zero, and
 columns are numbered rightward from the left starting at zero. This
 operation can then be defined as:
 </p>

 <pre>
 P(a, b) = rgbData[offset + (a - x) + (b - y) * scanlength]
 </pre>

 <p>
 for
 </p>

 <pre>
  x &lt;= a &lt; x + width
  y &lt;= b &lt; y + height
 </pre>

 <p>
 If either width or height is zero or less, no exception is thrown,
 and nothing is drawn.
 </p>

 <p>
 If <code>processAlpha</code> is <code>true</code>, the pixel values
 are assumed to be in the <a href="#32ARGB">32-bit RGB</a> format and
 high-order byte specifies opacity. The alpha value of each pixel in the
 array is multiplied by the alpha value of the Graphics object to
 determine its effective opacity when rendered.

 <p>
 If <code>processAlpha</code> is <code>false</code>, the pixel values
 are assumed to be in the <a href="#24RGB">24-bit RGB</a> format. The
 value in the high-order byte is ignored and all pixels are rendered with
 the alpha value of the Graphics object.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rgbData</CODE> - an array of 32-bit ARGB or 24-bit RGB values<DD><CODE>offset</CODE> - the array index of the first ARGB value<DD><CODE>scanlength</CODE> - the relative array offset between the corresponding pixels in
            consecutive rows in the <code>rgbData</code> array<DD><CODE>x</CODE> - the horizontal location of the region to be rendered<DD><CODE>y</CODE> - the vertical location of the region to be rendered<DD><CODE>width</CODE> - the width of the region to be rendered<DD><CODE>height</CODE> - the height of the region to be rendered<DD><CODE>processAlpha</CODE> - <code>true</code> if the pixel values should be processed
            assuming a 32-bit ARGB format, <code>false</code> if the
            pixel values should be processed assuming a 24-bit RGB format
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if the requested operation will attempt to access an element
             of <code>rgbData</code> whose index is either negative or
             beyond its length
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>rgbData</code> is <code>null</code><DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawARGB16(short[], int, int, int, int, int, int)"><!-- --></A><H3>
drawARGB16</H3>
<PRE>
public void <B>drawARGB16</B>(short[]&nbsp;argbData,
                       int&nbsp;offset,
                       int&nbsp;scanlength,
                       int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height)</PRE>
<DL>
<DD>Renders a series of device-independent ARGB values in a specified region.
 The values are stored in the <code>argbData</code> char array in a <a
 href="#16ARGB">16-bit ARGB</a> format, with the first value stored at
 the specified offset. The <code>scanlength</code> specifies the
 relative offset within the array between the corresponding pixels of
 consecutive rows. Any value for <code>scanlength</code> is acceptable
 (even negative values) provided that all resulting references are within
 the bounds of the <code>argbData</code> array. The ARGB data is
 rasterized horizontally from left to right within each row. The ARGB
 values are rendered in the region specified by <code>x</code>,
 <code>y</code>, <code>width</code> and <code>height</code>, and
 the operation is subject to the current clip region and translation for
 this <code>Graphics</code> object.

 <p>
 Consider <code>P(a,b)</code> to be the value of the pixel located at
 column <code>a</code> and row <code>b</code> of the Image, where rows
 and columns are numbered downward from the top starting at zero, and
 columns are numbered rightward from the left starting at zero. This
 operation can then be defined as:
 </p>

 <pre>
 P(a, b) = argbData[offset + (a - x) + (b - y) * scanlength]
 </pre>

 <p>
 for
 </p>

 <pre>
  x &lt;= a &lt; x + width
  y &lt;= b &lt; y + height
 </pre>

 <p>
 If either width or height is zero or less, no exception is thrown,
 and nothing is drawn.
 </p>

 <p>
 The alpha value of each pixel in the array is multiplied by the alpha
 value of the Graphics object to determine its effective opacity when
 rendered.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>argbData</CODE> - an array of 16-bit ARGB values<DD><CODE>offset</CODE> - the array index of the first ARGB value<DD><CODE>scanlength</CODE> - the relative array offset between the corresponding pixels in
            consecutive rows in the <code>argbData</code> array<DD><CODE>x</CODE> - the horizontal location of the region to be rendered<DD><CODE>y</CODE> - the vertical location of the region to be rendered<DD><CODE>width</CODE> - the width of the region to be rendered<DD><CODE>height</CODE> - the height of the region to be rendered
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if the requested operation will attempt to access an element
             of <code>argbData</code> whose index is either negative or
             beyond its length
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>argbData</code> is <code>null</code><DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawRGB16(short[], int, int, int, int, int, int)"><!-- --></A><H3>
drawRGB16</H3>
<PRE>
public void <B>drawRGB16</B>(short[]&nbsp;rgbData,
                      int&nbsp;offset,
                      int&nbsp;scanlength,
                      int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;width,
                      int&nbsp;height)</PRE>
<DL>
<DD>Renders a series of device-independent RGB values in a specified region.
 The values are stored in the <code>rgbData</code> char array in a <a
 href="#16RGB">16-bit RGB</a> format, with the first value stored at the
 specified offset. The <code>scanlength</code> specifies the relative
 offset within the array between the corresponding pixels of consecutive
 rows. Any value for <code>scanlength</code> is acceptable (even
 negative values) provided that all resulting references are within the
 bounds of the <code>rgbData</code> array. The RGB data is rasterized
 horizontally from left to right within each row. The RGB values are
 rendered in the region specified by <code>x</code>, <code>y</code>,
 <code>width</code> and <code>height</code>, and the operation is
 subject to the current clip region and translation for this
 <code>Graphics</code> object.

 <p>
 Consider <code>P(a,b)</code> to be the value of the pixel located at
 column <code>a</code> and row <code>b</code> of the Image, where rows
 and columns are numbered downward from the top starting at zero, and
 columns are numbered rightward from the left starting at zero. This
 operation can then be defined as:
 </p>

 <pre>
 P(a, b) = rgbData[offset + (a - x) + (b - y) * scanlength]
 </pre>

 <p>
 for
 </p>

 <pre>
  x &lt;= a &lt; x + width
  y &lt;= b &lt; y + height
 </pre>

 <p>
 If either width or height is zero or less, no exception is thrown,
 and nothing is drawn.
 </p>

 <p>
 The alpha value of the Graphics object determines the effective opacity
 of the pixel values when rendered.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rgbData</CODE> - an array of 16-bit RGB values<DD><CODE>offset</CODE> - the array index of the first RGB value<DD><CODE>scanlength</CODE> - the relative array offset between the corresponding pixels in
            consecutive rows in the <code>rgbData</code> array<DD><CODE>x</CODE> - the horizontal location of the region to be rendered<DD><CODE>y</CODE> - the vertical location of the region to be rendered<DD><CODE>width</CODE> - the width of the region to be rendered<DD><CODE>height</CODE> - the height of the region to be rendered
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if the requested operation will attempt to access an element
             of <code>rgbData</code> whose index is either negative or
             beyond its length
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>rgbData</code> is <code>null</code><DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDisplayColor(int)"><!-- --></A><H3>
getDisplayColor</H3>
<PRE>
public int <B>getDisplayColor</B>(int&nbsp;color)</PRE>
<DL>
<DD>Gets the color that will be displayed if the specified color is
 requested. This method enables the developer to check the manner in which
 RGB values are mapped to the set of distinct colors that the device can
 actually display. For example, with a monochrome device, this method will
 return either <code>0xFFFFFF</code> (white) or <code>0x000000</code>
 (black) depending on the brightness of the specified color.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>color</CODE> - the desired color encoded in the
                <a href="#24RGB">24-bit RGB</a> format
<DT><B>Returns:</B><DD>the corresponding color that will be displayed on the device's
         screen encoded in the <a href="#24RGB">24-bit RGB</a> format<DT><B>Since:</B></DT>
  <DD>MIDP 2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawText(javax.microedition.lcdui.Text, int, int)"><!-- --></A><H3>
drawText</H3>
<PRE>
public void <B>drawText</B>(<A HREF="../../../javax/microedition/lcdui/Text.html" title="class in javax.microedition.lcdui">Text</A>&nbsp;text,
                     int&nbsp;x,
                     int&nbsp;y)</PRE>
<DL>
<DD>Draw a Text object to the Graphics context at the requested location. The
 Text object contains the characters to be drawn and the location and size
 of the bounding box. The fonts and color of each character is set in the
 <A HREF="../../../javax/microedition/lcdui/Text.html" title="class in javax.microedition.lcdui"><CODE>Text</CODE></A> class. The alpha value of the Graphics object is uniformly
 applied to the entire text and it is rendered according to the current
 blending mode.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>text</CODE> - the Text object to draw.<DD><CODE>x</CODE> - the x offset of the upper left corner of the text bounding box<DD><CODE>y</CODE> - the y offset of the upper left corner of the text bounding box<DT><B>Since:</B></DT>
  <DD>MIDP 3.0</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Graphics.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<strong>MIDP3.0</strong></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/lcdui/Gauge.html" title="class in javax.microedition.lcdui"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/lcdui/IdleItem.html" title="class in javax.microedition.lcdui"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?javax/microedition/lcdui/Graphics.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Graphics.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size=-1><a href=mailto:jsr-271-comments@jcp.org>Send a comment or suggestion</a>Version 3.0 of Mobile Information Device Profile Specification<br>Java is a trademark or registered trademark of Sun Microsystems, Inc. in the US and other countries. Copyright 2002-2009 Motorola Inc. Portions copyright 1993-2002 Sun Microsystems, Inc. and Motorola, Inc. All Rights Reserved.</font>
</BODY>
</HTML>
