<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_04) on Tue Jun 01 12:32:59 CEST 2004 -->
<TITLE>
Overview (WMA 2.0 Reference Implementation)
</TITLE>

<META NAME="keywords" CONTENT="Overview, WMA 2.0 Reference Implementation">

<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Overview (WMA 2.0 Reference Implementation)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Overview</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="overview-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A></NOSCRIPT>

</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<CENTER>
<H1>
WMA 2.0&nbsp;
</H1>
</CENTER>
This document is the API documentation for the Wireless Messaging API (WMA) 2.0.
<P>
<B>See:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#overview_description"><B>Description</B></A>
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Packages</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="20%"><B><A HREF="javax/wireless/messaging/package-summary.html">javax.wireless.messaging</A></B></TD>
<TD>Provides classes and interfaces as specified in the WMA 2.0 specification.</TD>
</TR>
</TABLE>

<P>
&nbsp;<A NAME="overview_description"><!-- --></A>
    
    <P> The messaging API is based on the Generic Connection Framework (GCF), which 
      is defined in the Connected Limited Device Configuration (CLDC) 1.0 specification. 
      The package <code>javax.microedition.io</code> defines the framework and supports 
      input/output and networking functionality in J2ME profiles. It provides a coherent 
      way to access and organize data in a resource-constrained environment. </P>
    <P> The design of the messaging functionality is similar to the datagram functionality 
      that is used for UDP in the Generic Connection Framework. Like the datagram 
      functionality, messaging provides the notion of opening a connection based on 
      a string address and that the connection can be opened in either client or server 
      mode. However, there are differences between messages and datagrams, so messaging 
      interfaces do not inherit from datagram. It might also be confusing to use the 
      same interfaces for messages and datagrams. </P>
    
    <P> The interfaces for the messaging API have been defined in the
      <CODE>javax.wireless.messaging</CODE>
      package. </P>
    
    <H2>Representation of a message </H2>
    
    
    <P> A message can be thought of as having an address part and a data part. A message 
      is represented by a class that implements the interface defined for messages 
      in the API. This interface provides methods that are common for all messages. 
      In the <code>javax.wireless.messaging</code> package, the base interface that 
      is implemented by all messages is named <CODE>Message</CODE>. It provides methods 
      for addresses and timestamps.</P>
    
    
    <P> For the data part of the message, the API is designed to handle text, 
      binary and multipart messages. These are represented by three subinterfaces of <CODE>Message</CODE>: 
      <CODE>TextMessage</CODE>, <CODE>BinaryMessage</CODE> and <CODE>MultipartMessage</CODE>. These subinterfaces 
      provide ways to manipulate the payload of the message as Strings, byte arrays and  message parts, 
      respectively. </P>
    
    
    <P> Other subinterfaces of <CODE>Message</CODE> can be defined for message payloads 
      which are neither pure text nor pure binary. It is also possible to create further 
      subinterfaces of <CODE>TextMessage</CODE>, <CODE>BinaryMessage</CODE> and <CODE>MultipartMessage</CODE> for 
      possible protocol-specific features. </P>
    
    <H2>Sending and receiving messages </H2>
    
    <P> As defined by the Generic Connection Framework, the message sending and receiving 
      functionality is implemented by a <CODE>Connection</CODE> interface, in this 
      case, <CODE>MessageConnection</CODE>. To make a connection, the application 
      obtains an object implementing the <CODE>MessageConnection</CODE> from the <CODE>Connector</CODE> 
      class by providing a URL connection string that identifies the address. </P>
    
    
    <P> If the application specifies a full destination address that defines a recipient 
      to the <CODE>Connector</CODE>, it gets a <CODE>MessageConnection</CODE> that 
      works in a &quot;client&quot; mode. This kind of <CODE>Connection</CODE> can 
      only be used for sending messages to the address specified when creating it. 
    </P>
    <P> The application can create a &quot;server&quot; mode <CODE>MessageConnection</CODE> 
      by providing a URL connection string that includes only an identifier that specifies 
      the messages intended to be received by this application. Then it can use this 
      <CODE>MessageConnection</CODE> object for receiving and sending messages. </P>
    
    
    <P> The format of the URL connection string that identifies the address is specific 
      to the messaging protocol used. </P>
    <P> For sending messages, the <CODE>MessageConnection</CODE> object provides factory 
      methods for creating <CODE>Message</CODE> objects. For receiving messages, the 
      <CODE>MessageConnection</CODE> supports an event listener-based receiving mechanism, 
      in addition to a synchronous blocking <CODE>receive()</CODE> method. The methods 
      for sending and receiving messages can throw a <CODE>SecurityException</CODE> 
      if the application does not have the permission to perform these operations. 
    </P>
  
    <P>
      The generic connection framework includes convenience methods for getting
      <code>InputStream</code> and <code>OutputStream</code> handles for
      connections which are <code>StreamConnections</code>. The 
      <code>MessageConnection</code> does not support stream based operations.
      If an application calls the <code>Connector.open*Stream</code>
      methods, it will receive an <code>IllegalArgumentException</code>.
    </P>
      
    <H2>Bearer-specific Adapter</H2>
    <P>
      The basic <code>MessageConnection</code> and <code>Message</code>
      framework provides a general mechanism with establishing a 
      messaging application. 
      The appendices describe the specific adapter requirements
      for URL connection string formatting and bearer-specific 
      message handling requirements.
    </P>
    <UL>
      <LI class="Bullet1"> Appendix A - 
      <A HREF="sms_adapter.html">GSM SMS Adapter</A> </LI>
      <LI class="Bullet1"> Appendix B - 
      <A HREF="cbs_adapter.html">GSM CBS Adapter</A> </LI>
      <LI class="Bullet1"> Appendix C - 
      <A HREF="cdma_adapter.html">CDMA IS-637 SMS Adapter</A> </LI>
      <LI class="Bullet1"> Appendix D - MMS Adapter </LI>
    </UL>
    <P>
      The appendices of this specification include the definition of
      SMS, CBS and MMS URL connection strings. These connection schemes MAY be
      reused in other adapter specifications, as long as the specified
      syntax is not modified and the usage does not overlap with these
      specified adapters (that is, no platform can be expected to
      implement two protocols for which the URI scheme would be the
      same, making it impossible for the platform to distinguish which
      is desired by the application). Other adapter specifications MAY
      define new connection schemes, as long as these do not conflict with
      any other connection scheme in use with the Generic Connection Framework.    
    </P>  
    <P>
      The appendices describe how the SMS, CBS and MMS adpaters MUST be
      implemented to conform to the requirements of their specific
      wireless network environments and how these adapters supply the
      functionality defined in the <EM>javax.wireless.messaging
      package</EM>.
    </P>
    <P>
      When a GSM SMS message connection is established, the platform MUST
      use the rules in Appendix A for the syntax of the URL connection
      string and for treatment of the message contents.
    </P>
    <P>
      When a GSM CBS message connection is established, the platform MUST
      use the rules in Appendix B for the syntax of the URL connection
      string and for treatment of the message contents.
    </P>
    <P>
      When a CDMA SMS message connection is established, the platform MUST
      use the rules in Appendix C for the syntax of the URL connection
      string and for treatment of the message contents.
    </P>
    <P>
      When a MMS message connection is established, the platform MUST
      use the rules in Appendix D for the syntax of the URL connection
      string and for treatment of the message contents.
    </P>

  
    <H2>Security</H2>

    
    <P> To send and receive messages using this API, applications MUST be granted 
      a permission to perform the requested operation. The mechanisms for granting 
      a permission are implementation dependent. </P>
    
    <P> The permissions for sending and receiving MAY depend on the type 
      of messages and addresses being used. An implementation
      MAY restrict an application's ability to send some
      types of messages and/or sending messages to certain recipient
      addresses. These addresses can include device addresses and/or
      identifiers, such as port numbers, within a device. </P>

    <P> An implementation MAY restrict certain types of
      messages or connection addresses, such that the permission would
      never be available to an application on that device. </P>
    
    <P> The applications MUST NOT assume that successfully sending 
      one message implies that they have the permission to send all
      kinds of messages to all addresses. </P>

    
    <P> An application should handle <code>SecurityException</code>s when a connection 
      handle is provided from <code>Connector.open(url)</code> and for
      any message <code>receive()</code> or <code>send()</code>
      operation that potentially engages with the network or the
      privileged message storage on the device. </P>

    <H3>Permissions for MIDP 1.0 Platform</H3>
    
    <P> When the JSR 205 interfaces are deployed on a MIDP 1.0 device, there is no 
      formal mechanism to identify how a permission to use a specific feature can 
      be granted to a running application. On some systems, the decision to permit 
      a particular operation is left in the hands of the end user. If the user decides 
      to deny the required permission, then a <code>SecurityException</code> can be 
      thrown from the <code>Connector.open()</code>, the <code>MessageConnection.send()</code>, 
      or the <code> MessageConnection.receive()</code> method.</P>
      
      <h3> Permissions for MIDP 2.0 Platform </h3>
 
      <p>When the JSR 205 interfaces are deployed on a MIDP 2.0 device, 
      permissions must be granted to open a connection and to send and 
      receive messages.
      Separate permissions are provided for the SMS and CBS protocols.</p>
 
      <p>To open a connection, a MIDlet suite must have the appropriate 
      permission to access the <tt>MessageConnection</tt> implementation. 
      If the permission is not granted, then <tt>Connector.open</tt> must 
      throw a <tt>SecurityException</tt>. To send and receive messages, 
      the MIDlet suite can restrict certain types of messages or connection 
      addresses. If the application attempts to send or receive either a
      restricted type of message or a message with a restricted connection 
      address, then a <tt>SecurityException</tt> must be thrown.</p>
 
      <p>For more information on the permissions that are provided by 
      WMA 2.0, see Appendix E "<em>Deploying JSR 205 Interfaces on a MIDP 
      2.0 Platform</em>".</p>

    <H2>How to Use the Messaging API</H2>
    <P> This section provides some examples of how the messaging API can be used.</P>

    <H3>Sending a text message to an end user</H3>
    
    <P> The following sample code sends the string "Hello World!" to an end user as 
      a normal SMS message. </P>
    
<PRE><CODE>
try {
  String addr = "sms://+358401234567";
  MessageConnection conn = (MessageConnection) Connector.open(addr);
  TextMessage msg =   
    (TextMessage)conn.newMessage(MessageConnection.TEXT_MESSAGE);
  msg.setPayloadText("Hello World!");
  conn.send(msg);
} catch (Exception e) {
	...
}
</CODE>
</PRE>
    
    <h3>A server that responds to received messages</h3>
    
    <P> The following sample code illustrates a server application that waits for 
      messages sent to port <code>5432</code> and responds to them. </P>
    
<PRE><code>
try {
  String addr = "sms://:5432";
  MessageConnection conn = (MessageConnection) Connector.open(addr);
  Message msg = null;
  
  while (someExitCondition) {
  // wait for incoming messages
  
  msg = conn.receive();
  // received a message
  if (msg instanceof TextMessage) {
     TextMessage tmsg = (TextMessage)msg;
    
     String receivedText = tmsg.getPayloadText();
     // respond with the same text with "Received:" 
     // inserted in the beginning

     tmsg.setPayloadText("Received:" + receivedText);
     // Note that the recipient address in the	message is
     // already correct as we are reusing the same object
  
     conn.send(tmsg);
     } else {

     // Received message was not a text message, but e.g. binary
 
       ...
     }
   }
} catch (Exception e) {
   ...
}
</code>
</PRE>
      

    
<P>

<P>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Overview</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="overview-summary.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A></NOSCRIPT>

</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<p><address>Copyright (C) 2004 Siemens AG, Germany.       All rights reserved. Use is subject to license terms.</address>
</BODY>
</HTML>