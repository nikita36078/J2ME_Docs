<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2) on Thu Oct 12 14:34:32 PDT 2006 -->
<TITLE>
GL10 (JSR 239 Final Release)
</TITLE><meta name="collection" content="api">

<META NAME="keywords" CONTENT="javax.microedition.khronos.opengles.GL10 interface">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="GL10 (JSR 239 Final Release)";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A><small><b>Use is subject to <a href="http://java.sun.com/javame/reference/apis/license.html" target="_top">License Terms</a>.</b> Your use of this web site or any of its content or software indicates your agreement to be bound by these License Terms.<br><br>Copyright &copy; 2007 Sun Microsystems, Inc. All rights reserved.</small><hr>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GL10.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<font size=-1>The Java&trade; Binding for the OpenGL&reg; ES API</font></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../javax/microedition/khronos/opengles/GL.html" title="interface in javax.microedition.khronos.opengles"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../javax/microedition/khronos/opengles/GL10Ext.html" title="interface in javax.microedition.khronos.opengles"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GL10.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.microedition.khronos.opengles</FONT>
<BR>
Interface GL10</H2>
<DL>
<DT><B>All Superinterfaces:</B> <DD><A HREF="../../../../javax/microedition/khronos/opengles/GL.html" title="interface in javax.microedition.khronos.opengles">GL</A></DD>
</DL>
<DL>
<DT><B>All Known Subinterfaces:</B> <DD><A HREF="../../../../javax/microedition/khronos/opengles/GL11.html" title="interface in javax.microedition.khronos.opengles">GL11</A></DD>
</DL>
<HR>
<DL>
<DT>public interface <B>GL10</B><DT>extends <A HREF="../../../../javax/microedition/khronos/opengles/GL.html" title="interface in javax.microedition.khronos.opengles">GL</A></DL>

<P>
The <code>GL10</code> interface contains the Java(TM) programming
 language bindings for OpenGL(R) ES 1.0 core functionality.

 <p> The <code>OES_byte_coordinates</code>,
 <code>OES_single_precision</code>, <code>OES_fixed_point</code>,
 <code>OES_read_format</code>, and
 <code>OES_compressed_paletted_texture</code> extensions are
 included as part of this interface.

 <p> Methods with an <code>x</code> or <code>xv</code> suffix belong
 to the <code>OES_fixed_point</code> extension and take one or more
 fixed-point arguments. Fixed-point arguments may be derived from
 floating-point values by multiplying by 65536 (2^16) and rounding
 to the nearest integer.

 <p> For ease of use, this interface documents method behavior for
 all versions of OpenGL ES including version 1.1 and extensions.
 When running on an OpenGL ES 1.0 implementation, sections marked
 "(1.1 only)" should be disregarded.

 <p> See the <code>GL</code> interface for a description of how to
 obtain an instance of this interface.
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_ADD">GL_ADD</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_ALIASED_LINE_WIDTH_RANGE">GL_ALIASED_LINE_WIDTH_RANGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_ALIASED_POINT_SIZE_RANGE">GL_ALIASED_POINT_SIZE_RANGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_ALPHA">GL_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_ALPHA_BITS">GL_ALPHA_BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_ALPHA_TEST">GL_ALPHA_TEST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_ALWAYS">GL_ALWAYS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_AMBIENT">GL_AMBIENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_AMBIENT_AND_DIFFUSE">GL_AMBIENT_AND_DIFFUSE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_AND">GL_AND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_AND_INVERTED">GL_AND_INVERTED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_AND_REVERSE">GL_AND_REVERSE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_BACK">GL_BACK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_BLEND">GL_BLEND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_BLUE_BITS">GL_BLUE_BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_BYTE">GL_BYTE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_CCW">GL_CCW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_CLAMP_TO_EDGE">GL_CLAMP_TO_EDGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_CLEAR">GL_CLEAR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_COLOR_ARRAY">GL_COLOR_ARRAY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_COLOR_BUFFER_BIT">GL_COLOR_BUFFER_BIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_COLOR_LOGIC_OP">GL_COLOR_LOGIC_OP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_COLOR_MATERIAL">GL_COLOR_MATERIAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_COMPRESSED_TEXTURE_FORMATS">GL_COMPRESSED_TEXTURE_FORMATS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_CONSTANT_ATTENUATION">GL_CONSTANT_ATTENUATION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_COPY">GL_COPY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_COPY_INVERTED">GL_COPY_INVERTED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_CULL_FACE">GL_CULL_FACE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_CW">GL_CW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_DECAL">GL_DECAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_DECR">GL_DECR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_DEPTH_BITS">GL_DEPTH_BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_DEPTH_BUFFER_BIT">GL_DEPTH_BUFFER_BIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_DEPTH_TEST">GL_DEPTH_TEST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_DIFFUSE">GL_DIFFUSE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_DITHER">GL_DITHER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_DONT_CARE">GL_DONT_CARE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_DST_ALPHA">GL_DST_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_DST_COLOR">GL_DST_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_EMISSION">GL_EMISSION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_EQUAL">GL_EQUAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_EQUIV">GL_EQUIV</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_EXP">GL_EXP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_EXP2">GL_EXP2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_EXTENSIONS">GL_EXTENSIONS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_FALSE">GL_FALSE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_FASTEST">GL_FASTEST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_FIXED">GL_FIXED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_FLAT">GL_FLAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_FLOAT">GL_FLOAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_FOG">GL_FOG</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_FOG_COLOR">GL_FOG_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_FOG_DENSITY">GL_FOG_DENSITY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_FOG_END">GL_FOG_END</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_FOG_HINT">GL_FOG_HINT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_FOG_MODE">GL_FOG_MODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_FOG_START">GL_FOG_START</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_FRONT">GL_FRONT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_FRONT_AND_BACK">GL_FRONT_AND_BACK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_GEQUAL">GL_GEQUAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_GREATER">GL_GREATER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_GREEN_BITS">GL_GREEN_BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES">GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_IMPLEMENTATION_COLOR_READ_TYPE_OES">GL_IMPLEMENTATION_COLOR_READ_TYPE_OES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_INCR">GL_INCR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_INVALID_ENUM">GL_INVALID_ENUM</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_INVALID_OPERATION">GL_INVALID_OPERATION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_INVALID_VALUE">GL_INVALID_VALUE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_INVERT">GL_INVERT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_KEEP">GL_KEEP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LEQUAL">GL_LEQUAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LESS">GL_LESS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LIGHT_MODEL_AMBIENT">GL_LIGHT_MODEL_AMBIENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LIGHT_MODEL_TWO_SIDE">GL_LIGHT_MODEL_TWO_SIDE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LIGHT0">GL_LIGHT0</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LIGHT1">GL_LIGHT1</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LIGHT2">GL_LIGHT2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LIGHT3">GL_LIGHT3</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LIGHT4">GL_LIGHT4</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LIGHT5">GL_LIGHT5</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LIGHT6">GL_LIGHT6</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LIGHT7">GL_LIGHT7</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LIGHTING">GL_LIGHTING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LINE_LOOP">GL_LINE_LOOP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LINE_SMOOTH">GL_LINE_SMOOTH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LINE_SMOOTH_HINT">GL_LINE_SMOOTH_HINT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LINE_STRIP">GL_LINE_STRIP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LINEAR">GL_LINEAR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LINEAR_ATTENUATION">GL_LINEAR_ATTENUATION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LINEAR_MIPMAP_LINEAR">GL_LINEAR_MIPMAP_LINEAR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LINEAR_MIPMAP_NEAREST">GL_LINEAR_MIPMAP_NEAREST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LINES">GL_LINES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LUMINANCE">GL_LUMINANCE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_LUMINANCE_ALPHA">GL_LUMINANCE_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_MAX_ELEMENTS_INDICES">GL_MAX_ELEMENTS_INDICES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_MAX_ELEMENTS_VERTICES">GL_MAX_ELEMENTS_VERTICES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_MAX_LIGHTS">GL_MAX_LIGHTS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_MAX_MODELVIEW_STACK_DEPTH">GL_MAX_MODELVIEW_STACK_DEPTH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_MAX_PROJECTION_STACK_DEPTH">GL_MAX_PROJECTION_STACK_DEPTH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_MAX_TEXTURE_SIZE">GL_MAX_TEXTURE_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_MAX_TEXTURE_STACK_DEPTH">GL_MAX_TEXTURE_STACK_DEPTH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_MAX_TEXTURE_UNITS">GL_MAX_TEXTURE_UNITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_MAX_VIEWPORT_DIMS">GL_MAX_VIEWPORT_DIMS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_MODELVIEW">GL_MODELVIEW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_MODULATE">GL_MODULATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_MULTISAMPLE">GL_MULTISAMPLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_NAND">GL_NAND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_NEAREST">GL_NEAREST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_NEAREST_MIPMAP_LINEAR">GL_NEAREST_MIPMAP_LINEAR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_NEAREST_MIPMAP_NEAREST">GL_NEAREST_MIPMAP_NEAREST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_NEVER">GL_NEVER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_NICEST">GL_NICEST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_NO_ERROR">GL_NO_ERROR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_NOOP">GL_NOOP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_NOR">GL_NOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_NORMAL_ARRAY">GL_NORMAL_ARRAY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_NORMALIZE">GL_NORMALIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_NOTEQUAL">GL_NOTEQUAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_NUM_COMPRESSED_TEXTURE_FORMATS">GL_NUM_COMPRESSED_TEXTURE_FORMATS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_ONE">GL_ONE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_ONE_MINUS_DST_ALPHA">GL_ONE_MINUS_DST_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_ONE_MINUS_DST_COLOR">GL_ONE_MINUS_DST_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_ONE_MINUS_SRC_ALPHA">GL_ONE_MINUS_SRC_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_ONE_MINUS_SRC_COLOR">GL_ONE_MINUS_SRC_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_OR">GL_OR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_OR_INVERTED">GL_OR_INVERTED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_OR_REVERSE">GL_OR_REVERSE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_OUT_OF_MEMORY">GL_OUT_OF_MEMORY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_PACK_ALIGNMENT">GL_PACK_ALIGNMENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_PALETTE4_R5_G6_B5_OES">GL_PALETTE4_R5_G6_B5_OES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_PALETTE4_RGB5_A1_OES">GL_PALETTE4_RGB5_A1_OES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_PALETTE4_RGB8_OES">GL_PALETTE4_RGB8_OES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_PALETTE4_RGBA4_OES">GL_PALETTE4_RGBA4_OES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_PALETTE4_RGBA8_OES">GL_PALETTE4_RGBA8_OES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_PALETTE8_R5_G6_B5_OES">GL_PALETTE8_R5_G6_B5_OES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_PALETTE8_RGB5_A1_OES">GL_PALETTE8_RGB5_A1_OES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_PALETTE8_RGB8_OES">GL_PALETTE8_RGB8_OES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_PALETTE8_RGBA4_OES">GL_PALETTE8_RGBA4_OES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_PALETTE8_RGBA8_OES">GL_PALETTE8_RGBA8_OES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_PERSPECTIVE_CORRECTION_HINT">GL_PERSPECTIVE_CORRECTION_HINT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_POINT_SMOOTH">GL_POINT_SMOOTH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_POINT_SMOOTH_HINT">GL_POINT_SMOOTH_HINT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_POINTS">GL_POINTS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_POLYGON_OFFSET_FILL">GL_POLYGON_OFFSET_FILL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_POLYGON_SMOOTH_HINT">GL_POLYGON_SMOOTH_HINT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_POSITION">GL_POSITION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_PROJECTION">GL_PROJECTION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_QUADRATIC_ATTENUATION">GL_QUADRATIC_ATTENUATION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_RED_BITS">GL_RED_BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_RENDERER">GL_RENDERER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_REPEAT">GL_REPEAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_REPLACE">GL_REPLACE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_RESCALE_NORMAL">GL_RESCALE_NORMAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_RGB">GL_RGB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_RGBA">GL_RGBA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SAMPLE_ALPHA_TO_COVERAGE">GL_SAMPLE_ALPHA_TO_COVERAGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SAMPLE_ALPHA_TO_ONE">GL_SAMPLE_ALPHA_TO_ONE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SAMPLE_COVERAGE">GL_SAMPLE_COVERAGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SCISSOR_TEST">GL_SCISSOR_TEST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SET">GL_SET</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SHININESS">GL_SHININESS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SHORT">GL_SHORT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SMOOTH">GL_SMOOTH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SMOOTH_LINE_WIDTH_RANGE">GL_SMOOTH_LINE_WIDTH_RANGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SMOOTH_POINT_SIZE_RANGE">GL_SMOOTH_POINT_SIZE_RANGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SPECULAR">GL_SPECULAR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SPOT_CUTOFF">GL_SPOT_CUTOFF</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SPOT_DIRECTION">GL_SPOT_DIRECTION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SPOT_EXPONENT">GL_SPOT_EXPONENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SRC_ALPHA">GL_SRC_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SRC_ALPHA_SATURATE">GL_SRC_ALPHA_SATURATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SRC_COLOR">GL_SRC_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_STACK_OVERFLOW">GL_STACK_OVERFLOW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_STACK_UNDERFLOW">GL_STACK_UNDERFLOW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_STENCIL_BITS">GL_STENCIL_BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_STENCIL_BUFFER_BIT">GL_STENCIL_BUFFER_BIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_STENCIL_TEST">GL_STENCIL_TEST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_SUBPIXEL_BITS">GL_SUBPIXEL_BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE">GL_TEXTURE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE_2D">GL_TEXTURE_2D</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE_COORD_ARRAY">GL_TEXTURE_COORD_ARRAY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE_ENV">GL_TEXTURE_ENV</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE_ENV_COLOR">GL_TEXTURE_ENV_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE_ENV_MODE">GL_TEXTURE_ENV_MODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE_MAG_FILTER">GL_TEXTURE_MAG_FILTER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE_MIN_FILTER">GL_TEXTURE_MIN_FILTER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE_WRAP_S">GL_TEXTURE_WRAP_S</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE_WRAP_T">GL_TEXTURE_WRAP_T</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE0">GL_TEXTURE0</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE1">GL_TEXTURE1</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE10">GL_TEXTURE10</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE11">GL_TEXTURE11</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE12">GL_TEXTURE12</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE13">GL_TEXTURE13</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE14">GL_TEXTURE14</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE15">GL_TEXTURE15</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE16">GL_TEXTURE16</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE17">GL_TEXTURE17</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE18">GL_TEXTURE18</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE19">GL_TEXTURE19</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE2">GL_TEXTURE2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE20">GL_TEXTURE20</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE21">GL_TEXTURE21</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE22">GL_TEXTURE22</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE23">GL_TEXTURE23</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE24">GL_TEXTURE24</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE25">GL_TEXTURE25</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE26">GL_TEXTURE26</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE27">GL_TEXTURE27</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE28">GL_TEXTURE28</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE29">GL_TEXTURE29</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE3">GL_TEXTURE3</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE30">GL_TEXTURE30</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE31">GL_TEXTURE31</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE4">GL_TEXTURE4</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE5">GL_TEXTURE5</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE6">GL_TEXTURE6</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE7">GL_TEXTURE7</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE8">GL_TEXTURE8</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TEXTURE9">GL_TEXTURE9</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TRIANGLE_FAN">GL_TRIANGLE_FAN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TRIANGLE_STRIP">GL_TRIANGLE_STRIP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TRIANGLES">GL_TRIANGLES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_TRUE">GL_TRUE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_UNPACK_ALIGNMENT">GL_UNPACK_ALIGNMENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_UNSIGNED_BYTE">GL_UNSIGNED_BYTE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_UNSIGNED_SHORT">GL_UNSIGNED_SHORT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_UNSIGNED_SHORT_4_4_4_4">GL_UNSIGNED_SHORT_4_4_4_4</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_UNSIGNED_SHORT_5_5_5_1">GL_UNSIGNED_SHORT_5_5_5_1</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_UNSIGNED_SHORT_5_6_5">GL_UNSIGNED_SHORT_5_6_5</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_VENDOR">GL_VENDOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_VERSION">GL_VERSION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_VERTEX_ARRAY">GL_VERTEX_ARRAY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_XOR">GL_XOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#GL_ZERO">GL_ZERO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 1.0 constant.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glActiveTexture(int)">glActiveTexture</A></B>(int&nbsp;texture)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select server-side active texture unit.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glAlphaFunc(int, float)">glAlphaFunc</A></B>(int&nbsp;func,
            float&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify the alpha test function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glAlphaFuncx(int, int)">glAlphaFuncx</A></B>(int&nbsp;func,
             int&nbsp;ref)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glAlphaFunc</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glBindTexture(int, int)">glBindTexture</A></B>(int&nbsp;target,
              int&nbsp;texture)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bind a named texture to a texturing target.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glBlendFunc(int, int)">glBlendFunc</A></B>(int&nbsp;sfactor,
            int&nbsp;dfactor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify pixel arithmetic.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glClear(int)">glClear</A></B>(int&nbsp;mask)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clear buffers to preset values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glClearColor(float, float, float, float)">glClearColor</A></B>(float&nbsp;red,
             float&nbsp;green,
             float&nbsp;blue,
             float&nbsp;alpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify clear values for the color buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glClearColorx(int, int, int, int)">glClearColorx</A></B>(int&nbsp;red,
              int&nbsp;green,
              int&nbsp;blue,
              int&nbsp;alpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glClearColor</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glClearDepthf(float)">glClearDepthf</A></B>(float&nbsp;depth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify the clear value for the depth buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glClearDepthx(int)">glClearDepthx</A></B>(int&nbsp;depth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glClearDepth</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glClearStencil(int)">glClearStencil</A></B>(int&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify the clear value for the stencil buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glClientActiveTexture(int)">glClientActiveTexture</A></B>(int&nbsp;texture)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select client-side active texture unit.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glColor4f(float, float, float, float)">glColor4f</A></B>(float&nbsp;red,
          float&nbsp;green,
          float&nbsp;blue,
          float&nbsp;alpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the current color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glColor4x(int, int, int, int)">glColor4x</A></B>(int&nbsp;red,
          int&nbsp;green,
          int&nbsp;blue,
          int&nbsp;alpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glColor</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glColorMask(boolean, boolean, boolean, boolean)">glColorMask</A></B>(boolean&nbsp;red,
            boolean&nbsp;green,
            boolean&nbsp;blue,
            boolean&nbsp;alpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable and disable writing of color buffer components.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glColorPointer(int, int, int, java.nio.Buffer)">glColorPointer</A></B>(int&nbsp;size,
               int&nbsp;type,
               int&nbsp;stride,
               <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define an array of colors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glCompressedTexImage2D(int, int, int, int, int, int, int, java.nio.Buffer)">glCompressedTexImage2D</A></B>(int&nbsp;target,
                       int&nbsp;level,
                       int&nbsp;internalformat,
                       int&nbsp;width,
                       int&nbsp;height,
                       int&nbsp;border,
                       int&nbsp;imageSize,
                       <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify a two-dimensional compressed texture image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glCompressedTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)">glCompressedTexSubImage2D</A></B>(int&nbsp;target,
                          int&nbsp;level,
                          int&nbsp;xoffset,
                          int&nbsp;yoffset,
                          int&nbsp;width,
                          int&nbsp;height,
                          int&nbsp;format,
                          int&nbsp;imageSize,
                          <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify a two-dimensional compressed texture subimage.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)">glCopyTexImage2D</A></B>(int&nbsp;target,
                 int&nbsp;level,
                 int&nbsp;internalformat,
                 int&nbsp;x,
                 int&nbsp;y,
                 int&nbsp;width,
                 int&nbsp;height,
                 int&nbsp;border)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify a two-dimensional texture image with pixels from the
 color buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glCopyTexSubImage2D(int, int, int, int, int, int, int, int)">glCopyTexSubImage2D</A></B>(int&nbsp;target,
                    int&nbsp;level,
                    int&nbsp;xoffset,
                    int&nbsp;yoffset,
                    int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;width,
                    int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify a two-dimensional texture subimage with pixels from the
 color buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glCullFace(int)">glCullFace</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify whether front- or back-facing polygons are culled.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glDeleteTextures(int, int[], int)">glDeleteTextures</A></B>(int&nbsp;n,
                 int[]&nbsp;textures,
                 int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete named textures.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glDeleteTextures(int, java.nio.IntBuffer)">glDeleteTextures</A></B>(int&nbsp;n,
                 <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;textures)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <code>Buffer</code> version of <code>glDeleteTextures</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glDepthFunc(int)">glDepthFunc</A></B>(int&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify the value used for depth buffer comparisons.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glDepthMask(boolean)">glDepthMask</A></B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable or disable writing into the depth buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glDepthRangef(float, float)">glDepthRangef</A></B>(float&nbsp;zNear,
              float&nbsp;zFar)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify mapping of depth values from normalized device
 coordinates to window coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glDepthRangex(int, int)">glDepthRangex</A></B>(int&nbsp;zNear,
              int&nbsp;zFar)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glDepthRange</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glDisable(int)">glDisable</A></B>(int&nbsp;cap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disable server-side GL capabilities.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glDisableClientState(int)">glDisableClientState</A></B>(int&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disable client-side capability.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glDrawArrays(int, int, int)">glDrawArrays</A></B>(int&nbsp;mode,
             int&nbsp;first,
             int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Render primitives from array data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glDrawElements(int, int, int, java.nio.Buffer)">glDrawElements</A></B>(int&nbsp;mode,
               int&nbsp;count,
               int&nbsp;type,
               <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;indices)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Render primitives from array data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glEnable(int)">glEnable</A></B>(int&nbsp;cap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable server-side GL capabilities.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glEnableClientState(int)">glEnableClientState</A></B>(int&nbsp;array)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable client-side capability.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFinish()">glFinish</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Block until all GL execution is complete.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFlush()">glFlush</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Force execution of GL commands in finite time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFogf(int, float)">glFogf</A></B>(int&nbsp;pname,
       float&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify fog parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFogfv(int, float[], int)">glFogfv</A></B>(int&nbsp;pname,
        float[]&nbsp;params,
        int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify fog parameters (array version).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFogfv(int, java.nio.FloatBuffer)">glFogfv</A></B>(int&nbsp;pname,
        <A HREF="../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point <code>Buffer</code> version of <code>glFog</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFogx(int, int)">glFogx</A></B>(int&nbsp;pname,
       int&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glFog</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFogxv(int, int[], int)">glFogxv</A></B>(int&nbsp;pname,
        int[]&nbsp;params,
        int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point array version of <code>glFog</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFogxv(int, java.nio.IntBuffer)">glFogxv</A></B>(int&nbsp;pname,
        <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point <code>Buffer</code> version of <code>glFog</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFrontFace(int)">glFrontFace</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define front- and back-facing polygons.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFrustumf(float, float, float, float, float, float)">glFrustumf</A></B>(float&nbsp;left,
           float&nbsp;right,
           float&nbsp;bottom,
           float&nbsp;top,
           float&nbsp;near,
           float&nbsp;far)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiply the current matrix by a perspective matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFrustumx(int, int, int, int, int, int)">glFrustumx</A></B>(int&nbsp;left,
           int&nbsp;right,
           int&nbsp;bottom,
           int&nbsp;top,
           int&nbsp;near,
           int&nbsp;far)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glFrustum</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glGenTextures(int, int[], int)">glGenTextures</A></B>(int&nbsp;n,
              int[]&nbsp;textures,
              int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate texture names.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glGenTextures(int, java.nio.IntBuffer)">glGenTextures</A></B>(int&nbsp;n,
              <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;textures)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <code>Buffer</code> version of <code>glGenTextures</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glGetError()">glGetError</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return error information.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glGetIntegerv(int, int[], int)">glGetIntegerv</A></B>(int&nbsp;pname,
              int[]&nbsp;params,
              int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the value or values of a selected parameter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glGetIntegerv(int, java.nio.IntBuffer)">glGetIntegerv</A></B>(int&nbsp;pname,
              <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <code>Buffer</code> version of <code>glGetIntegerv</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glGetString(int)">glGetString</A></B>(int&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a string describing the underlying GL implementation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glHint(int, int)">glHint</A></B>(int&nbsp;target,
       int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify implementation-specific hints.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightf(int, int, float)">glLightf</A></B>(int&nbsp;light,
         int&nbsp;pname,
         float&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set light source parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightfv(int, int, float[], int)">glLightfv</A></B>(int&nbsp;light,
          int&nbsp;pname,
          float[]&nbsp;params,
          int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set light source parameters (array version).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightfv(int, int, java.nio.FloatBuffer)">glLightfv</A></B>(int&nbsp;light,
          int&nbsp;pname,
          <A HREF="../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point <code>Buffer</code> version of <code>glLight</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightModelf(int, float)">glLightModelf</A></B>(int&nbsp;pname,
              float&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the lighting model parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightModelfv(int, float[], int)">glLightModelfv</A></B>(int&nbsp;pname,
               float[]&nbsp;params,
               int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the lighting model parameters (array version).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightModelfv(int, java.nio.FloatBuffer)">glLightModelfv</A></B>(int&nbsp;pname,
               <A HREF="../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point <code>Buffer</code> version of <code>glLightModel</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightModelx(int, int)">glLightModelx</A></B>(int&nbsp;pname,
              int&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glLightModel</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightModelxv(int, int[], int)">glLightModelxv</A></B>(int&nbsp;pname,
               int[]&nbsp;params,
               int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point array version of <code>glLightModel</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightModelxv(int, java.nio.IntBuffer)">glLightModelxv</A></B>(int&nbsp;pname,
               <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point <code>Buffer</code> version of <code>glLightModel</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightx(int, int, int)">glLightx</A></B>(int&nbsp;light,
         int&nbsp;pname,
         int&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glLight</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightxv(int, int, int[], int)">glLightxv</A></B>(int&nbsp;light,
          int&nbsp;pname,
          int[]&nbsp;params,
          int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point array version of <code>glLight</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightxv(int, int, java.nio.IntBuffer)">glLightxv</A></B>(int&nbsp;light,
          int&nbsp;pname,
          <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point <code>Buffer</code> version of <code>glLight</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLineWidth(float)">glLineWidth</A></B>(float&nbsp;width)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify the width of rasterized lines.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLineWidthx(int)">glLineWidthx</A></B>(int&nbsp;width)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glLineWidth</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLoadIdentity()">glLoadIdentity</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replace the current matrix with the identity matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLoadMatrixf(float[], int)">glLoadMatrixf</A></B>(float[]&nbsp;m,
              int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replace the current matrix with the specified matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLoadMatrixf(java.nio.FloatBuffer)">glLoadMatrixf</A></B>(<A HREF="../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point <code>Buffer</code> version of <code>glLoadMatrix</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLoadMatrixx(int[], int)">glLoadMatrixx</A></B>(int[]&nbsp;m,
              int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point array version of <code>glLoadMatrix</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLoadMatrixx(java.nio.IntBuffer)">glLoadMatrixx</A></B>(<A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point <code>Buffer</code> version of <code>glLoadMatrix</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLogicOp(int)">glLogicOp</A></B>(int&nbsp;opcode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify a logical pixel operation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMaterialf(int, int, float)">glMaterialf</A></B>(int&nbsp;face,
            int&nbsp;pname,
            float&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify material parameters for the lighting model.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMaterialfv(int, int, float[], int)">glMaterialfv</A></B>(int&nbsp;face,
             int&nbsp;pname,
             float[]&nbsp;params,
             int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify material parameters for the lighting model (array
 version).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMaterialfv(int, int, java.nio.FloatBuffer)">glMaterialfv</A></B>(int&nbsp;face,
             int&nbsp;pname,
             <A HREF="../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point <code>Buffer</code> version of <code>glMaterial</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMaterialx(int, int, int)">glMaterialx</A></B>(int&nbsp;face,
            int&nbsp;pname,
            int&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glMaterial</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMaterialxv(int, int, int[], int)">glMaterialxv</A></B>(int&nbsp;face,
             int&nbsp;pname,
             int[]&nbsp;params,
             int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point array version of <code>glMaterial</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMaterialxv(int, int, java.nio.IntBuffer)">glMaterialxv</A></B>(int&nbsp;face,
             int&nbsp;pname,
             <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point <code>Buffer</code> version of <code>glMaterial</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMatrixMode(int)">glMatrixMode</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify which matrix is the current matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMultiTexCoord4f(int, float, float, float, float)">glMultiTexCoord4f</A></B>(int&nbsp;target,
                  float&nbsp;s,
                  float&nbsp;t,
                  float&nbsp;r,
                  float&nbsp;q)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the current texture coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMultiTexCoord4x(int, int, int, int, int)">glMultiTexCoord4x</A></B>(int&nbsp;target,
                  int&nbsp;s,
                  int&nbsp;t,
                  int&nbsp;r,
                  int&nbsp;q)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glMultiTexCoord</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMultMatrixf(float[], int)">glMultMatrixf</A></B>(float[]&nbsp;m,
              int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiply the current matrix with the specified matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMultMatrixf(java.nio.FloatBuffer)">glMultMatrixf</A></B>(<A HREF="../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point <code>Buffer</code> version of <code>glMultMatrix</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMultMatrixx(int[], int)">glMultMatrixx</A></B>(int[]&nbsp;m,
              int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point array version of <code>glMultMatrix</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMultMatrixx(java.nio.IntBuffer)">glMultMatrixx</A></B>(<A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point <code>Buffer</code> version of <code>glMultMatrix</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glNormal3f(float, float, float)">glNormal3f</A></B>(float&nbsp;nx,
           float&nbsp;ny,
           float&nbsp;nz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the current normal vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glNormal3x(int, int, int)">glNormal3x</A></B>(int&nbsp;nx,
           int&nbsp;ny,
           int&nbsp;nz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glNormal</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glNormalPointer(int, int, java.nio.Buffer)">glNormalPointer</A></B>(int&nbsp;type,
                int&nbsp;stride,
                <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define an array of normals.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glOrthof(float, float, float, float, float, float)">glOrthof</A></B>(float&nbsp;left,
         float&nbsp;right,
         float&nbsp;bottom,
         float&nbsp;top,
         float&nbsp;near,
         float&nbsp;far)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiply the current matrix with an orthographic matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glOrthox(int, int, int, int, int, int)">glOrthox</A></B>(int&nbsp;left,
         int&nbsp;right,
         int&nbsp;bottom,
         int&nbsp;top,
         int&nbsp;near,
         int&nbsp;far)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glOrtho</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glPixelStorei(int, int)">glPixelStorei</A></B>(int&nbsp;pname,
              int&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set pixel storage modes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glPointSize(float)">glPointSize</A></B>(float&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify the diameter of rasterized points.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glPointSizex(int)">glPointSizex</A></B>(int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glPointSize</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glPolygonOffset(float, float)">glPolygonOffset</A></B>(float&nbsp;factor,
                float&nbsp;units)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the scale and units used to calculate depth values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glPolygonOffsetx(int, int)">glPolygonOffsetx</A></B>(int&nbsp;factor,
                 int&nbsp;units)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glPolygonOffset</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glPopMatrix()">glPopMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pop the current matrix stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glPushMatrix()">glPushMatrix</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Push the current matrix stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glReadPixels(int, int, int, int, int, int, java.nio.Buffer)">glReadPixels</A></B>(int&nbsp;x,
             int&nbsp;y,
             int&nbsp;width,
             int&nbsp;height,
             int&nbsp;format,
             int&nbsp;type,
             <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pixels)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read a block of pixels from the color buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glRotatef(float, float, float, float)">glRotatef</A></B>(float&nbsp;angle,
          float&nbsp;x,
          float&nbsp;y,
          float&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiply the current matrix by a rotation matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glRotatex(int, int, int, int)">glRotatex</A></B>(int&nbsp;angle,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glRotate</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glSampleCoverage(float, boolean)">glSampleCoverage</A></B>(float&nbsp;value,
                 boolean&nbsp;invert)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify mask to modify multisampled pixel fragments.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glSampleCoveragex(int, boolean)">glSampleCoveragex</A></B>(int&nbsp;value,
                  boolean&nbsp;invert)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glSampleCoverage</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glScalef(float, float, float)">glScalef</A></B>(float&nbsp;x,
         float&nbsp;y,
         float&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiply the current matrix by a general scaling matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glScalex(int, int, int)">glScalex</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glScale</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glScissor(int, int, int, int)">glScissor</A></B>(int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define the scissor box.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glShadeModel(int)">glShadeModel</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select flat or smooth shading.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glStencilFunc(int, int, int)">glStencilFunc</A></B>(int&nbsp;func,
              int&nbsp;ref,
              int&nbsp;mask)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set function and reference value for stencil testing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glStencilMask(int)">glStencilMask</A></B>(int&nbsp;mask)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Control the writing of individual bits in the stencil planes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glStencilOp(int, int, int)">glStencilOp</A></B>(int&nbsp;fail,
            int&nbsp;zfail,
            int&nbsp;zpass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set stencil test actions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexCoordPointer(int, int, int, java.nio.Buffer)">glTexCoordPointer</A></B>(int&nbsp;size,
                  int&nbsp;type,
                  int&nbsp;stride,
                  <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define an array of texture coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexEnvf(int, int, float)">glTexEnvf</A></B>(int&nbsp;target,
          int&nbsp;pname,
          float&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set texture environment parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexEnvfv(int, int, float[], int)">glTexEnvfv</A></B>(int&nbsp;target,
           int&nbsp;pname,
           float[]&nbsp;params,
           int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set texture environment parameters (array version).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexEnvfv(int, int, java.nio.FloatBuffer)">glTexEnvfv</A></B>(int&nbsp;target,
           int&nbsp;pname,
           <A HREF="../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point <code>Buffer</code> version of <code>glTexEnv</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexEnvx(int, int, int)">glTexEnvx</A></B>(int&nbsp;target,
          int&nbsp;pname,
          int&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glTexEnv</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexEnvxv(int, int, int[], int)">glTexEnvxv</A></B>(int&nbsp;target,
           int&nbsp;pname,
           int[]&nbsp;params,
           int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point array version of <code>glTexEnv</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexEnvxv(int, int, java.nio.IntBuffer)">glTexEnvxv</A></B>(int&nbsp;target,
           int&nbsp;pname,
           <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point <code>Buffer</code> version of <code>glTexEnv</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)">glTexImage2D</A></B>(int&nbsp;target,
             int&nbsp;level,
             int&nbsp;internalformat,
             int&nbsp;width,
             int&nbsp;height,
             int&nbsp;border,
             int&nbsp;format,
             int&nbsp;type,
             <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pixels)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify a two-dimensional texture image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexParameterf(int, int, float)">glTexParameterf</A></B>(int&nbsp;target,
                int&nbsp;pname,
                float&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set texture parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexParameterx(int, int, int)">glTexParameterx</A></B>(int&nbsp;target,
                int&nbsp;pname,
                int&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glTexParameter</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)">glTexSubImage2D</A></B>(int&nbsp;target,
                int&nbsp;level,
                int&nbsp;xoffset,
                int&nbsp;yoffset,
                int&nbsp;width,
                int&nbsp;height,
                int&nbsp;format,
                int&nbsp;type,
                <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pixels)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify a two-dimensional texture subimage.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTranslatef(float, float, float)">glTranslatef</A></B>(float&nbsp;x,
             float&nbsp;y,
             float&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Multiply the current matrix by a translation matrix.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTranslatex(int, int, int)">glTranslatex</A></B>(int&nbsp;x,
             int&nbsp;y,
             int&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fixed-point version of <code>glTranslate</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glVertexPointer(int, int, int, java.nio.Buffer)">glVertexPointer</A></B>(int&nbsp;size,
                int&nbsp;type,
                int&nbsp;stride,
                <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pointer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define an array of vertex coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glViewport(int, int, int, int)">glViewport</A></B>(int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the viewport.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="GL_DEPTH_BUFFER_BIT"><!-- --></A><H3>
GL_DEPTH_BUFFER_BIT</H3>
<PRE>
public static final int <B>GL_DEPTH_BUFFER_BIT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_DEPTH_BUFFER_BIT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_STENCIL_BUFFER_BIT"><!-- --></A><H3>
GL_STENCIL_BUFFER_BIT</H3>
<PRE>
public static final int <B>GL_STENCIL_BUFFER_BIT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_STENCIL_BUFFER_BIT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_COLOR_BUFFER_BIT"><!-- --></A><H3>
GL_COLOR_BUFFER_BIT</H3>
<PRE>
public static final int <B>GL_COLOR_BUFFER_BIT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_COLOR_BUFFER_BIT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_FALSE"><!-- --></A><H3>
GL_FALSE</H3>
<PRE>
public static final int <B>GL_FALSE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_FALSE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TRUE"><!-- --></A><H3>
GL_TRUE</H3>
<PRE>
public static final int <B>GL_TRUE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TRUE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_POINTS"><!-- --></A><H3>
GL_POINTS</H3>
<PRE>
public static final int <B>GL_POINTS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_POINTS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LINES"><!-- --></A><H3>
GL_LINES</H3>
<PRE>
public static final int <B>GL_LINES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LINES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LINE_LOOP"><!-- --></A><H3>
GL_LINE_LOOP</H3>
<PRE>
public static final int <B>GL_LINE_LOOP</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LINE_LOOP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LINE_STRIP"><!-- --></A><H3>
GL_LINE_STRIP</H3>
<PRE>
public static final int <B>GL_LINE_STRIP</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LINE_STRIP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TRIANGLES"><!-- --></A><H3>
GL_TRIANGLES</H3>
<PRE>
public static final int <B>GL_TRIANGLES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TRIANGLES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TRIANGLE_STRIP"><!-- --></A><H3>
GL_TRIANGLE_STRIP</H3>
<PRE>
public static final int <B>GL_TRIANGLE_STRIP</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TRIANGLE_STRIP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TRIANGLE_FAN"><!-- --></A><H3>
GL_TRIANGLE_FAN</H3>
<PRE>
public static final int <B>GL_TRIANGLE_FAN</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TRIANGLE_FAN">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_NEVER"><!-- --></A><H3>
GL_NEVER</H3>
<PRE>
public static final int <B>GL_NEVER</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_NEVER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LESS"><!-- --></A><H3>
GL_LESS</H3>
<PRE>
public static final int <B>GL_LESS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LESS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_EQUAL"><!-- --></A><H3>
GL_EQUAL</H3>
<PRE>
public static final int <B>GL_EQUAL</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_EQUAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LEQUAL"><!-- --></A><H3>
GL_LEQUAL</H3>
<PRE>
public static final int <B>GL_LEQUAL</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LEQUAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_GREATER"><!-- --></A><H3>
GL_GREATER</H3>
<PRE>
public static final int <B>GL_GREATER</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_GREATER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_NOTEQUAL"><!-- --></A><H3>
GL_NOTEQUAL</H3>
<PRE>
public static final int <B>GL_NOTEQUAL</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_NOTEQUAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_GEQUAL"><!-- --></A><H3>
GL_GEQUAL</H3>
<PRE>
public static final int <B>GL_GEQUAL</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_GEQUAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_ALWAYS"><!-- --></A><H3>
GL_ALWAYS</H3>
<PRE>
public static final int <B>GL_ALWAYS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_ALWAYS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_ZERO"><!-- --></A><H3>
GL_ZERO</H3>
<PRE>
public static final int <B>GL_ZERO</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_ZERO">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_ONE"><!-- --></A><H3>
GL_ONE</H3>
<PRE>
public static final int <B>GL_ONE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_ONE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SRC_COLOR"><!-- --></A><H3>
GL_SRC_COLOR</H3>
<PRE>
public static final int <B>GL_SRC_COLOR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SRC_COLOR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_ONE_MINUS_SRC_COLOR"><!-- --></A><H3>
GL_ONE_MINUS_SRC_COLOR</H3>
<PRE>
public static final int <B>GL_ONE_MINUS_SRC_COLOR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_ONE_MINUS_SRC_COLOR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SRC_ALPHA"><!-- --></A><H3>
GL_SRC_ALPHA</H3>
<PRE>
public static final int <B>GL_SRC_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SRC_ALPHA">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_ONE_MINUS_SRC_ALPHA"><!-- --></A><H3>
GL_ONE_MINUS_SRC_ALPHA</H3>
<PRE>
public static final int <B>GL_ONE_MINUS_SRC_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_ONE_MINUS_SRC_ALPHA">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_DST_ALPHA"><!-- --></A><H3>
GL_DST_ALPHA</H3>
<PRE>
public static final int <B>GL_DST_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_DST_ALPHA">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_ONE_MINUS_DST_ALPHA"><!-- --></A><H3>
GL_ONE_MINUS_DST_ALPHA</H3>
<PRE>
public static final int <B>GL_ONE_MINUS_DST_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_ONE_MINUS_DST_ALPHA">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_DST_COLOR"><!-- --></A><H3>
GL_DST_COLOR</H3>
<PRE>
public static final int <B>GL_DST_COLOR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_DST_COLOR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_ONE_MINUS_DST_COLOR"><!-- --></A><H3>
GL_ONE_MINUS_DST_COLOR</H3>
<PRE>
public static final int <B>GL_ONE_MINUS_DST_COLOR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_ONE_MINUS_DST_COLOR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SRC_ALPHA_SATURATE"><!-- --></A><H3>
GL_SRC_ALPHA_SATURATE</H3>
<PRE>
public static final int <B>GL_SRC_ALPHA_SATURATE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SRC_ALPHA_SATURATE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_FRONT"><!-- --></A><H3>
GL_FRONT</H3>
<PRE>
public static final int <B>GL_FRONT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_FRONT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_BACK"><!-- --></A><H3>
GL_BACK</H3>
<PRE>
public static final int <B>GL_BACK</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_BACK">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_FRONT_AND_BACK"><!-- --></A><H3>
GL_FRONT_AND_BACK</H3>
<PRE>
public static final int <B>GL_FRONT_AND_BACK</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_FRONT_AND_BACK">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_FOG"><!-- --></A><H3>
GL_FOG</H3>
<PRE>
public static final int <B>GL_FOG</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_FOG">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LIGHTING"><!-- --></A><H3>
GL_LIGHTING</H3>
<PRE>
public static final int <B>GL_LIGHTING</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LIGHTING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_2D"><!-- --></A><H3>
GL_TEXTURE_2D</H3>
<PRE>
public static final int <B>GL_TEXTURE_2D</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE_2D">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_CULL_FACE"><!-- --></A><H3>
GL_CULL_FACE</H3>
<PRE>
public static final int <B>GL_CULL_FACE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_CULL_FACE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_ALPHA_TEST"><!-- --></A><H3>
GL_ALPHA_TEST</H3>
<PRE>
public static final int <B>GL_ALPHA_TEST</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_ALPHA_TEST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_BLEND"><!-- --></A><H3>
GL_BLEND</H3>
<PRE>
public static final int <B>GL_BLEND</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_BLEND">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_COLOR_LOGIC_OP"><!-- --></A><H3>
GL_COLOR_LOGIC_OP</H3>
<PRE>
public static final int <B>GL_COLOR_LOGIC_OP</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_COLOR_LOGIC_OP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_DITHER"><!-- --></A><H3>
GL_DITHER</H3>
<PRE>
public static final int <B>GL_DITHER</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_DITHER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_STENCIL_TEST"><!-- --></A><H3>
GL_STENCIL_TEST</H3>
<PRE>
public static final int <B>GL_STENCIL_TEST</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_STENCIL_TEST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_DEPTH_TEST"><!-- --></A><H3>
GL_DEPTH_TEST</H3>
<PRE>
public static final int <B>GL_DEPTH_TEST</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_DEPTH_TEST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_POINT_SMOOTH"><!-- --></A><H3>
GL_POINT_SMOOTH</H3>
<PRE>
public static final int <B>GL_POINT_SMOOTH</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_POINT_SMOOTH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LINE_SMOOTH"><!-- --></A><H3>
GL_LINE_SMOOTH</H3>
<PRE>
public static final int <B>GL_LINE_SMOOTH</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LINE_SMOOTH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SCISSOR_TEST"><!-- --></A><H3>
GL_SCISSOR_TEST</H3>
<PRE>
public static final int <B>GL_SCISSOR_TEST</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SCISSOR_TEST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_COLOR_MATERIAL"><!-- --></A><H3>
GL_COLOR_MATERIAL</H3>
<PRE>
public static final int <B>GL_COLOR_MATERIAL</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_COLOR_MATERIAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_NORMALIZE"><!-- --></A><H3>
GL_NORMALIZE</H3>
<PRE>
public static final int <B>GL_NORMALIZE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_NORMALIZE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_RESCALE_NORMAL"><!-- --></A><H3>
GL_RESCALE_NORMAL</H3>
<PRE>
public static final int <B>GL_RESCALE_NORMAL</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_RESCALE_NORMAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_POLYGON_OFFSET_FILL"><!-- --></A><H3>
GL_POLYGON_OFFSET_FILL</H3>
<PRE>
public static final int <B>GL_POLYGON_OFFSET_FILL</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_POLYGON_OFFSET_FILL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_VERTEX_ARRAY"><!-- --></A><H3>
GL_VERTEX_ARRAY</H3>
<PRE>
public static final int <B>GL_VERTEX_ARRAY</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_VERTEX_ARRAY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_NORMAL_ARRAY"><!-- --></A><H3>
GL_NORMAL_ARRAY</H3>
<PRE>
public static final int <B>GL_NORMAL_ARRAY</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_NORMAL_ARRAY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_COLOR_ARRAY"><!-- --></A><H3>
GL_COLOR_ARRAY</H3>
<PRE>
public static final int <B>GL_COLOR_ARRAY</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_COLOR_ARRAY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_COORD_ARRAY"><!-- --></A><H3>
GL_TEXTURE_COORD_ARRAY</H3>
<PRE>
public static final int <B>GL_TEXTURE_COORD_ARRAY</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE_COORD_ARRAY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_MULTISAMPLE"><!-- --></A><H3>
GL_MULTISAMPLE</H3>
<PRE>
public static final int <B>GL_MULTISAMPLE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_MULTISAMPLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SAMPLE_ALPHA_TO_COVERAGE"><!-- --></A><H3>
GL_SAMPLE_ALPHA_TO_COVERAGE</H3>
<PRE>
public static final int <B>GL_SAMPLE_ALPHA_TO_COVERAGE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SAMPLE_ALPHA_TO_COVERAGE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SAMPLE_ALPHA_TO_ONE"><!-- --></A><H3>
GL_SAMPLE_ALPHA_TO_ONE</H3>
<PRE>
public static final int <B>GL_SAMPLE_ALPHA_TO_ONE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SAMPLE_ALPHA_TO_ONE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SAMPLE_COVERAGE"><!-- --></A><H3>
GL_SAMPLE_COVERAGE</H3>
<PRE>
public static final int <B>GL_SAMPLE_COVERAGE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SAMPLE_COVERAGE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_NO_ERROR"><!-- --></A><H3>
GL_NO_ERROR</H3>
<PRE>
public static final int <B>GL_NO_ERROR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_NO_ERROR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_INVALID_ENUM"><!-- --></A><H3>
GL_INVALID_ENUM</H3>
<PRE>
public static final int <B>GL_INVALID_ENUM</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_INVALID_ENUM">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_INVALID_VALUE"><!-- --></A><H3>
GL_INVALID_VALUE</H3>
<PRE>
public static final int <B>GL_INVALID_VALUE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_INVALID_VALUE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_INVALID_OPERATION"><!-- --></A><H3>
GL_INVALID_OPERATION</H3>
<PRE>
public static final int <B>GL_INVALID_OPERATION</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_INVALID_OPERATION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_STACK_OVERFLOW"><!-- --></A><H3>
GL_STACK_OVERFLOW</H3>
<PRE>
public static final int <B>GL_STACK_OVERFLOW</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_STACK_OVERFLOW">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_STACK_UNDERFLOW"><!-- --></A><H3>
GL_STACK_UNDERFLOW</H3>
<PRE>
public static final int <B>GL_STACK_UNDERFLOW</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_STACK_UNDERFLOW">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_OUT_OF_MEMORY"><!-- --></A><H3>
GL_OUT_OF_MEMORY</H3>
<PRE>
public static final int <B>GL_OUT_OF_MEMORY</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_OUT_OF_MEMORY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_EXP"><!-- --></A><H3>
GL_EXP</H3>
<PRE>
public static final int <B>GL_EXP</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_EXP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_EXP2"><!-- --></A><H3>
GL_EXP2</H3>
<PRE>
public static final int <B>GL_EXP2</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_EXP2">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_FOG_DENSITY"><!-- --></A><H3>
GL_FOG_DENSITY</H3>
<PRE>
public static final int <B>GL_FOG_DENSITY</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_FOG_DENSITY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_FOG_START"><!-- --></A><H3>
GL_FOG_START</H3>
<PRE>
public static final int <B>GL_FOG_START</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_FOG_START">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_FOG_END"><!-- --></A><H3>
GL_FOG_END</H3>
<PRE>
public static final int <B>GL_FOG_END</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_FOG_END">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_FOG_MODE"><!-- --></A><H3>
GL_FOG_MODE</H3>
<PRE>
public static final int <B>GL_FOG_MODE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_FOG_MODE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_FOG_COLOR"><!-- --></A><H3>
GL_FOG_COLOR</H3>
<PRE>
public static final int <B>GL_FOG_COLOR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_FOG_COLOR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_CW"><!-- --></A><H3>
GL_CW</H3>
<PRE>
public static final int <B>GL_CW</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_CW">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_CCW"><!-- --></A><H3>
GL_CCW</H3>
<PRE>
public static final int <B>GL_CCW</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_CCW">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SMOOTH_POINT_SIZE_RANGE"><!-- --></A><H3>
GL_SMOOTH_POINT_SIZE_RANGE</H3>
<PRE>
public static final int <B>GL_SMOOTH_POINT_SIZE_RANGE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SMOOTH_POINT_SIZE_RANGE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SMOOTH_LINE_WIDTH_RANGE"><!-- --></A><H3>
GL_SMOOTH_LINE_WIDTH_RANGE</H3>
<PRE>
public static final int <B>GL_SMOOTH_LINE_WIDTH_RANGE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SMOOTH_LINE_WIDTH_RANGE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_ALIASED_POINT_SIZE_RANGE"><!-- --></A><H3>
GL_ALIASED_POINT_SIZE_RANGE</H3>
<PRE>
public static final int <B>GL_ALIASED_POINT_SIZE_RANGE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_ALIASED_POINT_SIZE_RANGE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_ALIASED_LINE_WIDTH_RANGE"><!-- --></A><H3>
GL_ALIASED_LINE_WIDTH_RANGE</H3>
<PRE>
public static final int <B>GL_ALIASED_LINE_WIDTH_RANGE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_ALIASED_LINE_WIDTH_RANGE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_IMPLEMENTATION_COLOR_READ_TYPE_OES"><!-- --></A><H3>
GL_IMPLEMENTATION_COLOR_READ_TYPE_OES</H3>
<PRE>
public static final int <B>GL_IMPLEMENTATION_COLOR_READ_TYPE_OES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_IMPLEMENTATION_COLOR_READ_TYPE_OES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES"><!-- --></A><H3>
GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES</H3>
<PRE>
public static final int <B>GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_MAX_LIGHTS"><!-- --></A><H3>
GL_MAX_LIGHTS</H3>
<PRE>
public static final int <B>GL_MAX_LIGHTS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_MAX_LIGHTS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_MAX_TEXTURE_SIZE"><!-- --></A><H3>
GL_MAX_TEXTURE_SIZE</H3>
<PRE>
public static final int <B>GL_MAX_TEXTURE_SIZE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_MAX_TEXTURE_SIZE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_MAX_MODELVIEW_STACK_DEPTH"><!-- --></A><H3>
GL_MAX_MODELVIEW_STACK_DEPTH</H3>
<PRE>
public static final int <B>GL_MAX_MODELVIEW_STACK_DEPTH</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_MAX_MODELVIEW_STACK_DEPTH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_MAX_PROJECTION_STACK_DEPTH"><!-- --></A><H3>
GL_MAX_PROJECTION_STACK_DEPTH</H3>
<PRE>
public static final int <B>GL_MAX_PROJECTION_STACK_DEPTH</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_MAX_PROJECTION_STACK_DEPTH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_MAX_TEXTURE_STACK_DEPTH"><!-- --></A><H3>
GL_MAX_TEXTURE_STACK_DEPTH</H3>
<PRE>
public static final int <B>GL_MAX_TEXTURE_STACK_DEPTH</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_MAX_TEXTURE_STACK_DEPTH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_MAX_VIEWPORT_DIMS"><!-- --></A><H3>
GL_MAX_VIEWPORT_DIMS</H3>
<PRE>
public static final int <B>GL_MAX_VIEWPORT_DIMS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_MAX_VIEWPORT_DIMS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_MAX_ELEMENTS_VERTICES"><!-- --></A><H3>
GL_MAX_ELEMENTS_VERTICES</H3>
<PRE>
public static final int <B>GL_MAX_ELEMENTS_VERTICES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_MAX_ELEMENTS_VERTICES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_MAX_ELEMENTS_INDICES"><!-- --></A><H3>
GL_MAX_ELEMENTS_INDICES</H3>
<PRE>
public static final int <B>GL_MAX_ELEMENTS_INDICES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_MAX_ELEMENTS_INDICES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_MAX_TEXTURE_UNITS"><!-- --></A><H3>
GL_MAX_TEXTURE_UNITS</H3>
<PRE>
public static final int <B>GL_MAX_TEXTURE_UNITS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_MAX_TEXTURE_UNITS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_NUM_COMPRESSED_TEXTURE_FORMATS"><!-- --></A><H3>
GL_NUM_COMPRESSED_TEXTURE_FORMATS</H3>
<PRE>
public static final int <B>GL_NUM_COMPRESSED_TEXTURE_FORMATS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_NUM_COMPRESSED_TEXTURE_FORMATS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_COMPRESSED_TEXTURE_FORMATS"><!-- --></A><H3>
GL_COMPRESSED_TEXTURE_FORMATS</H3>
<PRE>
public static final int <B>GL_COMPRESSED_TEXTURE_FORMATS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_COMPRESSED_TEXTURE_FORMATS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SUBPIXEL_BITS"><!-- --></A><H3>
GL_SUBPIXEL_BITS</H3>
<PRE>
public static final int <B>GL_SUBPIXEL_BITS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SUBPIXEL_BITS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_RED_BITS"><!-- --></A><H3>
GL_RED_BITS</H3>
<PRE>
public static final int <B>GL_RED_BITS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_RED_BITS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_GREEN_BITS"><!-- --></A><H3>
GL_GREEN_BITS</H3>
<PRE>
public static final int <B>GL_GREEN_BITS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_GREEN_BITS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_BLUE_BITS"><!-- --></A><H3>
GL_BLUE_BITS</H3>
<PRE>
public static final int <B>GL_BLUE_BITS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_BLUE_BITS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_ALPHA_BITS"><!-- --></A><H3>
GL_ALPHA_BITS</H3>
<PRE>
public static final int <B>GL_ALPHA_BITS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_ALPHA_BITS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_DEPTH_BITS"><!-- --></A><H3>
GL_DEPTH_BITS</H3>
<PRE>
public static final int <B>GL_DEPTH_BITS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_DEPTH_BITS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_STENCIL_BITS"><!-- --></A><H3>
GL_STENCIL_BITS</H3>
<PRE>
public static final int <B>GL_STENCIL_BITS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_STENCIL_BITS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_DONT_CARE"><!-- --></A><H3>
GL_DONT_CARE</H3>
<PRE>
public static final int <B>GL_DONT_CARE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_DONT_CARE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_FASTEST"><!-- --></A><H3>
GL_FASTEST</H3>
<PRE>
public static final int <B>GL_FASTEST</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_FASTEST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_NICEST"><!-- --></A><H3>
GL_NICEST</H3>
<PRE>
public static final int <B>GL_NICEST</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_NICEST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_PERSPECTIVE_CORRECTION_HINT"><!-- --></A><H3>
GL_PERSPECTIVE_CORRECTION_HINT</H3>
<PRE>
public static final int <B>GL_PERSPECTIVE_CORRECTION_HINT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_PERSPECTIVE_CORRECTION_HINT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_POINT_SMOOTH_HINT"><!-- --></A><H3>
GL_POINT_SMOOTH_HINT</H3>
<PRE>
public static final int <B>GL_POINT_SMOOTH_HINT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_POINT_SMOOTH_HINT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LINE_SMOOTH_HINT"><!-- --></A><H3>
GL_LINE_SMOOTH_HINT</H3>
<PRE>
public static final int <B>GL_LINE_SMOOTH_HINT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LINE_SMOOTH_HINT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_POLYGON_SMOOTH_HINT"><!-- --></A><H3>
GL_POLYGON_SMOOTH_HINT</H3>
<PRE>
public static final int <B>GL_POLYGON_SMOOTH_HINT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_POLYGON_SMOOTH_HINT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_FOG_HINT"><!-- --></A><H3>
GL_FOG_HINT</H3>
<PRE>
public static final int <B>GL_FOG_HINT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_FOG_HINT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LIGHT_MODEL_AMBIENT"><!-- --></A><H3>
GL_LIGHT_MODEL_AMBIENT</H3>
<PRE>
public static final int <B>GL_LIGHT_MODEL_AMBIENT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LIGHT_MODEL_AMBIENT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LIGHT_MODEL_TWO_SIDE"><!-- --></A><H3>
GL_LIGHT_MODEL_TWO_SIDE</H3>
<PRE>
public static final int <B>GL_LIGHT_MODEL_TWO_SIDE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LIGHT_MODEL_TWO_SIDE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_AMBIENT"><!-- --></A><H3>
GL_AMBIENT</H3>
<PRE>
public static final int <B>GL_AMBIENT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_AMBIENT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_DIFFUSE"><!-- --></A><H3>
GL_DIFFUSE</H3>
<PRE>
public static final int <B>GL_DIFFUSE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_DIFFUSE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SPECULAR"><!-- --></A><H3>
GL_SPECULAR</H3>
<PRE>
public static final int <B>GL_SPECULAR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SPECULAR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_POSITION"><!-- --></A><H3>
GL_POSITION</H3>
<PRE>
public static final int <B>GL_POSITION</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_POSITION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SPOT_DIRECTION"><!-- --></A><H3>
GL_SPOT_DIRECTION</H3>
<PRE>
public static final int <B>GL_SPOT_DIRECTION</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SPOT_DIRECTION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SPOT_EXPONENT"><!-- --></A><H3>
GL_SPOT_EXPONENT</H3>
<PRE>
public static final int <B>GL_SPOT_EXPONENT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SPOT_EXPONENT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SPOT_CUTOFF"><!-- --></A><H3>
GL_SPOT_CUTOFF</H3>
<PRE>
public static final int <B>GL_SPOT_CUTOFF</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SPOT_CUTOFF">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_CONSTANT_ATTENUATION"><!-- --></A><H3>
GL_CONSTANT_ATTENUATION</H3>
<PRE>
public static final int <B>GL_CONSTANT_ATTENUATION</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_CONSTANT_ATTENUATION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LINEAR_ATTENUATION"><!-- --></A><H3>
GL_LINEAR_ATTENUATION</H3>
<PRE>
public static final int <B>GL_LINEAR_ATTENUATION</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LINEAR_ATTENUATION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_QUADRATIC_ATTENUATION"><!-- --></A><H3>
GL_QUADRATIC_ATTENUATION</H3>
<PRE>
public static final int <B>GL_QUADRATIC_ATTENUATION</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_QUADRATIC_ATTENUATION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_BYTE"><!-- --></A><H3>
GL_BYTE</H3>
<PRE>
public static final int <B>GL_BYTE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_BYTE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_UNSIGNED_BYTE"><!-- --></A><H3>
GL_UNSIGNED_BYTE</H3>
<PRE>
public static final int <B>GL_UNSIGNED_BYTE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_UNSIGNED_BYTE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SHORT"><!-- --></A><H3>
GL_SHORT</H3>
<PRE>
public static final int <B>GL_SHORT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SHORT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_UNSIGNED_SHORT"><!-- --></A><H3>
GL_UNSIGNED_SHORT</H3>
<PRE>
public static final int <B>GL_UNSIGNED_SHORT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_UNSIGNED_SHORT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_FLOAT"><!-- --></A><H3>
GL_FLOAT</H3>
<PRE>
public static final int <B>GL_FLOAT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_FLOAT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_FIXED"><!-- --></A><H3>
GL_FIXED</H3>
<PRE>
public static final int <B>GL_FIXED</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_FIXED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_CLEAR"><!-- --></A><H3>
GL_CLEAR</H3>
<PRE>
public static final int <B>GL_CLEAR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_CLEAR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_AND"><!-- --></A><H3>
GL_AND</H3>
<PRE>
public static final int <B>GL_AND</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_AND">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_AND_REVERSE"><!-- --></A><H3>
GL_AND_REVERSE</H3>
<PRE>
public static final int <B>GL_AND_REVERSE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_AND_REVERSE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_COPY"><!-- --></A><H3>
GL_COPY</H3>
<PRE>
public static final int <B>GL_COPY</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_COPY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_AND_INVERTED"><!-- --></A><H3>
GL_AND_INVERTED</H3>
<PRE>
public static final int <B>GL_AND_INVERTED</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_AND_INVERTED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_NOOP"><!-- --></A><H3>
GL_NOOP</H3>
<PRE>
public static final int <B>GL_NOOP</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_NOOP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_XOR"><!-- --></A><H3>
GL_XOR</H3>
<PRE>
public static final int <B>GL_XOR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_XOR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_OR"><!-- --></A><H3>
GL_OR</H3>
<PRE>
public static final int <B>GL_OR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_OR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_NOR"><!-- --></A><H3>
GL_NOR</H3>
<PRE>
public static final int <B>GL_NOR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_NOR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_EQUIV"><!-- --></A><H3>
GL_EQUIV</H3>
<PRE>
public static final int <B>GL_EQUIV</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_EQUIV">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_INVERT"><!-- --></A><H3>
GL_INVERT</H3>
<PRE>
public static final int <B>GL_INVERT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_INVERT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_OR_REVERSE"><!-- --></A><H3>
GL_OR_REVERSE</H3>
<PRE>
public static final int <B>GL_OR_REVERSE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_OR_REVERSE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_COPY_INVERTED"><!-- --></A><H3>
GL_COPY_INVERTED</H3>
<PRE>
public static final int <B>GL_COPY_INVERTED</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_COPY_INVERTED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_OR_INVERTED"><!-- --></A><H3>
GL_OR_INVERTED</H3>
<PRE>
public static final int <B>GL_OR_INVERTED</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_OR_INVERTED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_NAND"><!-- --></A><H3>
GL_NAND</H3>
<PRE>
public static final int <B>GL_NAND</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_NAND">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SET"><!-- --></A><H3>
GL_SET</H3>
<PRE>
public static final int <B>GL_SET</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SET">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_EMISSION"><!-- --></A><H3>
GL_EMISSION</H3>
<PRE>
public static final int <B>GL_EMISSION</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_EMISSION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SHININESS"><!-- --></A><H3>
GL_SHININESS</H3>
<PRE>
public static final int <B>GL_SHININESS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SHININESS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_AMBIENT_AND_DIFFUSE"><!-- --></A><H3>
GL_AMBIENT_AND_DIFFUSE</H3>
<PRE>
public static final int <B>GL_AMBIENT_AND_DIFFUSE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_AMBIENT_AND_DIFFUSE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_MODELVIEW"><!-- --></A><H3>
GL_MODELVIEW</H3>
<PRE>
public static final int <B>GL_MODELVIEW</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_MODELVIEW">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_PROJECTION"><!-- --></A><H3>
GL_PROJECTION</H3>
<PRE>
public static final int <B>GL_PROJECTION</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_PROJECTION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE"><!-- --></A><H3>
GL_TEXTURE</H3>
<PRE>
public static final int <B>GL_TEXTURE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_ALPHA"><!-- --></A><H3>
GL_ALPHA</H3>
<PRE>
public static final int <B>GL_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_ALPHA">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_RGB"><!-- --></A><H3>
GL_RGB</H3>
<PRE>
public static final int <B>GL_RGB</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_RGB">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_RGBA"><!-- --></A><H3>
GL_RGBA</H3>
<PRE>
public static final int <B>GL_RGBA</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_RGBA">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LUMINANCE"><!-- --></A><H3>
GL_LUMINANCE</H3>
<PRE>
public static final int <B>GL_LUMINANCE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LUMINANCE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LUMINANCE_ALPHA"><!-- --></A><H3>
GL_LUMINANCE_ALPHA</H3>
<PRE>
public static final int <B>GL_LUMINANCE_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LUMINANCE_ALPHA">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_UNPACK_ALIGNMENT"><!-- --></A><H3>
GL_UNPACK_ALIGNMENT</H3>
<PRE>
public static final int <B>GL_UNPACK_ALIGNMENT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_UNPACK_ALIGNMENT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_PACK_ALIGNMENT"><!-- --></A><H3>
GL_PACK_ALIGNMENT</H3>
<PRE>
public static final int <B>GL_PACK_ALIGNMENT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_PACK_ALIGNMENT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_UNSIGNED_SHORT_4_4_4_4"><!-- --></A><H3>
GL_UNSIGNED_SHORT_4_4_4_4</H3>
<PRE>
public static final int <B>GL_UNSIGNED_SHORT_4_4_4_4</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_UNSIGNED_SHORT_4_4_4_4">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_UNSIGNED_SHORT_5_5_5_1"><!-- --></A><H3>
GL_UNSIGNED_SHORT_5_5_5_1</H3>
<PRE>
public static final int <B>GL_UNSIGNED_SHORT_5_5_5_1</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_UNSIGNED_SHORT_5_5_5_1">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_UNSIGNED_SHORT_5_6_5"><!-- --></A><H3>
GL_UNSIGNED_SHORT_5_6_5</H3>
<PRE>
public static final int <B>GL_UNSIGNED_SHORT_5_6_5</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_UNSIGNED_SHORT_5_6_5">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_FLAT"><!-- --></A><H3>
GL_FLAT</H3>
<PRE>
public static final int <B>GL_FLAT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_FLAT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_SMOOTH"><!-- --></A><H3>
GL_SMOOTH</H3>
<PRE>
public static final int <B>GL_SMOOTH</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_SMOOTH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_KEEP"><!-- --></A><H3>
GL_KEEP</H3>
<PRE>
public static final int <B>GL_KEEP</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_KEEP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_REPLACE"><!-- --></A><H3>
GL_REPLACE</H3>
<PRE>
public static final int <B>GL_REPLACE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_REPLACE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_INCR"><!-- --></A><H3>
GL_INCR</H3>
<PRE>
public static final int <B>GL_INCR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_INCR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_DECR"><!-- --></A><H3>
GL_DECR</H3>
<PRE>
public static final int <B>GL_DECR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_DECR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_VENDOR"><!-- --></A><H3>
GL_VENDOR</H3>
<PRE>
public static final int <B>GL_VENDOR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_VENDOR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_RENDERER"><!-- --></A><H3>
GL_RENDERER</H3>
<PRE>
public static final int <B>GL_RENDERER</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_RENDERER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_VERSION"><!-- --></A><H3>
GL_VERSION</H3>
<PRE>
public static final int <B>GL_VERSION</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_VERSION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_EXTENSIONS"><!-- --></A><H3>
GL_EXTENSIONS</H3>
<PRE>
public static final int <B>GL_EXTENSIONS</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_EXTENSIONS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_MODULATE"><!-- --></A><H3>
GL_MODULATE</H3>
<PRE>
public static final int <B>GL_MODULATE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_MODULATE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_DECAL"><!-- --></A><H3>
GL_DECAL</H3>
<PRE>
public static final int <B>GL_DECAL</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_DECAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_ADD"><!-- --></A><H3>
GL_ADD</H3>
<PRE>
public static final int <B>GL_ADD</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_ADD">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_ENV_MODE"><!-- --></A><H3>
GL_TEXTURE_ENV_MODE</H3>
<PRE>
public static final int <B>GL_TEXTURE_ENV_MODE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE_ENV_MODE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_ENV_COLOR"><!-- --></A><H3>
GL_TEXTURE_ENV_COLOR</H3>
<PRE>
public static final int <B>GL_TEXTURE_ENV_COLOR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE_ENV_COLOR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_ENV"><!-- --></A><H3>
GL_TEXTURE_ENV</H3>
<PRE>
public static final int <B>GL_TEXTURE_ENV</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE_ENV">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_NEAREST"><!-- --></A><H3>
GL_NEAREST</H3>
<PRE>
public static final int <B>GL_NEAREST</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_NEAREST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LINEAR"><!-- --></A><H3>
GL_LINEAR</H3>
<PRE>
public static final int <B>GL_LINEAR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LINEAR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_NEAREST_MIPMAP_NEAREST"><!-- --></A><H3>
GL_NEAREST_MIPMAP_NEAREST</H3>
<PRE>
public static final int <B>GL_NEAREST_MIPMAP_NEAREST</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_NEAREST_MIPMAP_NEAREST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LINEAR_MIPMAP_NEAREST"><!-- --></A><H3>
GL_LINEAR_MIPMAP_NEAREST</H3>
<PRE>
public static final int <B>GL_LINEAR_MIPMAP_NEAREST</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LINEAR_MIPMAP_NEAREST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_NEAREST_MIPMAP_LINEAR"><!-- --></A><H3>
GL_NEAREST_MIPMAP_LINEAR</H3>
<PRE>
public static final int <B>GL_NEAREST_MIPMAP_LINEAR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_NEAREST_MIPMAP_LINEAR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LINEAR_MIPMAP_LINEAR"><!-- --></A><H3>
GL_LINEAR_MIPMAP_LINEAR</H3>
<PRE>
public static final int <B>GL_LINEAR_MIPMAP_LINEAR</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LINEAR_MIPMAP_LINEAR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_MAG_FILTER"><!-- --></A><H3>
GL_TEXTURE_MAG_FILTER</H3>
<PRE>
public static final int <B>GL_TEXTURE_MAG_FILTER</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE_MAG_FILTER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_MIN_FILTER"><!-- --></A><H3>
GL_TEXTURE_MIN_FILTER</H3>
<PRE>
public static final int <B>GL_TEXTURE_MIN_FILTER</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE_MIN_FILTER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_WRAP_S"><!-- --></A><H3>
GL_TEXTURE_WRAP_S</H3>
<PRE>
public static final int <B>GL_TEXTURE_WRAP_S</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE_WRAP_S">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_WRAP_T"><!-- --></A><H3>
GL_TEXTURE_WRAP_T</H3>
<PRE>
public static final int <B>GL_TEXTURE_WRAP_T</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE_WRAP_T">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE0"><!-- --></A><H3>
GL_TEXTURE0</H3>
<PRE>
public static final int <B>GL_TEXTURE0</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE0">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE1"><!-- --></A><H3>
GL_TEXTURE1</H3>
<PRE>
public static final int <B>GL_TEXTURE1</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE1">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE2"><!-- --></A><H3>
GL_TEXTURE2</H3>
<PRE>
public static final int <B>GL_TEXTURE2</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE2">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE3"><!-- --></A><H3>
GL_TEXTURE3</H3>
<PRE>
public static final int <B>GL_TEXTURE3</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE3">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE4"><!-- --></A><H3>
GL_TEXTURE4</H3>
<PRE>
public static final int <B>GL_TEXTURE4</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE4">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE5"><!-- --></A><H3>
GL_TEXTURE5</H3>
<PRE>
public static final int <B>GL_TEXTURE5</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE5">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE6"><!-- --></A><H3>
GL_TEXTURE6</H3>
<PRE>
public static final int <B>GL_TEXTURE6</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE6">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE7"><!-- --></A><H3>
GL_TEXTURE7</H3>
<PRE>
public static final int <B>GL_TEXTURE7</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE7">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE8"><!-- --></A><H3>
GL_TEXTURE8</H3>
<PRE>
public static final int <B>GL_TEXTURE8</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE8">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE9"><!-- --></A><H3>
GL_TEXTURE9</H3>
<PRE>
public static final int <B>GL_TEXTURE9</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE9">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE10"><!-- --></A><H3>
GL_TEXTURE10</H3>
<PRE>
public static final int <B>GL_TEXTURE10</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE10">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE11"><!-- --></A><H3>
GL_TEXTURE11</H3>
<PRE>
public static final int <B>GL_TEXTURE11</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE11">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE12"><!-- --></A><H3>
GL_TEXTURE12</H3>
<PRE>
public static final int <B>GL_TEXTURE12</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE12">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE13"><!-- --></A><H3>
GL_TEXTURE13</H3>
<PRE>
public static final int <B>GL_TEXTURE13</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE13">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE14"><!-- --></A><H3>
GL_TEXTURE14</H3>
<PRE>
public static final int <B>GL_TEXTURE14</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE14">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE15"><!-- --></A><H3>
GL_TEXTURE15</H3>
<PRE>
public static final int <B>GL_TEXTURE15</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE15">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE16"><!-- --></A><H3>
GL_TEXTURE16</H3>
<PRE>
public static final int <B>GL_TEXTURE16</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE16">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE17"><!-- --></A><H3>
GL_TEXTURE17</H3>
<PRE>
public static final int <B>GL_TEXTURE17</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE17">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE18"><!-- --></A><H3>
GL_TEXTURE18</H3>
<PRE>
public static final int <B>GL_TEXTURE18</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE18">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE19"><!-- --></A><H3>
GL_TEXTURE19</H3>
<PRE>
public static final int <B>GL_TEXTURE19</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE19">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE20"><!-- --></A><H3>
GL_TEXTURE20</H3>
<PRE>
public static final int <B>GL_TEXTURE20</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE20">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE21"><!-- --></A><H3>
GL_TEXTURE21</H3>
<PRE>
public static final int <B>GL_TEXTURE21</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE21">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE22"><!-- --></A><H3>
GL_TEXTURE22</H3>
<PRE>
public static final int <B>GL_TEXTURE22</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE22">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE23"><!-- --></A><H3>
GL_TEXTURE23</H3>
<PRE>
public static final int <B>GL_TEXTURE23</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE23">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE24"><!-- --></A><H3>
GL_TEXTURE24</H3>
<PRE>
public static final int <B>GL_TEXTURE24</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE24">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE25"><!-- --></A><H3>
GL_TEXTURE25</H3>
<PRE>
public static final int <B>GL_TEXTURE25</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE25">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE26"><!-- --></A><H3>
GL_TEXTURE26</H3>
<PRE>
public static final int <B>GL_TEXTURE26</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE26">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE27"><!-- --></A><H3>
GL_TEXTURE27</H3>
<PRE>
public static final int <B>GL_TEXTURE27</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE27">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE28"><!-- --></A><H3>
GL_TEXTURE28</H3>
<PRE>
public static final int <B>GL_TEXTURE28</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE28">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE29"><!-- --></A><H3>
GL_TEXTURE29</H3>
<PRE>
public static final int <B>GL_TEXTURE29</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE29">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE30"><!-- --></A><H3>
GL_TEXTURE30</H3>
<PRE>
public static final int <B>GL_TEXTURE30</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE30">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_TEXTURE31"><!-- --></A><H3>
GL_TEXTURE31</H3>
<PRE>
public static final int <B>GL_TEXTURE31</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_TEXTURE31">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_REPEAT"><!-- --></A><H3>
GL_REPEAT</H3>
<PRE>
public static final int <B>GL_REPEAT</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_REPEAT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_CLAMP_TO_EDGE"><!-- --></A><H3>
GL_CLAMP_TO_EDGE</H3>
<PRE>
public static final int <B>GL_CLAMP_TO_EDGE</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_CLAMP_TO_EDGE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_PALETTE4_RGB8_OES"><!-- --></A><H3>
GL_PALETTE4_RGB8_OES</H3>
<PRE>
public static final int <B>GL_PALETTE4_RGB8_OES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_PALETTE4_RGB8_OES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_PALETTE4_RGBA8_OES"><!-- --></A><H3>
GL_PALETTE4_RGBA8_OES</H3>
<PRE>
public static final int <B>GL_PALETTE4_RGBA8_OES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_PALETTE4_RGBA8_OES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_PALETTE4_R5_G6_B5_OES"><!-- --></A><H3>
GL_PALETTE4_R5_G6_B5_OES</H3>
<PRE>
public static final int <B>GL_PALETTE4_R5_G6_B5_OES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_PALETTE4_R5_G6_B5_OES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_PALETTE4_RGBA4_OES"><!-- --></A><H3>
GL_PALETTE4_RGBA4_OES</H3>
<PRE>
public static final int <B>GL_PALETTE4_RGBA4_OES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_PALETTE4_RGBA4_OES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_PALETTE4_RGB5_A1_OES"><!-- --></A><H3>
GL_PALETTE4_RGB5_A1_OES</H3>
<PRE>
public static final int <B>GL_PALETTE4_RGB5_A1_OES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_PALETTE4_RGB5_A1_OES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_PALETTE8_RGB8_OES"><!-- --></A><H3>
GL_PALETTE8_RGB8_OES</H3>
<PRE>
public static final int <B>GL_PALETTE8_RGB8_OES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_PALETTE8_RGB8_OES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_PALETTE8_RGBA8_OES"><!-- --></A><H3>
GL_PALETTE8_RGBA8_OES</H3>
<PRE>
public static final int <B>GL_PALETTE8_RGBA8_OES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_PALETTE8_RGBA8_OES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_PALETTE8_R5_G6_B5_OES"><!-- --></A><H3>
GL_PALETTE8_R5_G6_B5_OES</H3>
<PRE>
public static final int <B>GL_PALETTE8_R5_G6_B5_OES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_PALETTE8_R5_G6_B5_OES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_PALETTE8_RGBA4_OES"><!-- --></A><H3>
GL_PALETTE8_RGBA4_OES</H3>
<PRE>
public static final int <B>GL_PALETTE8_RGBA4_OES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_PALETTE8_RGBA4_OES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_PALETTE8_RGB5_A1_OES"><!-- --></A><H3>
GL_PALETTE8_RGB5_A1_OES</H3>
<PRE>
public static final int <B>GL_PALETTE8_RGB5_A1_OES</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_PALETTE8_RGB5_A1_OES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LIGHT0"><!-- --></A><H3>
GL_LIGHT0</H3>
<PRE>
public static final int <B>GL_LIGHT0</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LIGHT0">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LIGHT1"><!-- --></A><H3>
GL_LIGHT1</H3>
<PRE>
public static final int <B>GL_LIGHT1</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LIGHT1">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LIGHT2"><!-- --></A><H3>
GL_LIGHT2</H3>
<PRE>
public static final int <B>GL_LIGHT2</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LIGHT2">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LIGHT3"><!-- --></A><H3>
GL_LIGHT3</H3>
<PRE>
public static final int <B>GL_LIGHT3</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LIGHT3">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LIGHT4"><!-- --></A><H3>
GL_LIGHT4</H3>
<PRE>
public static final int <B>GL_LIGHT4</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LIGHT4">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LIGHT5"><!-- --></A><H3>
GL_LIGHT5</H3>
<PRE>
public static final int <B>GL_LIGHT5</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LIGHT5">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LIGHT6"><!-- --></A><H3>
GL_LIGHT6</H3>
<PRE>
public static final int <B>GL_LIGHT6</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LIGHT6">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GL_LIGHT7"><!-- --></A><H3>
GL_LIGHT7</H3>
<PRE>
public static final int <B>GL_LIGHT7</B></PRE>
<DL>
<DD>OpenGL ES 1.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../constant-values.html#javax.microedition.khronos.opengles.GL10.GL_LIGHT7">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="glActiveTexture(int)"><!-- --></A><H3>
glActiveTexture</H3>
<PRE>
public void <B>glActiveTexture</B>(int&nbsp;texture)</PRE>
<DL>
<DD>Select server-side active texture unit.

 <p><code>glActiveTexture</code> selects which texture unit
 subsequent texture state calls will affect. The number of texture
 units an implementation supports is implementation dependent, it
 must be at least 1 for OpenGL ES 1.0, or 2 for OpenGL ES 1.1.

 <h4>Notes</h4>

 <p>It is always the case that <code>GL_TEXTURE</code><i>i</i> =
 <code>GL_TEXTURE0</code> + <i>i</i>.

 <p>A texture unit consists of the texture enable state, texture
 matrix stack, texture environment and currently bound
 texture. Modifying any of these states has an effect only on the
 active texture unit.

 <p>Vertex arrays are client-side GL resources, which are selected by
 the <code>glClientActiveTexture</code> routine.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if
 <code>texture</code> is not one of
 <code>GL_TEXTURE</code><i>i</i>, where <code>0 <= <i>i</i> <
 GL_MAX_TEXTURE_UNITS</code>.

 <h4>Associated Gets</h4>

 <p><code>glGetIntegerv</code> with argument
 <code>GL_MAX_TEXTURE_UNITS</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texture</CODE> - Specifies which texture unit to make active. The
 number of texture units is implementation dependent, but must be
 at least one (for 1.0) or two (for 1.1). <code>texture</code>
 must be one of <code>GL_TEXTURE</code><i>i</i>, where <code>0 <=
 <i>i</i> < GL_MAX_TEXTURE_UNITS</code>, which is an
 implementation-dependent value. The intial value is
 <code>GL_TEXTURE0</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glAlphaFunc(int, float)"><!-- --></A><H3>
glAlphaFunc</H3>
<PRE>
public void <B>glAlphaFunc</B>(int&nbsp;func,
                        float&nbsp;ref)</PRE>
<DL>
<DD>Specify the alpha test function.

 <p>The alpha test discards fragments depending on the outcome of a
 comparison between an incoming fragment's alpha value and a
 constant reference value. <code>glAlphaFunc</code> specifies the
 reference value and the comparison function. The comparison is
 performed only if alpha testing is enabled. To enable and disable
 alpha testing, call <code>glEnable</code> and
 <code>glDisable</code> with argument
 <code>GL_ALPHA_TEST</code>. Alpha testing is initially disabled.

 <p><code>func</code> and <code>ref</code> specify the conditions
 under which the pixel is drawn. The incoming alpha value is
 compared to <code>ref</code> using the function specified by
 <code>func</code>. If the value passes the comparison, the
 incoming fragment is drawn if it also passes subsequent stencil
 and depth buffer tests. If the value fails the comparison, no
 change is made to the frame buffer at that pixel location. The
 comparison functions are as follows:
 
 <ul>
 <li><code>GL_NEVER</code></li>
 Never passes.
 <li><code>GL_LESS</code></li>
 Passes if the incoming alpha value is less than the reference value.
 <li><code>GL_EQUAL</code></li>
 Passes if the incoming alpha value is equal to the reference value.
 <li><code>GL_LEQUAL</code></li>
 Passes if the incoming alpha value is less than or equal to the
 reference value.
 <li><code>GL_GREATER</code></li>
 Passes if the incoming alpha value is greater than the reference value.
 <li><code>GL_NOTEQUAL</code></li>
 Passes if the incoming alpha value is not equal to the reference value.
 <li><code>GL_GEQUAL</code></li>
 Passes if the incoming alpha value is greater than or equal to
 the reference value.
 <li><code>GL_ALWAYS</code></li>
 Always passes (initial value).
 </ul>

 <p><code>glAlphaFunc</code> operates on all pixel write
 operations, including those resulting from the scan conversion of
 points, lines, and polygons. <code>glAlphaFunc</code> does not
 affect <code>glClear</code>.

 <h4>Errors</h4>
 
 <p><code>GL_INVALID_ENUM</code> is generated if <code>func</code>
 is not an accepted value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>func</CODE> - Specifies the alpha comparison function. Symbolic
 constants <code>GL_NEVER</code>, <code>GL_LESS</code>,
 <code>GL_EQUAL</code>, <code>GL_LEQUAL</code>,
 <code>GL_GREATER</code>, <code>GL_NOTEQUAL</code>,
 <code>GL_GEQUAL</code>, and <code>GL_ALWAYS</code> are accepted. The
 initial value is <code>GL_ALWAYS</code>.<DD><CODE>ref</CODE> - Specifies the reference value that incoming alpha
 values are compared to. This value is clamped to the range
 <code>[0, 1]</code>, where 0 represents the lowest possible alpha
 value and 1 the highest possible value. The initial reference
 value is 0.</DL>
</DD>
</DL>
<HR>

<A NAME="glAlphaFuncx(int, int)"><!-- --></A><H3>
glAlphaFuncx</H3>
<PRE>
public void <B>glAlphaFuncx</B>(int&nbsp;func,
                         int&nbsp;ref)</PRE>
<DL>
<DD>Fixed-point version of <code>glAlphaFunc</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glAlphaFunc(int, float)"><CODE>glAlphaFunc(int, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glBindTexture(int, int)"><!-- --></A><H3>
glBindTexture</H3>
<PRE>
public void <B>glBindTexture</B>(int&nbsp;target,
                          int&nbsp;texture)</PRE>
<DL>
<DD>Bind a named texture to a texturing target.

 <p><code>glBindTexture</code> lets you create or use a named
 texture. Calling <code>glBindTexture</code> with
 <code>target</code> set to <code>GL_TEXTURE_2D</code>, and
 <code>texture</code> set to the name of the new texture binds the
 texture name to the target. When a texture is bound to a target,
 the previous binding for that target is automatically broken.

 <p>Texture names are unsigned integers. The value 0 is reserved
 to represent the default texture for each texture target. Texture
 names and the corresponding texture contents are local to the
 shared texture-object space (see <code>eglCreateContext</code>)
 of the current GL rendering context.

 <p>You may use <code>glGenTextures</code> to generate a set of new
 texture names.

 <p>While a texture is bound, GL operations on the target to which it
 is bound affect the bound texture. If texture mapping of the
 dimensionality of the target to which a texture is bound is
 active, the bound texture is used. In effect, the texture targets
 become aliases for the textures currently bound to them, and the
 texture name 0 refers to the default textures that were bound to
 them at initialization.

 <p>A texture binding created with <code>glBindTexture</code> remains
 active until a different texture is bound to the same target, or
 until the bound texture is deleted with
 <code>glDeleteTextures</code>.

 <p>Once created, a named texture may be re-bound to the target of
 the matching dimensionality as often as needed. It is usually
 much faster to use <code>glBindTexture</code> to bind an existing named
 texture to one of the texture targets than it is to reload the
 texture image using <code>glTexImage2D</code>.
 
 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if
 <code>target</code> is not one of the allowable values.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target to which the texture is
 bound. Must be <code>GL_TEXTURE_2D</code>.<DD><CODE>texture</CODE> - Specifies the name of a texture.</DL>
</DD>
</DL>
<HR>

<A NAME="glBlendFunc(int, int)"><!-- --></A><H3>
glBlendFunc</H3>
<PRE>
public void <B>glBlendFunc</B>(int&nbsp;sfactor,
                        int&nbsp;dfactor)</PRE>
<DL>
<DD>Specify pixel arithmetic.

 <p>Pixels can be drawn using a function that blends the incoming
 (source) values with the values that are already in the color
 buffer (the destination values). Use <code>glEnable</code> and
 <code>glDisable</code> with argument <code>GL_BLEND</code> to
 enable and disable blending. Blending is initially disabled.

 <p><code>glBlendFunc</code> defines the operation of blending
 when it is enabled. <code>sfactor</code> specifies which of eleven
 methods is used to scale the source color
 components. <code>dfactor</code> specifies which of ten methods
 is used to scale the destination color components. The eleven
 possible methods are described in the following table. Each
 method defines four scale factors, one each for red, green, blue,
 and alpha.

 <p>In the table and in subsequent equations, source and
 destination color components are referred to as <code>(Rs, Gs,
 Bs, As)</code> and <code>(Rd, Gd, Bd, Ad)</code>. They are
 understood to have integer values between 0 and <code>(kR, kG,
 kB, kA)</code>, where

 <pre>
 kc = 2mc - 1
 </pre>

 and <code>(mR, mG, mB, mA)</code> is the number of red, green,
 blue, and alpha bitplanes.

 <p>Source and destination scale factors are referred to as
 <code>(sR, sG, sB, sA)</code> and <code>(dR, dG, dB,
 dA)</code>. The scale factors described in the table, denoted
 <code>(fR, fG, fB, fA)</code>, represent either source or
 destination factors. All scale factors have range [0, 1].

 <pre>
 Parameter               (fR, fG, fB, fA)

 GL_ZERO                 (0, 0, 0, 0)
 GL_ONE                  (1, 1, 1, 1)
 GL_SRC_COLOR            (Rs/kR, Gs/kG, Bs/kB, As/kA )
 GL_ONE_MINUS_SRC_COLOR  (1, 1, 1, 1) - (Rs/kR, Gs/kG, Bs/kB, As/kA)
 GL_DST_COLOR            (Rd/kR, Gd/kG, Bd/kB, Ad/kA )
 GL_ONE_MINUS_DST_COLOR  (1, 1, 1, 1) - (Rd/kR, Gd/kG, Bd/kB, Ad/kA)
 GL_SRC_ALPHA            (As/kA, As/kA, As/kA, As/kA )
 GL_ONE_MINUS_SRC_ALPHA  (1, 1, 1, 1) - (As/kA, As/kA, As/kA, As/kA)
 GL_DST_ALPHA            (Ad/kA, Ad/kA, Ad/kA, Ad/kA )
 GL_ONE_MINUS_DST_ALPHA  (1, 1, 1, 1) - (Ad/kA, Ad/kA, Ad/kA, Ad/kA)
 GL_SRC_ALPHA_SATURATE   (i, i, i, 1)
 </pre>

 <p>In the table,

 <pre>
 i = min(As, kA - Ad) / kA
 </pre>

 <p>To determine the blended values of a pixel, the system uses the
 following equations:

 <pre>
 Rd = min( kR, Rs sR + Rd dR )
 Gd = min( kG, Gs sG + Gd dG )
 Bd = min( kB, Bs sB + Bd dB )
 Ad = min( kA, As sA + Ad dA )
 </pre>

 <p>Despite the apparent precision of the above equations,
 blending arithmetic is not exactly specified, because blending
 operates with imprecise integer color values. However, a blend
 factor that should be equal to 1 is guaranteed not to modify its
 multiplicand, and a blend factor equal to 0 reduces its
 multiplicand to 0. For example, when <code>sfactor</code> is
 <code>GL_SRC_ALPHA</code>, <code>dfactor</code> is
 <code>GL_ONE_MINUS_SRC_ALPHA</code>, and <code>As</code> is equal
 to <code>kA</code>, the equations reduce to simple replacement:

 <pre>
 Rd = Rs
 Gd = Gs
 Bd = Bs
 Ad = As
 </pre>

 <p><code>glBlendFunc</code> operates on all pixel write
 operations, including the scan conversion of points, lines, and
 polygons. <code>glBlendFunc</code> does not affect
 <code>glClear</code>.

 <h4>Examples</h4>

 <p>Transparency is best implemented using
 <code>glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)</code> with
 primitives sorted from farthest to nearest. Note that this
 transparency calculation does not require the presence of alpha
 bitplanes in the color buffer.

 <p><code>glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)</code> is
 also useful for rendering antialiased points and lines.

 <h4>Notes</h4> Incoming (source) alpha is correctly thought of as
 a material opacity, ranging from 1.0 (kA), representing complete
 opacity, to 0.0 (0), representing complete transparency.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if either
 <code>sfactor</code> or <code>dfactor</code> is not an accepted
 value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sfactor</CODE> - Specifies how the red, green, blue, and alpha
 source blending factors are computed. The following symbolic
 constants are accepted: <code>GL_ZERO</code>,
 <code>GL_ONE</code>, <code>GL_SRC_COLOR</code> (1.1 only),
 <code>GL_ONE_MINUS_SRC_COLOR</code> (1.1 only),
 <code>GL_DST_COLOR</code>, <code>GL_ONE_MINUS_DST_COLOR</code>,
 <code>GL_SRC_ALPHA</code>, <code>GL_ONE_MINUS_SRC_ALPHA</code>,
 <code>GL_DST_ALPHA</code>, <code>GL_ONE_MINUS_DST_ALPHA</code>,
 and <code>GL_SRC_ALPHA_SATURATE</code>. The initial value is
 <code>GL_ONE</code>.<DD><CODE>dfactor</CODE> - Specifies how the red, green, blue, and alpha
 destination blending factors are computed. The following symbolic
 constants are accepted: <code>GL_ZERO</code>,
 <code>GL_ONE</code>, <code>GL_SRC_COLOR</code>,
 <code>GL_ONE_MINUS_SRC_COLOR</code>, <code>GL_DST_COLOR</code>
 (1.1 only), <code>GL_ONE_MINUS_DST_COLOR</code> (1.1 only),
 <code>GL_SRC_ALPHA</code>, <code>GL_ONE_MINUS_SRC_ALPHA</code>,
 <code>GL_DST_ALPHA</code>, and
 <code>GL_ONE_MINUS_DST_ALPHA</code>. The initial value is
 <code>GL_ZERO</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glClear(int)"><!-- --></A><H3>
glClear</H3>
<PRE>
public void <B>glClear</B>(int&nbsp;mask)</PRE>
<DL>
<DD>Clear buffers to preset values.

 <p><code>glClear</code> sets the bitplane area of the window to
 values previously selected by <code>glClearColor</code>,
 <code>glClearDepth</code>, and <code>glClearStencil</code>.

 <p>The pixel ownership test, the scissor test, dithering, and the
 color buffer masks affect the operation of
 <code>glClear</code>. The scissor box bounds the cleared
 region. Alpha function, blend function, logical operation,
 stenciling, texture mapping, and depth-buffering are ignored by
 <code>glClear</code>.

 <p><code>glClear</code> takes a single argument that is the
 bitwise OR of several values indicating which buffer is to be
 cleared.

 <p>The values are as follows:

 <ul>
 <li><code>GL_COLOR_BUFFER_BIT</code></li>
 Indicates the color buffer.
 <li><code>GL_DEPTH_BUFFER_BIT</code></li>
 Indicates the depth buffer.
 <li><code>GL_STENCIL_BUFFER_BIT</code></li>
 Indicates the stencil buffer.
 </ul>
 
 <p>The value to which each buffer is cleared depends on the
 setting of the clear value for that buffer.

 <h4>Notes</h4>

 <p>If a buffer is not present, then a <code>glClear</code>
 directed at that buffer has no effect.

 <h4>Errors</h4>

 <p><code>GL_INVALID_VALUE</code> is generated if any bit other
 than the defined bits is set in <code>mask</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mask</CODE> - Bitwise OR of masks that indicate the buffers to be
 cleared. Valid masks are <code>GL_COLOR_BUFFER_BIT</code>,
 <code>GL_DEPTH_BUFFER_BIT</code>, and <code>GL_STENCIL_BUFFER_BIT</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glClearColor(float, float, float, float)"><!-- --></A><H3>
glClearColor</H3>
<PRE>
public void <B>glClearColor</B>(float&nbsp;red,
                         float&nbsp;green,
                         float&nbsp;blue,
                         float&nbsp;alpha)</PRE>
<DL>
<DD>Specify clear values for the color buffer.

 <p><code>glClearColor</code> specifies the red, green, blue, and
 alpha values used by <code>glClear</code> to clear the color
 buffer. Values specified by <code>glClearColor</code> are clamped
 to the range <code>[0, 1]</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>red</CODE> - Specifies the red value used when the color buffer is
 cleared.  The initial value is 0.<DD><CODE>green</CODE> - Specifies the green value used when the color buffer
 is cleared.  The initial value is 0.<DD><CODE>blue</CODE> - Specifies the blue value used when the color buffer is
 cleared.  The initial value is 0.<DD><CODE>alpha</CODE> - Specifies the alpha value used when the color buffer
 is cleared. The initial value is 0.</DL>
</DD>
</DL>
<HR>

<A NAME="glClearColorx(int, int, int, int)"><!-- --></A><H3>
glClearColorx</H3>
<PRE>
public void <B>glClearColorx</B>(int&nbsp;red,
                          int&nbsp;green,
                          int&nbsp;blue,
                          int&nbsp;alpha)</PRE>
<DL>
<DD>Fixed-point version of <code>glClearColor</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glClearColor(float, float, float, float)"><CODE>glClearColor(float, float, float, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glClearDepthf(float)"><!-- --></A><H3>
glClearDepthf</H3>
<PRE>
public void <B>glClearDepthf</B>(float&nbsp;depth)</PRE>
<DL>
<DD>Specify the clear value for the depth buffer.

 <p><code>glClearDepth</code> specifies the depth value used by
 <code>glClear</code> to clear the depth buffer. Values specified
 by <code>glClearDepth</code> are clamped to the range <code>[0, 1]</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>depth</CODE> - Specifies the depth value used when the depth buffer
 is cleared. The initial value is 1.</DL>
</DD>
</DL>
<HR>

<A NAME="glClearDepthx(int)"><!-- --></A><H3>
glClearDepthx</H3>
<PRE>
public void <B>glClearDepthx</B>(int&nbsp;depth)</PRE>
<DL>
<DD>Fixed-point version of <code>glClearDepth</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glClearDepthf(float)"><CODE>glClearDepthf(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glClearStencil(int)"><!-- --></A><H3>
glClearStencil</H3>
<PRE>
public void <B>glClearStencil</B>(int&nbsp;s)</PRE>
<DL>
<DD>Specify the clear value for the stencil buffer.

 <p><code>glClearStencil</code> specifies the index used by
 <code>glClear</code> to clear the stencil buffer. <code>s</code>
 is masked with 2^<i>m</i> - 1, where <i>m</i> is the number of
 bits in the stencil buffer.

 <h4>Associated Gets</h4>

 <p><code>glGetIntegerv</code> with argument
 <code>GL_STENCIL_BITS</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - Specifies the index used when the stencil buffer is
 cleared. The initial value is 0.</DL>
</DD>
</DL>
<HR>

<A NAME="glClientActiveTexture(int)"><!-- --></A><H3>
glClientActiveTexture</H3>
<PRE>
public void <B>glClientActiveTexture</B>(int&nbsp;texture)</PRE>
<DL>
<DD>Select client-side active texture unit.

 <p><code>glClientActiveTexture</code> selects the vertex array
 client state parameters to be modified by
 <code>glTexCoordPointer</code>, and enabled or disabled with
 <code>glEnableClientState</code> or
 <code>glDisableClientState</code>, respectively, when called with
 a parameter of <code>GL_TEXTURE_COORD_ARRAY</code>.

 <h4>Notes</h4>

 <p>It is always the case that <code>GL_TEXTURE</code><i>i</i> =
 <code>GL_TEXTURE0</code> + <i>i</i>.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if
 <code>texture</code> is not one of
 <code>GL_TEXTURE</code><i>i</i>, where <code>0 <= <i>i</i> <
 GL_MAX_TEXTURE_UNITS</code>.

 <h4>Associated Gets</h4>

 <p><code>glGetIntegerv</code> with argument
 <code>GL_MAX_TEXTURE_UNITS</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texture</CODE> - Specifies which texture unit to make active. The
 number of texture units is implementation dependent, but must be
 at least one (for 1.0), or two (for 1.1). <code>texture</code>
 must be one of <code>GL_TEXTURE</code><i>i</i>, <code>0 <=
 <i>i</i> < GL_MAX_TEXTURE_UNITS</code>, which is an
 implementation-dependent value. The initial value is
 <code>GL_TEXTURE0</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glColor4f(float, float, float, float)"><!-- --></A><H3>
glColor4f</H3>
<PRE>
public void <B>glColor4f</B>(float&nbsp;red,
                      float&nbsp;green,
                      float&nbsp;blue,
                      float&nbsp;alpha)</PRE>
<DL>
<DD>Set the current color.

 <p>The GL stores a current four-valued RGBA
 color. <code>glColor</code> sets a new four-valued RGBA color.

 <p>Current color values are stored in fixed-point or
 floating-point. In case the values are stored in floating-point,
 the mantissa and exponent sizes are unspecified.

 <p>Neither fixed-point nor floating-point values are clamped to
 the range <code>[0, 1]</code> before the current color is
 updated. However, color components are clamped to this range
 before they are interpolated or written into the color buffer.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>red</CODE> - Specifies a new red value for the current color.  The
 initial value is 1.<DD><CODE>green</CODE> - Specifies a new green value for the current color.  The
 initial value is 1.<DD><CODE>blue</CODE> - Specifies a new blue value for the current color.  The
 initial value is 1.<DD><CODE>alpha</CODE> - Specifies a new alpha value for the current color.  The
 initial value is 1.</DL>
</DD>
</DL>
<HR>

<A NAME="glColor4x(int, int, int, int)"><!-- --></A><H3>
glColor4x</H3>
<PRE>
public void <B>glColor4x</B>(int&nbsp;red,
                      int&nbsp;green,
                      int&nbsp;blue,
                      int&nbsp;alpha)</PRE>
<DL>
<DD>Fixed-point version of <code>glColor</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glColor4f(float, float, float, float)"><CODE>glColor4f(float, float, float, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glColorMask(boolean, boolean, boolean, boolean)"><!-- --></A><H3>
glColorMask</H3>
<PRE>
public void <B>glColorMask</B>(boolean&nbsp;red,
                        boolean&nbsp;green,
                        boolean&nbsp;blue,
                        boolean&nbsp;alpha)</PRE>
<DL>
<DD>Enable and disable writing of color buffer components.

 <p><code>glColorMask</code> specifies whether the individual
 components in the color buffer can or cannot be written. If
 <code>red</code> is <code>false</code>, for example, no change
 is made to the red component of any pixel in the color buffer,
 regardless of the drawing operation attempted, including
 <code>glClear</code>.

 <p>Changes to individual bits of components cannot be
 controlled. Rather, changes are either enabled or disabled for
 entire color components.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>red</CODE> - Specifies whether red can or cannot be written into
 the color buffer. The initial value is <code>true</code>, indicating
 that the color component can be written.<DD><CODE>green</CODE> - Specifies whether green can or cannot be written into
 the color buffer. The initial value is <code>true</code>, indicating
 that the color component can be written.<DD><CODE>blue</CODE> - Specifies whether blue can or cannot be written into
 the color buffer. The initial value is <code>true</code>, indicating
 that the color component can be written.<DD><CODE>alpha</CODE> - Specifies whether alpha can or cannot be written
 into the color buffer. The initial value is <code>true</code>,
 indicating that the color component can be written.</DL>
</DD>
</DL>
<HR>

<A NAME="glColorPointer(int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glColorPointer</H3>
<PRE>
public void <B>glColorPointer</B>(int&nbsp;size,
                           int&nbsp;type,
                           int&nbsp;stride,
                           <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pointer)</PRE>
<DL>
<DD>Define an array of colors.

 <p><code>glColorPointer</code> specifies an array of color
 components to use when rendering. <code>size</code> specifies the
 number of components per color, and must be 4. <code>type</code>
 specifies the data type of each color component, and
 <code>stride</code> specifies the byte stride from one color to
 the next allowing vertices and attributes to be packed into a
 single array or stored in separate arrays. (Single-array storage
 may be more efficient on some implementations.)

 <p>When a color array is specified, <code>size</code>,
 <code>type</code>, <code>stride</code>, and <code>pointer</code>
 are saved as client-side state.

 <p>If the color array is enabled, it is used when
 <code>glDrawArrays</code>, or <code>glDrawElements</code> is
 called. To enable and disable the color array, call
 <code>glEnableClientState</code> and
 <code>glDisableClientState</code> with the argument
 <code>GL_COLOR_ARRAY</code>. The color array is initially
 disabled and isn't accessed when <code>glDrawArrays</code> or
 <code>glDrawElements</code> is called.

 <p>Use <code>glDrawArrays</code> to construct a sequence of
 primitives (all of the same type) from prespecified vertex and
 vertex attribute arrays. Use <code>glDrawElements</code> to
 construct a sequence of primitives by indexing vertices and
 vertex attributes.

 <p>Setting <code>pointer</code> to <code>null</code> releases any
 previously set <code>Buffer</code>.

 <h4>Notes</h4>

 <p><code>glColorPointer</code> is typically implemented on the
 client side.

 <h4>Errors</h4>

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>size</code> is not 4.

 <p><code>GL_INVALID_ENUM</code> is generated if <code>type</code>
 is not an accepted value.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>stride</code> is negative.

 <p> The <code>pointer</code> argument must be a direct buffer
 with a type matching that specified by the <code>type</code>
 argument.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - Specifies the number of components per color. Must be
 4. The initial value is 4.<DD><CODE>type</CODE> - Specifies the data type of each color component in
 the array. Symbolic constants <code>GL_UNSIGNED_BYTE</code>,
 <code>GL_FIXED</code>, and <code>GL_FLOAT</code> are
 accepted. The initial value is <code>GL_FLOAT</code>.<DD><CODE>stride</CODE> - Specifies the byte offset between consecutive
 colors. If <code>stride</code> is 0, the colors are understood to
 be tightly packed in the array. The initial value is 0.<DD><CODE>pointer</CODE> - Specifies a <code>Buffer</code> containing the
 colors.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if OpenGL ES 1.1 is being used and
 VBOs are enabled.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>pointer</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>pointer</code> is
 not direct.</DL>
</DD>
</DL>
<HR>

<A NAME="glCompressedTexImage2D(int, int, int, int, int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glCompressedTexImage2D</H3>
<PRE>
public void <B>glCompressedTexImage2D</B>(int&nbsp;target,
                                   int&nbsp;level,
                                   int&nbsp;internalformat,
                                   int&nbsp;width,
                                   int&nbsp;height,
                                   int&nbsp;border,
                                   int&nbsp;imageSize,
                                   <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</PRE>
<DL>
<DD>Specify a two-dimensional compressed texture image.

 <p><code>glCompressedTexImage2D</code> defines a two-dimensional
 texture image in compressed format.

 <p>The supported compressed formats are paletted textures. The
 layout of the compressed image is a palette followed by multiple
 mip-levels of texture indices used for lookup into the
 palette. The palette format can be one of <code>R5_G6_B5</code>,
 <code>RGBA4</code>, <code>RGB5_A1</code>, <code>RGB8</code>, or
 <code>RGBA8</code>. The texture indices can have a resolution of
 4 or 8 bits. As a result, the number of palette entries is either
 16 or 256. If level is 0, only one mip-level of texture indices
 is described in data. Otherwise, the negative value of level
 specifies up to which mip-level the texture indices are
 described. A possibly remaining pad nibble (half byte) for the
 lowest resolution mip-level is ignored.

 <h4>Notes</h4>

 <p><code>glPixelStore</code> has no effect on compressed texture
 images.

 <p><code>glCompressedTexImage2D</code> specifies the
 two-dimensional texture for the currently bound texture,
 specified with <code>glBindTexture</code>, and the current
 texture unit, specified with <code>glActiveTexture</code>.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if
 <code>target</code> is not <code>GL_TEXTURE_2D</code>.

 <p><code>GL_INVALID_VALUE</code> may be generated if
 <code>level</code> is greater than 0 or the absolute value of
 level is greater than log_2(<i>max</i>), where <i>max</i> is the
 returned value of <code>GL_MAX_TEXTURE_SIZE</code>.

 <p>(1.0) <code>GL_INVALID_VALUE</code> is generated if
 <code>internalformat</code> is not one of the accepted symbolic
 constants.

 <p>(1.1) <code>GL_INVALID_ENUM</code> is generated if
 <code>internalformat</code> is not one of the accepted symbolic
 constants.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>width</code> or <code>height</code> is less than 0 or
 greater than 2 + <code>GL_MAX_TEXTURE_SIZE</code>, or if either
 cannot be represented as 2^<i>k</i> + 2*<code>border</code> for
 some integer <i>k</i>.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>border</code> is not 0.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>imageSize</code> is not consistent with format, dimentions,
 and contents of the compressed image.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture. Must be
 <code>GL_TEXTURE_2D</code>.<DD><CODE>level</CODE> - Specifies the level-of-detail number. Must be less
 than or equal to 0. Level 0 indicates a single
 mip-level. Negative values indicate how many mip-levels are
 described by data.<DD><CODE>internalformat</CODE> - Specifies the color components in the
 texture. The following symbolic constants are accepted:
 <code>GL_PALETTE4_RGB8_OES</code>,
 <code>GL_PALETTE4_RGBA8_OES</code>,
 <code>GL_PALETTE4_R5_G6_B5_OES</code>,
 <code>GL_PALETTE4_RGBA4_OES</code>,
 <code>GL_PALETTE4_RGB5_A1_OES</code>,
 <code>GL_PALETTE8_RGB8_OES</code>,
 <code>GL_PALETTE8_RGBA8_OES</code>,
 <code>GL_PALETTE8_R5_G6_B5_OES</code>,
 <code>GL_PALETTE8_RGBA4_OES</code>, and
 <code>GL_PALETTE8_RGB5_A1_OES</code>.<DD><CODE>width</CODE> - Specifies the width of the texture image. Must be
 2^<i>n</i> + 2*<code>border</code> for some integer <i>n</i>. All
 implementations support texture images that are at least 64
 texels wide.<DD><CODE>height</CODE> - Specifies the height of the texture image. Must be
 2^<i>m</i> + 2*<code>border</code> for some integer <i>m</i>. All
 implementations support texture images that are at least 64
 texels high.<DD><CODE>border</CODE> - Specifies the width of the border. Must be 0.<DD><CODE>imageSize</CODE> - Specifies the size of the compressed image data
 in bytes.<DD><CODE>data</CODE> - Specifies a <code>Buffer</code> containing the
 compressed image data.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>data</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if
 <code>data.remaining()</code> is less than
 <code>imageSize</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glCompressedTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glCompressedTexSubImage2D</H3>
<PRE>
public void <B>glCompressedTexSubImage2D</B>(int&nbsp;target,
                                      int&nbsp;level,
                                      int&nbsp;xoffset,
                                      int&nbsp;yoffset,
                                      int&nbsp;width,
                                      int&nbsp;height,
                                      int&nbsp;format,
                                      int&nbsp;imageSize,
                                      <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</PRE>
<DL>
<DD>Specify a two-dimensional compressed texture subimage.

 <p><code>glCompressedTexSubImage2D</code> redefines a contiguous
 subregion of an existing two-dimensional compressed texture
 image. The texels referenced by <code>pixels</code> replace the
 portion of the existing texture array with x indices
 <code>xoffset</code> and <code>xoffset</code> +
 <code>width</code> - 1, inclusive, and y indices
 <code>yoffset</code> and <code>yoffset</code> +
 <code>height</code> - 1, inclusive. This region may not include
 any texels outside the range of the texture array as it was
 originally specified. It is not an error to specify a subtexture
 with zero width or height, but such a specification has no
 effect.

 <p>Currently, there is no supported compressed format for this
 function.

 <h4>Notes</h4>

 <p><code>glPixelStore</code> has no effect on compressed texture
 images.

 <p><code>glCompressedTexSubImage2D</code> specifies the
 two-dimensional sub texture for the currently bound texture,
 specified with <code>glBindTexture</code>, and the current
 texture unit, specified with <code>glActiveTexture</code>.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if
 <code>target</code> is not <code>GL_TEXTURE_2D</code>.

 <p><code>GL_INVALID_OPERATION</code> is generated if the texture
 array has not been defined by a previous
 <code>glCompressedTexImage2D</code> operation.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>level</code> is less than 0.

 <p><code>GL_INVALID_VALUE</code> may be generated if
 <code>level</code> is greater than log2(<i>max</i>), where
 <i>max</i> is the returned value of
 <code>GL_MAX_TEXTURE_SIZE</code>.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>xoffset</code> < <i>-b</i>, <code>xoffset</code> + width >
 (<i>w - b</i>), <code>yoffset</code> < <i>-b</i>, or
 <code>yoffset</code> + <code>height</code> > (<i>h</i> - <i>b</i>)
 , where <i>w</i> is the texture width, <i>h</i> is the texture
 height, and <i>b</i> is the border of the texture image being
 modified. Note that <i>w</i> and <i>h</i> include twice the
 border width.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>width</code> or <code>height</code> is less than 0.

 <p><code>GL_INVALID_ENUM</code> is generated if <code>type</code>
 is not a type constant.

 <p><code>GL_INVALID_OPERATION</code> is generated if type
 <code>is</code> <code>GL_UNSIGNED_SHORT_5_6_5</code> and
 <code>format</code> is not <code>GL_RGB</code>.

 <p><code>GL_INVALID_OPERATION</code> is generated if
 <code>type</code> is one of
 <code>GL_UNSIGNED_SHORT_4_4_4_4</code>, or
 <code>GL_UNSIGNED_SHORT_5_5_5_1</code> and <code>format</code> is
 not <code>GL_RGBA</code>.

 <p><code>GL_INVALID_OPERATION</code> is generated if none of the
 above error conditions apply.

 <h4>Associated Gets</h4>

 <p><code>glGetIntegerv</code> with argument
 <code>GL_MAX_TEXTURE_SIZE</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture. Must be
 <code>GL_TEXTURE_2D</code>.<DD><CODE>level</CODE> - Specifies the level-of-detail number.<DD><CODE>xoffset</CODE> - Specifies a texel offset in the x direction within
 the texture array.<DD><CODE>yoffset</CODE> - Specifies a texel offset in the y direction within
 the texture array.<DD><CODE>width</CODE> - Specifies the width of the texture subimage.<DD><CODE>height</CODE> - Specifies the height of the texture subimage.<DD><CODE>format</CODE> - Specifies the format of the pixel data. Currently,
 there is no supported format.<DD><CODE>imageSize</CODE> - Specifies the size of the compressed pixel data in bytes.<DD><CODE>data</CODE> - Specifies a <code>Buffer</code> containing the
 compressed image data.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>data</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if
 <code>data.remaining()</code> is less than
 <code>imageSize</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glCopyTexImage2D(int, int, int, int, int, int, int, int)"><!-- --></A><H3>
glCopyTexImage2D</H3>
<PRE>
public void <B>glCopyTexImage2D</B>(int&nbsp;target,
                             int&nbsp;level,
                             int&nbsp;internalformat,
                             int&nbsp;x,
                             int&nbsp;y,
                             int&nbsp;width,
                             int&nbsp;height,
                             int&nbsp;border)</PRE>
<DL>
<DD>Specify a two-dimensional texture image with pixels from the
 color buffer.

 <p><code>glCopyTexImage2D</code> defines a two-dimensional
 texture image with pixels from the color buffer.

 <p>The screen-aligned pixel rectangle with lower left corner at
 (<code>x</code>, <code>y</code>) and with a width of
 <code>width</code> + 2*<code>border</code> and a height of
 <code>height</code> + 2*<code>border</code> defines the texture
 array at the mipmap level specified by
 <code>level</code>. <code>internalformat</code> specifies the
 color components of the texture.

 <p>The red, green, blue, and alpha components of each pixel that
 is read are converted to an internal fixed-point or
 floating-point format with unspecified precision. The conversion
 maps the largest representable component value to 1.0, and
 component value 0 to 0.0. The values are then converted to the
 texture's internal format for storage in the texel array.

 <p><code>internalformat</code> must be chosen such that color
 buffer components can be dropped during conversion to the
 internal format, but new components cannot be added. For example,
 an RGB color buffer can be used to create <code>LUMINANCE</code>
 or <code>RGB</code> textures, but not <code>ALPHA</code>,
 <code>LUMINANCE_ALPHA</code> or <code>RGBA</code> textures.

 <p>Pixel ordering is such that lower x and y screen coordinates
 correspond to lower s and t texture coordinates.

 <p>If any of the pixels within the specified rectangle of the
 color buffer are outside the window associated with the current
 rendering context, then the values obtained for those pixels are
 undefined.

 <h4>Notes</h4>

 <p>An image with <code>height</code> or <code>width</code> of 0
 indicates a null-texture.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if
 <code>target</code> is not <code>GL_TEXTURE_2D</code>. <!-- If the
 <code>OES_texture_cube_map</code> extension is present, then
 <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
 <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>,
 <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>,
 <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>,
 <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>, and
 <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code> are also accepted. -->

 <p><code>GL_INVALID_OPERATION</code> is generated if
 <code>internalformat</code> is not compatible with the color
 buffer format.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>level</code> is less than 0.

 <p><code>GL_INVALID_VALUE</code> may be generated if level is
 greater than log_2(<i>max</i>), where <i>max</i> is the returned
 value of <code>GL_MAX_TEXTURE_SIZE</code>.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>width</code> or <code>height</code> is less than 0, greater
 than <code>GL_MAX_TEXTURE_SIZE</code>, or if <code>width</code>
 or <code>height</code> cannot be represented as 2^<i>k</i> +
 2*<code>border</code> for some integer <i>k</i>.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>border</code> is not 0.

 <p>(1.0) <code>GL_INVALID_VALUE</code> is generated if
 <code>internalformat</code> is not an accepted constant.

 <p>(1.1) <code>GL_INVALID_ENUM</code> is generated if
 <code>internalformat</code> is not an accepted constant.

 <h4>Associated Gets</h4>

 <p><code>glGetIntegerv</code> with argument
 <code>GL_MAX_TEXTURE_SIZE</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture. Must be
 <code>GL_TEXTURE_2D</code>.<DD><CODE>level</CODE> - Specifies the level-of-detail number. Level 0 is the
 base image level. Level n is the nth mipmap reduction image.<DD><CODE>internalformat</CODE> - Specifies the color components of the
 texture. Must be one of the following symbolic constants:
 <code>GL_ALPHA</code>, <code>GL_LUMINANCE</code>,
 <code>GL_LUMINANCE_ALPHA</code>, <code>GL_RGB</code>, or
 <code>GL_RGBA</code>.<DD><CODE>x</CODE> - Specifies the window x coordinate of the lower left
 corner of the rectangular region of pixels to be copied.<DD><CODE>y</CODE> - Specifies the window y coordinate of the lower left
 corner of the rectangular region of pixels to be copied.<DD><CODE>width</CODE> - Specifies the width of the texture image. Must be 0
 or 2^<i>n</i? + 2*<code>border</code> for some integer <i>n</i>.<DD><CODE>height</CODE> - Specifies the height of the texture image. Must be
 0 or 2^<i>m</i> + 2*<code>border</code> for some integer <i>m</i>.<DD><CODE>border</CODE> - Specifies the width of the border. Must be 0.</DL>
</DD>
</DL>
<HR>

<A NAME="glCopyTexSubImage2D(int, int, int, int, int, int, int, int)"><!-- --></A><H3>
glCopyTexSubImage2D</H3>
<PRE>
public void <B>glCopyTexSubImage2D</B>(int&nbsp;target,
                                int&nbsp;level,
                                int&nbsp;xoffset,
                                int&nbsp;yoffset,
                                int&nbsp;x,
                                int&nbsp;y,
                                int&nbsp;width,
                                int&nbsp;height)</PRE>
<DL>
<DD>Specify a two-dimensional texture subimage with pixels from the
 color buffer.

 <p><code>glCopyTexSubImage2D</code> replaces a rectangular portion of a
 two-dimensional texture image with pixels from the color buffer.

 <p>The screen-aligned pixel rectangle with lower left corner at
 (<code>x</code>, <code>y</code>) and with width width and height
 height replaces the portion of the texture array with x indices
 <code>xoffset</code> through <code>xoffset</code> +
 <code>width</code> - 1, inclusive, and y indices
 <code>yoffset</code> through <code>yoffset</code> +
 <code>height</code> - 1, inclusive, at the mipmap level specified
 by level.

 <p>The pixels in the rectangle are processed the same way as with
 <code>glCopyTexImage2D</code>.

 <p><code>glCopyTexSubImage2D</code> requires that the internal
 format of the currently bound texture is such that color buffer
 components can be dropped during conversion to the internal
 format, but new components cannot be added. For example, an RGB
 color buffer can be used to create LUMINANCE or RGB textures, but
 not ALPHA, LUMINANCE_ALPHA or RGBA textures.

 <p>The destination rectangle in the texture array may not include
 any texels outside the texture array as it was originally
 specified. It is not an error to specify a subtexture with zero
 width or height, but such a specification has no effect.

 <p>If any of the pixels within the specified rectangle of the
 current color buffer are outside the read window associated with
 the current rendering context, then the values obtained for those
 pixels are undefined.

 <p>No change is made to the <code>internalformat</code>,
 <code>width</code>, <code>height</code>, or <code>border</code>
 parameters of the specified texture array or to texel values
 outside the specified subregion.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if
 <code>target</code> is not <code>GL_TEXTURE_2D</code>.

 <p><code>GL_INVALID_OPERATION</code> is generated if the texture
 array has not been defined by a previous
 <code>glTexImage2D</code> or <code>glCopyTexImage2D</code>
 operation or if the internal format of the currently bound
 texture is not compatible with the color buffer format.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>level</code> is less than 0.

 <p><code>GL_INVALID_VALUE</code> may be generated if
 <code>level</code> is greater than log_2(<i>max</i>), where
 <i>max</i> is the returned value of
 <code>GL_MAX_TEXTURE_SIZE</code>.

 <p><code>GL_INVALID_VALUE</code> is generated if x < <i>-b</i>,
 or y < <i>-b</i>, where <i>b</i> is the border of the texture
 being modified.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>xoffset</code> < <i>-b</i>, <code>xoffset</code> +
 <code>width</code> > (<i>w - b</i>) , <code>yoffset</code> <
 <i>-b</i>, or <code>yoffset</code> + <code>height</code> > (<i>h
 - b</i>) , where <i>w</i> is the texture width, <i>h</i> is the
 texture height, and <i>b</i> is the border of the texture image
 being modified. Note that <i>w</i> and <i>h</i> include twice the
 border width.

 <h4>Associated Gets</h4>

 <p><p><code>glGetIntegerv</code> with argument
 <code>GL_MAX_TEXTURE_SIZE</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture. Must be
 <code>GL_TEXTURE_2D</code>.<DD><CODE>level</CODE> - Specifies the level-of-detail number. Level 0 is the
 base image level. Level n is the nth mipmap reduction image.<DD><CODE>xoffset</CODE> - Specifies a texel offset in the x direction within
 the texture array.<DD><CODE>yoffset</CODE> - Specifies a texel offset in the y direction within
 the texture array.<DD><CODE>x</CODE> - Specifies the window x coordinate of the lower left
 corner of the rectangular region of pixels to be copied.<DD><CODE>y</CODE> - Specifies the window y coordinate of the lower left
 corner of the rectangular region of pixels to be copied.<DD><CODE>width</CODE> - Specifies the width of the texture subimage.<DD><CODE>height</CODE> - Specifies the height of the texture subimage.</DL>
</DD>
</DL>
<HR>

<A NAME="glCullFace(int)"><!-- --></A><H3>
glCullFace</H3>
<PRE>
public void <B>glCullFace</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Specify whether front- or back-facing polygons are culled.

 <p><code>glCullFace</code> specifies whether front- or
 back-facing polygons are culled (as specified by
 <code>mode</code>) when culling is enabled. To enable and disable
 culling, call <code>glEnable</code> and <code>glDisable</code>
 with argument <code>GL_CULL_FACE</code>. Culling is initially
 disabled.

 <p><code>glFrontFace</code> specifies which of the clockwise and
 counterclockwise polygons are front-facing and back-facing.

 <h4>Notes</h4>

 <p>If mode is <code>GL_FRONT_AND_BACK</code>, no polygons are
 drawn, but other primitives such as points and lines are drawn.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if <code>mode</code>
 is not an accepted value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - Specifies whether front- or back-facing polygons are
 culled. Symbolic constants <code>GL_FRONT</code>,
 <code>GL_BACK</code>, and <code>GL_FRONT_AND_BACK</code> are
 accepted. The initial value is <code>GL_BACK</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glDeleteTextures(int, int[], int)"><!-- --></A><H3>
glDeleteTextures</H3>
<PRE>
public void <B>glDeleteTextures</B>(int&nbsp;n,
                             int[]&nbsp;textures,
                             int&nbsp;offset)</PRE>
<DL>
<DD>Delete named textures.

 <p><code>glDeleteTextures</code> deletes <code>n</code> textures
 named by the elements of the array <code>textures</code>. After a
 texture is deleted, it has no contents or dimensionality, and its
 name is free for reuse (for example by
 <code>glGenTextures</code>). If a texture that is currently bound
 is deleted, the binding reverts to 0 (the default texture).

 <p><code>glDeleteTextures</code> silently ignores 0's and names
 that do not correspond to existing textures.

 <h4>Errors</h4>

 <p><code>GL_INVALID_VALUE</code> is generated if <code>n</code>
 is negative.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of textures to be deleted.<DD><CODE>textures</CODE> - Specifies an array of textures to be deleted.<DD><CODE>offset</CODE> - the starting offset within the
 <code>textures</code> array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>textures</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>textures.length -
 offset</code> is less than <code>n</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glDeleteTextures(int, java.nio.IntBuffer)"><!-- --></A><H3>
glDeleteTextures</H3>
<PRE>
public void <B>glDeleteTextures</B>(int&nbsp;n,
                             <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;textures)</PRE>
<DL>
<DD>Integer <code>Buffer</code> version of <code>glDeleteTextures</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>textures</CODE> - an <code>IntBuffer</code>.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>textures</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if
 <code>textures.remaining()</code> is less than <code>n</code>.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glDeleteTextures(int, int[], int)"><CODE>glDeleteTextures(int n, int[] textures, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glDepthFunc(int)"><!-- --></A><H3>
glDepthFunc</H3>
<PRE>
public void <B>glDepthFunc</B>(int&nbsp;func)</PRE>
<DL>
<DD>Specify the value used for depth buffer comparisons.

 <p><code>glDepthFunc</code> specifies the function used to compare
 each incoming pixel depth value with the depth value present in
 the depth buffer. The comparison is performed only if depth
 testing is enabled. To enable and disable depth testing, call
 <code>glEnable</code> and <code>glDisable</code> with argument
 <code>GL_DEPTH_TEST</code>. Depth testing is initially disabled.

 <p>func specifies the conditions under which the pixel will be
 drawn. The comparison functions are as follows:

 <ul>
 <li><code>GL_NEVER</code></li>
 Never passes.
 <li><code>GL_LESS</code></li>
 Passes if the incoming depth value is less than the stored depth value.
 <li><code>GL_EQUAL</code></li>
 Passes if the incoming depth value is equal to the stored depth value.
 <li><code>GL_LEQUAL</code></li>
 Passes if the incoming depth value is less than or equal to the
 stored depth value.
 <li><code>GL_GREATER</code></li>
 Passes if the incoming depth value is greater than the stored
 depth value.
 <li><code>GL_NOTEQUAL</code></li>
 Passes if the incoming depth value is not equal to the stored
 depth value.
 <li><code>GL_GEQUAL</code></li>
 Passes if the incoming depth value is greater than or equal to
 the stored depth value.
 <li><code>GL_ALWAYS</code></li>
 Always passes.
 </ul>

 <p>The initial value of func is <code>GL_LESS</code>. Initially,
 depth testing is disabled. Even if the depth buffer exists and
 the depth mask is non-zero, the depth buffer is not updated if
 the depth test is disabled.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if <code>func</code>
 is not an accepted value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>func</CODE> - Specifies the depth comparison function. Symbolic
 constants <code>GL_NEVER</code>, <code>GL_LESS</code>,
 <code>GL_EQUAL</code>, <code>GL_LEQUAL</code>,
 <code>GL_GREATER</code>, <code>GL_NOTEQUAL</code>,
 <code>GL_GEQUAL</code>, and <code>GL_ALWAYS</code> are
 accepted. The initial value is <code>GL_LESS</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glDepthMask(boolean)"><!-- --></A><H3>
glDepthMask</H3>
<PRE>
public void <B>glDepthMask</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>Enable or disable writing into the depth buffer.

 <p><code>glDepthMask</code> specifies whether the depth buffer is
 enabled for writing. If <code>flag</code> is <code>false</code>,
 depth buffer writing is disabled. Otherwise, it is
 enabled. Initially, depth buffer writing is enabled.

 <h4>1.0 Notes</h4>

 <p><code>glDepthMask</code> does not affect <code>glClear</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>flag</CODE> - Specifies whether the depth buffer is enabled for
 writing. If flag is <code>GL_FALSE</code>, depth buffer writing
 is disabled, otherwise it is enabled. The initial value is
 <code>true</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glDepthRangef(float, float)"><!-- --></A><H3>
glDepthRangef</H3>
<PRE>
public void <B>glDepthRangef</B>(float&nbsp;zNear,
                          float&nbsp;zFar)</PRE>
<DL>
<DD>Specify mapping of depth values from normalized device
 coordinates to window coordinates.

 <p>After clipping and division by w, depth coordinates range from
 -1 to 1, corresponding to the near and far clipping
 planes. <code>glDepthRange</code> specifies a linear mapping of
 the normalized depth coordinates in this range to window depth
 coordinates. Regardless of the actual depth buffer
 implementation, window coordinate depth values are treated as
 though they range from 0 through 1 (like color components). Thus,
 the values accepted by <code>glDepthRange</code> are both clamped
 to this range before they are accepted.

 <p>The setting of (0, 1) maps the near plane to 0 and the far
 plane to 1. With this mapping, the depth buffer range is fully
 utilized.

 <h4>Notes</h4>

 <p>It is not necessary that <code>near</code> be less than
 <code>far</code>. Reverse mappings such as <code>near</code> = 1,
 and <code>far</code> = 0 are acceptable.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>zNear</CODE> - Specifies the mapping of the near clipping plane to
 window coordinates. The initial value is 0.<DD><CODE>zFar</CODE> - Specifies the mapping of the far clipping plane to
 window coordinates. The initial value is 1.</DL>
</DD>
</DL>
<HR>

<A NAME="glDepthRangex(int, int)"><!-- --></A><H3>
glDepthRangex</H3>
<PRE>
public void <B>glDepthRangex</B>(int&nbsp;zNear,
                          int&nbsp;zFar)</PRE>
<DL>
<DD>Fixed-point version of <code>glDepthRange</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glDepthRangef(float, float)"><CODE>glDepthRangef(float zNear, float zFar)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glDisable(int)"><!-- --></A><H3>
glDisable</H3>
<PRE>
public void <B>glDisable</B>(int&nbsp;cap)</PRE>
<DL>
<DD>Disable server-side GL capabilities.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glEnable(int)"><CODE>glEnable(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glDisableClientState(int)"><!-- --></A><H3>
glDisableClientState</H3>
<PRE>
public void <B>glDisableClientState</B>(int&nbsp;array)</PRE>
<DL>
<DD>Disable client-side capability.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glEnableClientState(int)"><CODE>glEnableClientState(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glDrawArrays(int, int, int)"><!-- --></A><H3>
glDrawArrays</H3>
<PRE>
public void <B>glDrawArrays</B>(int&nbsp;mode,
                         int&nbsp;first,
                         int&nbsp;count)</PRE>
<DL>
<DD>Render primitives from array data.

 <p><code>glDrawArrays</code> specifies multiple geometric
 primitives with very few subroutine calls. You can prespecify
 separate arrays of vertices, normals, colors, and texture
 coordinates and use them to construct a sequence of primitives
 with a single call to <code>glDrawArrays</code>.

 <p>When <code>glDrawArrays</code> is called, it uses
 <code>count</code> sequential elements from each enabled array to
 construct a sequence of geometric primitives, beginning with
 element <code>first</code>. <code>mode</code> specifies what kind
 of primitives are constructed, and how the array elements
 construct those primitives. If <code>GL_VERTEX_ARRAY</code> is
 not enabled, no geometric primitives are generated.

 <p>Vertex attributes that are modified by
 <code>glDrawArrays</code> have an unspecified value after
 <code>glDrawArrays</code> returns. For example, if
 <code>GL_COLOR_ARRAY</code> is enabled, the value of the current
 color is undefined after <code>glDrawArrays</code>
 executes. Attributes that aren't modified remain well defined.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if <code>mode</code>
 is not an accepted value.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>count</code> is negative.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - Specifies what kind of primitives to render. Symbolic
 constants <code>GL_POINTS</code>, <code>GL_LINE_STRIP</code>,
 <code>GL_LINE_LOOP</code>, <code>GL_LINES</code>,
 <code>GL_TRIANGLE_STRIP</code>, <code>GL_TRIANGLE_FAN</code>, and
 <code>GL_TRIANGLES</code> are accepted.<DD><CODE>first</CODE> - Specifies the starting index in the enabled arrays.<DD><CODE>count</CODE> - Specifies the number of indices to be rendered.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if any index in the
 sequence <code>first, ..., first + count - 1</code> will result
 in a reference to an entry outside of the current vertex, color,
 normal, texture coordinate, point size, matrix index, or weight
 array.</DL>
</DD>
</DL>
<HR>

<A NAME="glDrawElements(int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glDrawElements</H3>
<PRE>
public void <B>glDrawElements</B>(int&nbsp;mode,
                           int&nbsp;count,
                           int&nbsp;type,
                           <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;indices)</PRE>
<DL>
<DD>Render primitives from array data.

 <p><code>glDrawElements</code> specifies multiple geometric
 primitives with very few subroutine calls. You can prespecify
 separate arrays of vertices, normals, colors, and texture
 coordinates and use them to construct a sequence of primitives
 with a single call to <code>glDrawElements</code>.

 <p>When <code>glDrawElements</code> is called, it uses
 <code>count</code> sequential indices from <code>indices</code>
 to lookup elements in enabled arrays to construct a sequence of
 geometric primitives. <code>mode</code> specifies what kind of
 primitives are constructed, and how the array elements construct
 these primitives. If <code>GL_VERTEX_ARRAY</code> is not enabled,
 no geometric primitives are constructed.

 <p>Vertex attributes that are modified by
 <code>glDrawElements</code> have an unspecified value after
 <code>glDrawElements</code> returns. For example, if
 <code>GL_COLOR_ARRAY</code> is enabled, the value of the current
 color is undefined after <code>glDrawElements</code>
 executes. Attributes that aren't modified maintain their previous
 values.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if <code>mode</code>
 is not an accepted value.

 <p><code>GL_INVALID_ENUM</code> is generated if <code>type</code>
 is not an accepted value.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>count</code> is negative.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - Specifies what kind of primitives to render. Symbolic
 constants <code>GL_POINTS</code>, <code>GL_LINE_STRIP</code>,
 <code>GL_LINE_LOOP</code>, <code>GL_LINES</code>,
 <code>GL_TRIANGLE_STRIP</code>, <code>GL_TRIANGLE_FAN</code>, and
 <code>GL_TRIANGLES</code> are accepted.<DD><CODE>count</CODE> - Specifies the number of elements to be rendered.<DD><CODE>type</CODE> - Specifies the type of the values in indices. Must be
 either <code>GL_UNSIGNED_BYTE</code> or <code>GL_UNSIGNED_SHORT</code>.<DD><CODE>indices</CODE> - Specifies a pointer to the location where the
 indices are stored.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if the most recent call to
 <code>glBindBuffer</code> for the
 <code>GL_ELEMENT_ARRAY_BUFFER</code> target had a non-zero
 <code>buffer</code> parameter (i.e., an index buffer is bound).
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>indices</code> is
 <code>null</code>.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if any index in the
 sequence of indices from <code>0</code> to <code>count - 1</code>
 would result in a reference to an entry outside of the currently
 bound index or data (vertex, color, normal, texture coordinate
 array, weight, matrix index, or point size) array.</DL>
</DD>
</DL>
<HR>

<A NAME="glEnable(int)"><!-- --></A><H3>
glEnable</H3>
<PRE>
public void <B>glEnable</B>(int&nbsp;cap)</PRE>
<DL>
<DD>Enable server-side GL capabilities.

 <p><code>glEnable</code> and <code>glDisable</code> enable and
 disable various capabilities. The initial value for each
 capability with the exception of <code>GL_DITHER</code> and
 <code>GL_MULTISAMPLE</code> is <code>GL_FALSE</code>. The initial
 value for <code>GL_DITHER</code> and <code>GL_MULTISAMPLE</code>
 is <code>GL_TRUE</code>.

 <p>Both <code>glEnable</code> and <code>glDisable</code> take a
 single argument, <code>cap</code>, which can assume one of the
 following values:

 <ul>
 <li><code>GL_ALPHA_TEST</code></li>

 <p>If enabled, do alpha testing. See <code>glAlphaFunc</code>.

 <li><code>GL_BLEND</code></li>

 <p>If enabled, blend the incoming color values with the values in
 the color buffers. See <code>glBlendFunc</code>.

 <li><code>GL_COLOR_LOGIC_OP</code></li>

 <p>If enabled, apply the currently selected logical operation to the
 incoming color and color buffer values. See <code>glLogicOp</code>.

 <li><code>GL_COLOR_MATERIAL</code></li>

 <p>If enabled, have ambient and diffuse material parameters track
 the current color.

 <li><code>GL_CULL_FACE</code></li>

 <p>If enabled, cull polygons based on their winding in window
 coordinates. See <code>glCullFace</code>.

 <li><code>GL_DEPTH_TEST</code></li>

 <p>If enabled, do depth comparisons and update the depth
 buffer. Note that even if the depth buffer exists and the depth
 mask is non-zero, the depth buffer is not updated if the depth
 test is disabled. See <code>glDepthFunc</code>,
 <code>glDepthMask</code>, and <code>glDepthRange</code>.

 <li><code>GL_DITHER</code></li>

 <p>If enabled, dither color components or indices before they are
 written to the color buffer.

 <li><code>GL_FOG</code></li>

 <p>If enabled, blend a fog color into the posttexturing color. See
 <code>glFog</code>.

 <li><code>GL_LIGHT</code><i>i</i></li>

 <p>If enabled, include light <i>i</i> in the evaluation of the
 lighting equation. See <code>glLightModel</code> and
 <code>glLight</code>.

 <li><code>GL_LIGHTING</code></li>

 <p>If enabled, use the current lighting parameters to compute the
 vertex color. Otherwise, simply associate the current color with
 each vertex. See <code>glMaterial</code>,
 <code>glLightModel</code>, and <code>glLight</code>.

 <li><code>GL_LINE_SMOOTH</code></li>

 <p>If enabled, draw lines with correct filtering. Otherwise, draw
 aliased lines. See <code>glLineWidth</code>.

 <li><code>GL_MULTISAMPLE</code></li>

 <p>If enabled, perform multisampling of fragments for single-pass
 antialiasing and other effects. See <code>glSampleCoverage</code>.

 <li><code>GL_NORMALIZE</code></li>

 <p>If enabled, normal vectors are scaled to unit length after
 transformation. See <code>glNormal</code> and
 <code>glNormalPointer</code>.

 <li><code>GL_POINT_SMOOTH</code></li>

 <p>If enabled, draw points with proper filtering. Otherwise, draw
 aliased points. See <code>glPointSize</code>.

 <li><code>GL_POLYGON_OFFSET_FILL</code></li>

 <p>If enabled, an offset is added to depth values of a polygon's
 fragments before the depth comparison is performed. See
 <code>glPolygonOffset</code>.

 <li><code>GL_RESCALE_NORMAL</code></li>

 <p>If enabled, normal vectors are scaled by a factor derived from
 the modelview matrix. See <code>glNormal</code> and
 <code>glNormalPointer</code>.

 <li><code>GL_SAMPLE_ALPHA_TO_MASK</code> (1.0 only)</li>

 <p>If enabled, convert fragment alpha values to multisample coverage
 modification masks. See <code>glSampleCoverage</code>.

 <li><code>GL_SAMPLE_ALPHA_TO_COVERAGE</code> (1.1 only)</li>

 <p>If enabled, a temporary coverage value is generated where each
 bit is determined by the alpha value at the corresponding sample
 location. The temporary coverage value is then ANDed with the
 fragment coverage value. Otherwise the fragment coverage value is
 unchanged at this point. See <code>glSampleCoverage</code>.

 <li><code>GL_SAMPLE_ALPHA_TO_ONE</code></li>

 <p>If enabled, set fragment alpha to the maximum permissible value
 after computing multisample coverage modification masks. See
 <code>glSampleCoverage</code>.

 <li><code>GL_SAMPLE_MASK</code> (1.0 only)</li>

 <p>If enabled, apply a mask to modify fragment coverage during
 multisampling. See <code>glSampleCoverage</code>.

 <li><code>GL_SAMPLE_COVERAGE</code> (1.1 only)</li>

 <p>If enabled, the fragment coverage is ANDed with another temporary
 coverage. This temporary coverage is generated in the same manner
 as for <code>GL_SAMPLE_ALPHA_TO_COVERAGE</code> described above,
 but as a function of the value of
 <code>GL_SAMPLE_COVERAGE_VALUE</code>. If
 <code>GL_SAMPLE_COVERAGE_INVERT</code> is <code>GL_TRUE</code>,
 the temporary coverage is inverted (all bit values are inverted)
 before it is ANDed with the fragment coverage. See
 <code>glSampleCoverage</code>.

 <li><code>GL_SCISSOR_TEST</code></li>

 <p>If enabled, discard fragments that are outside the scissor
 rectangle. See <code>glScissor</code>.

 <li><code>GL_STENCIL_TEST</code></li>

 <p>If enabled, do stencil testing and update the stencil buffer. See
 <code>glStencilFunc</code>, <code>glStencilMask</code>, and
 <code>glStencilOp</code>.

 <li><code>GL_TEXTURE_2D</code></li>

 <p>If enabled, two-dimensional texturing is performed for the active
 texture unit. See <code>glActiveTexture</code>,
 <code>glTexImage2D</code>, <code>glCompressedTexImage2D</code>,
 and <code>glCopyTexImage2D</code>.

 <li><code>GL_CLIP_PLANE</code><i>i</i> (1.1 only)</li>

 <p>If enabled, clipping plane <i>i</i> is enabled.  See
 <code>glClipPlane</code>.

 <li><code>GL_POINT_SPRITE_OES</code>
 (1.1 + <code>OES_point_sprite</code> extension)</li>

 <p>If enabled, point sprites are enabled. See
 <code>glPointSize</code> and <code>glTexEnv</code>.

 </ul>

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if cap is not one of
 the values listed previously.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cap</CODE> - Specifies a symbolic constant indicating a GL capability.</DL>
</DD>
</DL>
<HR>

<A NAME="glEnableClientState(int)"><!-- --></A><H3>
glEnableClientState</H3>
<PRE>
public void <B>glEnableClientState</B>(int&nbsp;array)</PRE>
<DL>
<DD>Enable client-side capability.

 <p><code>glEnableClientState</code> and
 <code>glDisableClientState</code> enable or disable individual
 client-side capabilities. By default, all client-side
 capabilities are disabled. Both <code>glEnableClientState</code>
 and <code>glDisableClientState</code> take a single argument,
 <code>array</code>, which can assume one of the following values:

 <ul>

 <li><code>GL_COLOR_ARRAY</code></li>

 <p>If enabled, the color array is enabled for writing and used
 during rendering when <code>glDrawArrays</code>, or
 <code>glDrawElements</code> is called. See
 <code>glColorPointer</code>.

 <li><code>GL_NORMAL_ARRAY</code></li>

 <p>If enabled, the normal array is enabled for writing and used
 during rendering when <code>glDrawArrays</code>, or
 <code>glDrawElements</code> is called. See
 <code>glNormalPointer</code>.

 <li><code>GL_TEXTURE_COORD_ARRAY</code></li>

 <p>If enabled, the texture coordinate array is enabled for writing
 and used during rendering when <code>glDrawArrays</code>, or
 <code>glDrawElements</code> is called. See
 <code>glTexCoordPointer</code>.

 <li><code>GL_VERTEX_ARRAY</code></li>

 <p>If enabled, the vertex array is enabled for writing and used
 during rendering when <code>glDrawArrays</code>, or
 <code>glDrawElements</code> is called. See
 <code>glVertexPointer</code>.

 <li><code>GL_POINT_SIZE_ARRAY_OES</code>
 (<code>OES_point_size_array</code> extension)</li>

 <p>If enabled, the point size array controls the sizes used to
 render points and point sprites. In this case the point size
 defined by <code>glPointSize</code> is ignored. The point sizes
 supplied in the point size arrays will be the sizes used to
 render both points and point sprites. See
 <code>glPointSize</code>.

 </ul>
 
 <h4>Notes</h4>

 <p>Enabling and disabling <code>GL_TEXTURE_COORD_ARRAY</code>
 affects the active client texture unit. The active client texture
 unit is controlled with <code>glClientActiveTexture</code>.
 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if
 <code>array</code> is not an accepted value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Specifies the capability to enable or
 disable. Symbolic constants <code>GL_COLOR_ARRAY</code>,
 <code>GL_NORMAL_ARRAY</code>,
 <code>GL_TEXTURE_COORD_ARRAY</code>,
 <code>GL_VERTEX_ARRAY</code>, and
 <code>GL_POINT_SIZE_ARRAY_OES</code>
 (<code>OES_point_size_array</code> extension) are accepted. <!-- If the
 <code>OES_matrix_palette</code> extension is present, symbolic
 constants <code>GL_MATRIX_INDEX_ARRAY_OES</code>,
 <code>GL_WEIGHT_ARRAY_OES</code> are additionally accepted. --></DL>
</DD>
</DL>
<HR>

<A NAME="glFinish()"><!-- --></A><H3>
glFinish</H3>
<PRE>
public void <B>glFinish</B>()</PRE>
<DL>
<DD>Block until all GL execution is complete.

 <p><code>glFinish</code> does not return until the effects of all
 previously called GL commands are complete. Such effects include
 all changes to GL state, all changes to connection state, and all
 changes to the frame buffer contents.

 <h4>Notes</h4>

 <p><code>glFinish</code> requires a round trip to the server.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="glFlush()"><!-- --></A><H3>
glFlush</H3>
<PRE>
public void <B>glFlush</B>()</PRE>
<DL>
<DD>Force execution of GL commands in finite time.

 <p>Different GL implementations buffer commands in several
 different locations, including network buffers and the graphics
 accelerator itself. <code>glFlush</code> empties all of these
 buffers, causing all issued commands to be executed as quickly as
 they are accepted by the actual rendering engine. Though this
 execution may not be completed in any particular time period, it
 does complete in finite time.

 <p>Because any GL program might be executed over a network, or on an
 accelerator that buffers commands, all programs should call
 <code>glFlush</code> whenever they count on having all of their previously
 issued commands completed. For example, call <code>glFlush</code> before
 waiting for user input that depends on the generated image.

 <h4>Notes</h4>

 <p><code>glFlush</code> can return at any time. It does not wait until the
 execution of all previously issued GL commands is complete.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="glFogf(int, float)"><!-- --></A><H3>
glFogf</H3>
<PRE>
public void <B>glFogf</B>(int&nbsp;pname,
                   float&nbsp;param)</PRE>
<DL>
<DD>Specify fog parameters.

 <p>If fog is enabled, fog affects rasterized geometry, bitmaps,
 and pixel blocks, but not buffer clear operations. To enable and
 disable fog, call <code>glEnable</code> and
 <code>glDisable</code> with argument <code>GL_FOG</code>. Fog is
 initially disabled.

 <p><code>glFog</code> assigns the value in <code>param</code> to
 the fog parameter specified by <code>pname</code>. The following
 values are accepted for <code>pname</code>:

 <ul>

 <li><code>GL_FOG_MODE</code></li>

 <p><code>param</code> is a single value that specifies the equation
 to be used to compute the fog blend factor f. Three symbolic
 constants are accepted: <code>GL_LINEAR</code>,
 <code>GL_EXP</code>, and <code>GL_EXP2</code>. The equations
 corresponding to these symbolic constants are defined below. The
 initial fog mode is <code>GL_EXP</code>.

 <li><code>GL_FOG_DENSITY</code></li>

 <p><code>param</code> is a single value that specifies density, the
 fog density used in both exponential fog equations. Only
 nonnegative densities are accepted. The initial fog density is 1.

 <li><code>GL_FOG_START</code></li>

 <p><code>param</code> is a single value that specifies start, the
 near distance used in the linear fog equation. The initial near
 distance is 0.

 <li><code>GL_FOG_END</code></li>

 <p><code>param</code> is a single value that specifies end, the far
 distance used in the linear fog equation. The initial far
 distance is 1.

 </ul>

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if
 <code>pname</code> is not an accepted value, or if
 <code>pname</code> is <code>GL_FOG_MODE</code> and
 <code>param</code> is not an accepted value.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>pname</code> is <code>GL_FOG_DENSITY</code>, and
 <code>param</code> is negative.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pname</CODE> - Specifies a single-valued fog
 parameter. <code>GL_FOG_MODE</code>, <code>GL_FOG_DENSITY</code>,
 <code>GL_FOG_START</code>, and <code>GL_FOG_END</code> are
 accepted.<DD><CODE>param</CODE> - Specifies the value that <code>pname</code> will be
 set to.</DL>
</DD>
</DL>
<HR>

<A NAME="glFogfv(int, float[], int)"><!-- --></A><H3>
glFogfv</H3>
<PRE>
public void <B>glFogfv</B>(int&nbsp;pname,
                    float[]&nbsp;params,
                    int&nbsp;offset)</PRE>
<DL>
<DD>Specify fog parameters (array version).

 <p>If fog is enabled, fog affects rasterized geometry, bitmaps,
 and pixel blocks, but not buffer clear operations. To enable and
 disable fog, call <code>glEnable</code> and
 <code>glDisable</code> with argument <code>GL_FOG</code>. Fog is
 initially disabled.

 <p><code>glFog</code> assigns the value or values in
 <code>params</code> to the fog parameter specified by
 <code>pname</code>. The following values are accepted for
 <code>pname</code>:

 <ul>

 <li><code>GL_FOG_MODE</code></li>

 <p><code>params</code> contains a single value that specifies the
 equation to be used to compute the fog blend factor f. Three
 symbolic constants are accepted: <code>GL_LINEAR</code>,
 <code>GL_EXP</code>, and <code>GL_EXP2</code>. The equations
 corresponding to these symbolic constants are defined below. The
 initial fog mode is <code>GL_EXP</code>.

 <li><code>GL_FOG_DENSITY</code></li>

 <p><code>params</code> contains a single value that specifies
 density, the fog density used in both exponential fog
 equations. Only nonnegative densities are accepted. The initial
 fog density is 1.

 <li><code>GL_FOG_START</code></li>

 <p><code>params</code> contains a single value that specifies start,
 the near distance used in the linear fog equation. The initial
 near distance is 0.

 <li><code>GL_FOG_END</code></li>

 <p><code>params</code> contains a single value that specifies end,
 the far distance used in the linear fog equation. The initial far
 distance is 1.

 <li><code>GL_FOG_COLOR</code></li>

 <p><code>params</code> contains four values that specify
 <i>Cf</i>, the fog color. Both fixed-point and floating-point
 values are mapped directly. After conversion, all color
 components are clamped to the range <code>[0, 1]</code>. The
 initial fog color is <code>(0, 0, 0, 0)</code>.

 </ul>

 <p>Fog blends a fog color with each rasterized pixel fragment's
 posttexturing color using a blending factor f. Factor f is computed in
 one of three ways, depending on the fog mode. Let z be the distance in
 eye coordinates from the origin to the fragment being fogged. The
 equation for <code>GL_LINEAR</code> fog is

 <pre>
 f = (end - z)/(end - start)
 </pre>

 <p>The equation for <code>GL_EXP</code> fog is

 <pre>
 f = e -(density - z)
 </pre>

 <p>The equation for <code>GL_EXP2</code> fog is

 <pre>
 f = e -(density - z)2
 </pre>

 <p>Regardless of the fog mode, <i>f</i> is clamped to the range
 <code>[0, 1]</code> after it is computed. Then, the fragment's
 red, green, and blue colors, represented by <i>Cr</i>, are
 replaced by:

 <pre>
 C'r = f Cr + (1 - f) Cf
 </pre>

 <p>Fog does not affect a fragment's alpha component.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if
 <code>pname</code> is not an accepted value, or if
 <code>pname</code> is <code>GL_FOG_MODE</code> and
 <code>params</code> is not an accepted value.

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>pname</code> is <code>GL_FOG_DENSITY</code>, and the first
 value in <code>params</code> is negative.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pname</CODE> - Specifies a fog parameter. <code>GL_FOG_MODE</code>,
 <code>GL_FOG_DENSITY</code>, <code>GL_FOG_START</code>,
 <code>GL_FOG_END</code>, and <code>GL_FOG_COLOR</code> are
 accepted.<DD><CODE>params</CODE> - Specifies the value or values to be assigned to
 <code>pname</code>. <code>GL_FOG_COLOR</code> requires an array
 of four values. All other parameters accept an array containing
 only a single value.<DD><CODE>offset</CODE> - the starting offset within the
 <code>params</code> array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params.length -
 offset</code> is smaller than the number of values required by
 the parameter.</DL>
</DD>
</DL>
<HR>

<A NAME="glFogfv(int, java.nio.FloatBuffer)"><!-- --></A><H3>
glFogfv</H3>
<PRE>
public void <B>glFogfv</B>(int&nbsp;pname,
                    <A HREF="../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Floating-point <code>Buffer</code> version of <code>glFog</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if
 <code>params.remaining()</code> is smaller than the number of
 values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFogfv(int, float[], int)"><CODE>glFogfv(int pname, float[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glFogx(int, int)"><!-- --></A><H3>
glFogx</H3>
<PRE>
public void <B>glFogx</B>(int&nbsp;pname,
                   int&nbsp;param)</PRE>
<DL>
<DD>Fixed-point version of <code>glFog</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFogf(int, float)"><CODE>glFogf(int pname, float param)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glFogxv(int, int[], int)"><!-- --></A><H3>
glFogxv</H3>
<PRE>
public void <B>glFogxv</B>(int&nbsp;pname,
                    int[]&nbsp;params,
                    int&nbsp;offset)</PRE>
<DL>
<DD>Fixed-point array version of <code>glFog</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params.length -
 offset</code> is smaller than the number of values required by
 the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFogfv(int, float[], int)"><CODE>glFogfv(int pname, float[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glFogxv(int, java.nio.IntBuffer)"><!-- --></A><H3>
glFogxv</H3>
<PRE>
public void <B>glFogxv</B>(int&nbsp;pname,
                    <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Fixed-point <code>Buffer</code> version of <code>glFog</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if
 <code>params.remaining()</code> is smaller than the number of
 values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFogfv(int, float[], int)"><CODE>glFogfv(int pname, float[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glFrontFace(int)"><!-- --></A><H3>
glFrontFace</H3>
<PRE>
public void <B>glFrontFace</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Define front- and back-facing polygons.

 <p>In a scene composed entirely of opaque closed surfaces,
 back-facing polygons are never visible. Eliminating (culling)
 these invisible polygons has the obvious benefit of speeding up
 the rendering of the image. To enable and disable culling, call
 <code>glEnable</code> and <code>glDisable</code> with argument
 <code>GL_CULL_FACE</code>. Culling is initially disabled.

 <p>The projection of a polygon to window coordinates is said to
 have clockwise winding if an imaginary object following the path
 from its first vertex, its second vertex, and so on, to its last
 vertex, and finally back to its first vertex, moves in a
 clockwise direction about the interior of the polygon. The
 polygon's winding is said to be counterclockwise if the imaginary
 object following the same path moves in a counterclockwise
 direction about the interior of the polygon. glFrontFace
 specifies whether polygons with clockwise winding in window
 coordinates, or counterclockwise winding in window coordinates,
 are taken to be front-facing. Passing <code>GL_CCW</code> to
 <code>mode</code> selects counterclockwise polygons as
 front-facing. <code>GL_CW</code> selects clockwise polygons as
 front-facing. By default, counterclockwise polygons are taken to
 be front-facing.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if <code>mode</code>
 is not an accepted value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - Specifies the orientation of front-facing
 polygons. <code>GL_CW</code> and <code>GL_CCW</code> are
 accepted. The initial value is <code>GL_CCW</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glFrustumf(float, float, float, float, float, float)"><!-- --></A><H3>
glFrustumf</H3>
<PRE>
public void <B>glFrustumf</B>(float&nbsp;left,
                       float&nbsp;right,
                       float&nbsp;bottom,
                       float&nbsp;top,
                       float&nbsp;near,
                       float&nbsp;far)</PRE>
<DL>
<DD>Multiply the current matrix by a perspective matrix.

 <p><code>glFrustum</code> describes a perspective matrix that
 produces a perspective projection. The current matrix (see
 <code>glMatrixMode</code>) is multiplied by this matrix and the
 result replaces the current matrix, as if
 <code>glMultMatrix</code> were called with the following matrix
 as its argument:

 <pre>
 ( 2/(right - left)        0            A        0 )
 ( 0                2/(top - bottom)    B        0 )
 ( 0                       0            C        D )
 ( 0                       0           -1        0 )
 </pre>

 <p>where

 <pre>
 A = - (right + left)/(right - left)
 B = - (top + bottom)/(top - bottom)
 C = - (far + near)/(far - near)
 D = - 2farnear/(far - near)
 </pre>

 <p>Typically, the matrix mode is <code>GL_PROJECTION</code>, and
 (<code>left</code>, <code>bottom</code>, -<code>near</code>) and
 (<code>right</code>, <code>top</code>, -<code>near</code>)
 specify the points on the near clipping plane that are mapped to
 the lower left and upper right corners of the window, assuming
 that the eye is located at (0, 0, 0). -<code>far</code> specifies
 the location of the far clipping plane. Both <code>near</code>
 and <code>far</code> must be positive.

 <p>Use <code>glPushMatrix</code> and <code>glPopMatrix</code> to
 save and restore the current matrix stack.

 <h4>Notes</h4>

 <p>Depth buffer precision is affected by the values specified for
 near and far. The greater the ratio of <code>far</code> to
 <code>near</code> is, the less effective the depth buffer will be
 at distinguishing between surfaces that are near each other. If

 <pre>
 r = far/near
 </pre>

 roughly log_2(<i>r</i>) bits of depth buffer precision are
 lost. Because <i>r</i> approaches infinity as <code>near</code>
 approaches 0, <code>near</code> must never be set to 0.

 <h4>Errors</h4>

 <p><code>GL_INVALID_VALUE</code> is generated if
 <code>near</code> or <code>far</code> is not positive, or if
 <code>left</code> = <code>right</code>, or <code>bottom</code> =
 <code>top</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>left</CODE> - Specifies the coordinate for the left vertical
 clipping plane.<DD><CODE>right</CODE> - Specifies the coordinate for the right vertical
 clipping plane.<DD><CODE>bottom</CODE> - Specifies the coordinate for the bottom horizontal
 clipping plane.<DD><CODE>top</CODE> - Specifies the coordinate for the top horizontal
 clipping plane.<DD><CODE>near</CODE> - Specifies the distances to the near depth clipping
 plane. The distance must be positive.<DD><CODE>far</CODE> - Specifies the distances to the near depth clipping
 plane. The distance must be positive.</DL>
</DD>
</DL>
<HR>

<A NAME="glFrustumx(int, int, int, int, int, int)"><!-- --></A><H3>
glFrustumx</H3>
<PRE>
public void <B>glFrustumx</B>(int&nbsp;left,
                       int&nbsp;right,
                       int&nbsp;bottom,
                       int&nbsp;top,
                       int&nbsp;near,
                       int&nbsp;far)</PRE>
<DL>
<DD>Fixed-point version of <code>glFrustum</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glFrustumf(float, float, float, float, float, float)"><CODE>glFrustumf(float, float, float, float, float, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glGenTextures(int, int[], int)"><!-- --></A><H3>
glGenTextures</H3>
<PRE>
public void <B>glGenTextures</B>(int&nbsp;n,
                          int[]&nbsp;textures,
                          int&nbsp;offset)</PRE>
<DL>
<DD>Generate texture names.

 <p><code>glGenTextures</code> returns <code>n</code> texture
 names in <code>textures</code>. There is no guarantee that the
 names form a contiguous set of integers. However, it is
 guaranteed that none of the returned names was in use immediately
 before the call to <code>glGenTextures</code>.

 <p>The generated textures have no dimensionality; they assume the
 dimensionality of the texture target to which they are first
 bound (see glBindTexture).

 <p>Texture names returned by a call to <code>glGenTextures</code> are not
 returned by subsequent calls, unless they are first deleted with
 <code>glDeleteTextures</code>.

 <h4>Errors</h4>

 <p><code>GL_INVALID_VALUE</code> is generated if <code>n</code>
 is negative.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of texture names to be generated.<DD><CODE>textures</CODE> - Specifies an array in which the generated texture
 names are stored.<DD><CODE>offset</CODE> - the starting offset within the
 <code>textures</code> array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>textures</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>textures.length -
 offset</code> is less than <code>n</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glGenTextures(int, java.nio.IntBuffer)"><!-- --></A><H3>
glGenTextures</H3>
<PRE>
public void <B>glGenTextures</B>(int&nbsp;n,
                          <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;textures)</PRE>
<DL>
<DD>Integer <code>Buffer</code> version of <code>glGenTextures</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>textures</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if
 <code>textures.remaining()</code> is less than <code>n</code>.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glGenTextures(int, int[], int)"><CODE>glGenTextures(int n, int[] textures, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glGetError()"><!-- --></A><H3>
glGetError</H3>
<PRE>
public int <B>glGetError</B>()</PRE>
<DL>
<DD>Return error information.

 <p><code>glGetError</code> returns the value of the error
 flag. Each detectable error is assigned a numeric code and
 symbolic name. When an error occurs, the error flag is set to the
 appropriate error code value. No other errors are recorded until
 <code>glGetError</code> is called, the error code is returned,
 and the flag is reset to <code>GL_NO_ERROR</code>. If a call to
 <code>glGetError</code> returns <code>GL_NO_ERROR</code>, there
 has been no detectable error since the last call to
 <code>glGetError</code>, or since the GL was initialized.

 <p>To allow for distributed implementations, there may be several
 error flags. If any single error flag has recorded an error, the
 value of that flag is returned and that flag is reset to
 <code>GL_NO_ERROR</code> when <code>glGetError</code> is
 called. If more than one flag has recorded an error,
 <code>glGetError</code> returns and clears an arbitrary error
 flag value. Thus, <code>glGetError</code> should always be called
 in a loop, until it returns <code>GL_NO_ERROR</code>, if all
 error flags are to be reset.

 <p>Initially, all error flags are set to <code>GL_NO_ERROR</code>.

 <p>The following errors are currently defined:

 <ul>

 <li><code>GL_NO_ERROR</code></li>

 <p>No error has been recorded. The value of this symbolic constant
 is guaranteed to be 0.

 <li><code>GL_INVALID_ENUM</code></li>

 <p>An unacceptable value is specified for an enumerated
 argument. The offending command is ignored, and has no other side
 effect than to set the error flag.

 <li><code>GL_INVALID_VALUE</code></li>

 <p>A numeric argument is out of range. The offending command is
 ignored, and has no other side effect than to set the error flag.

 <li><code>GL_INVALID_OPERATION</code></li>

 <p>The specified operation is not allowed in the current state. The
 offending command is ignored, and has no other side effect than
 to set the error flag.

 <li><code>GL_STACK_OVERFLOW</code></li>

 <p>This command would cause a stack overflow. The offending command
 is ignored, and has no other side effect than to set the error
 flag.

 <li><code>GL_STACK_UNDERFLOW</code></li>

 <p>This command would cause a stack underflow. The offending command
 is ignored, and has no other side effect than to set the error
 flag.

 <li><code>GL_OUT_OF_MEMORY</code></li>

 <p>There is not enough memory left to execute the command. The state
 of the GL is undefined, except for the state of the error flags,
 after this error is recorded.

 </ul>

 <p>When an error flag is set, results of a GL operation are
 undefined only if <code>GL_OUT_OF_MEMORY</code> has occurred. In
 all other cases, the command generating the error is ignored and
 has no effect on the GL state or frame buffer contents. If the
 generating command returns a value, it returns 0. If
 <code>glGetError</code> itself generates an error, it returns 0.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>One of the error codes listed above.</DL>
</DD>
</DL>
<HR>

<A NAME="glGetIntegerv(int, int[], int)"><!-- --></A><H3>
glGetIntegerv</H3>
<PRE>
public void <B>glGetIntegerv</B>(int&nbsp;pname,
                          int[]&nbsp;params,
                          int&nbsp;offset)</PRE>
<DL>
<DD>Return the value or values of a selected parameter.

 <p><code>glGet</code> returns values for static state
 variables in GL. <code>pname</code> is a symbolic constant
 indicating the static state variable to be returned, and
 <code>params</code> is an array of integers in which to place the
 returned data.

 <p> A boolean value is interpreted as either 1 or 0, and a
 floating-point value is rounded to the nearest integer, unless
 the value is an RGBA color component, a <code>DepthRange</code>
 value, a depth buffer clear value, or a normal coordinate. In
 these cases, the <code>glGet</code> command does a linear mapping
 that maps 1.0 to the most positive representable integer value,
 and -1.0 to the most negative representable integer value.

 <p> In OpenGL ES 1.0, on <code>glGetIntegerv</code> is provided.
 OpenGL ES 1.1 additionally provides <code>glGetBooleanv</code>,
 <code>glGetFixedv</code>, and <code>glGetFloatv</code>.

 <p>The following symbolic constants are accepted by
 <code>pname</code>:

 <ul>
 <li><code>GL_ALIASED_POINT_SIZE_RANGE</code></li>

 <p><code>params</code> returns two values, the smallest and largest
 supported sizes for aliased points. The range must include 1. See
 <code>glPointSize</code>.

 <li><code>GL_ALIASED_LINE_WIDTH_RANGE</code></li>

 <p><code>params</code> returns two values, the smallest and largest
 supported widths for aliased lines. The range must include 1. See
 <code>glLineWidth</code>.

 <li><code>GL_ALPHA_BITS</code></li>

 <p><code>params</code> returns one value, the number of alpha
 bitplanes in the color buffer.

 <li><code>GL_ALPHA_TEST_FUNC</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the symbolic name of
 the alpha test function. See <code>glAlphaFunc</code>.

 <li><code>GL_ALPHA_TEST_REF</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the reference value for
 the alpha test. An integer value, if requested, is linearly
 mapped from the internal floating-point representation such that
 1.0 returns the most positive representable integer value, and
 -1.0 returns the most negative representable integer value. See
 <code>glAlphaFunc</code>.

 <li><code>GL_BLEND_DST</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the symbolic constant
 identifying the destination blend function set by
 <code>glBlendFunc</code>, or the destination RGB blend function
 set by <code>glBlendFuncSeparate</code>. See
 <code>glBlendFunc</code> and <code>glBlendFuncSeparate</code>.

 <li><code>GL_BLUE_BITS</code></li>

 <p><code>params</code> returns one value, the number of blue
 bitplanes in the color buffer.

 <li><code>GL_COLOR_ARRAY_BUFFER_BINDING</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the color array buffer
 binding. See <code>glColorPointer</code>.

 <li><code>GL_COLOR_ARRAY_SIZE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the number of
 components per color in the color array. See
 <code>glColorPointer</code>.

 <li><code>GL_COLOR_ARRAY_STRIDE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the byte offset between
 consecutive colors in the color array. See
 <code>glColorPointer</code>.

 <li><code>GL_COLOR_ARRAY_TYPE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, returns the data type
 of each component in the color array. See
 <code>glColorPointer</code>.

 <li><code>GL_COLOR_CLEAR_VALUE</code> (1.1 only)</li>

 <p><code>params</code> returns four values: the red, green, blue,
 and alpha values used to clear the color buffers. See
 <code>glClearColor</code>

 <li><code>GL_COLOR_WRITEMASK</code> (1.1 only)</li>

 <p><code>params</code> returns four boolean values: the red,
 green, blue, and alpha write enables for the color buffers. See
 <code>glColorMask</code>.

 <li><code>GL_COMPRESSED_TEXTURE_FORMATS</code></li>

 <p><code>params</code> returns
 <code>GL_NUM_COMPRESSED_TEXTURE_FORMATS</code> values, the
 supported compressed texture formats. See glCompressedTexImage2D
 and <code>glCompressedTexSubImage2D</code>.

 <li><code>GL_CULL_FACE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, a symbolic constant
 indicating which polygon faces are to be culled. See
 <code>glCullFace</code>.

 <li><code>GL_DEPTH_BITS</code></li>

 <p><code>params</code> returns one value, the number of bitplanes in
 the depth buffer.

 <li><code>GL_DEPTH_CLEAR_VALUE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the value that is used
 to clear the depth buffer. See <code>glClearDepth</code>.

 <li><code>GL_DEPTH_FUNC</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the symbolic name of
 the depth comparision function. See <code>glDepthFunc</code>.

 <li><code>GL_DEPTH_RANGE</code> (1.1 only)</li>

 <p><code>params</code> returns two values: the near and far
 mapping limits for the depth buffer. See
 <code>glDepthRange</code>.

 <li><code>GL_DEPTH_WRITEMASK</code> (1.1 only)</li>

 <p><code>params</code> returns a single boolean value indicating
 if the depth buffer is enabled for writing. See
 <code>glDepthMask</code>.

 <li><code>GL_FOG_COLOR</code> (1.1 only)</li>

 <p><code>params</code> returns four values: the red, green, blue,
 and alpha components of the fog color. See <code>glFog</code>.

 <li><code>GL_FOG_DENSITY</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the fog density
 parameter. See <code>glFog</code>.

 <li><code>GL_FOG_END</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the end factor for the
 linear fog equation. See <code>glFog</code>.

 <li><code>GL_FOG_HINT</code> (1.1 only)</li>

 <p><code>params</code> returns one value, a symbolic constant
 indicating the mode of the fog hint. See <code>glHint</code>.

 <li><code>GL_FOG_MODE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, a symbolic constant
 indicating which fog equation is selected. See <code>glFog</code>.

 <li><code>GL_FOG_START</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the start factor for
 the linear fog equation. See <code>glFog</code>.

 <li><code>GL_FRONT_FACE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, a symbolic constant
 indicating whether clockwise or counterclockwise polygon winding
 is treated as front-facing. See <code>glFrontFace</code>.

 <li><code>GL_GREEN_BITS</code></li>

 <p><code>params</code> returns one value, the number of green
 bitplanes in the color buffer.

 <li><code>GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES</code>
 (<code>OES_read_format</code> extension)</li>

 <p><code>params</code> returns one value, the preferred format for
 pixel read back. See <code>glReadPixels</code>.

 <li><code>GL_IMPLEMENTATION_COLOR_READ_TYPE_OES</code> (
 (<code>OES_read_format</code> extension)</li>

 <p><code>params</code> returns one value, the preferred type for
 pixel read back. See <code>glReadPixels</code>.

 <li><code>GL_LIGHT_MODEL_AMBIENT</code> (1.1 only)</li>
 
 <p><code>params</code> returns four values: the red, green, blue,
 and alpha components of the ambient intensity of the entire
 scene. See <code>glLightModel</code>.
 
 <li><code>GL_LIGHT_MODEL_TWO_SIDE</code> (1.1 only)</li>
 
 <p><code>params</code> returns a single boolean value indicating
 whether separate materials are used to compute lighting for front
 and back facing polygons. See <code>glLightModel</code>.
 
 <li><code>GL_LINE_SMOOTH_HINT</code> (1.1 only)</li>
 
 <p><code>params</code> returns one value, a symbolic constant
 indicating the mode of the line antialiasing hint. See
 <code>glHint</code>.
 
 <li><code>GL_LINE_WIDTH</code> (1.1 only)</li>
 
 <p><code>params</code> returns one value, the line width as
 specified with <code>glLineWidth</code>.
 
 <li><code>GL_LOGIC_OP_MODE</code> (1.1 only)</li>
 
 <p><code>params</code> returns one value, a symbolic constant
 indicating the selected logic operation mode. See
 <code>glLogicOp</code>.
 
 <li><code>GL_MATRIX_INDEX_ARRAY_BUFFER_BINDING_OES</code>
 (<code>OES_matrix_palette</code> extension)</li>
 
 <p><code>params</code> returns one value, the matrix index array
 buffer binding. See <code>glMatrixIndexPointer</code>.
 
 <li><code>GL_MATRIX_INDEX_ARRAY_SIZE_OES</code>
 (<code>OES_matrix_palette</code> extension)</li>
 
 <p><code>params</code> returns one value, the number of matrix
 indices per vertex. See <code>glMatrixIndexPointer</code>.
 
 <li><code>GL_MATRIX_INDEX_ARRAY_STRIDE_OES</code>
 (<code>OES_matrix_palette</code> extension)</li>
 
 <p><code>params</code> returns one value, the byte offset between
 matrix indices. See <code>glMatrixIndexPointer</code>.
 
 <li><code>GL_MATRIX_INDEX_ARRAY_TYPE_OES</code>
 (<code>OES_matrix_palette</code> extension)</li>
 
 <p><code>params</code> returns one value, the data type of each
 matrix index in the matrix indices array. See
 <code>glMatrixIndexPointer</code>.
 
 <li><code>GL_MATRIX_MODE</code> (1.1 only)</li>
 
 <p><code>params</code> returns one value, a symbolic constant
 indicating which matrix stack is currently the target of all
 matrix operations. See <code>glMatrixMode</code>.
 
 <li><code>GL_MAX_CLIP_PLANES</code> (1.1 only)</li>
 
 <p><code>params</code> returns one value, the maximum number of
 application defined clipping planes. The value must be at least
 6. See <code>glClipPlane</code>.
 
 <li><code>GL_MAX_ELEMENTS_INDICES</code></li>

 <p><code>params</code> returns one value, the recommended maximum
 number of vertex array indices. See <code>glDrawElements</code>.

 <li><code>GL_MAX_ELEMENTS_VERTICES</code></li>

 <p><code>params</code> returns one value, the recommended maximum
 number of vertex array vertices. See <code>glDrawArrays</code>
 and <code>glDrawElements</code>.

 <li><code>GL_MAX_LIGHTS</code></li>

 <p><code>params</code> returns one value, the maximum number of
 lights. The value must be at least 8. See <code>glLight</code>.

 <li><code>GL_MAX_MODELVIEW_STACK_DEPTH</code></li>

 <p><code>params</code> returns one value, the maximum supported
 depth of the modelview matrix stack. The value must be at least
 16. See <code>glPushMatrix</code>.

 <li><code>GL_MAX_PALETTE_MATRICES_OES</code>
 (<code>OES_matrix_palette</code> extension)</li>

 <p><code>params</code> returns the size of the matrix
 palette. The initial value is 9.

 <li><code>GL_MAX_PROJECTION_STACK_DEPTH</code></li>

 <p><code>params</code> returns one value, the maximum supported
 depth of the projection matrix stack. The value must be at least
 2. See <code>glPushMatrix</code>.

 <li><code>GL_MAX_TEXTURE_SIZE</code></li>

 <p><code>params</code> returns one value. The value gives a rough
 estimate of the largest texture that the GL can handle. The value
 must be at least 64. See <code>glTexImage2D</code>,
 <code>glCompressedTexImage2D</code>, and
 <code>glCopyTexImage2D</code>.

 <li><code>GL_MAX_TEXTURE_STACK_DEPTH</code></li>

 <p><code>params</code> returns one value, the maximum supported
 depth of the texture matrix stack. The value must be at least
 2. See <code>glPushMatrix</code>.

 <li><code>GL_MAX_TEXTURE_UNITS</code></li>

 <p><code>params</code> returns a single value indicating the number
 of texture units supported. The value must be at least 1. See
 <code>glActiveTexture</code>, <code>glClientActiveTexture</code>
 and <code>glMultiTexCoord</code>.

 <li><code>GL_MAX_VERTEX_UNITS_OES</code>

 <p><code>params</code> returns the number of matrices per
 vertex. The initial value is 3.

 <li><code>GL_MAX_VIEWPORT_DIMS</code></li>

 <p><code>params</code> returns two values: the maximum supported
 width and height of the viewport. These must be at least as large
 as the visible dimensions of the display being rendered to. See
 <code>glViewport</code>.

 <li><code>GL_MODELVIEW_MATRIX</code> (1.1 only)</li>

 <p><code>params</code> returns sixteen values: the modelview
 matrix on the top of the modelview matrix stack. See
 <code>glPushMatrix</code>.

 <li><code>GL_MODELVIEW_MATRIX_FLOAT_AS_INT_BITS_OES</code>
 (<code>OES_matrix_get</code> extension)</li>

 <p><code>params</code> returns a representation of the floating
 point Model View matrix elements as as an array of integers,
 according to the IEEE 754 floating point "single format" bit
 layout. See <code>glMatrixMode</code>.

 <li><code>GL_MODELVIEW_STACK_DEPTH</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the number of matrices
 on the modelview matrix stack. See <code>glPushMatrix</code>.

 <li><code>GL_NORMAL_ARRAY_BUFFER_BINDING</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the normal array buffer
 binding. See <code>glNormalPointer</code>.

 <li><code>GL_NORMAL_ARRAY_STRIDE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the byte offset between
 consective normals in the normal array. See
 <code>glNormalPointer</code>.

 <li><code>GL_NORMAL_ARRAY_TYPE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the data type of each
 normal in the normal array. See <code>glNormalPointer</code>.

 <li><code>GL_NUM_COMPRESSED_TEXTURE_FORMATS</code></li>

 <p><code>params</code> returns one value, the number of supported
 compressed texture formats. The value must be at least 10. See
 <code>glCompressedTexImage2D</code> and
 <code>glCompressedTexSubImage2D</code>.

 <li><code>GL_PACK_ALIGNMENT</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the byte alignment used
 for writing pixel data to memory. See <code>glPixelStore</code>.

 <li><code>GL_PERSPECTIVE_CORRECTION_HINT</code> (1.1 only)</li>

 <p><code>params</code> returns one value, a symbolic constant
 indicating the mode of the perspective correction hint. See
 <code>glHint</code>.

 <li><code>GL_POINT_SIZE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the point size as
 specified by <code>glPointSize</code>.

 <li><code>GL_POINT_SIZE_ARRAY_BUFFER_BINDING_OES</code>
 (<code>OES_point_size_array</code> extension)</li>

 <p><code>params</code> returns one value, the point size array
 buffer binding. See <code>glPointSizePointer</code>.

 <li><code>GL_POINT_SIZE_ARRAY_STRIDE_OES</code>
 (<code>OES_point_size_array</code> extension)</li>

 <p><code>params</code> returns one value, the byte offset between
 consecutive point sizes in the point size array. See
 <code>glPointSizePointer</code>.

 <li><code>GL_POINT_SIZE_ARRAY_TYPE_OES</code>
 (<code>OES_point_size_array</code> extension)</li>

 <p><code>params</code> returns one value, the data type of each
 point size in the point array. See
 <code>glPointSizePointer</code>.

 <li><code>GL_POINT_SMOOTH_HINT</code> (1.1 only)</li>

 <p><code>params</code> returns one value, a symbolic constant
 indicating the mode of the point antialiasing hint. See
 <code>glHint</code>.

 <li><code>GL_POLYGON_OFFSET_FACTOR</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the scaling factor used
 to determine the variable offset that is added to the depth value
 of each fragment generated when a polygon is rasterized. See
 <code>glPolygonOffset</code>.

 <li><code>GL_POLYGON_OFFSET_UNITS</code> (1.1 only)</li>

 <p><code>params</code> returns one value. This value is
 multiplied by an implementation-specific value and then added to
 the depth value of each fragment generated when a polygon is
 rasterized. See <code>glPolygonOffset</code>.

 <li><code>GL_PROJECTION_MATRIX</code> (1.1 only)</li>

 <p><code>params</code> returns sixteen values: the projection
 matrix on the top of the projection matrix stack. See
 <code>glPushMatrix</code>.

 <li><code>GL_PROJECTION_MATRIX_FLOAT_AS_INT_BITS_OES</code>
 (<code>OES_matrix_get</code> extension)</li>

 <p><code>params</code> returns a representation of the floating
 point Projection matrix elements as as an array of integers,
 according to the IEEE 754 floating point "single format" bit
 layout. See <code>glMatrixMode</code>.

 <li><code>GL_PROJECTION_STACK_DEPTH</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the number of matrices
 on the projection matrix stack. See <code>glPushMatrix</code>.

 <li><code>GL_RED_BITS</code></li>

 <p><code>params</code> returns one value, the number of red
 bitplanes in each color buffer.

 <li><code>GL_SCISSOR_BOX</code> (1.1 only)</li>

 <p><code>params</code> returns four values: the x and y window
 coordinates of the scissor box, followed by its width and
 height. See <code>glScissor</code>.

 <li><code>GL_SHADE_MODEL</code> (1.1 only)</li>

 <p><code>params</code> returns one value, a symbolic constant
 indicating whether the shading mode is flat or smooth. See
 <code>glShadeModel</code>.

 <li><code>GL_SMOOTH_LINE_WIDTH_RANGE</code></li>

 <p><code>params</code> returns two values, the smallest and largest
 supported widths for antialiased lines. The range must include
 1. See <code>glLineWidth</code>.

 <li><code>GL_SMOOTH_POINT_SIZE_RANGE</code></li>

 <p><code>params</code> returns two values, the smallest and largest
 supported widths for antialiased points. The range must include
 1. See <code>glPointSize</code>.

 <li><code>GL_STENCIL_BITS</code></li>

 <p><code>params</code> returns one value, the number of bitplanes in
 the stencil buffer.

 <li><code>GL_STENCIL_CLEAR_VALUE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the index to which the
 stencil bitplanes are cleared. See <code>glClearStencil</code>.

 <li><code>GL_STENCIL_FAIL</code> (1.1 only)</li>

 <p><code>params</code> returns one value, a symbolic constant
 indicating what action is taken when the stencil test fails. See
 <code>glStencilOp</code>.

 <li><code>GL_STENCIL_FUNC</code> (1.1 only)</li>

 <p><code>params</code> returns one value, a symbolic constant
 indicating what function is used to compare the stencil reference
 value with the stencil buffer value. See
 <code>glStencilFunc</code>.

 <li><code>GL_STENCIL_PASS_DEPTH_FAIL</code> (1.1 only)</li>

 <p><code>params</code> returns one value, a symbolic constant
 indicating what action is taken when the stencil test passes, but
 the depth test fails. See <code>glStencilOp</code>.

 <li><code>GL_STENCIL_PASS_DEPTH_PASS</code> (1.1 only)</li>

 <p><code>params</code> returns one value, a symbolic constant
 indicating what action is taken when the stencil test passes, and
 the depth test passes. See <code>glStencilOp</code>.

 <li><code>GL_STENCIL_REF</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the reference value
 that is compared with the contents of the stencil buffer. See
 <code>glStencilFunc</code>.

 <li><code>GL_STENCIL_VALUE_MASK</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the mask that is used
 to mask both the stencil reference value and the stencil buffer
 value before they are compared. See <code>glStencilFunc</code>.

 <li><code>GL_STENCIL_WRITEMASK</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the mask that controls
 writing of the stencil bitplanes. See <code>glStencilMask</code>.

 <li><code>GL_SUBPIXEL_BITS</code></li>

 <p><code>params</code> returns one value, an estimate of the number
 of bits of subpixel resolution that are used to position
 rasterized geometry in window coordinates. The value must be at
 least 4.

 <li><code>GL_TEXTURE_BINDING_2D</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the name of the texture
 currently bound to the target <code>GL_TEXTURE_2D</code>. See
 <code>glBindTexture</code>.

 <li><code>GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the texture coordinate
 array buffer binding. See <code>glTexCoordPointer</code>.

 <li><code>GL_TEXTURE_COORD_ARRAY_SIZE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the number of
 coordinates per element in the texture coordinate array. See
 <code>glTexCoordPointer</code>.

 <li><code>GL_TEXTURE_COORD_ARRAY_STRIDE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the byte offset between
 consecutive elements in the texture coordinate array. See
 <code>glTexCoordPointer</code>.

 <li><code>GL_TEXTURE_COORD_ARRAY_TYPE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, returns the data type
 of each coordinate in the texture coordinate array. See
 <code>glTexCoordPointer</code>.

 <li><code>GL_TEXTURE_MATRIX</code> (1.1 only)</li>

 <p><code>params</code> returns sixteen values: the texture matrix
 on the top of the texture matrix stack. See
 <code>glPushMatrix</code>.

 <li><code>GL_TEXTURE_MATRIX_FLOAT_AS_INT_BITS_OES</code>
 (<code>OES_matrix_get</code> extension)</li>

 <p><code>params</code> returns a representation of the floating
 point Texture matrix elements as as an array of integers,
 according to the IEEE 754 floating point "single format" bit
 layout. See <code>glMatrixMode</code>.

 <li><code>GL_TEXTURE_STACK_DEPTH</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the number of matrices
 on the texture matrix stack. See <code>glBindTexture</code>.

 <li><code>GL_UNPACK_ALIGNMENT</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the byte alignment used
 for reading pixel data from memory. See
 <code>glPixelStore</code>.

 <li><code>GL_VIEWPORT</code> (1.1 only)</li>

 <p><code>params</code> returns four values:, the x and y window
 coordinates of the viewport, followed by its width and
 height. See <code>glViewport</code>.

 <li><code>GL_VERTEX_ARRAY_BUFFER_BINDING</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the vertex array buffer
 binding. See <code>glVertexPointer</code>.

 <li><code>GL_VERTEX_ARRAY_SIZE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, number of coordinates
 per vertex in the vertex array. See <code>glVertexPointer</code>.

 <li><code>GL_VERTEX_ARRAY_STRIDE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, the byte offset between
 consecutive vertexes in the vertex array. See
 <code>glVertexPointer</code>.

 <li><code>GL_VERTEX_ARRAY_TYPE</code> (1.1 only)</li>

 <p><code>params</code> returns one value, returns the data type
 of each coordinate in the vertex array. See
 <code>glVertexPointer</code>.

 <li><code>GL_WEIGHT_ARRAY_BUFFER_BINDING_OES</code>
 (<code>OES_matrix_palette</code> extension)</li>

 <p><code>params</code> returns one value, the weight array buffer
 binding. See <code>glWeightPointer</code>.

 <li><code>GL_WEIGHT_ARRAY_SIZE_OES</code>
 (<code>OES_matrix_palette</code> extension)</li>

 <p><code>params</code> returns one value, the number of weights
 per vertex. See <code>glWeightPointer</code>.

 <li><code>GL_WEIGHT_ARRAY_STRIDE_OES</code>
 (<code>OES_matrix_palette</code> extension)</li>

 <p><code>params</code> returns one value, the byte offset between
 weights per vertex. See <code>glWeightPointer</code>.

 <li><code>GL_WEIGHT_ARRAY_TYPE_OES</code>
 (<code>OES_matrix_palette</code> extension)</li>

 <p><code>params</code> returns one value, the data type of each
 weight in the weight array. See <code>glWeightPointer</code>.

 </ul>

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if <code>pname</code>
 is not an accepted value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pname</CODE> - Specifies the parameter value to be returned. The
 symbolic constants in the list above are accepted.<DD><CODE>params</CODE> - Returns the value or values of the specified
 parameter.<DD><CODE>offset</CODE> - the starting offset within the
 <code>params</code> array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params.length -
 offset</code> is smaller than the number of values required by
 the parameter.</DL>
</DD>
</DL>
<HR>

<A NAME="glGetIntegerv(int, java.nio.IntBuffer)"><!-- --></A><H3>
glGetIntegerv</H3>
<PRE>
public void <B>glGetIntegerv</B>(int&nbsp;pname,
                          <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Integer <code>Buffer</code> version of <code>glGetIntegerv</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if
 <code>params.remaining()</code> is smaller than the number of
 values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv(int pname, int[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glGetString(int)"><!-- --></A><H3>
glGetString</H3>
<PRE>
public java.lang.String <B>glGetString</B>(int&nbsp;name)</PRE>
<DL>
<DD>Return a string describing the underlying GL implementation. The
 GL string is converted to UTF8 format to produce a standard Java
 <code>String</code> object.

 <p><code>glGetString</code> returns a <code>String</code>
 describing some aspect of the current GL
 implementation. <code>name</code> can be one of the following:

 <ul>

 <li><code>GL_VENDOR</code></li>

 <p>Returns the company responsible for this GL implementation. This
 name does not change from release to release.

 <li><code>GL_RENDERER</code></li>

 <p>Returns the name of the renderer. This name is typically specific
 to a particular configuration of a hardware platform. It does not
 change from release to release.

 <li><code>GL_VERSION</code></li>

 <p>Returns the particular OpenGL ES profile as well as the
 version of that profile.

 <li><code>GL_EXTENSIONS</code></li>

 <p>Returns a space-separated list of supported extensions to GL.

 </ul>

 <p>Because the GL does not include queries for the performance
 characteristics of an implementation, some applications are
 written to recognize known platforms and modify their GL usage
 based on known performance characteristics of these
 platforms. Strings <code>GL_VENDOR</code> and
 <code>GL_RENDERER</code> together uniquely specify a
 platform. They do not change from release to release and should
 be used by platform-recognition algorithms.

 <p>Some applications want to make use of features that are not part
 of the standard GL. These features may be implemented as
 extensions to the standard GL. The <code>GL_EXTENSIONS</code>
 string is a space-separated list of supported GL
 extensions. (Extension names never contain a space character.)

 <p>The <code>GL_VERSION</code> string begins with a version
 number. The version number uses one of these forms:

 <p><i>major_number.minor_number</i> (1.0 only)
 <p><i>major_number.minor_number.release_number</i> (1.0 only)
 <p><i>OpenGL ES-CM</i> followed by
 <i>major_number.minor_number</i> for the common profile (1.1 only).
 <p><i>OpenGL ES-CL</i> followed by <i>major_number.minor_number</i> for
 the common-lite profile (1.1 only).

 <p>On 1.0 implementations, vendor-specific information may
 follow the version number. A space always separates the version
 number and the vendor-specific information.

 <h4>Notes</h4>

 <p>If an error is generated, <code>glGetString</code> returns NULL.

 <p>The client and server may support different versions or
 extensions. <code>glGetString</code> always returns a compatible
 version number or list of extensions. The release number always
 describes the server.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if <code>name</code>
 is not an accepted value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - Specifies a symbolic constant, one of
 <code>GL_VENDOR</code>, <code>GL_RENDERER</code>,
 <code>GL_VERSION</code>, or <code>GL_EXTENSIONS</code>.
<DT><B>Returns:</B><DD>A <code>String</code> formatted as described above.</DL>
</DD>
</DL>
<HR>

<A NAME="glHint(int, int)"><!-- --></A><H3>
glHint</H3>
<PRE>
public void <B>glHint</B>(int&nbsp;target,
                   int&nbsp;mode)</PRE>
<DL>
<DD>Specify implementation-specific hints.

 <p>Certain aspects of GL behavior, when there is room for
 interpretation, can be controlled with hints. A hint is specified
 with two arguments. <code>target</code> is a symbolic constant
 indicating the behavior to be controlled, and <code>mode</code>
 is another symbolic constant indicating the desired behavior. The
 initial value for each <code>target</code> is
 <code>GL_DONT_CARE</code>. <code>mode</code> can be one of the
 following:

 <ul>

 <li><code>GL_FASTEST</code></li>

 <p>The most efficient option should be chosen.

 <li><code>GL_NICEST</code></li>

 <p>The most correct, or highest quality, option should be chosen.

 <li><code>GL_DONT_CARE</code></li>

 <p>No preference.

 </ul>

 <p>Though the implementation aspects that can be hinted are well
 defined, the interpretation of the hints depends on the
 implementation. The hint aspects that can be specified with
 <code>target</code>, along with suggested semantics, are as follows:

 <ul>

 <li><code>GL_FOG_HINT</code></li>

 <p>Indicates the accuracy of fog calculation. If per-pixel fog
 calculation is not efficiently supported by the GL
 implementation, hinting <code>GL_DONT_CARE</code> or
 <code>GL_FASTEST</code> can result in per-vertex calculation of
 fog effects.

 <li><code>GL_LINE_SMOOTH_HINT</code></li>

 <p>Indicates the sampling quality of antialiased lines. If a larger
 filter function is applied, hinting <code>GL_NICEST</code> can
 result in more pixel fragments being generated during
 rasterization,

 <li><code>GL_PERSPECTIVE_CORRECTION_HINT</code></li>

 <p>Indicates the quality of color and texture coordinate
 interpolation. If perspective-corrected parameter interpolation
 is not efficiently supported by the GL implementation, hinting
 <code>GL_DONT_CARE</code> or <code>GL_FASTEST</code> can result
 in simple linear interpolation of colors and/or texture
 coordinates.

 <li><code>GL_POINT_SMOOTH_HINT</code></li>

 <p>Indicates the sampling quality of antialiased points. If a larger
 filter function is applied, hinting <code>GL_NICEST</code> can
 result in more pixel fragments being generated during
 rasterization.

 <li><code>GL_GENERATE_MIPMAP_HINT</code> (1.1 only)</li>

 <p>Indicates the desired quality and performance of automatic
 mipmap level generation.

 </ul>
 
 <h4>Notes</h4>

 <p>The interpretation of hints depends on the implementation. Some
 implementations ignore <code>glHint</code> settings.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if either
 <code>target</code> or <code>mode</code> is not an accepted
 value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies a symbolic constant indicating the
 behavior to be controlled. <code>GL_FOG_HINT</code> ,
 <code>GL_LINE_SMOOTH_HINT</code> ,
 <code>GL_PERSPECTIVE_CORRECTION_HINT</code>, and
 <code>GL_POINT_SMOOTH_HINT</code> are accepted. On 1.1,
 <code>GL_GENERATE_MIPMAP_HINT</code> is additionally accepted.<DD><CODE>mode</CODE> - Specifies a symbolic constant indicating the desired
 behavior. <code>GL_FASTEST</code>, <code>GL_NICEST</code>, and
 <code>GL_DONT_CARE</code> are accepted.</DL>
</DD>
</DL>
<HR>

<A NAME="glLightModelf(int, float)"><!-- --></A><H3>
glLightModelf</H3>
<PRE>
public void <B>glLightModelf</B>(int&nbsp;pname,
                          float&nbsp;param)</PRE>
<DL>
<DD>Set the lighting model parameters.

 <p><code>glLightModel</code> sets the lighting model
 parameter. <code>pname</code> names a parameter and param gives
 the new value. There is one single-valued lighting model parameter:

 <ul>

 <li><code>GL_LIGHT_MODEL_TWO_SIDE</code></li>

 <p><code>param</code> specifies whether one- or two-sided lighting
 calculations are done for polygons. It has no effect on the
 lighting calculations for points, lines, or bitmaps. If
 <code>param</code> is 0, one-sided lighting is specified, and
 only the front material parameters are used in the lighting
 equation. Otherwise, two-sided lighting is specified. In this
 case, vertices of back-facing polygons are lighted using the back
 material parameters, and have their normals reversed before the
 lighting equation is evaluated. Vertices of front-facing polygons
 are always lighted using the front material parameters, with no
 change to their normals. The initial value is 0.

 </ul>

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if
 <code>pname</code> is not an accepted value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pname</CODE> - Specifies a single-valued lighting model
 parameter. Must be <code>GL_LIGHT_MODEL_TWO_SIDE</code>.<DD><CODE>param</CODE> - Specifies the value that <code>param</code> will be
 set to.</DL>
</DD>
</DL>
<HR>

<A NAME="glLightModelfv(int, float[], int)"><!-- --></A><H3>
glLightModelfv</H3>
<PRE>
public void <B>glLightModelfv</B>(int&nbsp;pname,
                           float[]&nbsp;params,
                           int&nbsp;offset)</PRE>
<DL>
<DD>Set the lighting model parameters (array version).

 <p><code>glLightModel</code> sets the lighting model
 parameter. <code>pname</code> names a parameter and
 <code>params</code> gives the new value. There are two lighting
 model parameters:

 <ul>

 <li><code>GL_LIGHT_MODEL_AMBIENT</code></li>

 <p><code>params</code> contains four values that specify the ambient
 intensity of the entire scene. The values are not clamped. The
 initial value is (0.2, 0.2, 0.2, 1.0).

 <li><code>GL_LIGHT_MODEL_TWO_SIDE</code></li>

 <p><code>params</code> contains a single value that specifies
 whether one- or two-sided lighting calculations are done for
 polygons. It has no effect on the lighting calculations for
 points, lines, or bitmaps. If <code>params</code> contains 0,
 one-sided lighting is specified, and only the front material
 parameters are used in the lighting equation. Otherwise,
 two-sided lighting is specified. In this case, vertices of
 back-facing polygons are lighted using the back material
 parameters, and have their normals reversed before the lighting
 equation is evaluated. Vertices of front-facing polygons are
 always lighted using the front material parameters, with no
 change to their normals. The initial value is 0.

 </ul>

 <p>The lighted color of a vertex is the sum of the material
 emission intensity, the product of the material ambient
 reflectance and the lighting model full-scene ambient intensity,
 and the contribution of each enabled light source. Each light
 source contributes the sum of three terms: ambient, diffuse, and
 specular. The ambient light source contribution is the product of
 the material ambient reflectance and the light's ambient
 intensity. The diffuse light source contribution is the product
 of the material diffuse reflectance, the light's diffuse
 intensity, and the dot product of the vertex's normal with the
 normalized vector from the vertex to the light source. The
 specular light source contribution is the product of the material
 specular reflectance, the light's specular intensity, and the dot
 product of the normalized vertex-to-eye and vertex-to-light
 vectors, raised to the power of the shininess of the
 material. All three light source contributions are attenuated
 equally based on the distance from the vertex to the light source
 and on light source direction, spread exponent, and spread cutoff
 angle. All dot products are replaced with 0 if they evaluate to a
 negative value.

 <p>The alpha component of the resulting lighted color is set to the
 alpha value of the material diffuse reflectance.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if
 <code>pname</code> is not an accepted value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pname</CODE> - Specifies a lighting model
 parameter. <code>GL_LIGHT_MODEL_AMBIENT</code> and
 <code>GL_LIGHT_MODEL_TWO_SIDE</code> are accepted.<DD><CODE>params</CODE> - Specifies an array containing values that parameter
 <code>pname</code> will be set to.<DD><CODE>offset</CODE> - the starting offset within the
 <code>params</code> array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params.length -
 offset</code> is smaller than the number of values required by
 the parameter.</DL>
</DD>
</DL>
<HR>

<A NAME="glLightModelfv(int, java.nio.FloatBuffer)"><!-- --></A><H3>
glLightModelfv</H3>
<PRE>
public void <B>glLightModelfv</B>(int&nbsp;pname,
                           <A HREF="../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Floating-point <code>Buffer</code> version of <code>glLightModel</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if
 <code>params.remaining()</code> is smaller than the number of
 values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightModelfv(int, float[], int)"><CODE>glLightModelfv(int pname, float[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glLightModelx(int, int)"><!-- --></A><H3>
glLightModelx</H3>
<PRE>
public void <B>glLightModelx</B>(int&nbsp;pname,
                          int&nbsp;param)</PRE>
<DL>
<DD>Fixed-point version of <code>glLightModel</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightModelf(int, float)"><CODE>glLightModelf(int pname, float param)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glLightModelxv(int, int[], int)"><!-- --></A><H3>
glLightModelxv</H3>
<PRE>
public void <B>glLightModelxv</B>(int&nbsp;pname,
                           int[]&nbsp;params,
                           int&nbsp;offset)</PRE>
<DL>
<DD>Fixed-point array version of <code>glLightModel</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params.length -
 offset</code> is smaller than the number of values required by
 the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightModelfv(int, float[], int)"><CODE>glLightModelfv(int pname, float[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glLightModelxv(int, java.nio.IntBuffer)"><!-- --></A><H3>
glLightModelxv</H3>
<PRE>
public void <B>glLightModelxv</B>(int&nbsp;pname,
                           <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Fixed-point <code>Buffer</code> version of <code>glLightModel</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if
 <code>params.remaining()</code> is smaller than the number of
 values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightModelfv(int, float[], int)"><CODE>glLightModelfv(int pname, float[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glLightf(int, int, float)"><!-- --></A><H3>
glLightf</H3>
<PRE>
public void <B>glLightf</B>(int&nbsp;light,
                     int&nbsp;pname,
                     float&nbsp;param)</PRE>
<DL>
<DD>Set light source parameters.

 <p><code>glLight</code> sets the values of individual light
 source parameters. <code>light</code> names the light and is a
 symbolic name of the form <code>GL_LIGHT</code><i>i</i>, where
 <code>0 <= <i>i</i> < GL_MAX_LIGHTS</code>. <code>pname</code>
 specifies one of ten light source parameters, again by symbolic
 name. <code>param</code> contains the new value.

 <p>To enable and disable lighting calculation, call
 <code>glEnable</code> and <code>glDisable</code> with argument
 <code>GL_LIGHTING</code>. Lighting is initially disabled. When it
 is enabled, light sources that are enabled contribute to the
 lighting calculation. Light source <i>i</i> is enabled and disabled
 using <code>glEnable</code> and <code>glDisable</code> with
 argument <code>GL_LIGHT</code><i>i</i>.

 <p>The light parameters are as follows:

 <ul>

 <li><code>GL_SPOT_EXPONENT</code></li>

 <p><code>param</code> is a single value that specifies the
 intensity distribution of the light. Fixed-point and
 floating-point values are mapped directly. Only values in the
 range [0, 128] are accepted.

 <p>Effective light intensity is attenuated by the cosine of the
 angle between the direction of the light and the direction from
 the light to the vertex being lighted, raised to the power of the
 spot exponent. Thus, higher spot exponents result in a more
 focused light source, regardless of the spot cutoff angle (see
 <code>GL_SPOT_CUTOFF</code>, next paragraph). The initial spot
 exponent is 0, resulting in uniform light distribution.

 <li><code>GL_SPOT_CUTOFF</code></li>

 <p><code>param</code> is a single value that specifies the maximum
 spread angle of a light source. Fixed-point and floating-point
 values are mapped directly. Only values in the range [0, 90] and
 the special value 180 are accepted. If the angle between the
 direction of the light and the direction from the light to the
 vertex being lighted is greater than the spot cutoff angle, the
 light is completely masked. Otherwise, its intensity is
 controlled by the spot exponent and the attenuation factors. The
 initial spot cutoff is 180, resulting in uniform light
 distribution.

 <li><code>GL_CONSTANT_ATTENUATION</code>,
 <code>GL_LINEAR_ATTENUATION</code>,
 <code>GL_QUADRATIC_ATTENUATION</code></li>

 <p><code>param</code> is a single value that specifies one of the
 three light attenuation factors. Fixed-point and floating-point
 values are mapped directly. Only nonnegative values are
 accepted. If the light is positional, rather than directional,
 its intensity is attenuated by the reciprocal of the sum of the
 constant factor, the linear factor times the distance between the
 light and the vertex being lighted, and the quadratic factor
 times the square of the same distance. The initial attenuation
 factors are (1, 0, 0), resulting in no attenuation.

 </ul>
 
 <h4>Notes</h4>

 <p>It is always the case that <code>GL_LIGHT</code><i>i</i> =
 <code>GL_LIGHT0</code> + <i>i</i>.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if either
 <code>light</code> or <code>pname</code> is not an accepted
 value.

 <p><code>GL_INVALID_VALUE</code> is generated if a spot exponent
 value is specified outside the range [0, 128], or if spot cutoff
 is specified outside the range [0, 90] (except for the special
 value 180), or if a negative attenuation factor is specified.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>light</CODE> - Specifies a light. The number of lights depends on
 the implementation, but at least eight lights are supported. They
 are identified by symbolic names of the form
 <code>GL_LIGHT</code><i>i</i> where <code>0 <= <i>i</i> <
 GL_MAX_LIGHTS</code>.<DD><CODE>pname</CODE> - Specifies a single-valued light source parameter for
 light. <code>GL_SPOT_EXPONENT</code>,
 <code>GL_SPOT_CUTOFF</code>,
 <code>GL_CONSTANT_ATTENUATION</code>,
 <code>GL_LINEAR_ATTENUATION</code>, and
 <code>GL_QUADRATIC_ATTENUATION</code> are accepted.<DD><CODE>param</CODE> - Specifies the value that parameter
 <code>pname</code> of light source light will be set to.</DL>
</DD>
</DL>
<HR>

<A NAME="glLightfv(int, int, float[], int)"><!-- --></A><H3>
glLightfv</H3>
<PRE>
public void <B>glLightfv</B>(int&nbsp;light,
                      int&nbsp;pname,
                      float[]&nbsp;params,
                      int&nbsp;offset)</PRE>
<DL>
<DD>Set light source parameters (array version).

 <p><code>glLight</code> sets the values of individual light
 source parameters. <code>light</code> names the light and is a
 symbolic name of the form <code>GL_LIGHT</code><i>i</i>, where
 <code>0 <= <i>i</i> < GL_MAX_LIGHTS</code>. <code>pname</code>
 specifies one of ten light source parameters, again by symbolic
 name. <code>params</code> is an array that contains the new
 values.

 <p>To enable and disable lighting calculation, call
 <code>glEnable</code> and <code>glDisable</code> with argument
 <code>GL_LIGHTING</code>. Lighting is initially disabled. When it
 is enabled, light sources that are enabled contribute to the
 lighting calculation. Light source <i>i</i> is enabled and disabled
 using <code>glEnable</code> and <code>glDisable</code> with
 argument <code>GL_LIGHT</code><i>i</i>.

 <p>The light parameters are as follows:

 <ul>

 <li><code>GL_AMBIENT</code></li>

 <p><code>params</code> contains four values that specify the ambient
 RGBA intensity of the light. Both fixed-point and floating-point
 values are mapped directly. Neither fixed-point nor
 floating-point values are clamped. The initial ambient light
 intensity is (0, 0, 0, 1).

 <li><code>GL_DIFFUSE</code></li>

 <p><code>params</code> contains four values that specify the diffuse
 RGBA intensity of the light. Both fixed-point and floating-point
 values are mapped directly. Neither fixed-point nor
 floating-point values are clamped. The initial value for
 <code>GL_LIGHT0</code> is (1, 1, 1, 1). For other lights, the
 initial value is (0, 0, 0, 0).

 <li><code>GL_SPECULAR</code></li>

 <p><code>params</code> contains four values that specify the
 specular RGBA intensity of the light. Both fixed-point and
 floating-point values are mapped directly. Neither fixed-point
 nor floating-point values are clamped. The initial value for
 <code>GL_LIGHT0</code> is (1, 1, 1, 1). For other lights, the
 initial value is (0, 0, 0, 0).

 <li><code>GL_POSITION</code> (1.0 only)</li>

 <p><code>params</code> contains four values that specify the
 position of the light in homogeneous object coordinates. Both
 fixed-point and floating-point values are mapped
 directly. Neither fixed-point nor floating-point values are
 clamped.

 <p>The position is transformed by the modelview matrix when
 <code>glLight</code> is called (just as if it were a point), and
 it is stored in eye coordinates. If the w component of the
 position is 0, the light is treated as a directional
 source. Diffuse and specular lighting calculations take the
 light's direction, but not its actual position, into account, and
 attenuation is disabled. Otherwise, diffuse and specular lighting
 calculations are based on the actual location of the light in eye
 coordinates, and attenuation is enabled. The initial position is
 (0, 0, 1, 0). Thus, the initial light source is directional,
 parallel to, and in the direction of the -z axis.

 <li><code>GL_SPOT_DIRECTION</code></li>

 <p><code>params</code> contains three values that specify the
 direction of the light in homogeneous object coordinates. Both
 fixed-point and floating-point values are mapped
 directly. Neither fixed-point nor floating-point values are
 clamped.

 <p>The spot direction is transformed by the inverse of the modelview
 matrix when <code>glLight</code> is called (just as if it were a
 normal), and it is stored in eye coordinates. It is significant
 only when <code>GL_SPOT_CUTOFF</code> is not 180, which it is
 initially. The initial direction is (0, 0, -1).

 <li><code>GL_SPOT_EXPONENT</code></li>

 <p><code>params</code> is a single value that specifies the
 intensity distribution of the light. Fixed-point and
 floating-point values are mapped directly. Only values in the
 range [0, 128] are accepted.

 <p>Effective light intensity is attenuated by the cosine of the
 angle between the direction of the light and the direction from
 the light to the vertex being lighted, raised to the power of the
 spot exponent. Thus, higher spot exponents result in a more
 focused light source, regardless of the spot cutoff angle (see
 <code>GL_SPOT_CUTOFF</code>, next paragraph). The initial spot
 exponent is 0, resulting in uniform light distribution.

 <li><code>GL_SPOT_CUTOFF</code></li>

 <p><code>params</code> is a single value that specifies the maximum
 spread angle of a light source. Fixed-point and floating-point
 values are mapped directly. Only values in the range [0, 90] and
 the special value 180 are accepted. If the angle between the
 direction of the light and the direction from the light to the
 vertex being lighted is greater than the spot cutoff angle, the
 light is completely masked. Otherwise, its intensity is
 controlled by the spot exponent and the attenuation factors. The
 initial spot cutoff is 180, resulting in uniform light
 distribution.

 <li><code>GL_CONSTANT_ATTENUATION</code>,
 <code>GL_LINEAR_ATTENUATION</code>,
 <code>GL_QUADRATIC_ATTENUATION</code></li>

 <p><code>params</code> is a single value that specifies one of the
 three light attenuation factors. Fixed-point and floating-point
 values are mapped directly. Only nonnegative values are
 accepted. If the light is positional, rather than directional,
 its intensity is attenuated by the reciprocal of the sum of the
 constant factor, the linear factor times the distance between the
 light and the vertex being lighted, and the quadratic factor
 times the square of the same distance. The initial attenuation
 factors are (1, 0, 0), resulting in no attenuation.

 </ul>
 
 <h4>Notes</h4>

 <p>It is always the case that <code>GL_LIGHT</code><i>i</i> =
 <code>GL_LIGHT0</code> + <i>i</i>.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if either
 <code>light</code> or <code>pname</code> is not an accepted
 value.

 <p><code>GL_INVALID_VALUE</code> is generated if a spot exponent
 value is specified outside the range [0, 128], or if spot cutoff
 is specified outside the range [0, 90] (except for the special
 value 180), or if a negative attenuation factor is specified.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>light</CODE> - Specifies a light. The number of lights depends on
 the implementation, but at least eight lights are supported. They
 are identified by symbolic names of the form
 <code>GL_LIGHT</code><i>i</i> where <code>0 <= <i>i</i> <
 GL_MAX_LIGHTS</code>.<DD><CODE>pname</CODE> - Specifies a light source parameter for
 light. <code>GL_AMBIENT</code>, <code>GL_DIFFUSE</code>,
 <code>GL_SPECULAR</code>, <code>GL_POSITION</code> (1.0 only),
 <code>GL_SPOT_CUTOFF</code>, <code>GL_SPOT_DIRECTION</code>,
 <code>GL_SPOT_EXPONENT</code>,
 <code>GL_CONSTANT_ATTENUATION</code>,
 <code>GL_LINEAR_ATTENUATION</code>, and
 <code>GL_QUADRATIC_ATTENUATION</code> are accepted.<DD><CODE>params</CODE> - Specifies an array containing values that parameter
 <code>pname</code> of light source light will be set to.<DD><CODE>offset</CODE> - the starting offset within the
 <code>params</code> array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params.length -
 offset</code> is smaller than the number of values required by
 the parameter.</DL>
</DD>
</DL>
<HR>

<A NAME="glLightfv(int, int, java.nio.FloatBuffer)"><!-- --></A><H3>
glLightfv</H3>
<PRE>
public void <B>glLightfv</B>(int&nbsp;light,
                      int&nbsp;pname,
                      <A HREF="../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Floating-point <code>Buffer</code> version of <code>glLight</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if
 <code>params.remaining()</code> is smaller than the number of
 values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightfv(int, int, float[], int)"><CODE>glLightfv(int light, int pname, float[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glLightx(int, int, int)"><!-- --></A><H3>
glLightx</H3>
<PRE>
public void <B>glLightx</B>(int&nbsp;light,
                     int&nbsp;pname,
                     int&nbsp;param)</PRE>
<DL>
<DD>Fixed-point version of <code>glLight</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightf(int, int, float)"><CODE>glLightf(int light, int pname, float param)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glLightxv(int, int, int[], int)"><!-- --></A><H3>
glLightxv</H3>
<PRE>
public void <B>glLightxv</B>(int&nbsp;light,
                      int&nbsp;pname,
                      int[]&nbsp;params,
                      int&nbsp;offset)</PRE>
<DL>
<DD>Fixed-point array version of <code>glLight</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params.length -
 offset</code> is smaller than the number of values required by
 the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightfv(int, int, float[], int)"><CODE>glLightfv(int light, int pname, float[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glLightxv(int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glLightxv</H3>
<PRE>
public void <B>glLightxv</B>(int&nbsp;light,
                      int&nbsp;pname,
                      <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Fixed-point <code>Buffer</code> version of <code>glLight</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if
 <code>params.remaining()</code> is smaller than the number of
 values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLightfv(int, int, float[], int)"><CODE>glLightfv(int light, int pname, float[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glLineWidth(float)"><!-- --></A><H3>
glLineWidth</H3>
<PRE>
public void <B>glLineWidth</B>(float&nbsp;width)</PRE>
<DL>
<DD>Specify the width of rasterized lines.
   
 <p><code>glLineWidth</code> specifies the rasterized width of
 both aliased and antialiased lines. Using a line width other than
 1 has different effects, depending on whether line antialiasing
 is enabled. To enable and disable line antialiasing, call
 <code>glEnable</code> and <code>glDisable</code> with argument
 <code>GL_LINE_SMOOTH</code>. Line antialiasing is initially
 disabled.

 <p>If line antialiasing is disabled, the actual width is
 determined by rounding the supplied width to the nearest
 integer. (If the rounding results in the value 0, it is as if the
 line width were 1.) If <code>|delta x| >= |delta y|</code>,
 <i>i</i> pixels are filled in each column that is rasterized,
 where <i>i</i> is the rounded value of
 <code>width</code>. Otherwise, <i>i</i> pixels are filled in each
 row that is rasterized.

 <p>If antialiasing is enabled, line rasterization produces a
 fragment for each pixel square that intersects the region lying
 within the rectangle having width equal to the current line
 width, length equal to the actual length of the line, and
 centered on the mathematical line segment. The coverage value for
 each fragment is the window coordinate area of the intersection
 of the rectangular region with the corresponding pixel
 square. This value is saved and used in the final rasterization
 step.

 <p>Not all widths can be supported when line antialiasing is
 enabled. If an unsupported width is requested, the nearest
 supported width is used. Only width 1 is guaranteed to be
 supported; others depend on the implementation. Likewise, there
 is a range for aliased line widths as well. To query the range of
 supported widths and the size difference between supported widths
 within the range, call <code>glGetIntegerv</code> with arguments
 <code>GL_ALIASED_LINE_WIDTH_RANGE</code>,
 <code>GL_SMOOTH_LINE_WIDTH_RANGE</code>,
 <code>GL_SMOOTH_LINE_WIDTH_GRANULARITY</code>.

 <h4>Notes</h4>

 <p>Nonantialiased line width may be clamped to an
 implementation-dependent maximum. Call <code>glGetIntegerv</code>
 with <code>GL_ALIASED_LINE_WIDTH_RANGE</code> to determine the
 maximum width.

 <h4>Errors</h4>

 <p><code>GL_INVALID_VALUE</code> is generated if width is less
 than or equal to 0.

 <h4>Associated Gets</h4> 

 <p><code>glGetIntegerv</code> with argument
 <code>GL_ALIASED_LINE_WIDTH_RANGE</code>

 <p><code>glGetIntegerv</code> with argument
 <code>GL_SMOOTH_LINE_WIDTH_RANGE</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>width</CODE> - Specifies the width of rasterized lines. The initial
 value is 1.</DL>
</DD>
</DL>
<HR>

<A NAME="glLineWidthx(int)"><!-- --></A><H3>
glLineWidthx</H3>
<PRE>
public void <B>glLineWidthx</B>(int&nbsp;width)</PRE>
<DL>
<DD>Fixed-point version of <code>glLineWidth</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLineWidth(float)"><CODE>glLineWidth(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glLoadIdentity()"><!-- --></A><H3>
glLoadIdentity</H3>
<PRE>
public void <B>glLoadIdentity</B>()</PRE>
<DL>
<DD>Replace the current matrix with the identity matrix.

 <p><code>glLoadIdentity</code> replaces the current matrix with
 the identity matrix. It is semantically equivalent to calling
 glLoadMatrix with the identity matrix

 <pre>
 ( 1       0       0       0 )
 ( 0       1       0       0 )
 ( 0       0       1       0 )
 ( 0       0       0       1 )
 </pre>

 but in some cases it is more efficient.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="glLoadMatrixf(float[], int)"><!-- --></A><H3>
glLoadMatrixf</H3>
<PRE>
public void <B>glLoadMatrixf</B>(float[]&nbsp;m,
                          int&nbsp;offset)</PRE>
<DL>
<DD>Replace the current matrix with the specified matrix.

 <p><code>glLoadMatrix</code> replaces the current matrix with the
 one whose elements are specified by <code>m</code>. The current
 matrix is the projection matrix, modelview matrix, or texture
 matrix, depending on the current matrix mode (see glMatrixMode).

 <p>The current matrix, <code>M</code>, defines a transformation
 of coordinates. For instance, assume <code>M</code> refers to the
 modelview matrix. If <code>v = (v[0], v[1], v[2], v[3])</code> is
 the set of object coordinates of a vertex, and <code>m</code> is
 an array of 16 fixed-point or single-precision floating-point
 values <code>m[0]</code>, <code>m[1]</code>, ...,
 <code>m[15]</code>, then the modelview transformation
 <code>M(v)</code> does the following:

 <pre>
        ( m[0] m[4] m[8]  m[12] )   ( v[0] )
 M(v) = ( m[1] m[5] m[9]  m[13] ) x ( v[1] )
        ( m[2] m[6] m[10] m[14] )   ( v[2] )
        ( m[3] m[7] m[11] m[15] )   ( v[3] )
 </pre>

 where "x" denotes matrix multiplication.

 <p>Projection and texture transformations are similarly defined.

 <h4>Notes</h4>

 <p>While the elements of the matrix may be specified with single or
 double precision, the GL implementation may store or operate on
 these values in less than single precision.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>m</CODE> - Specifies an array of at least 16 consecutive values,
 the first 16 of which are used as the elements of a 4  4
 column-major matrix.<DD><CODE>offset</CODE> - the starting offset within the
 <code>m</code> array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m.length -
 offset</code> is less than 16.</DL>
</DD>
</DL>
<HR>

<A NAME="glLoadMatrixf(java.nio.FloatBuffer)"><!-- --></A><H3>
glLoadMatrixf</H3>
<PRE>
public void <B>glLoadMatrixf</B>(<A HREF="../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;m)</PRE>
<DL>
<DD>Floating-point <code>Buffer</code> version of <code>glLoadMatrix</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m.remaining()</code>
 is less than 16.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLoadMatrixf(float[], int)"><CODE>glLoadMatrixf(float[] m, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glLoadMatrixx(int[], int)"><!-- --></A><H3>
glLoadMatrixx</H3>
<PRE>
public void <B>glLoadMatrixx</B>(int[]&nbsp;m,
                          int&nbsp;offset)</PRE>
<DL>
<DD>Fixed-point array version of <code>glLoadMatrix</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m.length -
 offset</code> is less than 16.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLoadMatrixf(float[], int)"><CODE>glLoadMatrixf(float[] m, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glLoadMatrixx(java.nio.IntBuffer)"><!-- --></A><H3>
glLoadMatrixx</H3>
<PRE>
public void <B>glLoadMatrixx</B>(<A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;m)</PRE>
<DL>
<DD>Fixed-point <code>Buffer</code> version of <code>glLoadMatrix</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m.remaining()</code>
 is less than 16.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glLoadMatrixf(float[], int)"><CODE>glLoadMatrixf(float[] m, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glLogicOp(int)"><!-- --></A><H3>
glLogicOp</H3>
<PRE>
public void <B>glLogicOp</B>(int&nbsp;opcode)</PRE>
<DL>
<DD>Specify a logical pixel operation.

 <p><code>glLogicOp</code> specifies a logical operation that,
 when enabled, is applied between the incoming color and the color
 at the corresponding location in the frame buffer. To enable or
 disable the logical operation, call <code>glEnable</code> and
 <code>glDisable</code> with argument
 <code>GL_COLOR_LOGIC_OP</code>. Logical operation is initially
 disabled.

 <pre>
 Opcode            Resulting Operation

 GL_CLEAR                     0
 GL_SET                       1
 GL_COPY                      s
 GL_COPY_INVERTED           ~ s
 GL_NOOP                      d
 GL_INVERT                  ~ d
 GL_AND                 s &   d
 GL_NAND             ~ (s &   d)
 GL_OR                  s |   d
 GL_NOR              ~ (s |   d)
 GL_XOR                 s ^   d
 GL_EQUIV            ~ (s ^   d)
 GL_AND_REVERSE         s & ~ d
 GL_AND_INVERTED      ~ s &   d
 GL_OR_REVERSE          s | ~ d
 GL_OR_INVERTED       ~ s |   d
 </pre>

 <p><code>opcode</code> is a symbolic constant chosen from the
 list above. In the explanation of the logical operations,
 <i>s</i> represents the incoming color and <i>d</i> represents
 the color in the frame buffer. As in the Java language, "~"
 represents bitwise negation, "&" represents bitwise AND, "|"
 represents bitwise OR, and "^" represents bitwise XOR.  As these
 bitwise operators suggest, the logical operation is applied
 independently to each bit pair of the source and destination
 indices or colors.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if opcode is not an
 accepted value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>opcode</CODE> - Specifies a symbolic constant that selects a
 logical operation. The following symbols are accepted:
 <code>GL_CLEAR</code>, <code>GL_SET</code>, <code>GL_COPY</code>,
 <code>GL_COPY_INVERTED</code>, <code>GL_NOOP</code>,
 <code>GL_INVERT</code>, <code>GL_AND</code>,
 <code>GL_NAND</code>, <code>GL_OR</code>, <code>GL_NOR</code>,
 <code>GL_XOR</code>, <code>GL_EQUIV</code>,
 <code>GL_AND_REVERSE</code>, <code>GL_AND_INVERTED</code>,
 <code>GL_OR_REVERSE</code>, and <code>GL_OR_INVERTED</code>. The
 initial value is <code>GL_COPY</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glMaterialf(int, int, float)"><!-- --></A><H3>
glMaterialf</H3>
<PRE>
public void <B>glMaterialf</B>(int&nbsp;face,
                        int&nbsp;pname,
                        float&nbsp;param)</PRE>
<DL>
<DD>Specify material parameters for the lighting model.

 <p><code>glMaterial</code> assigns values to material
 parameters. There are two matched sets of material
 parameters. One, the front-facing set, is used to shade points,
 lines, and all polygons (when two-sided lighting is disabled), or
 just front-facing polygons (when two-sided lighting is
 enabled). The other set, back-facing, is used to shade
 back-facing polygons only when two-sided lighting is
 enabled. Refer to the <code>glLightModel</code> reference page
 for details concerning one- and two-sided lighting calculations.

 <p><code>glMaterial</code> takes three arguments. The first,
 face, must be <code>GL_FRONT_AND_BACK</code> and specifies that
 both front and back materials will be modified. The second,
 pname, specifies which of several parameters in one or both sets
 will be modified. The third, params, specifies what value or
 values will be assigned to the specified parameter.

 <p>Material parameters are used in the lighting equation that is
 optionally applied to each vertex. The equation is discussed in
 the <code>glLightModel</code> reference page. The parameters that
 can be specified using <code>glMaterial</code>, and their
 interpretations by the lighting equation, are as follows:

 <ul>

 <li><code>GL_AMBIENT</code></li>

 <p><code>params</code> contains four fixed-point or
 floating-point values that specify the ambient RGBA reflectance
 of the material. The values are not clamped. The initial ambient
 reflectance is (0.2, 0.2, 0.2, 1.0).

 <li><code>GL_DIFFUSE</code></li>

 <p><code>params</code> contains four fixed-point or
 floating-point values that specify the diffuse RGBA reflectance
 of the material. The values are not clamped. The initial diffuse
 reflectance is (0.8, 0.8, 0.8, 1.0).

 <li><code>GL_SPECULAR</code></li>

 <p><code>params</code> contains four fixed-point or
 floating-point values that specify the specular RGBA reflectance
 of the material. The values are not clamped. The initial specular
 reflectance is (0, 0, 0, 1).

 <li><code>GL_EMISSION</code></li>

 <p><code>params</code> contains four fixed-point or
 floating-point values that specify the RGBA emitted light
 intensity of the material. The values are not clamped. The
 initial emission intensity is (0, 0, 0, 1).

 <li><code>GL_SHININESS</code></li>

 <p><code>params</code> is a single fixed-point or floating-point
 value that specifies the RGBA specular exponent of the
 material. Only values in the range [0, 128] are accepted. The
 initial specular exponent is 0.

 <li><code>GL_AMBIENT_AND_DIFFUSE</code></li>

 <p>Equivalent to calling <code>glMaterial</code> twice with the same
 parameter values, once with <code>GL_AMBIENT</code> and once with
 <code>GL_DIFFUSE</code>.

 </ul>

 <h4>Notes</h4>

 <p>To change the diffuse and ambient material per vertex, color
 material can be used. To enable and disable
 <code>GL_COLOR_MATERIAL</code>, call <code>glEnable</code> and
 <code>glDisable</code> with argument
 <code>GL_COLOR_MATERIAL</code>. Color material is initially
 disabled.

 <p>While the ambient, diffuse, specular and emission material
 parameters all have alpha components, only the diffuse alpha
 component is used in the lighting computation.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if either face or
 <code>pname</code> is not an accepted value.

 <p><code>GL_INVALID_VALUE</code> is generated if a specular
 exponent outside the range [0, 128] is specified.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>face</CODE> - Specifies which face or faces are being updated. Must
 be <code>GL_FRONT_AND_BACK</code>.<DD><CODE>pname</CODE> - Specifies the single-valued material parameter of
 the face or faces that is being updated. Must be
 <code>GL_SHININESS</code>.<DD><CODE>param</CODE> - Specifies the value that parameter
 <code>GL_SHININESS</code> will be set to.</DL>
</DD>
</DL>
<HR>

<A NAME="glMaterialfv(int, int, float[], int)"><!-- --></A><H3>
glMaterialfv</H3>
<PRE>
public void <B>glMaterialfv</B>(int&nbsp;face,
                         int&nbsp;pname,
                         float[]&nbsp;params,
                         int&nbsp;offset)</PRE>
<DL>
<DD>Specify material parameters for the lighting model (array
 version).

 <p><code>glMaterial</code> assigns values to material
 parameters. There are two matched sets of material
 parameters. One, the front-facing set, is used to shade points,
 lines, and all polygons (when two-sided lighting is disabled), or
 just front-facing polygons (when two-sided lighting is
 enabled). The other set, back-facing, is used to shade
 back-facing polygons only when two-sided lighting is
 enabled. Refer to the <code>glLightModel</code> reference page
 for details concerning one- and two-sided lighting calculations.

 <p><code>glMaterial</code> takes three arguments. The first,
 face, must be <code>GL_FRONT_AND_BACK</code> and specifies that
 both front and back materials will be modified. The second,
 pname, specifies which of several parameters in one or both sets
 will be modified. The third, params, specifies what value or
 values will be assigned to the specified parameter.

 <p>Material parameters are used in the lighting equation that is
 optionally applied to each vertex. The equation is discussed in
 the <code>glLightModel</code> reference page. The parameters that
 can be specified using <code>glMaterial</code>, and their
 interpretations by the lighting equation, are as follows:

 <ul>

 <li><code>GL_AMBIENT</code></li>

 <p><code>params</code> contains four fixed-point or
 floating-point values that specify the ambient RGBA reflectance
 of the material. The values are not clamped. The initial ambient
 reflectance is (0.2, 0.2, 0.2, 1.0).

 <li><code>GL_DIFFUSE</code></li>

 <p><code>params</code> contains four fixed-point or
 floating-point values that specify the diffuse RGBA reflectance
 of the material. The values are not clamped. The initial diffuse
 reflectance is (0.8, 0.8, 0.8, 1.0).

 <li><code>GL_SPECULAR</code></li>

 <p><code>params</code> contains four fixed-point or
 floating-point values that specify the specular RGBA reflectance
 of the material. The values are not clamped. The initial specular
 reflectance is (0, 0, 0, 1).

 <li><code>GL_EMISSION</code></li>

 <p><code>params</code> contains four fixed-point or
 floating-point values that specify the RGBA emitted light
 intensity of the material. The values are not clamped. The
 initial emission intensity is (0, 0, 0, 1).

 <li><code>GL_SHININESS</code></li>

 <p><code>params</code> is a single fixed-point or floating-point
 value that specifies the RGBA specular exponent of the
 material. Only values in the range [0, 128] are accepted. The
 initial specular exponent is 0.

 <li><code>GL_AMBIENT_AND_DIFFUSE</code></li>

 <p>Equivalent to calling <code>glMaterial</code> twice with the same
 parameter values, once with <code>GL_AMBIENT</code> and once with
 <code>GL_DIFFUSE</code>.

 </ul>

 <h4>Notes</h4>

 <p>To change the diffuse and ambient material per vertex, color
 material can be used. To enable and disable
 <code>GL_COLOR_MATERIAL</code>, call <code>glEnable</code> and
 <code>glDisable</code> with argument
 <code>GL_COLOR_MATERIAL</code>. Color material is initially
 disabled.

 <p>While the ambient, diffuse, specular and emission material
 parameters all have alpha components, only the diffuse alpha
 component is used in the lighting computation.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if either face or
 <code>pname</code> is not an accepted value.

 <p><code>GL_INVALID_VALUE</code> is generated if a specular
 exponent outside the range [0, 128] is specified.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>face</CODE> - Specifies which face or faces are being updated. Must
 be <code>GL_FRONT_AND_BACK</code>.<DD><CODE>pname</CODE> - Specifies the material parameter of the face or
 faces that is being updated. Must be one of
 <code>GL_AMBIENT</code>, <code>GL_DIFFUSE</code>,
 <code>GL_SPECULAR</code>, <code>GL_EMISSION</code>,
 <code>GL_SHININESS</code>, or
 <code>GL_AMBIENT_AND_DIFFUSE</code>.<DD><CODE>params</CODE> - Specifies a pointer to the value or values that
 <code>pname</code> will be set to.<DD><CODE>offset</CODE> - the starting offset within the
 <code>params</code> array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params.length -
 offset</code> is smaller than the number of values required by
 the parameter.</DL>
</DD>
</DL>
<HR>

<A NAME="glMaterialfv(int, int, java.nio.FloatBuffer)"><!-- --></A><H3>
glMaterialfv</H3>
<PRE>
public void <B>glMaterialfv</B>(int&nbsp;face,
                         int&nbsp;pname,
                         <A HREF="../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Floating-point <code>Buffer</code> version of <code>glMaterial</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if
 <code>params.remaining()</code> is smaller than the number of
 values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMaterialfv(int, int, float[], int)"><CODE>glMaterialfv(int face, int pname, float[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glMaterialx(int, int, int)"><!-- --></A><H3>
glMaterialx</H3>
<PRE>
public void <B>glMaterialx</B>(int&nbsp;face,
                        int&nbsp;pname,
                        int&nbsp;param)</PRE>
<DL>
<DD>Fixed-point version of <code>glMaterial</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMaterialf(int, int, float)"><CODE>glMaterialf(int face, int pname, float param)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glMaterialxv(int, int, int[], int)"><!-- --></A><H3>
glMaterialxv</H3>
<PRE>
public void <B>glMaterialxv</B>(int&nbsp;face,
                         int&nbsp;pname,
                         int[]&nbsp;params,
                         int&nbsp;offset)</PRE>
<DL>
<DD>Fixed-point array version of <code>glMaterial</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params.length -
 offset</code> is smaller than the number of values required by
 the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMaterialfv(int, int, float[], int)"><CODE>glMaterialfv(int face, int pname, float[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glMaterialxv(int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glMaterialxv</H3>
<PRE>
public void <B>glMaterialxv</B>(int&nbsp;face,
                         int&nbsp;pname,
                         <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Fixed-point <code>Buffer</code> version of <code>glMaterial</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if
 <code>params.remaining()</code> is smaller than the number of
 values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMaterialfv(int, int, float[], int)"><CODE>glMaterialfv(int face, int pname, float[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glMatrixMode(int)"><!-- --></A><H3>
glMatrixMode</H3>
<PRE>
public void <B>glMatrixMode</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Specify which matrix is the current matrix.

 <p><code>glMatrixMode</code> sets the current matrix mode. mode
 can assume one of three values:

 <ul>

 <li><code>GL_MODELVIEW</code></li>

 <p>Applies subsequent matrix operations to the modelview matrix
 stack.

 <li><code>GL_PROJECTION</code></li>

 <p>Applies subsequent matrix operations to the projection matrix
 stack.

 <li><code>GL_TEXTURE</code></li>

 <p>Applies subsequent matrix operations to the texture matrix stack.

 <li><code>GL_MATRIX_PALETTE_OES</code>
 (<code>OES_matrix_palette</code> extension)</li>

 <p>Enables the matrix palette stack extension, and applies
 subsequent matrix operations to the matrix palette stack.

 </ul>

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if mode is not an
 accepted value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - Specifies which matrix stack is the target for
 subsequent matrix operations. These values are accepted:
 <code>GL_MODELVIEW</code>, <code>GL_PROJECTION</code>, and
 <code>GL_TEXTURE</code>. In the <code>OES_matrix_palette</code>
 extension is available, <code>GL_MATRIX_PALETTE_OES</code> is
 additionally accepted. The initial value is
 <code>GL_MODELVIEW</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glMultMatrixf(float[], int)"><!-- --></A><H3>
glMultMatrixf</H3>
<PRE>
public void <B>glMultMatrixf</B>(float[]&nbsp;m,
                          int&nbsp;offset)</PRE>
<DL>
<DD>Multiply the current matrix with the specified matrix.

 <p><code>glMultMatrix</code> multiplies the current matrix with
 the one specified using m, and replaces the current matrix with
 the product.

 <p>The current matrix is determined by the current matrix mode (see
 glMatrixMode). It is either the projection matrix, modelview
 matrix, or the texture matrix.

 <h4>Examples</h4>

 <p>If the current matrix is <code>C</code>, and the coordinates
 to be transformed are, <code>v</code> = (<code>v[0]</code>,
 <code>v[1]</code>, <code>v[2]</code>, <code>v[3]</code>), then
 the current transformation is <code>C x v</code>, or

 <pre>
 ( c[0] c[4] c[8]  c[12] )   ( v[0] )
 ( c[1] c[5] c[9]  c[13] ) x ( v[1] )
 ( c[2] c[6] c[10] c[14] )   ( v[2] )
 ( c[3] c[7] c[11] c[15] )   ( v[3] )
 </pre>

 <p>Calling <code>glMultMatrix</code> with an argument of
 <code>m</code> = <code>m[0]</code>, <code>m[1]</code>, ...,
 <code>m[15]</code> replaces the current transformation with
 <code>(C x M) x v</code>, or

 <pre>
 ( c[0] c[4] c[8]  c[12] )   ( m[0] m[4] m[8]  m[12] )   ( v[0] )
 ( c[1] c[5] c[9]  c[13] ) x ( m[1] m[5] m[9]  m[13] ) x ( v[1] )
 ( c[2] c[6] c[10] c[14] )   ( m[2] m[6] m[10] m[14] )   ( v[2] )
 ( c[3] c[7] c[11] c[15] )   ( m[3] m[7] m[11] m[15] )   ( v[3] )
 </pre>

 <p>where "x" denotes matrix multiplication, and <code>v</code> is
 represented as a 4  1 matrix.

 <h4>Notes</h4>

 <p>While the elements of the matrix may be specified with single or
 double precision, the GL may store or operate on these values in
 less than single precision.

 <p>The array elements are passed in as a one-dimensional
 array in column-major order. The order of the multiplication
 is important. For example, if the current transformation is a
 rotation, and <code>glMultMatrix</code> is called with a
 translation matrix, the translation is done directly on the
 coordinates to be transformed, while the rotation is done on the
 results of that translation.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>m</CODE> - Specifies an array of at least 16 consecutive values,
 the first 16 of which are used as the elements of a 4  4
 column-major matrix.<DD><CODE>offset</CODE> - the starting offset within the
 <code>m</code> array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m.length -
 offset</code> is less than 16.</DL>
</DD>
</DL>
<HR>

<A NAME="glMultMatrixf(java.nio.FloatBuffer)"><!-- --></A><H3>
glMultMatrixf</H3>
<PRE>
public void <B>glMultMatrixf</B>(<A HREF="../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;m)</PRE>
<DL>
<DD>Floating-point <code>Buffer</code> version of <code>glMultMatrix</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m.remaining()</code>
 is less than 16.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMultMatrixf(float[], int)"><CODE>glMultMatrixf(float[] m, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glMultMatrixx(int[], int)"><!-- --></A><H3>
glMultMatrixx</H3>
<PRE>
public void <B>glMultMatrixx</B>(int[]&nbsp;m,
                          int&nbsp;offset)</PRE>
<DL>
<DD>Fixed-point array version of <code>glMultMatrix</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m.length -
 offset</code> is less than 16.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMultMatrixf(float[], int)"><CODE>glMultMatrixf(float[] m, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glMultMatrixx(java.nio.IntBuffer)"><!-- --></A><H3>
glMultMatrixx</H3>
<PRE>
public void <B>glMultMatrixx</B>(<A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;m)</PRE>
<DL>
<DD>Fixed-point <code>Buffer</code> version of <code>glMultMatrix</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>m.remaining()</code>
 is less than 16.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMultMatrixf(float[], int)"><CODE>glMultMatrixf(float[] m, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glMultiTexCoord4f(int, float, float, float, float)"><!-- --></A><H3>
glMultiTexCoord4f</H3>
<PRE>
public void <B>glMultiTexCoord4f</B>(int&nbsp;target,
                              float&nbsp;s,
                              float&nbsp;t,
                              float&nbsp;r,
                              float&nbsp;q)</PRE>
<DL>
<DD>Set the current texture coordinates.

 <p><code>glMultiTexCoord</code> specifies the four texture
 coordinates as <code>(s, t, r, q)</code>.

 <p>The current texture coordinates are part of the data that is
 associated with each vertex.

 <h4>Notes</h4>

 <p>It is always the case that <code>GL_TEXTURE</code><i>i</i> =
 <code>GL_TEXTURE0</code> + <i>i</i>.

 <h4>Associated Gets</h4>

 <p><code>glGetIntegerv</code> with argument
 <code>GL_MAX_TEXTURE_UNITS</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies texture unit whose coordinates should be
 modified. The number of texture units is implementation
 dependent, but must be at least one. Must be one of
 <code>GL_TEXTURE</code><i>i</i>, where <code>0 <= <i>i</i> <
 GL_MAX_TEXTURE_UNITS</code>, which is an implementation-dependent
 value.<DD><CODE>s</CODE> - Specifies an s texture coordinate for target texture
 unit. The initial value is 0.<DD><CODE>t</CODE> - Specifies a t texture coordinate for
 target texture unit. The initial value is 0.<DD><CODE>r</CODE> - Specifies an r texture coordinate for
 target texture unit. The initial value is 0.<DD><CODE>q</CODE> - Specifies a q texture coordinate for
 target texture unit. The initial value is 1.</DL>
</DD>
</DL>
<HR>

<A NAME="glMultiTexCoord4x(int, int, int, int, int)"><!-- --></A><H3>
glMultiTexCoord4x</H3>
<PRE>
public void <B>glMultiTexCoord4x</B>(int&nbsp;target,
                              int&nbsp;s,
                              int&nbsp;t,
                              int&nbsp;r,
                              int&nbsp;q)</PRE>
<DL>
<DD>Fixed-point version of <code>glMultiTexCoord</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glMultiTexCoord4f(int, float, float, float, float)"><CODE>glMultiTexCoord4f(int, float, float, float, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glNormal3f(float, float, float)"><!-- --></A><H3>
glNormal3f</H3>
<PRE>
public void <B>glNormal3f</B>(float&nbsp;nx,
                       float&nbsp;ny,
                       float&nbsp;nz)</PRE>
<DL>
<DD>Set the current normal vector.

 <p>The current normal is set to the given coordinates whenever
 <code>glNormal</code> is issued. Byte, short, or integer arguments are
 converted to floating-point with a linear mapping that maps the
 most positive representable integer value to 1.0, and the most
 negative representable integer value to -1.0.

 <p>Normals specified with <code>glNormal</code> need not have
 unit length. If <code>GL_NORMALIZE</code> is enabled, then
 normals of any length specified with <code>glNormal</code> are
 normalized after transformation. If
 <code>GL_RESCALE_NORMAL</code> is enabled, normals are scaled by
 a scaling factor derived from the modelview
 matrix. <code>GL_RESCALE_NORMAL</code> requires that the
 originally specified normals were of unit length, and that the
 modelview matrix contain only uniform scales for proper
 results. To enable and disable normalization, call
 <code>glEnable</code> and <code>glDisable</code> with either
 <code>GL_NORMALIZE</code> or
 <code>GL_RESCALE_NORMAL</code>. Normalization is initially
 disabled.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>nx</CODE> - Specifies the x coordinate of the new
 current normal. The initial value is 0.<DD><CODE>ny</CODE> - Specifies the y coordinate of the new
 current normal. The initial value is 0.<DD><CODE>nz</CODE> - Specifies the z coordinate of the new
 current normal. The initial value is 1.</DL>
</DD>
</DL>
<HR>

<A NAME="glNormal3x(int, int, int)"><!-- --></A><H3>
glNormal3x</H3>
<PRE>
public void <B>glNormal3x</B>(int&nbsp;nx,
                       int&nbsp;ny,
                       int&nbsp;nz)</PRE>
<DL>
<DD>Fixed-point version of <code>glNormal</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glNormal3f(float, float, float)"><CODE>glNormal3f(float, float, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glNormalPointer(int, int, java.nio.Buffer)"><!-- --></A><H3>
glNormalPointer</H3>
<PRE>
public void <B>glNormalPointer</B>(int&nbsp;type,
                            int&nbsp;stride,
                            <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pointer)</PRE>
<DL>
<DD>Define an array of normals.

 <p><code>glNormalPointer</code> specifies the location and data
 of an array of normals to use when rendering. type specifies the
 data type of the normal coordinates and stride gives the byte
 stride from one normal to the next, allowing vertices and
 attributes to be packed into a single array or stored in separate
 arrays. (Single-array storage may be more efficient on some
 implementations.) When a normal array is specified, type , stride
 , and pointer are saved as client-side state.

 <p>If the normal array is enabled, it is used when
 <code>glDrawArrays</code> or <code>glDrawElements</code> is
 called. To enable and disable the normal array, call
 <code>glEnableClientState</code> and
 <code>glDisableClientState</code> with the argument
 <code>GL_NORMAL_ARRAY</code>. The normal array is initially
 disabled and isn't accessed when <code>glDrawArrays</code> or
 <code>glDrawElements</code> is called.

 <p>Use <code>glDrawArrays</code> to construct a sequence of
 primitives (all of the same type) from prespecified vertex and
 vertex attribute arrays. Use <code>glDrawElements</code> to
 construct a sequence of primitives by indexing vertices and
 vertex attributes.

 <h4>Notes</h4>

 <p><code>glNormalPointer</code> is typically implemented on the
 client side.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if type is not an
 accepted value.

 <p><code>GL_INVALID_VALUE</code> is generated if stride is
 negative.

 <p> The <code>pointer</code> argument must be a direct buffer
 with a type matching that specified by the <code>type</code>
 argument.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - Specifies the data type of each coordinate in the
 array. Symbolic constants <code>GL_BYTE</code>,
 <code>GL_SHORT</code>, <code>GL_FIXED</code>, and
 <code>GL_FLOAT</code> are accepted. The initial value is
 <code>GL_FLOAT</code>.<DD><CODE>stride</CODE> - Specifies the byte offset between consecutive
 normals. If stride is 0, the normals are understood to be tightly
 packed in the array. The initial value is 0.<DD><CODE>pointer</CODE> - Specifies a pointer to the first coordinate of the
 first normal in the array. The initial value is 0.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if OpenGL ES 1.1 is being used and
 VBOs are enabled.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>pointer</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>pointer</code> is not direct.</DL>
</DD>
</DL>
<HR>

<A NAME="glOrthof(float, float, float, float, float, float)"><!-- --></A><H3>
glOrthof</H3>
<PRE>
public void <B>glOrthof</B>(float&nbsp;left,
                     float&nbsp;right,
                     float&nbsp;bottom,
                     float&nbsp;top,
                     float&nbsp;near,
                     float&nbsp;far)</PRE>
<DL>
<DD>Multiply the current matrix with an orthographic matrix.

 <p><code>glOrtho</code> describes a transformation that produces
 a parallel projection. The current matrix (see glMatrixMode) is
 multiplied by this matrix and the result replaces the current
 matrix, as if <code>glMultMatrix</code> were called with the
 following matrix as its argument:

 <pre>
 ( 2/(right - left)           0                    0            tx )
 (          0          2/(top - bottom)            0            ty )
 (          0                 0          (-2)/(far - near)      tz )
 (          0                 0                    0             1 )
 </pre>

 <p>where

 <pre>
 tx = - (right + left)/(right - left)
 ty = - (top + bottom)/(top - bottom)
 tz = - (far + near)  /(far - near)
 </pre>

 <p>Typically, the matrix mode is <code>GL_PROJECTION</code>, and
 (left, bottom, -near) and (right, top, -near) specify the points
 on the near clipping plane that are mapped to the lower left and
 upper right corners of the window, respectively, assuming that
 the eye is located at (0, 0, 0). -far specifies the location of
 the far clipping plane. Both near and far can be either positive
 or negative.

 <p>Use <code>glPushMatrix</code> and <code>glPopMatrix</code> to
 save and restore the current matrix stack.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>left</CODE> - Specifies the coordinate for the left
 vertical clipping plane.<DD><CODE>right</CODE> - Specifies the coordinate for the right
 vertical clipping plane.<DD><CODE>bottom</CODE> - Specifies the coordinate for the bottom
 horizontal clipping plane.<DD><CODE>top</CODE> - Specifies the coordinate for the top
 horizontal clipping plane.<DD><CODE>near</CODE> - Specifies the distance to the nearer
 depth clipping plane. This value is negative if the plane is
 to be behind the viewer.<DD><CODE>far</CODE> - Specifies the distance to the farther
 depth clipping plane. This value is negative if the plane is
 to be behind the viewer.</DL>
</DD>
</DL>
<HR>

<A NAME="glOrthox(int, int, int, int, int, int)"><!-- --></A><H3>
glOrthox</H3>
<PRE>
public void <B>glOrthox</B>(int&nbsp;left,
                     int&nbsp;right,
                     int&nbsp;bottom,
                     int&nbsp;top,
                     int&nbsp;near,
                     int&nbsp;far)</PRE>
<DL>
<DD>Fixed-point version of <code>glOrtho</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glOrthof(float, float, float, float, float, float)"><CODE>glOrthof(float, float, float, float, float, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glPixelStorei(int, int)"><!-- --></A><H3>
glPixelStorei</H3>
<PRE>
public void <B>glPixelStorei</B>(int&nbsp;pname,
                          int&nbsp;param)</PRE>
<DL>
<DD>Set pixel storage modes.

 <p><code>glPixelStore</code> sets pixel storage modes that affect
 the operation of subsequent <code>glReadPixels</code> as well as
 the unpacking of <code>glTexImage2D</code>, and
 <code>glTexSubImage2D</code>.

 <p><code>pname</code> is a symbolic constant indicating the
 parameter to be set, and <code>param</code> is the new value. The
 following storage parameter affects how pixel data is returned to
 client memory. This value is significant for
 <code>glReadPixels</code>:

 <ul>

 <li><code>GL_PACK_ALIGNMENT</code></li>

 <p>Specifies the alignment requirements for the start of each pixel
 row in memory. The allowable values are 1 (byte-alignment), 2
 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8
 (rows start on double-word boundaries). The initial value is 4.

 <p>The following storage parameter affects how pixel data is read
 from client memory. This value is significant for
 <code>glTexImage2D</code> and <code>glTexSubImage2D</code>:

 <li><code>GL_UNPACK_ALIGNMENT</code></li>

 <p>Specifies the alignment requirements for the start of each pixel
 row in memory. The allowable values are 1 (byte-alignment), 2
 (rows aligned to even-numbered bytes), 4 (word-alignment), and 8
 (rows start on double-word boundaries). The initial value is 4.

 </ul>

 <h4>Notes</h4>

 <p>Pixel storage modes are client states.

 <p><code>glCompressedTexImage2D</code> and
 <code>glCompressedTexSubImage2D</code> are not affected by
 <code>glPixelStore</code>.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if
 <code>pname</code> is not an accepted value.

 <p><code>GL_INVALID_VALUE</code> is generated if alignment is
 specified as other than 1, 2, 4, or 8.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pname</CODE> - Specifies the symbolic name of the parameter to be
 set. <code>GL_PACK_ALIGNMENT</code> affects the packing of pixel
 data into memory. <code>GL_UNPACK_ALIGNMENT</code> affects the
 unpacking of pixel data from memory.<DD><CODE>param</CODE> - Specifies the value that <code>pname</code> is set
 to.</DL>
</DD>
</DL>
<HR>

<A NAME="glPointSize(float)"><!-- --></A><H3>
glPointSize</H3>
<PRE>
public void <B>glPointSize</B>(float&nbsp;size)</PRE>
<DL>
<DD>Specify the diameter of rasterized points.

 <p><code>glPointSize</code> specifies the rasterized diameter of
 both aliased and antialiased points. Using a point size other
 than 1 has different effects, depending on whether point
 antialiasing is enabled. To enable and disable point
 antialiasing, call <code>glEnable</code> and
 <code>glDisable</code> with argument
 <code>GL_POINT_SMOOTH</code>. Point antialiasing is initially
 disabled.

 <p>If point antialiasing is disabled, the actual size is determined
 by rounding the supplied size to the nearest integer. (If the
 rounding results in the value 0, it is as if the point size were
 1.) If the rounded size is odd, then the center point (x, y) of
 the pixel fragment that represents the point is computed as

 <pre>
 (floor(xw) + 1/2, floor(yw) + 1/2)
 </pre>

 <p>where w subscripts indicate window coordinates. All pixels that
 lie within the square grid of the rounded size centered at (x, y)
 make up the fragment. If the size is even, the center point is

 <pre>
 (floor(xw + 1/2), floor(yw + 1/2))
 </pre>

 <p>and the rasterized fragment's centers are the half-integer window
 coordinates within the square of the rounded size centered at (x,
 y). All pixel fragments produced in rasterizing a nonantialiased
 point are assigned the same associated data, that of the vertex
 corresponding to the point.

 <p>If antialiasing is enabled, then point rasterization produces a
 fragment for each pixel square that intersects the region lying
 within the circle having diameter equal to the current point size
 and centered at the point's (xw, yw) . The coverage value for
 each fragment is the window coordinate area of the intersection
 of the circular region with the corresponding pixel square. This
 value is saved and used in the final rasterization step. The data
 associated with each fragment is the data associated with the
 point being rasterized.

 <p>Not all sizes are supported when point antialiasing is
 enabled. If an unsupported size is requested, the nearest
 supported size is used. Only size 1 is guaranteed to be
 supported; others depend on the implementation. To query the
 range of supported sizes, call <code>glGetIntegerv</code> with the argument
 <code>GL_SMOOTH_POINT_SIZE_RANGE</code>. For aliased points, query the
 supported ranges <code>glGetIntegerv</code> with the argument
 <code>GL_ALIASED_POINT_SIZE_RANGE</code>.

 <h4>Notes</h4>

 <p>A non-antialiased point size may be clamped to an
 implementation-dependent maximum. Although this maximum cannot be
 queried, it must be no less than the maximum value for
 antialiased points, rounded to the nearest integer value.

 <h4>Errors</h4>

 <p><code>GL_INVALID_VALUE</code> is generated if size is less
 than or equal to 0.

 <h4>Associated Gets</h4> 

 <p><code>glGetIntegerv</code> with argument
 <code>GL_ALIASED_POINT_SIZE_RANGE</code>

 <p><code>glGetIntegerv</code> with argument
 <code>GL_SMOOTH_POINT_SIZE_RANGE</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - Specifies the diameter of rasterized points. The
 initial value is 1.</DL>
</DD>
</DL>
<HR>

<A NAME="glPointSizex(int)"><!-- --></A><H3>
glPointSizex</H3>
<PRE>
public void <B>glPointSizex</B>(int&nbsp;size)</PRE>
<DL>
<DD>Fixed-point version of <code>glPointSize</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glPointSize(float)"><CODE>glPointSize(float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glPolygonOffset(float, float)"><!-- --></A><H3>
glPolygonOffset</H3>
<PRE>
public void <B>glPolygonOffset</B>(float&nbsp;factor,
                            float&nbsp;units)</PRE>
<DL>
<DD>Set the scale and units used to calculate depth values.

 <p>When <code>GL_POLYGON_OFFSET_FILL</code> is enabled, each
 fragment's depth value will be offset after it is interpolated
 from the depth values of the appropriate vertices. The value of
 the offset is m * factor + r * units, where m is a measurement of
 the change in depth relative to the screen area of the polygon,
 and r is the smallest value that is guaranteed to produce a
 resolvable offset for a given implementation. The offset is added
 before the depth test is performed and before the value is
 written into the depth buffer.

 <p><code>glPolygonOffset</code> is useful for for applying decals
 to surfaces.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>factor</CODE> - Specifies a scale factor that is used to create a
 variable depth offset for each polygon. The initial value is 0.<DD><CODE>units</CODE> - Is multiplied by an implementation-specific value to
 create a constant depth offset. The initial value is 0.</DL>
</DD>
</DL>
<HR>

<A NAME="glPolygonOffsetx(int, int)"><!-- --></A><H3>
glPolygonOffsetx</H3>
<PRE>
public void <B>glPolygonOffsetx</B>(int&nbsp;factor,
                             int&nbsp;units)</PRE>
<DL>
<DD>Fixed-point version of <code>glPolygonOffset</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glPolygonOffset(float, float)"><CODE>glPolygonOffset(float, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glPopMatrix()"><!-- --></A><H3>
glPopMatrix</H3>
<PRE>
public void <B>glPopMatrix</B>()</PRE>
<DL>
<DD>Pop the current matrix stack.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glPushMatrix()"><CODE>glPushMatrix()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glPushMatrix()"><!-- --></A><H3>
glPushMatrix</H3>
<PRE>
public void <B>glPushMatrix</B>()</PRE>
<DL>
<DD>Push the current matrix stack.

 <p>There is a stack of matrices for each of the matrix modes. In
 <code>GL_MODELVIEW</code> mode, the stack depth is at least
 16. In the other modes, <code>GL_PROJECTION</code>, and
 <code>GL_TEXTURE</code>, the depth is at least 2. The current
 matrix in any mode is the matrix on the top of the stack for that
 mode.

 <p><code>glPushMatrix</code> pushes the current matrix stack down
 by one, duplicating the current matrix. That is, after a
 glPushMatrix call, the matrix on top of the stack is identical to
 the one below it.

 <p><code>glPopMatrix</code> pops the current matrix stack,
 replacing the current matrix with the one below it on the stack.

 <p>Initially, each of the stacks contains one matrix, an identity matrix.

 <p>It is an error to push a full matrix stack, or to pop a matrix
 stack that contains only a single matrix. In either case, the
 error flag is set and no other change is made to GL state.

 <h4>Notes</h4>

 <p>Each texture unit has its own texture matrix stack. Use
 <code>glActiveTexture</code> to select the desired texture matrix stack.

 <h4>Errors</h4>

 <p><code>GL_STACK_OVERFLOW</code> is generated if
 <code>glPushMatrix</code> is called while the current matrix
 stack is full.

 <p><code>GL_STACK_UNDERFLOW</code> is generated if
 <code>glPopMatrix</code> is called while the current matrix stack
 contains only a single matrix.

 <h4>Associated Gets</h4> 

 <p><code>glGetIntegerv</code> with argument
 <code>GL_MAX_MODELVIEW_STACK_DEPTH</code>

 <p><code>glGetIntegerv</code> with argument
 <code>GL_MAX_PROJECTION_STACK_DEPTH</code>

 <p><code>glGetIntegerv</code> with argument
 <code>GL_MAX_TEXTURE_STACK_DEPTH</code>

 <p><code>glGetIntegerv</code> with argument
 <code>GL_MAX_TEXTURE_UNITS</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="glReadPixels(int, int, int, int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glReadPixels</H3>
<PRE>
public void <B>glReadPixels</B>(int&nbsp;x,
                         int&nbsp;y,
                         int&nbsp;width,
                         int&nbsp;height,
                         int&nbsp;format,
                         int&nbsp;type,
                         <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pixels)</PRE>
<DL>
<DD>Read a block of pixels from the color buffer.

 <p><code>glReadPixels</code> returns pixel data from the color
 buffer, starting with the pixel whose lower left corner is at
 location (x, y), into client memory starting at location
 pixels. The processing of the pixel data before it is placed into
 client memory can be controlled with <code>glPixelStore</code>.

 <p><code>glReadPixels</code> returns values from each pixel with
 lower left corner at <code>(x + i, y + j)</code> for <code>0 <=
 <i>i</i> < width</code> and <code>0 <= j < height</code>. This
 pixel is said to be the ith pixel in the jth row. Pixels are
 returned in row order from the lowest to the highest row, left to
 right in each row.

 <p><code>format</code> specifies the format of the returned pixel
 values. <code>GL_RGBA</code> is always accepted, the value of
 <code>GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES</code> may allow
 another format:

 <ul>

 <li><code>GL_RGBA</code></li>

 <p>Each color component is converted to floating point such that
 zero intensity maps to 0 and full intensity maps to 1.

 <li><code>GL_RGB</code></li>

 <p>Each element is an RGB triple. The GL converts it to floating
 point and assembles it into an RGBA element by attaching 1 for
 alpha.

 <li><code>GL_LUMINANCE</code></li>

 <p>Each element is a single luminance value. The GL converts it to
 floating point and assembles it into an RGBA element by
 replicating the luminance value three times for red, green and
 blue and attaching 1 for alpha.

 <li><code>GL_LUMINANCE_ALPHA</code></li>

 <p>Each element is a luminance/alpha pair. The GL converts it to
 floating point and assembles it into an RGBA element by
 replicating the luminance value three times for red, green and
 blue.

 <li><code>GL_ALPHA</code></li>

 <p>Each element is a single alpha component. The GL converts it to
 floating point and assembles it into an RGBA element by attaching
 0 for red, green and blue.

 </ul>

 <p>Unneeded data is then discarded. For example,
 <code>GL_ALPHA</code> discards the red, green, and blue
 components, while <code>GL_RGB</code> discards only the alpha
 component. <code>GL_LUMINANCE</code> computes a single-component
 value as the sum of the red, green, and blue components, and
 <code>GL_LUMINANCE_ALPHA</code> does the same, while keeping
 alpha as a second value. The final values are clamped to the
 range <code>[0, 1]</code>.

 <p>Finally, the components are converted to the proper, as specified
 by type where each component is multiplied by 2^n - 1, where n is
 the number of bits per component.

 <p>Return values are placed in memory as follows. If format is
 <code>GL_ALPHA</code>, or <code>GL_LUMINANCE</code>, a single
 value is returned and the data for the ith pixel in the jth row
 is placed in location j * width + i. <code>GL_RGB</code> returns
 three values, <code>GL_RGBA</code> returns four values, and
 <code>GL_LUMINANCE_ALPHA</code> returns two values for each
 pixel, with all values corresponding to a single pixel occupying
 contiguous space in pixels. Storage parameter
 <code>GL_PACK_ALIGNMENT</code> set by <code>glPixelStore</code>,
 affects the way that data is written into memory. See
 <code>glPixelStore</code> for a description.

 <h4>Notes</h4>

 <p>Values for pixels that lie outside the window connected to the
 current GL context are undefined.

 <p>If an error is generated, no change is made to the contents of pixels.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if format is not
 <code>GL_RGBA</code> or the value of
 <code>GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES</code>.

 <p><code>GL_INVALID_ENUM</code> is generated if type is not
 <code>GL_UNSIGNED_BYTE</code> or the value of
 <code>GL_IMPLEMENTATION_COLOR_READ_TYPE_OES</code>.

 <p><code>GL_INVALID_VALUE</code> is generated if either width or
 height is negative.

 <p><code>GL_INVALID_OPERATION</code> is generated if format and
 type are neither (<code>GL_RGBA</code>,
 <code>GL_UNSIGNED_BYTE)</code> nor the values of
 (<code>GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES</code>,
 <code>GL_IMPLEMENTATION_COLOR_READ_TYPE_OES)</code>.

 <h4>Associated Gets</h4> 

 <p><code>glGetIntegerv</code> with argument
 <code>GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES</code>

 <p><code>glGetIntegerv</code> with argument
 <code>GL_IMPLEMENTATION_COLOR_READ_TYPE_OES</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Specifies the window x coordinate of the first pixel
 that is read from the color buffer. This location is the lower
 left corner of a rectangular block of pixels.<DD><CODE>y</CODE> - Specifies the window y coordinate of the first pixel
 that is read from the color buffer. This location is the lower
 left corner of a rectangular block of pixels.<DD><CODE>width</CODE> - Specifies the width of the pixel
 rectangle. width and height of one correspond to a single pixel.<DD><CODE>height</CODE> - Specifies the height of the pixel
 rectangle. width and height of one correspond to a single pixel.<DD><CODE>format</CODE> - Specifies the format of the pixel data. Must be
 either <code>GL_RGBA</code> or the value of
 <code>GL_IMPLEMENTATION_COLOR_READ_FORMAT_OES</code>.<DD><CODE>type</CODE> - Specifies the data type of the pixel data. Must be
 either <code>GL_UNSIGNED_BYTE</code> or the value of
 <code>GL_IMPLEMENTATION_COLOR_READ_TYPE_OES</code>.<DD><CODE>pixels</CODE> - Returns the pixel data.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>pixels</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>pixels</code> does
 not contain enough room for the pixel data.</DL>
</DD>
</DL>
<HR>

<A NAME="glRotatef(float, float, float, float)"><!-- --></A><H3>
glRotatef</H3>
<PRE>
public void <B>glRotatef</B>(float&nbsp;angle,
                      float&nbsp;x,
                      float&nbsp;y,
                      float&nbsp;z)</PRE>
<DL>
<DD>Multiply the current matrix by a rotation matrix.

 <p><code>glRotate</code> produces a rotation of angle degrees
 around the vector (x, y, z) . The current matrix (see
 glMatrixMode) is multiplied by a rotation matrix with the product
 replacing the current matrix, as if <code>glMultMatrix</code>
 were called with the following matrix as its argument:

 <pre>
 ( x^2(1 - c) + c        xy (1 - c) - zs       xz (1 - c) + ys       0 )
 ( xy (1 - c) + zs       y^2(1 - c) + c        yz (1 - c) - xs       0 )
 ( xz (1 - c) - ys       yz (1 - c) + xs       z^2(1 - c) + c        0 )
 (         0                    0                     0              1 )
 </pre>

 <p>Where c = cos (angle), s = sin (angle), and ||(x, y, z)|| = 1,
 (if not, the GL will normalize this vector).

 <p>If the matrix mode is either <code>GL_MODELVIEW</code> or
 <code>GL_PROJECTION</code>, all objects drawn after
 <code>glRotate</code> is called are rotated. Use
 <code>glPushMatrix</code> and <code>glPopMatrix</code> to save
 and restore the unrotated coordinate system.

 <h4>Notes</h4>

 <p>This rotation follows the right-hand rule, so if the vector (x,
 y, z) points toward the user, the rotation will be
 counterclockwise.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>angle</CODE> - Specifies the angle of rotation, in degrees.<DD><CODE>x</CODE> - Specifies the x coordinate of a vector.<DD><CODE>y</CODE> - Specifies the y coordinate of a vector.<DD><CODE>z</CODE> - Specifies the z coordinate of a vector.</DL>
</DD>
</DL>
<HR>

<A NAME="glRotatex(int, int, int, int)"><!-- --></A><H3>
glRotatex</H3>
<PRE>
public void <B>glRotatex</B>(int&nbsp;angle,
                      int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;z)</PRE>
<DL>
<DD>Fixed-point version of <code>glRotate</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glRotatef(float, float, float, float)"><CODE>glRotatef(float, float, float, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glSampleCoverage(float, boolean)"><!-- --></A><H3>
glSampleCoverage</H3>
<PRE>
public void <B>glSampleCoverage</B>(float&nbsp;value,
                             boolean&nbsp;invert)</PRE>
<DL>
<DD>Specify mask to modify multisampled pixel fragments.

 <p><code>glSampleCoverage</code> defines a mask to modify the coverage of
 multisampled pixel fragments. This capability is used for
 antialiased screen-door transparency and smooth transitions
 between two renderings of an object (often for level-of-detail
 management in simulation systems).

 <p>When multisampling is enabled (see <code>glEnable</code> with
 argument <code>GL_MULTISAMPLE)</code> a ``fragment mask'' is
 computed for each fragment generated by a primitive. This mask
 reflects the amount of the pixel covered by the fragment, and
 determines the frame buffer samples that may be affected by the
 fragment.

 <p>If conversion of alpha values to masks is enabled
 (<code>glEnable</code> with argument
 <code>GL_SAMPLE_ALPHA_TO_MASK)</code>, the fragment alpha value
 is used to generate a temporary modification mask which is then
 ANDed with the fragment mask. One way to interpret this is as a
 form of dithering: a multivalued alpha (coverage or opacity) for
 the whole fragment is converted to simple binary values of
 coverage at many locations (the samples).

 <p>After conversion of alpha values to masks, if replacement of
 alpha values is enabled (<code>glEnable</code> with argument
 <code>GL_SAMPLE_ALPHA_TO_ONE)</code>, the fragment's alpha is set
 to the maximum allowable value.

 <p>Finally, if fragment mask modification is enabled
 (<code>glEnable</code> with argument
 <code>GL_SAMPLE_MASK)</code>, <code>glSampleCoverage</code>
 defines an additional modification mask. value is used to
 generate a modification mask in much the same way alpha was used
 above. If invert is <code>GL_TRUE</code>, then the modification
 mask specified by value will be inverted. The final modification
 mask will then be ANDed with the fragment mask resulting from the
 previous steps. This can be viewed as an ``override'' control
 that selectively fades the effects of multisampled fragments.

 <p>Note that <code>glSampleCoverage(value, GL_TRUE)</code> is not
 necessarily equivalent to <code>glSampleCoverage(1.0 - value,
 GL_FALSE)</code>; due to round-off and other issues, complementing
 the coverage will not necessarily yield an inverted modification
 mask.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - Specifies the coverage of the modification mask. The
 value is clamped to the range <code>[0, 1]</code>, where 0
 represents no coverage and 1 full coverage. The initial value is
 1.<DD><CODE>invert</CODE> - Specifies whether the modification mask implied by
 value is inverted or not. The initial value is <code>GL_FALSE</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glSampleCoveragex(int, boolean)"><!-- --></A><H3>
glSampleCoveragex</H3>
<PRE>
public void <B>glSampleCoveragex</B>(int&nbsp;value,
                              boolean&nbsp;invert)</PRE>
<DL>
<DD>Fixed-point version of <code>glSampleCoverage</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glSampleCoverage(float, boolean)"><CODE>glSampleCoverage(float, boolean)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glScalef(float, float, float)"><!-- --></A><H3>
glScalef</H3>
<PRE>
public void <B>glScalef</B>(float&nbsp;x,
                     float&nbsp;y,
                     float&nbsp;z)</PRE>
<DL>
<DD>Multiply the current matrix by a general scaling matrix.

 <p><code>glScale</code> produces a nonuniform scaling along the
 x, y, and z axes. The three parameters indicate the desired scale
 factor along each of the three axes.

 <p>The current matrix (see glMatrixMode) is multiplied by this scale
 matrix, and the product replaces the current matrix as if glScale
 were called with the following matrix as its argument:

 <pre> 
 ( x       0       0       0 )
 ( 0       y       0       0 )
 ( 0       0       z       0 )
 ( 0       0       0       1 )
 </pre> 

 <p>If the matrix mode is either <code>GL_MODELVIEW</code> or
 <code>GL_PROJECTION</code>, all objects drawn after
 <code>glScale</code> is called are scaled.

 <p>Use <code>glPushMatrix</code> and <code>glPopMatrix</code> to
 save and restore the unscaled coordinate system.

 <h4>Notes</h4>

 <p>If scale factors other than 1 are applied to the modelview matrix
 and lighting is enabled, lighting often appears wrong. In that
 case, enable automatic normalization of normals by calling
 <code>glEnable</code> with the argument <code>GL_NORMALIZE</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Specifies the scale factor along the x axis.<DD><CODE>y</CODE> - Specifies the scale factor along the y axis.<DD><CODE>z</CODE> - Specifies the scale factor along the z axis.</DL>
</DD>
</DL>
<HR>

<A NAME="glScalex(int, int, int)"><!-- --></A><H3>
glScalex</H3>
<PRE>
public void <B>glScalex</B>(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;z)</PRE>
<DL>
<DD>Fixed-point version of <code>glScale</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glScalef(float, float, float)"><CODE>glScalef(float, float, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glScissor(int, int, int, int)"><!-- --></A><H3>
glScissor</H3>
<PRE>
public void <B>glScissor</B>(int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;width,
                      int&nbsp;height)</PRE>
<DL>
<DD>Define the scissor box.

 <p><code>glScissor</code> defines a rectangle, called the scissor
 box, in window coordinates. The first two arguments, x and y,
 specify the lower left corner of the box. width and height
 specify the width and height of the box.

 <p>To enable and disable the scissor test, call
 <code>glEnable</code> and <code>glDisable</code> with argument
 <code>GL_SCISSOR_TEST</code>. The scissor test is initially
 disabled. While scissor test is enabled, only pixels that lie
 within the scissor box can be modified by drawing
 commands. Window coordinates have integer values at the shared
 corners of frame buffer pixels. glScissor(0, 0, 1, 1) allows
 modification of only the lower left pixel in the window, and
 glScissor(0, 0, 0, 0) doesn't allow modification of any pixels in
 the window.

 <p>When the scissor test is disabled, it is as though the scissor
 box includes the entire window.

 <h4>Errors</h4>

 <p><code>GL_INVALID_VALUE</code> is generated if either width or
 height is negative.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Specifies the x coordinate of the lower left corner
 of the scissor box, in pixels. The initial value is 0.<DD><CODE>y</CODE> - Specifies the y coordinate of the lower left corner
 of the scissor box, in pixels. The initial value is 0.<DD><CODE>width</CODE> - Specifies the width of the scissor box. When a GL
 context is first attached to a surface (e.g. window), width and
 height are set to the dimensions of that surface.<DD><CODE>height</CODE> - Specifies the height of the scissor box. When a GL
 context is first attached to a surface (e.g. window), width and
 height are set to the dimensions of that surface.</DL>
</DD>
</DL>
<HR>

<A NAME="glShadeModel(int)"><!-- --></A><H3>
glShadeModel</H3>
<PRE>
public void <B>glShadeModel</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Select flat or smooth shading.

 <p>GL primitives can have either flat or smooth shading. Smooth
 shading, the default, causes the computed colors of vertices to
 be interpolated as the primitive is rasterized, typically
 assigning different colors to each resulting pixel fragment. Flat
 shading selects the computed color of just one vertex and assigns
 it to all the pixel fragments generated by rasterizing a single
 primitive. In either case, the computed color of a vertex is the
 result of lighting if lighting is enabled, or it is the current
 color at the time the vertex was specified if lighting is
 disabled.

 <p>Flat and smooth shading are indistinguishable for
 points. Starting at the beginning of the vertex array and
 counting vertices and primitives from 1, the GL gives each
 flat-shaded line segment <i>i</i> the computed color of
 vertex <i>i</i> + 1, its second vertex. Counting similarly from 1,
 the GL gives each flat-shaded polygon the computed color of
 vertex <i>i</i> + 2, which is the last vertex to specify the
 polygon.

 <p>Flat and smooth shading are specified by
 <code>glShadeModel</code> with mode set to <code>GL_FLAT</code>
 and <code>GL_SMOOTH</code>, respectively.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if mode is any value
 other than <code>GL_FLAT</code> or <code>GL_SMOOTH</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - Specifies a symbolic value representing a shading
 technique. Accepted values are <code>GL_FLAT</code> and
 <code>GL_SMOOTH</code>. The initial value is
 <code>GL_SMOOTH</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glStencilFunc(int, int, int)"><!-- --></A><H3>
glStencilFunc</H3>
<PRE>
public void <B>glStencilFunc</B>(int&nbsp;func,
                          int&nbsp;ref,
                          int&nbsp;mask)</PRE>
<DL>
<DD>Set function and reference value for stencil testing.

 <p>Stenciling, like depth-buffering, enables and disables drawing on
 a per-pixel basis. You draw into the stencil planes using GL
 drawing primitives, then render geometry and images, using the
 stencil planes to mask out portions of the screen. Stenciling is
 typically used in multipass rendering algorithms to achieve
 special effects, such as decals, outlining, and constructive
 solid geometry rendering.

 <p>The stencil test conditionally eliminates a pixel based on the
 outcome of a comparison between the reference value and the value
 in the stencil buffer. To enable and disable stencil test, call
 <code>glEnable</code> and <code>glDisable</code> with argument
 <code>GL_STENCIL_TEST</code>. Stencil test is initially
 disabled. To specify actions based on the outcome of the stencil
 test, call <code>glStencilOp</code>.

 <p><code>func</code> is a symbolic constant that determines the
 stencil comparison function. It accepts one of eight values,
 shown in the following list. <code>ref</code> is an integer
 reference value that is used in the stencil comparison. It is
 clamped to the range <code>[0, 2^n - 1]</code>, where <i>n</i> is
 the number of bitplanes in the stencil buffer. <code>mask</code>
 is bitwise ANDed with both the reference value and the stored
 stencil value, with the ANDed values participating in the
 comparison.

 <p>If <code>stencil</code> represents the value stored in the
 corresponding stencil buffer location, the following list shows
 the effect of each comparison function that can be specified by
 func. Only if the comparison succeeds is the pixel passed through
 to the next stage in the rasterization process (see
 glStencilOp). All tests treat stencil values as unsigned integers
 in the range <code>[0, 2^n - 1]</code>, where <i>n</i> is the
 number of bitplanes in the stencil buffer.

 <p>The following values are accepted by <code>func</code>:

 <ul>

 <li><code>GL_NEVER</code></li>

 <p>Always fails.

 <li><code>GL_LESS</code></li>

 <p>Passes if (ref & mask) < (stencil & mask) .

 <li><code>GL_LEQUAL</code></li>

 <p>Passes if (ref & mask) <= (stencil & mask) .

 <li><code>GL_GREATER</code></li>

 <p>Passes if (ref & mask) > (stencil & mask) .

 <li><code>GL_GEQUAL</code></li>

 <p>Passes if (ref & mask) >= (stencil & mask) .

 <li><code>GL_EQUAL</code></li>

 <p>Passes if (ref & mask) == (stencil & mask) .

 <li><code>GL_NOTEQUAL</code></li>

 <p>Passes if (ref & mask) != (stencil & mask) .

 <li><code>GL_ALWAYS</code></li>

 <p>Always passes.

 </ul>
 
 <h4>Notes</h4>

 <p>Initially, the stencil test is disabled. If there is no stencil
 buffer, no stencil modification can occur and it is as if the
 stencil test always passes.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if func is not one
 of the eight accepted values.

 <h4>Associated Gets</h4> 

 <p><code>glGetIntegerv</code> with argument <code>GL_STENCIL_BITS</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>func</CODE> - Specifies the test function. Eight tokens are valid:
 <code>GL_NEVER</code>, <code>GL_LESS</code>,
 <code>GL_LEQUAL</code>, <code>GL_GREATER</code>,
 <code>GL_GEQUAL</code>, <code>GL_EQUAL</code>,
 <code>GL_NOTEQUAL</code>, and <code>GL_ALWAYS</code>. The initial
 value is <code>GL_ALWAYS</code>.<DD><CODE>ref</CODE> - Specifies the reference value for the stencil
 test. <code>ref</code> is clamped to the range <code>[0, 2^n -
 1]</code>, where <i>n</i> is the number of bitplanes in the
 stencil buffer. The initial value is 0.<DD><CODE>mask</CODE> - Specifies a mask that is ANDed with both the
 reference value and the stored stencil value when the test is
 done. The initial value is all 1's.</DL>
</DD>
</DL>
<HR>

<A NAME="glStencilMask(int)"><!-- --></A><H3>
glStencilMask</H3>
<PRE>
public void <B>glStencilMask</B>(int&nbsp;mask)</PRE>
<DL>
<DD>Control the writing of individual bits in the stencil planes.

 <p><code>glStencilMask</code> controls the writing of individual
 bits in the stencil planes. The least significant n bits of mask,
 where n is the number of bits in the stencil buffer, specify a
 mask. Where a 1 appears in the mask, it's possible to write to
 the corresponding bit in the stencil buffer. Where a 0 appears,
 the corresponding bit is write-protected. Initially, all bits are
 enabled for writing.

 <h4>Associated Gets</h4> 

 <p><code>glGetIntegerv</code> with argument <code>GL_STENCIL_BITS</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mask</CODE> - Specifies a bit mask to enable and disable writing of
 individual bits in the stencil planes. The initial value is all
 1's.</DL>
</DD>
</DL>
<HR>

<A NAME="glStencilOp(int, int, int)"><!-- --></A><H3>
glStencilOp</H3>
<PRE>
public void <B>glStencilOp</B>(int&nbsp;fail,
                        int&nbsp;zfail,
                        int&nbsp;zpass)</PRE>
<DL>
<DD>Set stencil test actions.

 <p>Stenciling, like depth-buffering, enables and disables drawing on
 a per-pixel basis. You draw into the stencil planes using GL
 drawing primitives, then render geometry and images, using the
 stencil planes to mask out portions of the screen. Stenciling is
 typically used in multipass rendering algorithms to achieve
 special effects, such as decals, outlining, and constructive
 solid geometry rendering.

 <p>The stencil test conditionally eliminates a pixel based on the
 outcome of a comparison between the value in the stencil buffer
 and a reference value. To enable and disable stencil test, call
 <code>glEnable</code> and <code>glDisable</code> with argument
 <code>GL_STENCIL_TEST</code>. To control it, call
 <code>glStencilFunc</code>. Stenciling is initially disabled.

 <p><code>glStencilOp</code> takes three arguments that indicate
 what happens to the stored stencil value while stenciling is
 enabled. If the stencil test fails, no change is made to the
 pixel's color or depth buffers, and fail specifies what happens
 to the stencil buffer contents. The following six actions are
 possible.

 <ul>

 <li><code>GL_KEEP</code></li>

 <p>Keeps the current value.

 <li><code>GL_ZERO</code></li>

 <p>Sets the stencil buffer value to 0.

 <li><code>GL_REPLACE</code></li>

 <p>Sets the stencil buffer value to ref, as specified by
 <code>glStencilFunc</code>.

 <li><code>GL_INCR</code></li>

 <p>Increments the current stencil buffer value. Clamps to the
 maximum representable unsigned value.

 <li><code>GL_DECR</code></li>

 <p>Decrements the current stencil buffer value. Clamps to 0.

 <li><code>GL_INVERT</code></li>

 <p>Bitwise inverts the current stencil buffer value.

 <--
 <li>(<code>OES_stencil_wrap</code> extension)
 <code>GL_DECR_WRAP</code></li>

 <p>Decrements the current stencil buffer value, wrapping around
 to the maximum representable unsigned value if less than 0.

 <li>(<code>OES_stencil_wrap</code> extension)
 <code>GL_INCR</code></li>

 <p>Increments the current stencil buffer value, wrapping around
 to 0 if greater than the maximum representable unsigned value.
 -->

 </ul>

 <p>Stencil buffer values are treated as unsigned integers. When
 incremented and decremented, values are clamped to 0 and 2^n - 1,
 where n is the value returned by querying <code>GL_STENCIL_BITS</code>.

 <p>The other two arguments to <code>glStencilOp</code> specify
 stencil buffer actions that depend on whether subsequent depth
 buffer tests succeed (<code>zpass</code>) or fail
 (<code>zfail</code>) (see <code>glDepthFunc</code>). The actions
 are specified using the same six symbolic constants as
 <code>fail</code>. Note that <code>zfail</code> is ignored when
 there is no depth buffer, or when the depth buffer is not
 enabled. In these cases, <code>fail</code> and <code>zpass</code>
 specify stencil action when the stencil test fails and passes,
 respectively.

 <h4>Notes</h4>

 <p>If there is no stencil buffer, no stencil modification can occur
 and it is as if the stencil tests always pass, regardless of any
 call to <code>glStencilOp</code>.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if fail, zfail, or
 zpass is any value other than the six defined constant values.

 <h4>Associated Gets</h4> 

 <p><code>glGetIntegerv</code> with argument <code>GL_STENCIL_BITS</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fail</CODE> - Specifies the action to take when the stencil test
 fails. Six symbolic constants are accepted: <code>GL_KEEP</code>,
 <code>GL_ZERO</code>, <code>GL_REPLACE</code>,
 <code>GL_INCR</code>, <code>GL_DECR</code>, and
 <code>GL_INVERT</code> <!-- <code>GL_INCR_WRAP</code>
 (<code>OES_stencil_wrap</code> extension), and
 <code>GL_DECR_WRAP</code> (<code>OES_stencil_wrap</code>
 extension) -->. The initial value is <code>GL_KEEP</code>.<DD><CODE>zfail</CODE> - Specifies the stencil action when the stencil test
 passes, but the depth test fails. <code>zfail</code> accepts the
 same symbolic constants as <code>fail</code>. The initial value
 is <code>GL_KEEP</code>.<DD><CODE>zpass</CODE> - Specifies the stencil action when both the stencil
 test and the depth test pass, or when the stencil test passes and
 either there is no depth buffer or depth testing is not
 enabled. <code>zpass</code> accepts the same symbolic constants
 as <code>fail</code>. The initial value is <code>GL_KEEP</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glTexCoordPointer(int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glTexCoordPointer</H3>
<PRE>
public void <B>glTexCoordPointer</B>(int&nbsp;size,
                              int&nbsp;type,
                              int&nbsp;stride,
                              <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pointer)</PRE>
<DL>
<DD>Define an array of texture coordinates.

 <p><code>glTexCoordPointer</code> specifies the location and data
 of an array of texture coordinates to use when rendering. size
 specifies the number of coordinates per element, and must be 2,
 3, or 4. type specifies the data type of each texture coordinate
 and stride specifies the byte stride from one array element to
 the next allowing vertices and attributes to be packed into a
 single array or stored in separate arrays. (Single-array storage
 may be more efficient on some implementations.)

 <p>When a texture coordinate array is specified, size, type, stride,
 and pointer are saved as client-side state.

 <p>If the texture coordinate array is enabled, it is used when
 <code>glDrawArrays</code>, or <code>glDrawElements</code> is
 called. To enable and disable the texture coordinate array for
 the client-side active texture unit, call
 <code>glEnableClientState</code> and
 <code>glDisableClientState</code> with the argument
 <code>GL_TEXTURE_COORD_ARRAY</code>. The texture coordinate array
 is initially disabled for all client-side active texture units
 and isn't accessed when <code>glDrawArrays</code> or
 <code>glDrawElements</code> is called.

 <p>Use <code>glDrawArrays</code> to construct a sequence of
 primitives (all of the same type) from prespecified vertex and
 vertex attribute arrays. Use <code>glDrawElements</code> to
 construct a sequence of primitives by indexing vertices and
 vertex attributes.

 <h4>Notes</h4>

 <p><code>glTexCoordPointer</code> is typically implemented on the
 client side.

 <p><code>glTexCoordPointer</code> updates the texture coordinate
 array state of the client-side active texture unit, specified
 with <code>glClientActiveTexture</code>.

 <h4>Errors</h4>

 <p><code>GL_INVALID_VALUE</code> is generated if size is not 2, 3, or 4.

 <p><code>GL_INVALID_ENUM</code> is generated if type is not an
 accepted value.

 <p><code>GL_INVALID_VALUE</code> is generated if stride is negative.

 <p> The <code>pointer</code> argument must be a direct buffer
 with a type matching that specified by the <code>type</code>
 argument.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - Specifies the number of coordinates per array
 element. Must be 2, 3 or 4. The initial value is 4.<DD><CODE>type</CODE> - Specifies the data type of each texture
 coordinate. Symbolic constants <code>GL_BYTE</code>,
 <code>GL_SHORT</code>, <code>GL_FIXED</code>,and
 <code>GL_FLOAT</code> are accepted. The initial value is
 <code>GL_FLOAT</code>.<DD><CODE>stride</CODE> - Specifies the byte offset between consecutive array
 elements. If stride is 0, the array elements are understood to be
 tightly packed. The initial value is 0.<DD><CODE>pointer</CODE> - Specifies a pointer to the first coordinate of the
 first element in the array. The initial value is 0.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if OpenGL ES 1.1 is being used and
 VBOs are enabled.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>pointer</code> is
 <code>null</code> or is not direct.</DL>
</DD>
</DL>
<HR>

<A NAME="glTexEnvf(int, int, float)"><!-- --></A><H3>
glTexEnvf</H3>
<PRE>
public void <B>glTexEnvf</B>(int&nbsp;target,
                      int&nbsp;pname,
                      float&nbsp;param)</PRE>
<DL>
<DD>Set texture environment parameters.

 <p>If <code>target</code> is <code>GL_TEXTURE_ENV</code>, then
 the following applies:

 <p>A texture environment specifies how texture values are
 interpreted when a fragment is textured. <code>target</code> must
 be <code>GL_TEXTURE_ENV</code>. <code>pname</code> can be either
 <code>GL_TEXTURE_ENV_MODE</code> or
 <code>GL_TEXTURE_ENV_COLOR</code>.

 <p>If <code>pname</code> is <code>GL_TEXTURE_ENV_MODE</code>,
 then <code>params</code> contains the symbolic name of a texture
 function. Four texture functions may be specified:
 <code>GL_MODULATE</code>, <code>GL_DECAL</code>,
 <code>GL_BLEND</code>, and <code>GL_REPLACE</code>.

 <p>A texture function acts on the fragment to be textured using
 the texture image value that applies to the fragment (see
 <code>glTexParameter</code>) and produces an RGBA color for that
 fragment. The following table shows how the RGBA color is
 produced for each of the three texture functions that can be
 chosen. <i>C</i> is a triple of color values (RGB) and <i>A</i>
 is the associated alpha value. RGBA values extracted from a
 texture image are in the range <code>[0, 1]</code>. The subscript
 <i>f</i> refers to the incoming fragment, the subscript <i>t</i>
 to the texture image, the subscript <i>c</i> to the texture
 environment color, and subscript <i>v</i> indicates a value
 produced by the texture function.

 <p>A texture image can have up to four components per texture
 element (see <code>glTexImage2D</code>, and
 <code>glCopyTexImage2D</code>). In a one-component image,
 <i>Lt</i> indicates that single component. A two-component image
 uses <i>Lt</i> and <i>At</i>. A three-component image has only a
 color value, <i>Ct</i>. A four-component image has both a color
 value <i>Ct</i> and an alpha value <i>At</i>.

 <p>For texture functions: <code>GL_REPLACE</code>,
 <code>GL_MODULATE</code>, <code>GL_DECAL</code>,
 <code>GL_BLEND</code>, or <code>GL_ADD</code>:

 <pre>
 Base internal          Texture functions
 format                 GL_MODULATE                GL_DECAL

 <p>GL_ALPHA               Cv = Cf                    undefined
                        Av = Af*At      

 <p>GL_LUMINANCE           Cv = Cf*Lt                 undefined
                        Av = Af         

 <p>GL_LUMINANCE_ALPHA     Cv = Cf*Lt                 undefined
                        Av = Af*At      

 <p>GL_RGB                 Cv = Cf*Ct                 Cv = Ct
                        Av = Af                    Av = Af

 <p>GL_RGBA                Cv = Cf*Ct                 Cv = Cf*(1 - At) + Ct*At
                        Av = Af*At                 Av = Af

 <p>Base internal          Texture functions
 format                 GL_BLEND                   GL_REPLACE

 <p>GL_ALPHA               Cv = Cf                    Cv = Cf
                        Av = Af*At                 Av = At

 <p>GL_LUMINANCE           Cv = Cf*(1 - Lt) + Cc*Lt   Cv = Lt
                        Av = Af                    Av = Af

 <p>GL_LUMINANCE_ALPHA     Cv = Cf*(1 - Lt) + Cc*Lt   Cv = Lt
                        Av = Af*At                 Av = At

 <p>GL_RGB                 Cv = Cf*(1 - Ct) + Cc*Ct   Cv = Ct
                        Av = Af                    Av = Af

 <p>GL_RGBA                Cv = Cf*(1 - Ct) + Cc*Ct   Cv = Ct
                        Av = Af*At                 Av = At

 <p>Base internal          Texture functions
 format                 GL_ADD

 <p>GL_ALPHA               Cv = Cf
                        Av = Af*At

 <p>GL_LUMINANCE           Cv = Cf + Lt
                        Av = Af

 <p>GL_LUMINANCE_ALPHA     Cv = Cf + Lt
                        Av = Af*At

 <p>GL_RGB                 Cv = Cf + Ct
                        Av = Af

 <p>GL_RGBA                Cv = Cf + Ct
                        Av = Af*At
 </pre>

 <p>If <code>pname</code> is <code>GL_TEXTURE_ENV_COLOR</code>,
 <code>params</code> is a pointer to an array that holds an RGBA
 color consisting of four values. The values are clamped to the
 range <code>[0, 1]</code> when they are specified. <i>Cc</i>
 takes these four values.

 <p>The initial value of <code>GL_TEXTURE_ENV_MODE</code> is
 <code>GL_MODULATE</code>. The initial value of
 <code>GL_TEXTURE_ENV_COLOR</code> is (0, 0, 0, 0).

 <h4>1.1 Notes</h4>

 <p> If the value of <code>GL_TEXTURE_ENV_MODE</code> is
 <code>GL_COMBINE</code>, then the form of the texture function
 depends on the values of <code>GL_COMBINE_RGB</code> and
 <code>GL_COMBINE_ALPHA</code>.

 <p>The RGB and ALPHA results of the texture function are then
 multiplied by the values of <code>GL_RGB_SCALE</code> and
 <code>GL_ALPHA_SCALE</code>, respectively.

 <p>The results are clamped to <code>[0, 1]</code>.

 <p>The arguments <i>Arg0</i>, <i>Arg1</i>, <i>Arg2</i> are
 determined by the values of
 <code>GL_SRC</code><i>n</i><code>_RGB</code>,
 <code>GL_SRC</code><i>n</i><code>_ALPHA</code>,
 <code>GL_OPERAND</code><i>n</i><code>_RGB</code>,
 <code>GL_OPERAND</code><i>n</i><code>_ALPHA</code>, where
 <i>n</i> = 0, 1, or 2, <i>Cs</i> and <i>As</i> denote the texture
 source color and alpha from the texture image bound to texture
 unit <i>n</i>.

 <p>The state required for the current texture environment, for
 each texture unit, consists of a six-valued integer indicating
 the texture function, an eight-valued integer indicating the RGB
 combiner function and a six-valued integer indicating the ALPHA
 combiner function, six four-valued integers indicating the
 combiner RGB and ALPHA source arguments, three four-valued
 integers indicating the combiner RGB operands, three two-valued
 integers indicating the combiner ALPHA operands, and four
 floating-point environment color values. In the initial state,
 the texture and combiner functions are each
 <code>GL_MODULATE</code>, the combiner RGB and ALPHA sources are
 each <code>GL_TEXTURE</code>, <code>GL_PREVIOUS</code>, and
 <code>GL_CONSTANT</code> for sources 0, 1, and 2 respectively,
 the combiner RGB operands for sources 0 and 1 are each
 <code>SRC_COLOR</code>, the combiner RGB operand for source 2, as
 well as for the combiner ALPHA operands, are each
 <code>GL_SRC_ALPHA</code>, and the environment color is (0, 0, 0,
 0).

 <p>The state required for the texture filtering parameters, for
 each texture unit, consists of a single floating-point level of
 detail bias. The initial value of the bias is 0.0.

 <p>If <code>pname</code> is <code>GL_TEXTURE_ENV_COLOR</code>,
 then <code>params</code> is an array that holds an RGBA color
 consisting of four values. The values are clamped to the range
 <code>[0, 1]</code> when they are specified. <i>Cc</i> takes
 these four values.

 <p>The initial value of <code>GL_TEXTURE_ENV_MODE</code> is
 <code>GL_MODULATE</code>. The initial value of
 <code>GL_TEXTURE_ENV_COLOR</code> is (0, 0, 0, 0).

 <p>If <code>target</code> is <code>GL_POINT_SPRITE_OES</code>
 then the following applies:

 <p>If <code>pname</code> is <code>GL_COORD_REPLACE_OES</code>,
 then the point sprite texture coordinate replacement mode is set
 from the value given by param, which may either be
 <code>GL_FALSE</code> or <code>GL_TRUE</code>. The default value
 for each texture unit is for point sprite texture coordinate
 replacement to be disabled.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated when target or pname
 is not one of the accepted values, or when <code>params</code>
 should have a defined constant value (based on the value of
 <code>pname</code>) and does not.

 <h4>Associated Gets (1.1 only)</h4>

 <p><code>glGetTexEnv</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies a texture environment. Can be either
 <code>GL_TEXTURE_ENV</code> or <code>GL_POINT_SPRITE_OES</code>
 (<code>OES_point_sprite</code> extension).<DD><CODE>pname</CODE> - Specifies the symbolic name of a single-valued
 texture environment parameter. Must be one of
 <code>GL_TEXTURE_ENV_MODE</code>,
 <code>GL_TEXTURE_ENV_COLOR</code> (1.1 only),
 <code>GL_COMBINE_RGB</code> (1.1 only),
 <code>GL_COMBINE_ALPHA</code> (1.1 only), or
 <code>GL_COORD_REPLACE_OES</code> (<code>OES_point_sprite</code>
 extension).<DD><CODE>param</CODE> - Specifies a single symbolic constant, one of
 <code>GL_REPLACE</code>, <code>GL_MODULATE</code>,
 <code>GL_DECAL</code>, <code>GL_BLEND</code>, or
 <code>GL_ADD</code> (1.1 only).</DL>
</DD>
</DL>
<HR>

<A NAME="glTexEnvfv(int, int, float[], int)"><!-- --></A><H3>
glTexEnvfv</H3>
<PRE>
public void <B>glTexEnvfv</B>(int&nbsp;target,
                       int&nbsp;pname,
                       float[]&nbsp;params,
                       int&nbsp;offset)</PRE>
<DL>
<DD>Set texture environment parameters (array version).

 <p>A texture environment specifies how texture values are
 interpreted when a fragment is textured. <code>target</code> must
 be <code>GL_TEXTURE_ENV</code>. <code>pname</code> can be either
 <code>GL_TEXTURE_ENV_MODE</code> or
 <code>GL_TEXTURE_ENV_COLOR</code>.

 <p>If <code>pname</code> is <code>GL_TEXTURE_ENV_MODE</code>,
 then <code>params</code> contains the symbolic name of a texture
 function. Four texture functions may be specified:
 <code>GL_MODULATE</code>, <code>GL_DECAL</code>,
 <code>GL_BLEND</code>, and <code>GL_REPLACE</code>.

 <p>A texture function acts on the fragment to be textured using
 the texture image value that applies to the fragment (see
 <code>glTexParameter</code>) and produces an RGBA color for that
 fragment. The following table shows how the RGBA color is
 produced for each of the three texture functions that can be
 chosen. C is a triple of color values (RGB) and A is the
 associated alpha value. RGBA values extracted from a texture
 image are in the range <code>[0, 1]</code>. The subscript
 <i>f</i> refers to the incoming fragment, the subscript <i>t</i>
 to the texture image, the subscript <i>c</i> to the texture
 environment color, and subscript <i>v</i> indicates a value
 produced by the texture function.

 <p>A texture image can have up to four components per texture
 element (see <code>glTexImage2D</code>, and
 <code>glCopyTexImage2D</code>). In a one-component image,
 <i>Lt</i> indicates that single component. A two-component image
 uses <i>Lt</i> and <i>At</i>. A three-component image has only a
 color value, <i>Ct</i>. A four-component image has both a color
 value <i>Ct</i> and an alpha value <i>At</i>.

 <pre>
 Base internal          Texture functions
 format                 GL_MODULATE                GL_DECAL

 <p>GL_ALPHA               Cv = Cf                    undefined
                        Av = At Af      

 <p>GL_LUMINANCE           Cv = Lt Cf                 undefined
                        Av = Af         

 <p>GL_LUMINANCE_ALPHA     Cv = Lt Cf                 undefined
                        Av = At Af      

 <p>GL_RGB                 Cv = Ct Cf                 Cv = Ct
                        Av = Af                    Av = Af

 <p>GL_RGBA                Cv = Ct Cf                 Cv = (1 - At) Cf + At Ct
                        Av = At Af                 Av = Af

 <p>Base internal          Texture functions
 format                 GL_BLEND                   GL_REPLACE

 <p>GL_ALPHA               Cv = Cf                    Cv = Cf
                        Av = At Af                 Av = At

 <p>GL_LUMINANCE           Cv = (1 - Lt) Cf + Lt Cc   Cv = Lt
                        Av = Af                    Av = Af

 <p>GL_LUMINANCE_ALPHA     Cv = (1 - Lt) Cf + Lt Cc   Cv = Lt
                        Av = At Af                 Av = At

 <p>GL_RGB                 Cv = (1 - Ct) Cf + Ct Cc   Cv = Ct
                        Av = Af                    Av = Af

 <p>GL_RGBA                Cv = (1 - Ct) Cf + Ct Cc   Cv = Ct
                        Av = At Af                 Av = At
 </pre>

 <p>If <code>pname</code> is <code>GL_TEXTURE_ENV_COLOR</code>,
 <code>params</code> holds an RGBA color consisting of four
 values. The values are clamped to the range <code>[0, 1]</code>
 when they are specified. <i>Cc</i> takes these four values.

 <p>The initial value of <code>GL_TEXTURE_ENV_MODE</code> is
 <code>GL_MODULATE</code>. The initial value of
 <code>GL_TEXTURE_ENV_COLOR</code> is (0, 0, 0, 0).

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated when target or pname
 is not one of the accepted values, or when <code>params</code>
 should have a defined constant value (based on the value of
 <code>pname</code>) and does not.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies a texture environment. Must be
 <code>GL_TEXTURE_ENV</code>.<DD><CODE>pname</CODE> - Specifies the symbolic name of a texture environment
 parameter. Accepted values are <code>GL_TEXTURE_ENV_MODE</code> and
 <code>GL_TEXTURE_ENV_COLOR</code>.<DD><CODE>params</CODE> - Specifies a parameter array that contains either a
 single symbolic constant or an RGBA color.<DD><CODE>offset</CODE> - the starting offset within the
 <code>params</code> array.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params.length -
 offset</code> is smaller than the number of values required by
 the parameter.</DL>
</DD>
</DL>
<HR>

<A NAME="glTexEnvfv(int, int, java.nio.FloatBuffer)"><!-- --></A><H3>
glTexEnvfv</H3>
<PRE>
public void <B>glTexEnvfv</B>(int&nbsp;target,
                       int&nbsp;pname,
                       <A HREF="../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Floating-point <code>Buffer</code> version of <code>glTexEnv</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if
 <code>params.remaining()</code> is smaller than the number of
 values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexEnvfv(int, int, float[], int)"><CODE>glTexEnvfv(int target, int pname, float[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glTexEnvx(int, int, int)"><!-- --></A><H3>
glTexEnvx</H3>
<PRE>
public void <B>glTexEnvx</B>(int&nbsp;target,
                      int&nbsp;pname,
                      int&nbsp;param)</PRE>
<DL>
<DD>Fixed-point version of <code>glTexEnv</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexEnvf(int, int, float)"><CODE>glTexEnvf(int target, int pname, float param)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glTexEnvxv(int, int, int[], int)"><!-- --></A><H3>
glTexEnvxv</H3>
<PRE>
public void <B>glTexEnvxv</B>(int&nbsp;target,
                       int&nbsp;pname,
                       int[]&nbsp;params,
                       int&nbsp;offset)</PRE>
<DL>
<DD>Fixed-point array version of <code>glTexEnv</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>offset</code> is
 less than 0.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params.length -
 offset</code> is smaller than the number of values required by
 the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexEnvfv(int, int, float[], int)"><CODE>glTexEnvfv(int target, int pname, float[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glTexEnvxv(int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glTexEnvxv</H3>
<PRE>
public void <B>glTexEnvxv</B>(int&nbsp;target,
                       int&nbsp;pname,
                       <A HREF="../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Fixed-point <code>Buffer</code> version of <code>glTexEnv</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>params</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if
 <code>params.remaining()</code> is smaller than the number of
 values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexEnvfv(int, int, float[], int)"><CODE>glTexEnvfv(int target, int pname, float[] params, int offset)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glTexImage2D</H3>
<PRE>
public void <B>glTexImage2D</B>(int&nbsp;target,
                         int&nbsp;level,
                         int&nbsp;internalformat,
                         int&nbsp;width,
                         int&nbsp;height,
                         int&nbsp;border,
                         int&nbsp;format,
                         int&nbsp;type,
                         <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pixels)</PRE>
<DL>
<DD>Specify a two-dimensional texture image.

 <p>Texturing maps a portion of a specified texture image onto
 each graphical primitive for which texturing is enabled. To
 enable and disable two-dimensional texturing, call
 <code>glEnable</code> and glDisable with argument
 <code>GL_TEXTURE_2D</code>. Two-dimensional texturing is
 initially disabled.

 <p>To define texture images, call <code>glTexImage2D</code>. The arguments
 describe the parameters of the texture image, such as height,
 width, width of the border, level-of-detail number (see
 glTexParameter), and number of color components provided. The
 last three arguments describe how the image is represented in
 memory.

 <p>Data is read from pixels as a sequence of unsigned bytes or
 shorts, depending on type. These values are grouped into sets of
 one, two, three, or four values, depending on format, to form
 elements.

 <p>When type is <code>GL_UNSIGNED_BYTE</code>, each of these
 bytes is interpreted as one color component, depending on
 format. When type is one of <code>GL_UNSIGNED_SHORT_5_6_5</code>,
 <code>GL_UNSIGNED_SHORT_4_4_4_4</code>,
 <code>GL_UNSIGNED_SHORT_5_5_5_1</code>, each unsigned value is
 interpreted as containing all the components for a single pixel,
 with the color components arranged according to format.

 <p>The first element corresponds to the lower left corner of the
 texture image. Subsequent elements progress left-to-right through
 the remaining texels in the lowest row of the texture image, and
 then in successively higher rows of the texture image. The final
 element corresponds to the upper right corner of the texture
 image.

 <p>By default, adjacent pixels are taken from adjacent memory
 locations, except that after all width pixels are read, the read
 pointer is advanced to the next four-byte boundary. The four-byte
 row alignment is specified by <code>glPixelStore</code> with argument
 <code>GL_UNPACK_ALIGNMENT</code>, and it can be set to one, two, four, or
 eight bytes.

 <p>format determines the composition of each element in pixels. It
 can assume one of the following symbolic values:

 <ul>

 <li><code>GL_ALPHA</code></li>

 <p>Each element is a single alpha component. The GL converts it to
 floating point and assembles it into an RGBA element by attaching
 0 for red, green, and blue.

 <li><code>GL_RGB</code></li>

 <p>Each element is an RGB triple. The GL converts it to fixed-point
 or floating-point and assembles it into an RGBA element by
 attaching 1 for alpha.

 <li><code>GL_RGBA</code></li>

 <p>Each element contains all four components. The GL converts it to
 fixed-point or floating-point.

 <li><code>GL_LUMINANCE</code></li>

 <p>Each element is a single luminance value. The GL converts it to
 fixed-point or floating-point, then assembles it into an RGBA
 element by replicating the luminance value three times for red,
 green, and blue and attaching 1 for alpha.

 <li><code>GL_LUMINANCE_ALPHA</code></li>

 <p>Each element is a luminance/alpha pair. The GL converts it to
 fixed-point or floating point, then assembles it into an RGBA
 element by replicating the luminance value three times for red,
 green, and blue.
 
 </ul>

 <h4>Notes</h4>

 <p>pixels may be NULL. In this case texture memory is allocated to
 accommodate a texture of width width and height height. You can
 then download subtextures to initialize this texture memory. The
 image is undefined if the user tries to apply an uninitialized
 portion of the texture image to a primitive.

 <p><code>glTexImage2D</code> specifies the two-dimensional texture for the
 currently bound texture specified with <code>glBindTexture</code>, and the
 current texture unit, specified with <code>glActiveTexture</code>.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if target is not
 <code>GL_TEXTURE_2D</code>.

 <p><code>GL_INVALID_ENUM</code> is generated if format is not an
 accepted constant.

 <p><code>GL_INVALID_ENUM</code> is generated if type is not a
 type constant.

 <p><code>GL_INVALID_VALUE</code> is generated if level is less
 than 0.

 <p><code>GL_INVALID_VALUE</code> may be generated if level is
 greater than log2max, where max is the returned value of
 <code>GL_MAX_TEXTURE_SIZE</code>.

 <p><code>GL_INVALID_VALUE</code> is generated if internalformat
 is not an accepted constant.

 <p><code>GL_INVALID_VALUE</code> is generated if width or height
 is less than 0 or greater than <code>GL_MAX_TEXTURE_SIZE</code>,
 or if either cannot be represented as 2^k + 2*border for some
 integer k.

 <p><code>GL_INVALID_VALUE</code> is generated if border is not 0.

 <p><code>GL_INVALID_OPERATION</code> is generated if
 internalformat and format are not the same.

 <p><code>GL_INVALID_OPERATION</code> is generated if type is
 <code>GL_UNSIGNED_SHORT_5_6_5</code> and format is not
 <code>GL_RGB</code>.

 <p><code>GL_INVALID_OPERATION</code> is generated if typeis one
 of <code>GL_UNSIGNED_SHORT_4_4_4_4</code>, or
 <code>GL_UNSIGNED_SHORT_5_5_5_1</code> and formatis not
 <code>GL_RGBA</code>.

 <h4>Associated Gets</h4> 

 <p><code>glGetIntegerv</code> with argument
 <code>GL_MAX_TEXTURE_SIZE</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture. Must be
 <code>GL_TEXTURE_2D</code>.<DD><CODE>level</CODE> - Specifies the level-of-detail number. Level 0 is the
 base image level. Level n is the nth mipmap reduction image. Must
 be greater or equal 0.<DD><CODE>internalformat</CODE> - Specifies the color components in the
 texture. Must be same as format. The following symbolic values
 are accepted: <code>GL_ALPHA</code>, <code>GL_RGB</code>,
 <code>GL_RGBA</code>, <code>GL_LUMINANCE</code>, or
 <code>GL_LUMINANCE_ALPHA</code>.<DD><CODE>width</CODE> - Specifies the width of the texture image. Must be
 2^n + 2*border for some integer n. All implementations support
 texture images that are at least 64 texels wide.<DD><CODE>height</CODE> - Specifies the height of the texture image. Must be
 2^m + 2*border for some integer m. All implementations support
 texture images that are at least 64 texels high.<DD><CODE>border</CODE> - Specifies the width of the border. Must be 0.<DD><CODE>format</CODE> - Specifies the format of the pixel data. Must be
 same as internalformat. The following symbolic values are
 accepted: <code>GL_ALPHA</code>, <code>GL_RGB</code>,
 <code>GL_RGBA</code>, <code>GL_LUMINANCE</code>, and
 <code>GL_LUMINANCE_ALPHA</code>.<DD><CODE>type</CODE> - Specifies the data type of the pixel data. The
 following symbolic values are accepted:
 <code>GL_UNSIGNED_BYTE</code>,
 <code>GL_UNSIGNED_SHORT_5_6_5</code>,
 <code>GL_UNSIGNED_SHORT_4_4_4_4</code>, and
 <code>GL_UNSIGNED_SHORT_5_5_5_1</code>.<DD><CODE>pixels</CODE> - Specifies a pointer to the image data in memory.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>pixels</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>pixels</code> does
 not contain the desired number of pixels.</DL>
</DD>
</DL>
<HR>

<A NAME="glTexParameterf(int, int, float)"><!-- --></A><H3>
glTexParameterf</H3>
<PRE>
public void <B>glTexParameterf</B>(int&nbsp;target,
                            int&nbsp;pname,
                            float&nbsp;param)</PRE>
<DL>
<DD>Set texture parameters.

 <p>Texture mapping is a technique that applies an image onto an
 object's surface as if the image were a decal or cellophane
 shrink-wrap. The image is created in texture space, with an (s,
 t) coordinate system. A texture is a one- or two-dimensional
 image and a set of parameters that determine how samples are
 derived from the image.

 <p><code>glTexParameter</code> assigns the value or values in
 <code>param</code> to the texture parameter specified as
 <code>pname</code>. <code>target</code> defines the target
 texture, which must be <code>GL_TEXTURE_2D</code>. The following
 symbols are accepted in <code>pname</code>:

 <ul>

 <li><code>GL_TEXTURE_MIN_FILTER</code></li>

 <p>The texture minifying function is used whenever the pixel being
 textured maps to an area greater than one texture element. There
 are six defined minifying functions. Two of them use the nearest
 one or nearest four texture elements to compute the texture
 value. The other four use mipmaps.

 <p>A mipmap is an ordered set of arrays representing the same image
 at progressively lower resolutions. If the texture has dimensions
 2^n  2^m, there are max (n, m) + 1 mipmaps. The first mipmap is
 the original texture, with dimensions 2^n  2^m. Each subsequent
 mipmap has dimensions 2^(k - 1)  2^(l - 1), where 2^k  2^l are
 the dimensions of the previous mipmap, until either k = 0 or l =
 0. At that point, subsequent mipmaps have dimension 1  2^(l - 1)
 or 2^(k - 1)  1 until the final mipmap, which has dimension 1 
 1. To define the mipmaps, call <code>glTexImage2D</code> or
 glCopyTexImage2D with the level argument indicating the order of
 the mipmaps. Level 0 is the original texture. Level max (n, m) is
 the final 1  1 mipmap.

 <p><code>param</code> supplies a function for minifying the
 texture as one of the following:
 
 <ul>
 <li><code>GL_NEAREST</code></li>

 <p>Returns the value of the texture element that is nearest (in
 Manhattan distance) to the center of the pixel being textured.

 <li><code>GL_LINEAR</code></li>

 <p>Returns the weighted average of the four texture elements that
 are closest to the center of the pixel being textured. These can
 include border texture elements, depending on the values of
 <code>GL_TEXTURE_WRAP_S</code> and
 <code>GL_TEXTURE_WRAP_T</code>, and on the exact mapping.

 <li><code>GL_NEAREST_MIPMAP_NEAREST</code></li>

 <p>Chooses the mipmap that most closely matches the size of the
 pixel being textured and uses the <code>GL_NEAREST</code>
 criterion (the texture element nearest to the center of the
 pixel) to produce a texture value.

 <li><code>GL_LINEAR_MIPMAP_NEAREST</code></li>

 <p>Chooses the mipmap that most closely matches the size of the
 pixel being textured and uses the <code>GL_LINEAR</code>
 criterion (a weighted average of the four texture elements that
 are closest to the center of the pixel) to produce a texture
 value.

 <li><code>GL_NEAREST_MIPMAP_LINEAR</code></li>

 <p>Chooses the two mipmaps that most closely match the size of the
 pixel being textured and uses the <code>GL_NEAREST</code> criterion (the
 texture element nearest to the center of the pixel) to produce a
 texture value from each mipmap. The final texture value is a
 weighted average of those two values.

 <li><code>GL_LINEAR_MIPMAP_LINEAR</code></li>

 <p>Chooses the two mipmaps that most closely match the size of the
 pixel being textured and uses the <code>GL_LINEAR</code>
 criterion (a weighted average of the four texture elements that
 are closest to the center of the pixel) to produce a texture
 value from each mipmap. The final texture value is a weighted
 average of those two values.

 </ul>

 <p>As more texture elements are sampled in the minification process,
 fewer aliasing artifacts will be apparent. While the
 <code>GL_NEAREST</code> and <code>GL_LINEAR</code> minification
 functions can be faster than the other four, they sample only one
 or four texture elements to determine the texture value of the
 pixel being rendered and can produce moire patterns or ragged
 transitions.

 <p>The initial value of <code>GL_TEXTURE_MIN_FILTER</code> is
 <code>GL_NEAREST_MIPMAP_LINEAR</code>.

 <li><code>GL_TEXTURE_MAG_FILTER</code></li>

 <p>The texture magnification function is used when the pixel being
 textured maps to an area less than or equal to one texture
 element. It sets the texture magnification function to either
 <code>GL_NEAREST</code> or <code>GL_LINEAR</code> (see
 below). <code>GL_NEAREST</code> is generally faster than
 <code>GL_LINEAR</code>, but it can produce textured images with
 sharper edges because the transition between texture elements is
 not as smooth.

 <p>The initial value of <code>GL_TEXTURE_MAG_FILTER</code> is
 <code>GL_LINEAR</code>.

 <li><code>GL_NEAREST</code></li>

 <p>Returns the value of the texture element that is nearest (in
 Manhattan distance) to the center of the pixel being textured.

 <li><code>GL_LINEAR</code></li>

 <p>Returns the weighted average of the four texture elements that
 are closest to the center of the pixel being textured. These can
 include border texture elements, depending on the values of
 <code>GL_TEXTURE_WRAP_S</code> and
 <code>GL_TEXTURE_WRAP_T</code>, and on the exact mapping.

 <li><code>GL_TEXTURE_WRAP_S</code></li>

 <p>Sets the wrap parameter for texture coordinate <i>s</i> to
 either <code>GL_CLAMP</code>, <code>GL_CLAMP_TO_EDGE</code>, or
 <code>GL_REPEAT</code> <!-- , or <code>GL_MIRRORED_REPEAT</code>
 (<code>OES_texture_mirrored_repeat</code>
 extension) -->. <code>GL_CLAMP</code> causes <i>s</i> coordinates to
 be clamped to the range <code>[0, 1]</code> and is useful for
 preventing wrapping artifacts when mapping a single image onto an
 object. <code>GL_CLAMP_TO_EDGE</code> causes <i>s</i> coordinates
 to be clamped to the range <code>[1/(2<i>N</i>), 1 -
 1/(2<i>N</i>)]</code>, where <i>N</i> is the size of the texture
 in the direction of clamping. <code>GL_REPEAT</code> causes the
 integer part of the <i>s</i> coordinate to be ignored; the GL
 uses only the fractional part, thereby creating a repeating
 pattern. Border texture elements are accessed only if wrapping is
 set to <code>GL_CLAMP</code>.

 <p>Initially, <code>GL_TEXTURE_WRAP_S</code> is set to
 <code>GL_REPEAT</code>.

 <li><code>GL_TEXTURE_WRAP_T</code></li>

 <p>Sets the wrap parameter for texture coordinate <i>t</i> to
 either <code>GL_CLAMP</code>, <code>GL_CLAMP_TO_EDGE</code>, or
 <code>GL_REPEAT</code> <!-- , or <code>GL_MIRRORED_REPEAT</code>
 (<code>OES_texture_mirrored_repeat</code> extension) -->. See the
 discussion under <code>GL_TEXTURE_WRAP_S</code>.

 <p>Initially, <code>GL_TEXTURE_WRAP_T</code> is set to
 <code>GL_REPEAT</code>.

 <li><code>GL_GENERATE_MIPMAP</code> (1.1 only)</li>

 <p>Sets the automatic mipmap generation parameter. If set to
 <code>GL_TRUE</code>, making any change to the interior or border
 texels of the levelbase array of a mipmap will also compute a
 complete set of mipmap arrays derived from the modified levelbase
 array. Array levels <i>levelbase + 1</i> through <i>p</i> are
 replaced with the derived arrays, regardless of their previous
 contents. All other mipmap arrays, including the levelbase array,
 are left unchanged by this computation.

 <p>The initial value of <code>GL_GENERATE_MIPMAP</code> is
 <code>GL_FALSE</code>.

 </ul>

 <h4>Notes</h4>

 <p>Suppose that a program has enabled texturing (by calling
 glEnable with argument <code>GL_TEXTURE_2D</code> and has set
 <code>GL_TEXTURE_MIN_FILTER</code> to one of the functions that
 requires a mipmap. If either the dimensions of the texture images
 currently defined (with previous calls to
 <code>glTexImage2D</code>, or glCopyTexImage2D) do not follow the
 proper sequence for mipmaps (described above), or there are fewer
 texture images defined than are needed, or the set of texture
 images have differing numbers of texture components, then it is
 as if texture mapping were disabled.

 <p>Linear filtering accesses the four nearest texture elements.

 <p><code>glTexParameter</code> specifies the texture parameters
 for the active texture unit, specified by calling
 <code>glActiveTexture</code>.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if target or pname
 is not one of the accepted defined values.

 <p><code>GL_INVALID_ENUM</code> is generated if param should have
 a defined constant value (based on the value of pname) and does
 not.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture, which must be 
 <code>GL_TEXTURE_2D</code>.<DD><CODE>pname</CODE> - Specifies the symbolic name of a single-valued
 texture parameter. <code>pname</code> can be one of the
 following: <code>GL_TEXTURE_MIN_FILTER</code>,
 <code>GL_TEXTURE_MAG_FILTER</code>,
 <code>GL_TEXTURE_WRAP_S</code>, <code>GL_TEXTURE_WRAP_T</code>, or
 <code>GL_GENERATE_MIPMAP</code> (1.1 only) <!--, or
 <code>GL_TEXTURE_CROP_RECT_OES</code>
 (<code>OES_draw_texture</code> extension) -->.<DD><CODE>param</CODE> - Specifies the value of <code>pname</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="glTexParameterx(int, int, int)"><!-- --></A><H3>
glTexParameterx</H3>
<PRE>
public void <B>glTexParameterx</B>(int&nbsp;target,
                            int&nbsp;pname,
                            int&nbsp;param)</PRE>
<DL>
<DD>Fixed-point version of <code>glTexParameter</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTexParameterf(int, int, float)"><CODE>glTexParameterf(int target, int pname, float param)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glTexSubImage2D</H3>
<PRE>
public void <B>glTexSubImage2D</B>(int&nbsp;target,
                            int&nbsp;level,
                            int&nbsp;xoffset,
                            int&nbsp;yoffset,
                            int&nbsp;width,
                            int&nbsp;height,
                            int&nbsp;format,
                            int&nbsp;type,
                            <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pixels)</PRE>
<DL>
<DD>Specify a two-dimensional texture subimage.

 <p>Texturing maps a portion of a specified texture image onto
 each graphical primitive for which texturing is enabled. To
 enable and disable two-dimensional texturing, call
 <code>glEnable</code> and glDisable with argument
 <code>GL_TEXTURE_2D</code>. Two-dimensional texturing is
 initially disabled.

 <p><code>glTexSubImage2D</code> redefines a contiguous subregion
 of an existing two-dimensional texture image. The texels
 referenced by pixels replace the portion of the existing texture
 array with x indices xoffset and xoffset + width - 1, inclusive,
 and y indices yoffset and yoffset + height - 1, inclusive. This
 region may not include any texels outside the range of the
 texture array as it was originally specified. It is not an error
 to specify a subtexture with zero width or height, but such a
 specification has no effect.

 <h4>Notes</h4>

 <p><code>glPixelStore</code> affects texture images in exactly
 the way it affects <code>glTexImage2D</code>.

 <p><code>glTexSubImage2D</code> specifies a two-dimensional sub
 texture for the currently bound texture, specified with
 <code>glBindTexture</code> and current texture unit, specified
 with <code>glActiveTexture</code>.

 <h4>Errors</h4>

 <p><code>GL_INVALID_ENUM</code> is generated if target is not
 <code>GL_TEXTURE_2D</code>.

 <p><code>GL_INVALID_OPERATION</code> is generated if the texture
 array has not been defined by a previous
 <code>glTexImage2D</code> or glCopyTexImage2D operation.

 <p><code>GL_INVALID_VALUE</code> is generated if level is less
 than 0.

 <p><code>GL_INVALID_VALUE</code> may be generated if level is
 greater than log2max, where max is the returned value of
 <code>GL_MAX_TEXTURE_SIZE</code>.

 <p><code>GL_INVALID_VALUE</code> is generated if xoffset < - b,
 xoffset + width > (w - b) , yoffset < - b, or yoffset + height >
 (h - b) , where w is the texture width, h is the texture height,
 and b is the border of the texture image being modified. Note
 that w and h include twice the border width.

 <p><code>GL_INVALID_VALUE</code> is generated if width or height
 is less than 0.

 <p><code>GL_INVALID_ENUM</code> is generated if format is not an
 accepted constant.

 <p><code>GL_INVALID_ENUM</code> is generated if type is not a
 type constant.

 <p><code>GL_INVALID_OPERATION</code> is generated if type is
 <code>GL_UNSIGNED_SHORT_5_6_5</code> and format is not
 <code>GL_RGB</code>.

 <p><code>GL_INVALID_OPERATION</code> is generated if type is one
 of <code>GL_UNSIGNED_SHORT_4_4_4_4</code>, or
 <code>GL_UNSIGNED_SHORT_5_5_5_1</code> and format is not
 <code>GL_RGBA</code>.

 <h4>Associated Gets</h4> 

 <p><code>glGetIntegerv</code> with argument
 <code>GL_MAX_TEXTURE_SIZE</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture. Must be
 <code>GL_TEXTURE_2D</code>.<DD><CODE>level</CODE> - Specifies the level-of-detail number. Level 0 is the
 base image level. Level n is the nth mipmap reduction image.<DD><CODE>xoffset</CODE> - Specifies a texel offset in the x direction within
 the texture array.<DD><CODE>yoffset</CODE> - Specifies a texel offset in the y direction within
 the texture array.<DD><CODE>width</CODE> - Specifies the width of the texture subimage.<DD><CODE>height</CODE> - Specifies the height of the texture subimage.<DD><CODE>format</CODE> - Specifies the of the pixel data. The following
 symbolic values are accepted: <code>GL_ALPHA</code>,
 <code>GL_RGB</code>, <code>GL_RGBA</code>,
 <code>GL_LUMINANCE</code>, and <code>GL_LUMINANCE_ALPHA</code>.<DD><CODE>type</CODE> - Specifies the data type of the pixel data. The
 following symbolic values are accepted:
 <code>GL_UNSIGNED_BYTE</code>,
 <code>GL_UNSIGNED_SHORT_5_6_5</code>,
 <code>GL_UNSIGNED_SHORT_4_4_4_4</code>, and
 <code>GL_UNSIGNED_SHORT_5_5_5_1</code>.<DD><CODE>pixels</CODE> - Specifies the image data.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>pixels</code> is
 <code>null</code>.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>pixels</code> does
 not contain the desired number of pixels.</DL>
</DD>
</DL>
<HR>

<A NAME="glTranslatef(float, float, float)"><!-- --></A><H3>
glTranslatef</H3>
<PRE>
public void <B>glTranslatef</B>(float&nbsp;x,
                         float&nbsp;y,
                         float&nbsp;z)</PRE>
<DL>
<DD>Multiply the current matrix by a translation matrix.

 <p><code>glTranslate</code> produces a translation by (x, y, z).
 The current matrix (see glMatrixMode) is multiplied by this
 translation matrix, with the product replacing the current
 matrix, as if <code>glMultMatrix</code> were called with the
 following matrix for its argument:

 <pre>
 ( 1       0       0       x )
 ( 0       1       0       y )
 ( 0       0       1       z )
 ( 0       0       0       1 )
 </pre>

 <p>If the matrix mode is either <code>GL_MODELVIEW</code> or
 <code>GL_PROJECTION</code>, all objects drawn after a call to
 <code>glTranslate</code> are translated.

 <p>Use <code>glPushMatrix</code> and <code>glPopMatrix</code> to
 save and restore the untranslated coordinate system.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Specifies the x coordinate of a translation vector.<DD><CODE>y</CODE> - Specifies the y coordinate of a translation vector.<DD><CODE>z</CODE> - Specifies the z coordinate of a translation vector.</DL>
</DD>
</DL>
<HR>

<A NAME="glTranslatex(int, int, int)"><!-- --></A><H3>
glTranslatex</H3>
<PRE>
public void <B>glTranslatex</B>(int&nbsp;x,
                         int&nbsp;y,
                         int&nbsp;z)</PRE>
<DL>
<DD>Fixed-point version of <code>glTranslate</code>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../javax/microedition/khronos/opengles/GL10.html#glTranslatef(float, float, float)"><CODE>glTranslatef(float, float, float)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="glVertexPointer(int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glVertexPointer</H3>
<PRE>
public void <B>glVertexPointer</B>(int&nbsp;size,
                            int&nbsp;type,
                            int&nbsp;stride,
                            <A HREF="../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pointer)</PRE>
<DL>
<DD>Define an array of vertex coordinates.

 <p><code>glVertexPointer</code> specifies the location and data
 of an array of vertex coordinates to use when
 rendering. <code>size</code> specifies the number of coordinates
 per vertex and type the data type of the
 coordinates. <code>stride</code> specifies the byte stride from
 one vertex to the next allowing vertices and attributes to be
 packed into a single array or stored in separate
 arrays. (Single-array storage may be more efficient on some
 implementations.)

 <p>When a vertex array is specified, <code>size</code>,
 <code>type</code>, <code>stride</code>, and <code>pointer</code>
 are saved as client-side state.

 <p>If the vertex array is enabled, it is used when
 <code>glDrawArrays</code>, or <code>glDrawElements</code> is
 called. To enable and disable the vertex array, call
 <code>glEnableClientState</code> and
 <code>glDisableClientState</code> with the argument
 <code>GL_VERTEX_ARRAY</code>. The vertex array is initially
 disabled and isn't accessed when <code>glDrawArrays</code> or
 <code>glDrawElements</code> is called.

 <p>Use <code>glDrawArrays</code> to construct a sequence of
 primitives (all of the same type) from prespecified vertex and
 vertex attribute arrays. Use <code>glDrawElements</code> to
 construct a sequence of primitives by indexing vertices and
 vertex attributes.

 <h4>Notes</h4>

 <p><code>glVertexPointer</code> is typically implemented on the
 client side.

 <h4>Errors</h4>

 <p><code>GL_INVALID_VALUE</code> is generated if size is not 2,
 3, or 4.

 <p><code>GL_INVALID_ENUM</code> is generated if type is is not an
 accepted value.

 <p><code>GL_INVALID_VALUE</code> is generated if stride is
 negative.

 <p> The <code>pointer</code> argument must be a direct buffer
 with a type matching that specified by the <code>type</code>
 argument.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>size</CODE> - Specifies the number of coordinates per vertex. Must
 be 2, 3, or 4. The initial value is 4.<DD><CODE>type</CODE> - Specifies the data type of each vertex coordinate in
 the array. Symbolic constants <code>GL_BYTE</code>,
 <code>GL_SHORT</code>, <code>GL_FIXED</code>, and
 <code>GL_FLOAT</code> are accepted. The initial value is
 <code>GL_FLOAT</code>.<DD><CODE>stride</CODE> - Specifies the byte offset between consecutive
 vertices. If stride is 0, the vertices are understood to be
 tightly packed in the array. The initial value is 0.<DD><CODE>pointer</CODE> - Specifies a Buffer containing the coordinates of
 the vertices.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - if OpenGL ES 1.1 is being used and
 VBOs are enabled.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>pointer</code>
 is not direct.</DL>
</DD>
</DL>
<HR>

<A NAME="glViewport(int, int, int, int)"><!-- --></A><H3>
glViewport</H3>
<PRE>
public void <B>glViewport</B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height)</PRE>
<DL>
<DD>Set the viewport.

 <p><code>glViewport</code> specifies the affine transformation of
 x and y from normalized device coordinates to window
 coordinates. Let (xnd, ynd) be normalized device
 coordinates. Then the window coordinates (xw, yw) are computed as
 follows:

 <pre>
 xw = ( xnd + 1 ) width/2 + x
 yw = ( ynd + 1 ) height/2 + y
 </pre>

 <p>Viewport width and height are silently clamped to a range that
 depends on the implementation. To query this range, call
 <code>glGetIntegerv</code> with argument
 <code>GL_MAX_VIEWPORT_DIMS</code>.

 <h4>Errors</h4>

 <p><code>GL_INVALID_VALUE</code> is generated if either width or
 height is negative.

 <h4>Associated Gets</h4> 

 <p><code>glGetIntegerv</code> with argument
 <code>GL_MAX_VIEWPORT_DIMS</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Specifies the x coordinate of the lower left corner of
 the viewport rectangle, in pixels. The initial value is 0.<DD><CODE>y</CODE> - Specifies the y coordinate of the lower left corner of
 the viewport rectangle, in pixels. The initial value is 0.<DD><CODE>width</CODE> - Specifies the width of the viewport. When a GL
 context is first attached to a surface (e.g. window), width and
 height are set to the dimensions of that surface.<DD><CODE>height</CODE> - Specifies the height of the viewport. When a GL
 context is first attached to a surface (e.g. window), width and
 height are set to the dimensions of that surface.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GL10.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<font size=-1>Final Release, Oct 2006</font></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../javax/microedition/khronos/opengles/GL.html" title="interface in javax.microedition.khronos.opengles"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../javax/microedition/khronos/opengles/GL10Ext.html" title="interface in javax.microedition.khronos.opengles"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GL10.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size=-1>                This specification is protected under the JSPA version 2.6.<br>                Copyright &copy; 2006 Sun Microsystems, Inc. 4150 Network Circle, California, 95054, U.S.A.<br>                All Rights Reserved.                 Use is subject to <A href=../../../../LICENSE.txt>license</a> terms.</font>
<small>Copyright &copy; 2007 Sun Microsystems, Inc. All rights reserved. <b>Use is subject to <a href="http://java.sun.com/javame/reference/apis/license.html" target="_top">License Terms</a>.</b> Your use of this web site or any of its content or software indicates your agreement to be bound by these License Terms.<br><br>For more information, please consult the <a href="http://jcp.org/en/jsr/detail?id=239" target="_top">JSR 239 specification.</a></small></BODY>
</HTML>
