<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_04) on Thu Nov 24 17:40:25 EST 2011 -->
<TITLE>
GL20 (BlackBerry JDE 7.1.0 API Reference)
</TITLE>

<META NAME="keywords" CONTENT="net.rim.device.api.opengles.GL20 interface">
<META NAME="keywords" CONTENT="GL_ES_VERSION_2_0">
<META NAME="keywords" CONTENT="GL_DEPTH_BUFFER_BIT">
<META NAME="keywords" CONTENT="GL_STENCIL_BUFFER_BIT">
<META NAME="keywords" CONTENT="GL_COLOR_BUFFER_BIT">
<META NAME="keywords" CONTENT="GL_FALSE">
<META NAME="keywords" CONTENT="GL_TRUE">
<META NAME="keywords" CONTENT="GL_POINTS">
<META NAME="keywords" CONTENT="GL_LINES">
<META NAME="keywords" CONTENT="GL_LINE_LOOP">
<META NAME="keywords" CONTENT="GL_LINE_STRIP">
<META NAME="keywords" CONTENT="GL_TRIANGLES">
<META NAME="keywords" CONTENT="GL_TRIANGLE_STRIP">
<META NAME="keywords" CONTENT="GL_TRIANGLE_FAN">
<META NAME="keywords" CONTENT="GL_ZERO">
<META NAME="keywords" CONTENT="GL_ONE">
<META NAME="keywords" CONTENT="GL_SRC_COLOR">
<META NAME="keywords" CONTENT="GL_ONE_MINUS_SRC_COLOR">
<META NAME="keywords" CONTENT="GL_SRC_ALPHA">
<META NAME="keywords" CONTENT="GL_ONE_MINUS_SRC_ALPHA">
<META NAME="keywords" CONTENT="GL_DST_ALPHA">
<META NAME="keywords" CONTENT="GL_ONE_MINUS_DST_ALPHA">
<META NAME="keywords" CONTENT="GL_DST_COLOR">
<META NAME="keywords" CONTENT="GL_ONE_MINUS_DST_COLOR">
<META NAME="keywords" CONTENT="GL_SRC_ALPHA_SATURATE">
<META NAME="keywords" CONTENT="GL_FUNC_ADD">
<META NAME="keywords" CONTENT="GL_BLEND_EQUATION">
<META NAME="keywords" CONTENT="GL_BLEND_EQUATION_RGB">
<META NAME="keywords" CONTENT="GL_BLEND_EQUATION_ALPHA">
<META NAME="keywords" CONTENT="GL_FUNC_SUBTRACT">
<META NAME="keywords" CONTENT="GL_FUNC_REVERSE_SUBTRACT">
<META NAME="keywords" CONTENT="GL_BLEND_DST_RGB">
<META NAME="keywords" CONTENT="GL_BLEND_SRC_RGB">
<META NAME="keywords" CONTENT="GL_BLEND_DST_ALPHA">
<META NAME="keywords" CONTENT="GL_BLEND_SRC_ALPHA">
<META NAME="keywords" CONTENT="GL_CONSTANT_COLOR">
<META NAME="keywords" CONTENT="GL_ONE_MINUS_CONSTANT_COLOR">
<META NAME="keywords" CONTENT="GL_CONSTANT_ALPHA">
<META NAME="keywords" CONTENT="GL_ONE_MINUS_CONSTANT_ALPHA">
<META NAME="keywords" CONTENT="GL_BLEND_COLOR">
<META NAME="keywords" CONTENT="GL_ARRAY_BUFFER">
<META NAME="keywords" CONTENT="GL_ELEMENT_ARRAY_BUFFER">
<META NAME="keywords" CONTENT="GL_ARRAY_BUFFER_BINDING">
<META NAME="keywords" CONTENT="GL_ELEMENT_ARRAY_BUFFER_BINDING">
<META NAME="keywords" CONTENT="GL_STREAM_DRAW">
<META NAME="keywords" CONTENT="GL_STATIC_DRAW">
<META NAME="keywords" CONTENT="GL_DYNAMIC_DRAW">
<META NAME="keywords" CONTENT="GL_BUFFER_SIZE">
<META NAME="keywords" CONTENT="GL_BUFFER_USAGE">
<META NAME="keywords" CONTENT="GL_CURRENT_VERTEX_ATTRIB">
<META NAME="keywords" CONTENT="GL_FRONT">
<META NAME="keywords" CONTENT="GL_BACK">
<META NAME="keywords" CONTENT="GL_FRONT_AND_BACK">
<META NAME="keywords" CONTENT="GL_TEXTURE_2D">
<META NAME="keywords" CONTENT="GL_CULL_FACE">
<META NAME="keywords" CONTENT="GL_BLEND">
<META NAME="keywords" CONTENT="GL_DITHER">
<META NAME="keywords" CONTENT="GL_STENCIL_TEST">
<META NAME="keywords" CONTENT="GL_DEPTH_TEST">
<META NAME="keywords" CONTENT="GL_SCISSOR_TEST">
<META NAME="keywords" CONTENT="GL_POLYGON_OFFSET_FILL">
<META NAME="keywords" CONTENT="GL_SAMPLE_ALPHA_TO_COVERAGE">
<META NAME="keywords" CONTENT="GL_SAMPLE_COVERAGE">
<META NAME="keywords" CONTENT="GL_NO_ERROR">
<META NAME="keywords" CONTENT="GL_INVALID_ENUM">
<META NAME="keywords" CONTENT="GL_INVALID_VALUE">
<META NAME="keywords" CONTENT="GL_INVALID_OPERATION">
<META NAME="keywords" CONTENT="GL_OUT_OF_MEMORY">
<META NAME="keywords" CONTENT="GL_CW">
<META NAME="keywords" CONTENT="GL_CCW">
<META NAME="keywords" CONTENT="GL_LINE_WIDTH">
<META NAME="keywords" CONTENT="GL_ALIASED_POINT_SIZE_RANGE">
<META NAME="keywords" CONTENT="GL_ALIASED_LINE_WIDTH_RANGE">
<META NAME="keywords" CONTENT="GL_CULL_FACE_MODE">
<META NAME="keywords" CONTENT="GL_FRONT_FACE">
<META NAME="keywords" CONTENT="GL_DEPTH_RANGE">
<META NAME="keywords" CONTENT="GL_DEPTH_WRITEMASK">
<META NAME="keywords" CONTENT="GL_DEPTH_CLEAR_VALUE">
<META NAME="keywords" CONTENT="GL_DEPTH_FUNC">
<META NAME="keywords" CONTENT="GL_STENCIL_CLEAR_VALUE">
<META NAME="keywords" CONTENT="GL_STENCIL_FUNC">
<META NAME="keywords" CONTENT="GL_STENCIL_FAIL">
<META NAME="keywords" CONTENT="GL_STENCIL_PASS_DEPTH_FAIL">
<META NAME="keywords" CONTENT="GL_STENCIL_PASS_DEPTH_PASS">
<META NAME="keywords" CONTENT="GL_STENCIL_REF">
<META NAME="keywords" CONTENT="GL_STENCIL_VALUE_MASK">
<META NAME="keywords" CONTENT="GL_STENCIL_WRITEMASK">
<META NAME="keywords" CONTENT="GL_STENCIL_BACK_FUNC">
<META NAME="keywords" CONTENT="GL_STENCIL_BACK_FAIL">
<META NAME="keywords" CONTENT="GL_STENCIL_BACK_PASS_DEPTH_FAIL">
<META NAME="keywords" CONTENT="GL_STENCIL_BACK_PASS_DEPTH_PASS">
<META NAME="keywords" CONTENT="GL_STENCIL_BACK_REF">
<META NAME="keywords" CONTENT="GL_STENCIL_BACK_VALUE_MASK">
<META NAME="keywords" CONTENT="GL_STENCIL_BACK_WRITEMASK">
<META NAME="keywords" CONTENT="GL_VIEWPORT">
<META NAME="keywords" CONTENT="GL_SCISSOR_BOX">
<META NAME="keywords" CONTENT="GL_COLOR_CLEAR_VALUE">
<META NAME="keywords" CONTENT="GL_COLOR_WRITEMASK">
<META NAME="keywords" CONTENT="GL_UNPACK_ALIGNMENT">
<META NAME="keywords" CONTENT="GL_PACK_ALIGNMENT">
<META NAME="keywords" CONTENT="GL_MAX_TEXTURE_SIZE">
<META NAME="keywords" CONTENT="GL_MAX_VIEWPORT_DIMS">
<META NAME="keywords" CONTENT="GL_SUBPIXEL_BITS">
<META NAME="keywords" CONTENT="GL_RED_BITS">
<META NAME="keywords" CONTENT="GL_GREEN_BITS">
<META NAME="keywords" CONTENT="GL_BLUE_BITS">
<META NAME="keywords" CONTENT="GL_ALPHA_BITS">
<META NAME="keywords" CONTENT="GL_DEPTH_BITS">
<META NAME="keywords" CONTENT="GL_STENCIL_BITS">
<META NAME="keywords" CONTENT="GL_POLYGON_OFFSET_UNITS">
<META NAME="keywords" CONTENT="GL_POLYGON_OFFSET_FACTOR">
<META NAME="keywords" CONTENT="GL_TEXTURE_BINDING_2D">
<META NAME="keywords" CONTENT="GL_SAMPLE_BUFFERS">
<META NAME="keywords" CONTENT="GL_SAMPLES">
<META NAME="keywords" CONTENT="GL_SAMPLE_COVERAGE_VALUE">
<META NAME="keywords" CONTENT="GL_SAMPLE_COVERAGE_INVERT">
<META NAME="keywords" CONTENT="GL_NUM_COMPRESSED_TEXTURE_FORMATS">
<META NAME="keywords" CONTENT="GL_COMPRESSED_TEXTURE_FORMATS">
<META NAME="keywords" CONTENT="GL_DONT_CARE">
<META NAME="keywords" CONTENT="GL_FASTEST">
<META NAME="keywords" CONTENT="GL_NICEST">
<META NAME="keywords" CONTENT="GL_GENERATE_MIPMAP_HINT">
<META NAME="keywords" CONTENT="GL_BYTE">
<META NAME="keywords" CONTENT="GL_UNSIGNED_BYTE">
<META NAME="keywords" CONTENT="GL_SHORT">
<META NAME="keywords" CONTENT="GL_UNSIGNED_SHORT">
<META NAME="keywords" CONTENT="GL_INT">
<META NAME="keywords" CONTENT="GL_UNSIGNED_INT">
<META NAME="keywords" CONTENT="GL_FLOAT">
<META NAME="keywords" CONTENT="GL_FIXED">
<META NAME="keywords" CONTENT="GL_DEPTH_COMPONENT">
<META NAME="keywords" CONTENT="GL_ALPHA">
<META NAME="keywords" CONTENT="GL_RGB">
<META NAME="keywords" CONTENT="GL_RGBA">
<META NAME="keywords" CONTENT="GL_LUMINANCE">
<META NAME="keywords" CONTENT="GL_LUMINANCE_ALPHA">
<META NAME="keywords" CONTENT="GL_UNSIGNED_SHORT_4_4_4_4">
<META NAME="keywords" CONTENT="GL_UNSIGNED_SHORT_5_5_5_1">
<META NAME="keywords" CONTENT="GL_UNSIGNED_SHORT_5_6_5">
<META NAME="keywords" CONTENT="GL_FRAGMENT_SHADER">
<META NAME="keywords" CONTENT="GL_VERTEX_SHADER">
<META NAME="keywords" CONTENT="GL_MAX_VERTEX_ATTRIBS">
<META NAME="keywords" CONTENT="GL_MAX_VERTEX_UNIFORM_VECTORS">
<META NAME="keywords" CONTENT="GL_MAX_VARYING_VECTORS">
<META NAME="keywords" CONTENT="GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS">
<META NAME="keywords" CONTENT="GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS">
<META NAME="keywords" CONTENT="GL_MAX_TEXTURE_IMAGE_UNITS">
<META NAME="keywords" CONTENT="GL_MAX_FRAGMENT_UNIFORM_VECTORS">
<META NAME="keywords" CONTENT="GL_SHADER_TYPE">
<META NAME="keywords" CONTENT="GL_DELETE_STATUS">
<META NAME="keywords" CONTENT="GL_LINK_STATUS">
<META NAME="keywords" CONTENT="GL_VALIDATE_STATUS">
<META NAME="keywords" CONTENT="GL_ATTACHED_SHADERS">
<META NAME="keywords" CONTENT="GL_ACTIVE_UNIFORMS">
<META NAME="keywords" CONTENT="GL_ACTIVE_UNIFORM_MAX_LENGTH">
<META NAME="keywords" CONTENT="GL_ACTIVE_ATTRIBUTES">
<META NAME="keywords" CONTENT="GL_ACTIVE_ATTRIBUTE_MAX_LENGTH">
<META NAME="keywords" CONTENT="GL_SHADING_LANGUAGE_VERSION">
<META NAME="keywords" CONTENT="GL_CURRENT_PROGRAM">
<META NAME="keywords" CONTENT="GL_NEVER">
<META NAME="keywords" CONTENT="GL_LESS">
<META NAME="keywords" CONTENT="GL_EQUAL">
<META NAME="keywords" CONTENT="GL_LEQUAL">
<META NAME="keywords" CONTENT="GL_GREATER">
<META NAME="keywords" CONTENT="GL_NOTEQUAL">
<META NAME="keywords" CONTENT="GL_GEQUAL">
<META NAME="keywords" CONTENT="GL_ALWAYS">
<META NAME="keywords" CONTENT="GL_KEEP">
<META NAME="keywords" CONTENT="GL_REPLACE">
<META NAME="keywords" CONTENT="GL_INCR">
<META NAME="keywords" CONTENT="GL_DECR">
<META NAME="keywords" CONTENT="GL_INVERT">
<META NAME="keywords" CONTENT="GL_INCR_WRAP">
<META NAME="keywords" CONTENT="GL_DECR_WRAP">
<META NAME="keywords" CONTENT="GL_VENDOR">
<META NAME="keywords" CONTENT="GL_RENDERER">
<META NAME="keywords" CONTENT="GL_VERSION">
<META NAME="keywords" CONTENT="GL_EXTENSIONS">
<META NAME="keywords" CONTENT="GL_NEAREST">
<META NAME="keywords" CONTENT="GL_LINEAR">
<META NAME="keywords" CONTENT="GL_NEAREST_MIPMAP_NEAREST">
<META NAME="keywords" CONTENT="GL_LINEAR_MIPMAP_NEAREST">
<META NAME="keywords" CONTENT="GL_NEAREST_MIPMAP_LINEAR">
<META NAME="keywords" CONTENT="GL_LINEAR_MIPMAP_LINEAR">
<META NAME="keywords" CONTENT="GL_TEXTURE_MAG_FILTER">
<META NAME="keywords" CONTENT="GL_TEXTURE_MIN_FILTER">
<META NAME="keywords" CONTENT="GL_TEXTURE_WRAP_S">
<META NAME="keywords" CONTENT="GL_TEXTURE_WRAP_T">
<META NAME="keywords" CONTENT="GL_TEXTURE">
<META NAME="keywords" CONTENT="GL_TEXTURE_CUBE_MAP">
<META NAME="keywords" CONTENT="GL_TEXTURE_BINDING_CUBE_MAP">
<META NAME="keywords" CONTENT="GL_TEXTURE_CUBE_MAP_POSITIVE_X">
<META NAME="keywords" CONTENT="GL_TEXTURE_CUBE_MAP_NEGATIVE_X">
<META NAME="keywords" CONTENT="GL_TEXTURE_CUBE_MAP_POSITIVE_Y">
<META NAME="keywords" CONTENT="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y">
<META NAME="keywords" CONTENT="GL_TEXTURE_CUBE_MAP_POSITIVE_Z">
<META NAME="keywords" CONTENT="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z">
<META NAME="keywords" CONTENT="GL_MAX_CUBE_MAP_TEXTURE_SIZE">
<META NAME="keywords" CONTENT="GL_TEXTURE0">
<META NAME="keywords" CONTENT="GL_TEXTURE1">
<META NAME="keywords" CONTENT="GL_TEXTURE2">
<META NAME="keywords" CONTENT="GL_TEXTURE3">
<META NAME="keywords" CONTENT="GL_TEXTURE4">
<META NAME="keywords" CONTENT="GL_TEXTURE5">
<META NAME="keywords" CONTENT="GL_TEXTURE6">
<META NAME="keywords" CONTENT="GL_TEXTURE7">
<META NAME="keywords" CONTENT="GL_TEXTURE8">
<META NAME="keywords" CONTENT="GL_TEXTURE9">
<META NAME="keywords" CONTENT="GL_TEXTURE10">
<META NAME="keywords" CONTENT="GL_TEXTURE11">
<META NAME="keywords" CONTENT="GL_TEXTURE12">
<META NAME="keywords" CONTENT="GL_TEXTURE13">
<META NAME="keywords" CONTENT="GL_TEXTURE14">
<META NAME="keywords" CONTENT="GL_TEXTURE15">
<META NAME="keywords" CONTENT="GL_TEXTURE16">
<META NAME="keywords" CONTENT="GL_TEXTURE17">
<META NAME="keywords" CONTENT="GL_TEXTURE18">
<META NAME="keywords" CONTENT="GL_TEXTURE19">
<META NAME="keywords" CONTENT="GL_TEXTURE20">
<META NAME="keywords" CONTENT="GL_TEXTURE21">
<META NAME="keywords" CONTENT="GL_TEXTURE22">
<META NAME="keywords" CONTENT="GL_TEXTURE23">
<META NAME="keywords" CONTENT="GL_TEXTURE24">
<META NAME="keywords" CONTENT="GL_TEXTURE25">
<META NAME="keywords" CONTENT="GL_TEXTURE26">
<META NAME="keywords" CONTENT="GL_TEXTURE27">
<META NAME="keywords" CONTENT="GL_TEXTURE28">
<META NAME="keywords" CONTENT="GL_TEXTURE29">
<META NAME="keywords" CONTENT="GL_TEXTURE30">
<META NAME="keywords" CONTENT="GL_TEXTURE31">
<META NAME="keywords" CONTENT="GL_ACTIVE_TEXTURE">
<META NAME="keywords" CONTENT="GL_REPEAT">
<META NAME="keywords" CONTENT="GL_CLAMP_TO_EDGE">
<META NAME="keywords" CONTENT="GL_MIRRORED_REPEAT">
<META NAME="keywords" CONTENT="GL_FLOAT_VEC2">
<META NAME="keywords" CONTENT="GL_FLOAT_VEC3">
<META NAME="keywords" CONTENT="GL_FLOAT_VEC4">
<META NAME="keywords" CONTENT="GL_INT_VEC2">
<META NAME="keywords" CONTENT="GL_INT_VEC3">
<META NAME="keywords" CONTENT="GL_INT_VEC4">
<META NAME="keywords" CONTENT="GL_BOOL">
<META NAME="keywords" CONTENT="GL_BOOL_VEC2">
<META NAME="keywords" CONTENT="GL_BOOL_VEC3">
<META NAME="keywords" CONTENT="GL_BOOL_VEC4">
<META NAME="keywords" CONTENT="GL_FLOAT_MAT2">
<META NAME="keywords" CONTENT="GL_FLOAT_MAT3">
<META NAME="keywords" CONTENT="GL_FLOAT_MAT4">
<META NAME="keywords" CONTENT="GL_SAMPLER_2D">
<META NAME="keywords" CONTENT="GL_SAMPLER_CUBE">
<META NAME="keywords" CONTENT="GL_VERTEX_ATTRIB_ARRAY_ENABLED">
<META NAME="keywords" CONTENT="GL_VERTEX_ATTRIB_ARRAY_SIZE">
<META NAME="keywords" CONTENT="GL_VERTEX_ATTRIB_ARRAY_STRIDE">
<META NAME="keywords" CONTENT="GL_VERTEX_ATTRIB_ARRAY_TYPE">
<META NAME="keywords" CONTENT="GL_VERTEX_ATTRIB_ARRAY_NORMALIZED">
<META NAME="keywords" CONTENT="GL_VERTEX_ATTRIB_ARRAY_POINTER">
<META NAME="keywords" CONTENT="GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING">
<META NAME="keywords" CONTENT="GL_IMPLEMENTATION_COLOR_READ_TYPE">
<META NAME="keywords" CONTENT="GL_IMPLEMENTATION_COLOR_READ_FORMAT">
<META NAME="keywords" CONTENT="GL_COMPILE_STATUS">
<META NAME="keywords" CONTENT="GL_INFO_LOG_LENGTH">
<META NAME="keywords" CONTENT="GL_SHADER_SOURCE_LENGTH">
<META NAME="keywords" CONTENT="GL_SHADER_COMPILER">
<META NAME="keywords" CONTENT="GL_SHADER_BINARY_FORMATS">
<META NAME="keywords" CONTENT="GL_NUM_SHADER_BINARY_FORMATS">
<META NAME="keywords" CONTENT="GL_LOW_FLOAT">
<META NAME="keywords" CONTENT="GL_MEDIUM_FLOAT">
<META NAME="keywords" CONTENT="GL_HIGH_FLOAT">
<META NAME="keywords" CONTENT="GL_LOW_INT">
<META NAME="keywords" CONTENT="GL_MEDIUM_INT">
<META NAME="keywords" CONTENT="GL_HIGH_INT">
<META NAME="keywords" CONTENT="GL_FRAMEBUFFER">
<META NAME="keywords" CONTENT="GL_RENDERBUFFER">
<META NAME="keywords" CONTENT="GL_RGBA4">
<META NAME="keywords" CONTENT="GL_RGB5_A1">
<META NAME="keywords" CONTENT="GL_RGB565">
<META NAME="keywords" CONTENT="GL_DEPTH_COMPONENT16">
<META NAME="keywords" CONTENT="GL_STENCIL_INDEX">
<META NAME="keywords" CONTENT="GL_STENCIL_INDEX8">
<META NAME="keywords" CONTENT="GL_RENDERBUFFER_WIDTH">
<META NAME="keywords" CONTENT="GL_RENDERBUFFER_HEIGHT">
<META NAME="keywords" CONTENT="GL_RENDERBUFFER_INTERNAL_FORMAT">
<META NAME="keywords" CONTENT="GL_RENDERBUFFER_RED_SIZE">
<META NAME="keywords" CONTENT="GL_RENDERBUFFER_GREEN_SIZE">
<META NAME="keywords" CONTENT="GL_RENDERBUFFER_BLUE_SIZE">
<META NAME="keywords" CONTENT="GL_RENDERBUFFER_ALPHA_SIZE">
<META NAME="keywords" CONTENT="GL_RENDERBUFFER_DEPTH_SIZE">
<META NAME="keywords" CONTENT="GL_RENDERBUFFER_STENCIL_SIZE">
<META NAME="keywords" CONTENT="GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE">
<META NAME="keywords" CONTENT="GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME">
<META NAME="keywords" CONTENT="GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL">
<META NAME="keywords" CONTENT="GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE">
<META NAME="keywords" CONTENT="GL_COLOR_ATTACHMENT0">
<META NAME="keywords" CONTENT="GL_DEPTH_ATTACHMENT">
<META NAME="keywords" CONTENT="GL_STENCIL_ATTACHMENT">
<META NAME="keywords" CONTENT="GL_NONE">
<META NAME="keywords" CONTENT="GL_FRAMEBUFFER_COMPLETE">
<META NAME="keywords" CONTENT="GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT">
<META NAME="keywords" CONTENT="GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT">
<META NAME="keywords" CONTENT="GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS">
<META NAME="keywords" CONTENT="GL_FRAMEBUFFER_UNSUPPORTED">
<META NAME="keywords" CONTENT="GL_FRAMEBUFFER_BINDING">
<META NAME="keywords" CONTENT="GL_RENDERBUFFER_BINDING">
<META NAME="keywords" CONTENT="GL_MAX_RENDERBUFFER_SIZE">
<META NAME="keywords" CONTENT="GL_INVALID_FRAMEBUFFER_OPERATION">
<META NAME="keywords" CONTENT="glActiveTexture()">
<META NAME="keywords" CONTENT="glAttachShader()">
<META NAME="keywords" CONTENT="glBindAttribLocation()">
<META NAME="keywords" CONTENT="glBindBuffer()">
<META NAME="keywords" CONTENT="glBindFramebuffer()">
<META NAME="keywords" CONTENT="glBindRenderbuffer()">
<META NAME="keywords" CONTENT="glBindTexture()">
<META NAME="keywords" CONTENT="glBlendColor()">
<META NAME="keywords" CONTENT="glBlendEquation()">
<META NAME="keywords" CONTENT="glBlendEquationSeparate()">
<META NAME="keywords" CONTENT="glBlendFunc()">
<META NAME="keywords" CONTENT="glBlendFuncSeparate()">
<META NAME="keywords" CONTENT="glBufferData()">
<META NAME="keywords" CONTENT="glBufferSubData()">
<META NAME="keywords" CONTENT="glCheckFramebufferStatus()">
<META NAME="keywords" CONTENT="glClear()">
<META NAME="keywords" CONTENT="glClearColor()">
<META NAME="keywords" CONTENT="glClearDepthf()">
<META NAME="keywords" CONTENT="glClearStencil()">
<META NAME="keywords" CONTENT="glColorMask()">
<META NAME="keywords" CONTENT="glCompileShader()">
<META NAME="keywords" CONTENT="glCompressedTexImage2D()">
<META NAME="keywords" CONTENT="glCompressedTexSubImage2D()">
<META NAME="keywords" CONTENT="glCopyTexImage2D()">
<META NAME="keywords" CONTENT="glCopyTexSubImage2D()">
<META NAME="keywords" CONTENT="glCreateProgram()">
<META NAME="keywords" CONTENT="glCreateShader()">
<META NAME="keywords" CONTENT="glCullFace()">
<META NAME="keywords" CONTENT="glDeleteBuffers()">
<META NAME="keywords" CONTENT="glDeleteFramebuffers()">
<META NAME="keywords" CONTENT="glDeleteProgram()">
<META NAME="keywords" CONTENT="glDeleteRenderbuffers()">
<META NAME="keywords" CONTENT="glDeleteShader()">
<META NAME="keywords" CONTENT="glDeleteTextures()">
<META NAME="keywords" CONTENT="glDepthFunc()">
<META NAME="keywords" CONTENT="glDepthMask()">
<META NAME="keywords" CONTENT="glDepthRangef()">
<META NAME="keywords" CONTENT="glDetachShader()">
<META NAME="keywords" CONTENT="glDisable()">
<META NAME="keywords" CONTENT="glDisableVertexAttribArray()">
<META NAME="keywords" CONTENT="glDrawArrays()">
<META NAME="keywords" CONTENT="glDrawElements()">
<META NAME="keywords" CONTENT="glEnable()">
<META NAME="keywords" CONTENT="glEnableVertexAttribArray()">
<META NAME="keywords" CONTENT="glFinish()">
<META NAME="keywords" CONTENT="glFlush()">
<META NAME="keywords" CONTENT="glFramebufferRenderbuffer()">
<META NAME="keywords" CONTENT="glFramebufferTexture2D()">
<META NAME="keywords" CONTENT="glFrontFace()">
<META NAME="keywords" CONTENT="glGenBuffers()">
<META NAME="keywords" CONTENT="glGenFramebuffers()">
<META NAME="keywords" CONTENT="glGenRenderbuffers()">
<META NAME="keywords" CONTENT="glGenTextures()">
<META NAME="keywords" CONTENT="glGenerateMipmap()">
<META NAME="keywords" CONTENT="glGetActiveAttrib()">
<META NAME="keywords" CONTENT="glGetActiveUniform()">
<META NAME="keywords" CONTENT="glGetAttachedShaders()">
<META NAME="keywords" CONTENT="glGetAttribLocation()">
<META NAME="keywords" CONTENT="glGetBooleanv()">
<META NAME="keywords" CONTENT="glGetBufferParameteriv()">
<META NAME="keywords" CONTENT="glGetError()">
<META NAME="keywords" CONTENT="glGetFloatv()">
<META NAME="keywords" CONTENT="glGetFramebufferAttachmentParameteriv()">
<META NAME="keywords" CONTENT="glGetIntegerv()">
<META NAME="keywords" CONTENT="glGetProgramiv()">
<META NAME="keywords" CONTENT="glGetProgramInfoLog()">
<META NAME="keywords" CONTENT="glGetRenderbufferParameteriv()">
<META NAME="keywords" CONTENT="glGetShaderiv()">
<META NAME="keywords" CONTENT="glGetShaderInfoLog()">
<META NAME="keywords" CONTENT="glGetShaderPrecisionFormat()">
<META NAME="keywords" CONTENT="glGetShaderSource()">
<META NAME="keywords" CONTENT="glGetString()">
<META NAME="keywords" CONTENT="glGetTexParameterfv()">
<META NAME="keywords" CONTENT="glGetTexParameteriv()">
<META NAME="keywords" CONTENT="glGetUniformfv()">
<META NAME="keywords" CONTENT="glGetUniformiv()">
<META NAME="keywords" CONTENT="glGetUniformLocation()">
<META NAME="keywords" CONTENT="glGetVertexAttribfv()">
<META NAME="keywords" CONTENT="glGetVertexAttribiv()">
<META NAME="keywords" CONTENT="glHint()">
<META NAME="keywords" CONTENT="glIsBuffer()">
<META NAME="keywords" CONTENT="glIsEnabled()">
<META NAME="keywords" CONTENT="glIsFramebuffer()">
<META NAME="keywords" CONTENT="glIsProgram()">
<META NAME="keywords" CONTENT="glIsRenderbuffer()">
<META NAME="keywords" CONTENT="glIsShader()">
<META NAME="keywords" CONTENT="glIsTexture()">
<META NAME="keywords" CONTENT="glLineWidth()">
<META NAME="keywords" CONTENT="glLinkProgram()">
<META NAME="keywords" CONTENT="glPixelStorei()">
<META NAME="keywords" CONTENT="glPolygonOffset()">
<META NAME="keywords" CONTENT="glReadPixels()">
<META NAME="keywords" CONTENT="glReleaseShaderCompiler()">
<META NAME="keywords" CONTENT="glRenderbufferStorage()">
<META NAME="keywords" CONTENT="glSampleCoverage()">
<META NAME="keywords" CONTENT="glScissor()">
<META NAME="keywords" CONTENT="glShaderBinary()">
<META NAME="keywords" CONTENT="glShaderSource()">
<META NAME="keywords" CONTENT="glStencilFunc()">
<META NAME="keywords" CONTENT="glStencilFuncSeparate()">
<META NAME="keywords" CONTENT="glStencilMask()">
<META NAME="keywords" CONTENT="glStencilMaskSeparate()">
<META NAME="keywords" CONTENT="glStencilOp()">
<META NAME="keywords" CONTENT="glStencilOpSeparate()">
<META NAME="keywords" CONTENT="glTexImage2D()">
<META NAME="keywords" CONTENT="glTexParameterf()">
<META NAME="keywords" CONTENT="glTexParameterfv()">
<META NAME="keywords" CONTENT="glTexParameteri()">
<META NAME="keywords" CONTENT="glTexParameteriv()">
<META NAME="keywords" CONTENT="glTexSubImage2D()">
<META NAME="keywords" CONTENT="glUniform1f()">
<META NAME="keywords" CONTENT="glUniform1fv()">
<META NAME="keywords" CONTENT="glUniform1i()">
<META NAME="keywords" CONTENT="glUniform1iv()">
<META NAME="keywords" CONTENT="glUniform2f()">
<META NAME="keywords" CONTENT="glUniform2fv()">
<META NAME="keywords" CONTENT="glUniform2i()">
<META NAME="keywords" CONTENT="glUniform2iv()">
<META NAME="keywords" CONTENT="glUniform3f()">
<META NAME="keywords" CONTENT="glUniform3fv()">
<META NAME="keywords" CONTENT="glUniform3i()">
<META NAME="keywords" CONTENT="glUniform3iv()">
<META NAME="keywords" CONTENT="glUniform4f()">
<META NAME="keywords" CONTENT="glUniform4fv()">
<META NAME="keywords" CONTENT="glUniform4i()">
<META NAME="keywords" CONTENT="glUniform4iv()">
<META NAME="keywords" CONTENT="glUniformMatrix2fv()">
<META NAME="keywords" CONTENT="glUniformMatrix3fv()">
<META NAME="keywords" CONTENT="glUniformMatrix4fv()">
<META NAME="keywords" CONTENT="glUseProgram()">
<META NAME="keywords" CONTENT="glValidateProgram()">
<META NAME="keywords" CONTENT="glVertexAttrib1f()">
<META NAME="keywords" CONTENT="glVertexAttrib1fv()">
<META NAME="keywords" CONTENT="glVertexAttrib2f()">
<META NAME="keywords" CONTENT="glVertexAttrib2fv()">
<META NAME="keywords" CONTENT="glVertexAttrib3f()">
<META NAME="keywords" CONTENT="glVertexAttrib3fv()">
<META NAME="keywords" CONTENT="glVertexAttrib4f()">
<META NAME="keywords" CONTENT="glVertexAttrib4fv()">
<META NAME="keywords" CONTENT="glVertexAttribPointer()">
<META NAME="keywords" CONTENT="glViewport()">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="GL20 (BlackBerry JDE 7.1.0 API Reference)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<SCRIPT SRC="../../../../../script.js" TYPE="text/javascript"></SCRIPT>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../../../net/rim/device/api/opengles/GLField.html" title="class in net.rim.device.api.opengles"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?net/rim/device/api/opengles/GL20.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GL20.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<FORM action="https://www.blackberry.com/DocsFeedback/" method="GET" target="_new">
<INPUT type="hidden" name="title" value="API Reference">
<INPUT type="hidden" name="source" value="External">
<INPUT type="hidden" name="version" value="7.1.0">
<INPUT type="hidden" name="classname" value="net.rim.device.api.opengles.GL20">
<INPUT type="submit" value="Submit Feedback" /></FORM>

<BR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.rim.device.api.opengles</FONT>
<BR>
Interface GL20</H2>
<DL>
<DT><B>All Superinterfaces:</B> <DD><A HREF="../../../../../javax/microedition/khronos/opengles/GL.html" title="interface in javax.microedition.khronos.opengles">GL</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public interface <B>GL20</B><DT>extends <A HREF="../../../../../javax/microedition/khronos/opengles/GL.html" title="interface in javax.microedition.khronos.opengles">GL</A></DL>
</PRE>

<P>
The <code>GL20</code> interface contains Java&trade; programming
 language bindings for OpenGL&reg; ES 2.0 functionality. The bindings
 are similar to the bindings described for OpenGL ES 1.1 in JSR 239.
 <p>
 See the <A HREF="../../../../../javax/microedition/khronos/opengles/GL.html" title="interface in javax.microedition.khronos.opengles"><CODE>GL</CODE></A> interface 
 documentation to learn how to get an object that implements this interface.
 <p>
 The <code>glGetVertexAttribPointerv(int index, int pname, void** pointer)</code>
 OpenGL ES 2.0 method is not implemented.<p>
<P>

<P>
<DL>
<DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="" CLASS="SummaryTable">
<TR BGCOLOR="#CCCCFF">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+0">
Field Summary</FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ACTIVE_ATTRIBUTES">GL_ACTIVE_ATTRIBUTES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ACTIVE_ATTRIBUTE_MAX_LENGTH">GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ACTIVE_TEXTURE">GL_ACTIVE_TEXTURE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ACTIVE_UNIFORMS">GL_ACTIVE_UNIFORMS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ACTIVE_UNIFORM_MAX_LENGTH">GL_ACTIVE_UNIFORM_MAX_LENGTH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ALIASED_LINE_WIDTH_RANGE">GL_ALIASED_LINE_WIDTH_RANGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ALIASED_POINT_SIZE_RANGE">GL_ALIASED_POINT_SIZE_RANGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ALPHA">GL_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ALPHA_BITS">GL_ALPHA_BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ALWAYS">GL_ALWAYS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ARRAY_BUFFER">GL_ARRAY_BUFFER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ARRAY_BUFFER_BINDING">GL_ARRAY_BUFFER_BINDING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ATTACHED_SHADERS">GL_ATTACHED_SHADERS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BACK">GL_BACK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BLEND">GL_BLEND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BLEND_COLOR">GL_BLEND_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BLEND_DST_ALPHA">GL_BLEND_DST_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BLEND_DST_RGB">GL_BLEND_DST_RGB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BLEND_EQUATION">GL_BLEND_EQUATION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BLEND_EQUATION_ALPHA">GL_BLEND_EQUATION_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BLEND_EQUATION_RGB">GL_BLEND_EQUATION_RGB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BLEND_SRC_ALPHA">GL_BLEND_SRC_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BLEND_SRC_RGB">GL_BLEND_SRC_RGB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BLUE_BITS">GL_BLUE_BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BOOL">GL_BOOL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BOOL_VEC2">GL_BOOL_VEC2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BOOL_VEC3">GL_BOOL_VEC3</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BOOL_VEC4">GL_BOOL_VEC4</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BUFFER_SIZE">GL_BUFFER_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BUFFER_USAGE">GL_BUFFER_USAGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_BYTE">GL_BYTE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_CCW">GL_CCW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_CLAMP_TO_EDGE">GL_CLAMP_TO_EDGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_COLOR_ATTACHMENT0">GL_COLOR_ATTACHMENT0</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_COLOR_BUFFER_BIT">GL_COLOR_BUFFER_BIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_COLOR_CLEAR_VALUE">GL_COLOR_CLEAR_VALUE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_COLOR_WRITEMASK">GL_COLOR_WRITEMASK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_COMPILE_STATUS">GL_COMPILE_STATUS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_COMPRESSED_TEXTURE_FORMATS">GL_COMPRESSED_TEXTURE_FORMATS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_CONSTANT_ALPHA">GL_CONSTANT_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_CONSTANT_COLOR">GL_CONSTANT_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_CULL_FACE">GL_CULL_FACE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_CULL_FACE_MODE">GL_CULL_FACE_MODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_CURRENT_PROGRAM">GL_CURRENT_PROGRAM</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_CURRENT_VERTEX_ATTRIB">GL_CURRENT_VERTEX_ATTRIB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_CW">GL_CW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DECR">GL_DECR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DECR_WRAP">GL_DECR_WRAP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DELETE_STATUS">GL_DELETE_STATUS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DEPTH_ATTACHMENT">GL_DEPTH_ATTACHMENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DEPTH_BITS">GL_DEPTH_BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DEPTH_BUFFER_BIT">GL_DEPTH_BUFFER_BIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DEPTH_CLEAR_VALUE">GL_DEPTH_CLEAR_VALUE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DEPTH_COMPONENT">GL_DEPTH_COMPONENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DEPTH_COMPONENT16">GL_DEPTH_COMPONENT16</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DEPTH_FUNC">GL_DEPTH_FUNC</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DEPTH_RANGE">GL_DEPTH_RANGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DEPTH_TEST">GL_DEPTH_TEST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DEPTH_WRITEMASK">GL_DEPTH_WRITEMASK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DITHER">GL_DITHER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DONT_CARE">GL_DONT_CARE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DST_ALPHA">GL_DST_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DST_COLOR">GL_DST_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_DYNAMIC_DRAW">GL_DYNAMIC_DRAW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ELEMENT_ARRAY_BUFFER">GL_ELEMENT_ARRAY_BUFFER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ELEMENT_ARRAY_BUFFER_BINDING">GL_ELEMENT_ARRAY_BUFFER_BINDING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_EQUAL">GL_EQUAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ES_VERSION_2_0">GL_ES_VERSION_2_0</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_EXTENSIONS">GL_EXTENSIONS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FALSE">GL_FALSE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FASTEST">GL_FASTEST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FIXED">GL_FIXED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FLOAT">GL_FLOAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FLOAT_MAT2">GL_FLOAT_MAT2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FLOAT_MAT3">GL_FLOAT_MAT3</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FLOAT_MAT4">GL_FLOAT_MAT4</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FLOAT_VEC2">GL_FLOAT_VEC2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FLOAT_VEC3">GL_FLOAT_VEC3</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FLOAT_VEC4">GL_FLOAT_VEC4</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FRAGMENT_SHADER">GL_FRAGMENT_SHADER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FRAMEBUFFER">GL_FRAMEBUFFER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME">GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE">GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE">GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL">GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FRAMEBUFFER_BINDING">GL_FRAMEBUFFER_BINDING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FRAMEBUFFER_COMPLETE">GL_FRAMEBUFFER_COMPLETE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT">GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS">GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT">GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FRAMEBUFFER_UNSUPPORTED">GL_FRAMEBUFFER_UNSUPPORTED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FRONT">GL_FRONT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FRONT_AND_BACK">GL_FRONT_AND_BACK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FRONT_FACE">GL_FRONT_FACE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FUNC_ADD">GL_FUNC_ADD</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FUNC_REVERSE_SUBTRACT">GL_FUNC_REVERSE_SUBTRACT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_FUNC_SUBTRACT">GL_FUNC_SUBTRACT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_GENERATE_MIPMAP_HINT">GL_GENERATE_MIPMAP_HINT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_GEQUAL">GL_GEQUAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_GREATER">GL_GREATER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_GREEN_BITS">GL_GREEN_BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_HIGH_FLOAT">GL_HIGH_FLOAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_HIGH_INT">GL_HIGH_INT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_IMPLEMENTATION_COLOR_READ_FORMAT">GL_IMPLEMENTATION_COLOR_READ_FORMAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_IMPLEMENTATION_COLOR_READ_TYPE">GL_IMPLEMENTATION_COLOR_READ_TYPE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_INCR">GL_INCR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_INCR_WRAP">GL_INCR_WRAP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_INFO_LOG_LENGTH">GL_INFO_LOG_LENGTH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_INT">GL_INT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_INT_VEC2">GL_INT_VEC2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_INT_VEC3">GL_INT_VEC3</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_INT_VEC4">GL_INT_VEC4</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_INVALID_ENUM">GL_INVALID_ENUM</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_INVALID_FRAMEBUFFER_OPERATION">GL_INVALID_FRAMEBUFFER_OPERATION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_INVALID_OPERATION">GL_INVALID_OPERATION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_INVALID_VALUE">GL_INVALID_VALUE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_INVERT">GL_INVERT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_KEEP">GL_KEEP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_LEQUAL">GL_LEQUAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_LESS">GL_LESS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_LINEAR">GL_LINEAR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_LINEAR_MIPMAP_LINEAR">GL_LINEAR_MIPMAP_LINEAR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_LINEAR_MIPMAP_NEAREST">GL_LINEAR_MIPMAP_NEAREST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_LINES">GL_LINES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_LINE_LOOP">GL_LINE_LOOP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_LINE_STRIP">GL_LINE_STRIP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_LINE_WIDTH">GL_LINE_WIDTH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_LINK_STATUS">GL_LINK_STATUS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_LOW_FLOAT">GL_LOW_FLOAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_LOW_INT">GL_LOW_INT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_LUMINANCE">GL_LUMINANCE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_LUMINANCE_ALPHA">GL_LUMINANCE_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS">GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_MAX_CUBE_MAP_TEXTURE_SIZE">GL_MAX_CUBE_MAP_TEXTURE_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_MAX_FRAGMENT_UNIFORM_VECTORS">GL_MAX_FRAGMENT_UNIFORM_VECTORS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_MAX_RENDERBUFFER_SIZE">GL_MAX_RENDERBUFFER_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_MAX_TEXTURE_IMAGE_UNITS">GL_MAX_TEXTURE_IMAGE_UNITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_MAX_TEXTURE_SIZE">GL_MAX_TEXTURE_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_MAX_VARYING_VECTORS">GL_MAX_VARYING_VECTORS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_MAX_VERTEX_ATTRIBS">GL_MAX_VERTEX_ATTRIBS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS">GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_MAX_VERTEX_UNIFORM_VECTORS">GL_MAX_VERTEX_UNIFORM_VECTORS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_MAX_VIEWPORT_DIMS">GL_MAX_VIEWPORT_DIMS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_MEDIUM_FLOAT">GL_MEDIUM_FLOAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_MEDIUM_INT">GL_MEDIUM_INT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_MIRRORED_REPEAT">GL_MIRRORED_REPEAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_NEAREST">GL_NEAREST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_NEAREST_MIPMAP_LINEAR">GL_NEAREST_MIPMAP_LINEAR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_NEAREST_MIPMAP_NEAREST">GL_NEAREST_MIPMAP_NEAREST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_NEVER">GL_NEVER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_NICEST">GL_NICEST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_NONE">GL_NONE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_NOTEQUAL">GL_NOTEQUAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_NO_ERROR">GL_NO_ERROR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_NUM_COMPRESSED_TEXTURE_FORMATS">GL_NUM_COMPRESSED_TEXTURE_FORMATS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_NUM_SHADER_BINARY_FORMATS">GL_NUM_SHADER_BINARY_FORMATS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ONE">GL_ONE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ONE_MINUS_CONSTANT_ALPHA">GL_ONE_MINUS_CONSTANT_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ONE_MINUS_CONSTANT_COLOR">GL_ONE_MINUS_CONSTANT_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ONE_MINUS_DST_ALPHA">GL_ONE_MINUS_DST_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ONE_MINUS_DST_COLOR">GL_ONE_MINUS_DST_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ONE_MINUS_SRC_ALPHA">GL_ONE_MINUS_SRC_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ONE_MINUS_SRC_COLOR">GL_ONE_MINUS_SRC_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_OUT_OF_MEMORY">GL_OUT_OF_MEMORY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_PACK_ALIGNMENT">GL_PACK_ALIGNMENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_POINTS">GL_POINTS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_POLYGON_OFFSET_FACTOR">GL_POLYGON_OFFSET_FACTOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_POLYGON_OFFSET_FILL">GL_POLYGON_OFFSET_FILL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_POLYGON_OFFSET_UNITS">GL_POLYGON_OFFSET_UNITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RED_BITS">GL_RED_BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RENDERBUFFER">GL_RENDERBUFFER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RENDERBUFFER_ALPHA_SIZE">GL_RENDERBUFFER_ALPHA_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RENDERBUFFER_BINDING">GL_RENDERBUFFER_BINDING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RENDERBUFFER_BLUE_SIZE">GL_RENDERBUFFER_BLUE_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RENDERBUFFER_DEPTH_SIZE">GL_RENDERBUFFER_DEPTH_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RENDERBUFFER_GREEN_SIZE">GL_RENDERBUFFER_GREEN_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RENDERBUFFER_HEIGHT">GL_RENDERBUFFER_HEIGHT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RENDERBUFFER_INTERNAL_FORMAT">GL_RENDERBUFFER_INTERNAL_FORMAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RENDERBUFFER_RED_SIZE">GL_RENDERBUFFER_RED_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RENDERBUFFER_STENCIL_SIZE">GL_RENDERBUFFER_STENCIL_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RENDERBUFFER_WIDTH">GL_RENDERBUFFER_WIDTH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RENDERER">GL_RENDERER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_REPEAT">GL_REPEAT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_REPLACE">GL_REPLACE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RGB">GL_RGB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RGB565">GL_RGB565</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RGB5_A1">GL_RGB5_A1</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RGBA">GL_RGBA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_RGBA4">GL_RGBA4</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SAMPLER_2D">GL_SAMPLER_2D</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SAMPLER_CUBE">GL_SAMPLER_CUBE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SAMPLES">GL_SAMPLES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SAMPLE_ALPHA_TO_COVERAGE">GL_SAMPLE_ALPHA_TO_COVERAGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SAMPLE_BUFFERS">GL_SAMPLE_BUFFERS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SAMPLE_COVERAGE">GL_SAMPLE_COVERAGE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SAMPLE_COVERAGE_INVERT">GL_SAMPLE_COVERAGE_INVERT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SAMPLE_COVERAGE_VALUE">GL_SAMPLE_COVERAGE_VALUE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SCISSOR_BOX">GL_SCISSOR_BOX</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SCISSOR_TEST">GL_SCISSOR_TEST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SHADER_BINARY_FORMATS">GL_SHADER_BINARY_FORMATS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SHADER_COMPILER">GL_SHADER_COMPILER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SHADER_SOURCE_LENGTH">GL_SHADER_SOURCE_LENGTH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SHADER_TYPE">GL_SHADER_TYPE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SHADING_LANGUAGE_VERSION">GL_SHADING_LANGUAGE_VERSION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SHORT">GL_SHORT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SRC_ALPHA">GL_SRC_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SRC_ALPHA_SATURATE">GL_SRC_ALPHA_SATURATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SRC_COLOR">GL_SRC_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STATIC_DRAW">GL_STATIC_DRAW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_ATTACHMENT">GL_STENCIL_ATTACHMENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_BACK_FAIL">GL_STENCIL_BACK_FAIL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_BACK_FUNC">GL_STENCIL_BACK_FUNC</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_BACK_PASS_DEPTH_FAIL">GL_STENCIL_BACK_PASS_DEPTH_FAIL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_BACK_PASS_DEPTH_PASS">GL_STENCIL_BACK_PASS_DEPTH_PASS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_BACK_REF">GL_STENCIL_BACK_REF</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_BACK_VALUE_MASK">GL_STENCIL_BACK_VALUE_MASK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_BACK_WRITEMASK">GL_STENCIL_BACK_WRITEMASK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_BITS">GL_STENCIL_BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_BUFFER_BIT">GL_STENCIL_BUFFER_BIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_CLEAR_VALUE">GL_STENCIL_CLEAR_VALUE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_FAIL">GL_STENCIL_FAIL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_FUNC">GL_STENCIL_FUNC</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_INDEX">GL_STENCIL_INDEX</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_INDEX8">GL_STENCIL_INDEX8</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_PASS_DEPTH_FAIL">GL_STENCIL_PASS_DEPTH_FAIL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_PASS_DEPTH_PASS">GL_STENCIL_PASS_DEPTH_PASS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_REF">GL_STENCIL_REF</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_TEST">GL_STENCIL_TEST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_VALUE_MASK">GL_STENCIL_VALUE_MASK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STENCIL_WRITEMASK">GL_STENCIL_WRITEMASK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_STREAM_DRAW">GL_STREAM_DRAW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_SUBPIXEL_BITS">GL_SUBPIXEL_BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE">GL_TEXTURE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE0">GL_TEXTURE0</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE1">GL_TEXTURE1</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE10">GL_TEXTURE10</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE11">GL_TEXTURE11</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE12">GL_TEXTURE12</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE13">GL_TEXTURE13</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE14">GL_TEXTURE14</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE15">GL_TEXTURE15</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE16">GL_TEXTURE16</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE17">GL_TEXTURE17</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE18">GL_TEXTURE18</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE19">GL_TEXTURE19</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE2">GL_TEXTURE2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE20">GL_TEXTURE20</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE21">GL_TEXTURE21</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE22">GL_TEXTURE22</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE23">GL_TEXTURE23</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE24">GL_TEXTURE24</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE25">GL_TEXTURE25</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE26">GL_TEXTURE26</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE27">GL_TEXTURE27</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE28">GL_TEXTURE28</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE29">GL_TEXTURE29</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE3">GL_TEXTURE3</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE30">GL_TEXTURE30</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE31">GL_TEXTURE31</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE4">GL_TEXTURE4</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE5">GL_TEXTURE5</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE6">GL_TEXTURE6</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE7">GL_TEXTURE7</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE8">GL_TEXTURE8</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE9">GL_TEXTURE9</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE_2D">GL_TEXTURE_2D</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE_BINDING_2D">GL_TEXTURE_BINDING_2D</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE_BINDING_CUBE_MAP">GL_TEXTURE_BINDING_CUBE_MAP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE_CUBE_MAP">GL_TEXTURE_CUBE_MAP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE_CUBE_MAP_NEGATIVE_X">GL_TEXTURE_CUBE_MAP_NEGATIVE_X</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE_CUBE_MAP_NEGATIVE_Y">GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE_CUBE_MAP_NEGATIVE_Z">GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE_CUBE_MAP_POSITIVE_X">GL_TEXTURE_CUBE_MAP_POSITIVE_X</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE_CUBE_MAP_POSITIVE_Y">GL_TEXTURE_CUBE_MAP_POSITIVE_Y</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE_CUBE_MAP_POSITIVE_Z">GL_TEXTURE_CUBE_MAP_POSITIVE_Z</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE_MAG_FILTER">GL_TEXTURE_MAG_FILTER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE_MIN_FILTER">GL_TEXTURE_MIN_FILTER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE_WRAP_S">GL_TEXTURE_WRAP_S</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TEXTURE_WRAP_T">GL_TEXTURE_WRAP_T</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TRIANGLES">GL_TRIANGLES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TRIANGLE_FAN">GL_TRIANGLE_FAN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TRIANGLE_STRIP">GL_TRIANGLE_STRIP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_TRUE">GL_TRUE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_UNPACK_ALIGNMENT">GL_UNPACK_ALIGNMENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_UNSIGNED_BYTE">GL_UNSIGNED_BYTE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_UNSIGNED_INT">GL_UNSIGNED_INT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_UNSIGNED_SHORT">GL_UNSIGNED_SHORT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_UNSIGNED_SHORT_4_4_4_4">GL_UNSIGNED_SHORT_4_4_4_4</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_UNSIGNED_SHORT_5_5_5_1">GL_UNSIGNED_SHORT_5_5_5_1</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_UNSIGNED_SHORT_5_6_5">GL_UNSIGNED_SHORT_5_6_5</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_VALIDATE_STATUS">GL_VALIDATE_STATUS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_VENDOR">GL_VENDOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_VERSION">GL_VERSION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING">GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_VERTEX_ATTRIB_ARRAY_ENABLED">GL_VERTEX_ATTRIB_ARRAY_ENABLED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_VERTEX_ATTRIB_ARRAY_NORMALIZED">GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_VERTEX_ATTRIB_ARRAY_POINTER">GL_VERTEX_ATTRIB_ARRAY_POINTER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_VERTEX_ATTRIB_ARRAY_SIZE">GL_VERTEX_ATTRIB_ARRAY_SIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_VERTEX_ATTRIB_ARRAY_STRIDE">GL_VERTEX_ATTRIB_ARRAY_STRIDE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_VERTEX_ATTRIB_ARRAY_TYPE">GL_VERTEX_ATTRIB_ARRAY_TYPE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_VERTEX_SHADER">GL_VERTEX_SHADER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_VIEWPORT">GL_VIEWPORT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#GL_ZERO">GL_ZERO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OpenGL ES 2.0 constant.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="" CLASS="SummaryTable">
<TR BGCOLOR="#CCCCFF">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+0">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)">glActiveTexture</A></B>(int&nbsp;texture)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Select active texture unit.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glAttachShader(int, int)">glAttachShader</A></B>(int&nbsp;program,
               int&nbsp;shader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attach a shader object to a program object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindAttribLocation(int, int, java.lang.String)">glBindAttribLocation</A></B>(int&nbsp;program,
                     int&nbsp;index,
                     <A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Associate a generic vertex attribute index with a named attribute variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)">glBindBuffer</A></B>(int&nbsp;target,
             int&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bind a named buffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindFramebuffer(int, int)">glBindFramebuffer</A></B>(int&nbsp;target,
                  int&nbsp;framebuffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bind a named framebuffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindRenderbuffer(int, int)">glBindRenderbuffer</A></B>(int&nbsp;target,
                   int&nbsp;renderbuffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bind a named renderbuffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindTexture(int, int)">glBindTexture</A></B>(int&nbsp;target,
              int&nbsp;texture)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bind a named texture to a texturing target.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendColor(float, float, float, float)">glBlendColor</A></B>(float&nbsp;red,
             float&nbsp;green,
             float&nbsp;blue,
             float&nbsp;alpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the blend color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendEquation(int)">glBlendEquation</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify the equation used for both the RGB blend equation and the Alpha blend equation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendEquationSeparate(int, int)">glBlendEquationSeparate</A></B>(int&nbsp;modeRGB,
                        int&nbsp;modeAlpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the RGB blend equation and the alpha blend equation separately.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)">glBlendFunc</A></B>(int&nbsp;sfactor,
            int&nbsp;dfactor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify pixel arithmetic.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFuncSeparate(int, int, int, int)">glBlendFuncSeparate</A></B>(int&nbsp;srcRGB,
                    int&nbsp;dstRGB,
                    int&nbsp;srcAlpha,
                    int&nbsp;dstAlpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify pixel arithmetic for RGB and alpha components separately.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBufferData(int, int, java.nio.Buffer, int)">glBufferData</A></B>(int&nbsp;target,
             int&nbsp;size,
             <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data,
             int&nbsp;usage)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create and initialize a buffer object's data store.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBufferSubData(int, int, int, java.nio.Buffer)">glBufferSubData</A></B>(int&nbsp;target,
                int&nbsp;offset,
                int&nbsp;size,
                <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Update a subset of a buffer object's data store.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)">glCheckFramebufferStatus</A></B>(int&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the framebuffer completeness status of a framebuffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClear(int)">glClear</A></B>(int&nbsp;mask)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clear buffers to preset values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClearColor(float, float, float, float)">glClearColor</A></B>(float&nbsp;red,
             float&nbsp;green,
             float&nbsp;blue,
             float&nbsp;alpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify clear values for the color buffers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClearDepthf(float)">glClearDepthf</A></B>(float&nbsp;depth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify the clear value for the depth buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClearStencil(int)">glClearStencil</A></B>(int&nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify the clear value for the stencil buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glColorMask(boolean, boolean, boolean, boolean)">glColorMask</A></B>(boolean&nbsp;red,
            boolean&nbsp;green,
            boolean&nbsp;blue,
            boolean&nbsp;alpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable and disable writing of frame buffer color components.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)">glCompileShader</A></B>(int&nbsp;shader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compile a shader object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexImage2D(int, int, int, int, int, int, int, java.nio.Buffer)">glCompressedTexImage2D</A></B>(int&nbsp;target,
                       int&nbsp;level,
                       int&nbsp;internalformat,
                       int&nbsp;width,
                       int&nbsp;height,
                       int&nbsp;border,
                       int&nbsp;imageSize,
                       <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify a two-dimensional texture image in a compressed format.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)">glCompressedTexSubImage2D</A></B>(int&nbsp;target,
                          int&nbsp;level,
                          int&nbsp;xoffset,
                          int&nbsp;yoffset,
                          int&nbsp;width,
                          int&nbsp;height,
                          int&nbsp;format,
                          int&nbsp;imageSize,
                          <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify a two-dimensional texture subimage in a compressed format.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)">glCopyTexImage2D</A></B>(int&nbsp;target,
                 int&nbsp;level,
                 int&nbsp;internalformat,
                 int&nbsp;x,
                 int&nbsp;y,
                 int&nbsp;width,
                 int&nbsp;height,
                 int&nbsp;border)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copy pixels into a 2D texture image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexSubImage2D(int, int, int, int, int, int, int, int)">glCopyTexSubImage2D</A></B>(int&nbsp;target,
                    int&nbsp;level,
                    int&nbsp;xoffset,
                    int&nbsp;yoffset,
                    int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;width,
                    int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copy a two-dimensional texture subimage.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateProgram()">glCreateProgram</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a program object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateShader(int)">glCreateShader</A></B>(int&nbsp;type)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a shader object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCullFace(int)">glCullFace</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify whether front- or back-facing facets can be culled.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, int[], int)">glDeleteBuffers</A></B>(int&nbsp;n,
                int[]&nbsp;buffers,
                int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete named buffer objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, java.nio.IntBuffer)">glDeleteBuffers</A></B>(int&nbsp;n,
                <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;buffers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, int[], int)"><CODE>glDeleteBuffers</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, int[], int)">glDeleteFramebuffers</A></B>(int&nbsp;n,
                     int[]&nbsp;framebuffers,
                     int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete named framebuffer objects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, java.nio.IntBuffer)">glDeleteFramebuffers</A></B>(int&nbsp;n,
                     <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;framebuffers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, int[], int)"><CODE>glDeleteFramebuffers</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteProgram(int)">glDeleteProgram</A></B>(int&nbsp;program)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete a program object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, int[], int)">glDeleteRenderbuffers</A></B>(int&nbsp;n,
                      int[]&nbsp;renderbuffers,
                      int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete named renderbuffer objects
 
 Description
 <code>glDeleteRenderbuffers</code> deletes <i><code>n</code></i> renderbuffer objects 
 named by the elements of the array <i><code>renderbuffers</code></i>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, java.nio.IntBuffer)">glDeleteRenderbuffers</A></B>(int&nbsp;n,
                      <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;renderbuffers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, java.nio.IntBuffer)"><CODE>glDeleteRenderbuffers</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteShader(int)">glDeleteShader</A></B>(int&nbsp;shader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete a shader object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, int[], int)">glDeleteTextures</A></B>(int&nbsp;n,
                 int[]&nbsp;textures,
                 int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete named textures.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, java.nio.IntBuffer)">glDeleteTextures</A></B>(int&nbsp;n,
                 <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;textures)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, int[], int)"><CODE>glDeleteTextures</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)">glDepthFunc</A></B>(int&nbsp;func)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify the value used for depth buffer comparisons.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthMask(boolean)">glDepthMask</A></B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable or disable writing into the depth buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthRangef(float, float)">glDepthRangef</A></B>(float&nbsp;zNear,
              float&nbsp;zFar)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify mapping of depth values from normalized device coordinates 
 to window coordinates.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDetachShader(int, int)">glDetachShader</A></B>(int&nbsp;program,
               int&nbsp;shader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Detach a shader object from a program object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisable(int)">glDisable</A></B>(int&nbsp;cap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disable server-side GL capabilities.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisableVertexAttribArray(int)">glDisableVertexAttribArray</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disable a generic vertex attribute array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawArrays(int, int, int)">glDrawArrays</A></B>(int&nbsp;mode,
             int&nbsp;first,
             int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Render primitives from array data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)">glDrawElements</A></B>(int&nbsp;mode,
               int&nbsp;count,
               int&nbsp;type,
               int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VBO version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>glDrawElements</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)">glDrawElements</A></B>(int&nbsp;mode,
               int&nbsp;count,
               int&nbsp;type,
               <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;indices)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Render primitives from array data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)">glEnable</A></B>(int&nbsp;cap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enable server-side GL capabilities.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnableVertexAttribArray(int)">glEnableVertexAttribArray</A></B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables a generic vertex attribute array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFinish()">glFinish</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Block until all GL execution is complete.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFlush()">glFlush</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Force execution of GL commands in finite time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFramebufferRenderbuffer(int, int, int, int)">glFramebufferRenderbuffer</A></B>(int&nbsp;target,
                          int&nbsp;attachment,
                          int&nbsp;renderbuffertarget,
                          int&nbsp;renderbuffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attach a renderbuffer object to a framebuffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFramebufferTexture2D(int, int, int, int, int)">glFramebufferTexture2D</A></B>(int&nbsp;target,
                       int&nbsp;attachment,
                       int&nbsp;textarget,
                       int&nbsp;texture,
                       int&nbsp;level)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attach a texture image to a framebuffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFrontFace(int)">glFrontFace</A></B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define front- and back-facing polygons.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, int[], int)">glGenBuffers</A></B>(int&nbsp;n,
             int[]&nbsp;buffers,
             int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate buffer object names.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, java.nio.IntBuffer)">glGenBuffers</A></B>(int&nbsp;n,
             <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;buffers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <code>glGenBuffers</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, int[], int)">glGenFramebuffers</A></B>(int&nbsp;n,
                  int[]&nbsp;framebuffers,
                  int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate framebuffer object names
 
 Description
 <code>glGenFramebuffers</code> returns <i><code>n</code></i> framebuffer object names in <i><code>framebuffers</code></i>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, java.nio.IntBuffer)">glGenFramebuffers</A></B>(int&nbsp;n,
                  <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;framebuffers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, int[], int)"><CODE>glGenBuffers</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, int[], int)">glGenRenderbuffers</A></B>(int&nbsp;n,
                   int[]&nbsp;renderbuffers,
                   int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate renderbuffer object names.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, java.nio.IntBuffer)">glGenRenderbuffers</A></B>(int&nbsp;n,
                   <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;renderbuffers)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, int[], int)"><CODE>glGenRenderbuffers</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, int[], int)">glGenTextures</A></B>(int&nbsp;n,
              int[]&nbsp;textures,
              int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate texture names.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, java.nio.IntBuffer)">glGenTextures</A></B>(int&nbsp;n,
              <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;textures)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, int[], int)"><CODE>glGenTextures</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenerateMipmap(int)">glGenerateMipmap</A></B>(int&nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Generate a complete set of mipmaps for a texture object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveAttrib(int, int, int, int[], int, int[], int, int[], int, byte[], int)">glGetActiveAttrib</A></B>(int&nbsp;program,
                  int&nbsp;index,
                  int&nbsp;bufSize,
                  int[]&nbsp;length,
                  int&nbsp;lengthOffset,
                  int[]&nbsp;size,
                  int&nbsp;sizeOffset,
                  int[]&nbsp;type,
                  int&nbsp;typeOffset,
                  byte[]&nbsp;name,
                  int&nbsp;nameOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return information about an active attribute variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveAttrib(int, int, int[], int, int[], int)">glGetActiveAttrib</A></B>(int&nbsp;program,
                  int&nbsp;index,
                  int[]&nbsp;size,
                  int&nbsp;sizeOffset,
                  int[]&nbsp;type,
                  int&nbsp;typeOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return information about an active attribute variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveUniform(int, int, int, int[], int, int[], int, int[], int, byte[], int)">glGetActiveUniform</A></B>(int&nbsp;program,
                   int&nbsp;index,
                   int&nbsp;bufSize,
                   int[]&nbsp;length,
                   int&nbsp;lengthOffset,
                   int[]&nbsp;size,
                   int&nbsp;sizeOffset,
                   int[]&nbsp;type,
                   int&nbsp;typeOffset,
                   byte[]&nbsp;name,
                   int&nbsp;nameOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return information about an active uniform variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveUniform(int, int, int[], int, int[], int)">glGetActiveUniform</A></B>(int&nbsp;program,
                   int&nbsp;index,
                   int[]&nbsp;size,
                   int&nbsp;sizeOffset,
                   int[]&nbsp;type,
                   int&nbsp;typeOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return information about an active uniform variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, int[], int, int[], int)">glGetAttachedShaders</A></B>(int&nbsp;program,
                     int&nbsp;maxcount,
                     int[]&nbsp;count,
                     int&nbsp;countOffset,
                     int[]&nbsp;shaders,
                     int&nbsp;shadersOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the handles of the shader objects attached to a program object
 
 Description
 <code>glGetAttachedShaders</code> returns the names of the shader 
 objects attached to <i><code>program</code></i>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, java.nio.IntBuffer, java.nio.IntBuffer)">glGetAttachedShaders</A></B>(int&nbsp;program,
                     int&nbsp;maxcount,
                     <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;count,
                     <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;shaders)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, int[], int, int[], int)"><CODE>glGetAttachedShaders</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttribLocation(int, java.lang.String)">glGetAttribLocation</A></B>(int&nbsp;program,
                    <A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the location of an attribute variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, boolean[], int)">glGetBooleanv</A></B>(int&nbsp;pname,
              boolean[]&nbsp;params,
              int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boolean version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, java.nio.IntBuffer)">glGetBooleanv</A></B>(int&nbsp;pname,
              <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Boolean version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBufferParameteriv(int, int, int[], int)">glGetBufferParameteriv</A></B>(int&nbsp;target,
                       int&nbsp;pname,
                       int[]&nbsp;params,
                       int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return parameters of a buffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBufferParameteriv(int, int, java.nio.IntBuffer)">glGetBufferParameteriv</A></B>(int&nbsp;target,
                       int&nbsp;pname,
                       <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBufferParameteriv(int, int, int[], int)"><CODE>glGetBufferParameteriv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetError()">glGetError</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return error information.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFloatv(int, float[], int)">glGetFloatv</A></B>(int&nbsp;pname,
            float[]&nbsp;params,
            int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFloatv(int, java.nio.FloatBuffer)">glGetFloatv</A></B>(int&nbsp;pname,
            <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)">glGetFramebufferAttachmentParameteriv</A></B>(int&nbsp;target,
                                      int&nbsp;attachment,
                                      int&nbsp;pname,
                                      int[]&nbsp;params,
                                      int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return attachment parameters of a framebuffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, java.nio.IntBuffer)">glGetFramebufferAttachmentParameteriv</A></B>(int&nbsp;target,
                                      int&nbsp;attachment,
                                      int&nbsp;pname,
                                      <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)"><CODE>glGetFramebufferAttachmentParameteriv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)">glGetIntegerv</A></B>(int&nbsp;pname,
              int[]&nbsp;params,
              int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the value or values of a selected parameter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)">glGetIntegerv</A></B>(int&nbsp;pname,
              <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramInfoLog(int)">glGetProgramInfoLog</A></B>(int&nbsp;program)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the information log for a program object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramInfoLog(int, int, int[], byte[])">glGetProgramInfoLog</A></B>(int&nbsp;program,
                    int&nbsp;maxsize,
                    int[]&nbsp;length,
                    byte[]&nbsp;infolog)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the information log for a program object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)">glGetProgramiv</A></B>(int&nbsp;program,
               int&nbsp;pname,
               int[]&nbsp;params,
               int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a parameter from a program object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)">glGetProgramiv</A></B>(int&nbsp;program,
               int&nbsp;pname,
               <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, int[], int)">glGetRenderbufferParameteriv</A></B>(int&nbsp;target,
                             int&nbsp;pname,
                             int[]&nbsp;params,
                             int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return parameters of a renderbuffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, java.nio.IntBuffer)">glGetRenderbufferParameteriv</A></B>(int&nbsp;target,
                             int&nbsp;pname,
                             <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, int[], int)"><CODE>glGetRenderbufferParameteriv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderInfoLog(int)">glGetShaderInfoLog</A></B>(int&nbsp;shader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the information log for a shader object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderInfoLog(int, int, int[], byte[])">glGetShaderInfoLog</A></B>(int&nbsp;shader,
                   int&nbsp;maxsize,
                   int[]&nbsp;length,
                   byte[]&nbsp;infolog)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the information log for a shader object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderPrecisionFormat(int, int, int[], int, int[], int)">glGetShaderPrecisionFormat</A></B>(int&nbsp;shadertype,
                           int&nbsp;precisiontype,
                           int[]&nbsp;range,
                           int&nbsp;rangeOffset,
                           int[]&nbsp;precision,
                           int&nbsp;precisionOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the range and precision for different shader numeric formats.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderSource(int)">glGetShaderSource</A></B>(int&nbsp;shader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the source code string from a shader object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderSource(int, int, int[], byte[])">glGetShaderSource</A></B>(int&nbsp;shader,
                  int&nbsp;bufSize,
                  int[]&nbsp;length,
                  byte[]&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the source code string from a shader object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)">glGetShaderiv</A></B>(int&nbsp;shader,
              int&nbsp;pname,
              int[]&nbsp;params,
              int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a parameter from a shader object
 
 Description
 <code>glGetShaderiv</code> returns in <i><code>params</code></i> the value of a parameter
 for a specific shader object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)">glGetShaderiv</A></B>(int&nbsp;shader,
              int&nbsp;pname,
              <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetString(int)">glGetString</A></B>(int&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a string describing the current GL connection.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, float[], int)">glGetTexParameterfv</A></B>(int&nbsp;target,
                    int&nbsp;pname,
                    float[]&nbsp;params,
                    int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, int[], int)"><CODE>glGetTexParameteriv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, java.nio.FloatBuffer)">glGetTexParameterfv</A></B>(int&nbsp;target,
                    int&nbsp;pname,
                    <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>glGetTexParameteriv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, int[], int)">glGetTexParameteriv</A></B>(int&nbsp;target,
                    int&nbsp;pname,
                    int[]&nbsp;params,
                    int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return texture parameter values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, java.nio.IntBuffer)">glGetTexParameteriv</A></B>(int&nbsp;target,
                    int&nbsp;pname,
                    <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, int[], int)"><CODE>glGetTexParameteriv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformLocation(int, java.lang.String)">glGetUniformLocation</A></B>(int&nbsp;program,
                     <A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the location of a uniform variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, float[], int)">glGetUniformfv</A></B>(int&nbsp;program,
               int&nbsp;location,
               int&nbsp;count,
               float[]&nbsp;params,
               int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>glGetUniformiv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, java.nio.FloatBuffer)">glGetUniformfv</A></B>(int&nbsp;program,
               int&nbsp;location,
               int&nbsp;count,
               <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, java.nio.IntBuffer)"><CODE>glGetUniformiv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)">glGetUniformiv</A></B>(int&nbsp;program,
               int&nbsp;location,
               int&nbsp;count,
               int[]&nbsp;params,
               int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the value of a uniform variable.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, java.nio.IntBuffer)">glGetUniformiv</A></B>(int&nbsp;program,
               int&nbsp;location,
               int&nbsp;count,
               <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Int <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>glGetUniformiv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, float[], int)">glGetVertexAttribfv</A></B>(int&nbsp;index,
                    int&nbsp;pname,
                    float[]&nbsp;params,
                    int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>glGetVertexAttribiv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, java.nio.FloatBuffer)">glGetVertexAttribfv</A></B>(int&nbsp;index,
                    int&nbsp;pname,
                    <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><CODE>glGetVertexAttribiv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)">glGetVertexAttribiv</A></B>(int&nbsp;index,
                    int&nbsp;pname,
                    int[]&nbsp;params,
                    int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return a generic vertex attribute parameter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)">glGetVertexAttribiv</A></B>(int&nbsp;index,
                    int&nbsp;pname,
                    <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>glGetVertexAttribiv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glHint(int, int)">glHint</A></B>(int&nbsp;target,
       int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify implementation-specific hints.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsBuffer(int)">glIsBuffer</A></B>(int&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine if a name corresponds to a buffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)">glIsEnabled</A></B>(int&nbsp;cap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test whether a capability is enabled
 
 <code>glIsEnabled</code> returns <code>true</code> if <i><code>cap</code></i> is an enabled capability and 
 returns <code>false</code> otherwise.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsFramebuffer(int)">glIsFramebuffer</A></B>(int&nbsp;framebuffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine if a name corresponds to a framebuffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)">glIsProgram</A></B>(int&nbsp;program)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine if a name corresponds to a program object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsRenderbuffer(int)">glIsRenderbuffer</A></B>(int&nbsp;renderbuffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine if a name corresponds to a renderbuffer object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsShader(int)">glIsShader</A></B>(int&nbsp;shader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine if a name corresponds to a shader object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsTexture(int)">glIsTexture</A></B>(int&nbsp;texture)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine if a name corresponds to a texture.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLineWidth(float)">glLineWidth</A></B>(float&nbsp;width)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify the width of rasterized lines
 
 Description
 <code>glLineWidth</code> specifies the rasterized width of lines.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)">glLinkProgram</A></B>(int&nbsp;program)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Link a program object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPixelStorei(int, int)">glPixelStorei</A></B>(int&nbsp;pname,
              int&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set pixel storage modes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPolygonOffset(float, float)">glPolygonOffset</A></B>(float&nbsp;factor,
                float&nbsp;units)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the scale and units used to calculate depth values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReadPixels(int, int, int, int, int, int, java.nio.Buffer)">glReadPixels</A></B>(int&nbsp;x,
             int&nbsp;y,
             int&nbsp;width,
             int&nbsp;height,
             int&nbsp;format,
             int&nbsp;type,
             <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pixels)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read a block of pixels from the frame buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReleaseShaderCompiler()">glReleaseShaderCompiler</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Release resources allocated by the shader compiler.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glRenderbufferStorage(int, int, int, int)">glRenderbufferStorage</A></B>(int&nbsp;target,
                      int&nbsp;internalformat,
                      int&nbsp;width,
                      int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create and initialize a renderbuffer object's data store.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glSampleCoverage(float, boolean)">glSampleCoverage</A></B>(float&nbsp;value,
                 boolean&nbsp;invert)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify multisample coverage parameters
 
 Description
 Multisampling samples a pixel multiple times at various implementation-dependent 
 subpixel locations to generate antialiasing effects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glScissor(int, int, int, int)">glScissor</A></B>(int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define the scissor box.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)">glShaderBinary</A></B>(int&nbsp;n,
               int[]&nbsp;shaders,
               int&nbsp;shadersOffset,
               int&nbsp;binaryformat,
               <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;binary,
               int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Load a precompiled shader binary.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, java.nio.IntBuffer, int, java.nio.Buffer, int)">glShaderBinary</A></B>(int&nbsp;n,
               <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;shaders,
               int&nbsp;binaryformat,
               <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;binary,
               int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])">glShaderSource</A></B>(int&nbsp;shader,
               int&nbsp;count,
               <A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>[]&nbsp;strings,
               int[]&nbsp;lengths)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replace the source code in a shader object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, java.lang.String)">glShaderSource</A></B>(int&nbsp;shader,
               <A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;source)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replace the source code in a shader object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)">glStencilFunc</A></B>(int&nbsp;func,
              int&nbsp;ref,
              int&nbsp;mask)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set front and back function and reference value for stencil testing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)">glStencilFuncSeparate</A></B>(int&nbsp;face,
                      int&nbsp;func,
                      int&nbsp;ref,
                      int&nbsp;mask)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set front and/or back function and reference value for stencil testing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMask(int)">glStencilMask</A></B>(int&nbsp;mask)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Control the front and back writing of individual bits in the stencil planes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMaskSeparate(int, int)">glStencilMaskSeparate</A></B>(int&nbsp;face,
                      int&nbsp;mask)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Control the front and/or back writing of individual bits in the stencil planes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)">glStencilOp</A></B>(int&nbsp;fail,
            int&nbsp;zfail,
            int&nbsp;zpass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set front and back stencil test actions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)">glStencilOpSeparate</A></B>(int&nbsp;face,
                    int&nbsp;fail,
                    int&nbsp;zfail,
                    int&nbsp;zpass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set front and/or back stencil test actions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)">glTexImage2D</A></B>(int&nbsp;target,
             int&nbsp;level,
             int&nbsp;internalformat,
             int&nbsp;width,
             int&nbsp;height,
             int&nbsp;border,
             int&nbsp;format,
             int&nbsp;type,
             <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify a two-dimensional texture image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)">glTexParameterf</A></B>(int&nbsp;target,
                int&nbsp;pname,
                float&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set texture parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)">glTexParameterfv</A></B>(int&nbsp;target,
                 int&nbsp;pname,
                 float[]&nbsp;params,
                 int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>glTexParameterf</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)">glTexParameterfv</A></B>(int&nbsp;target,
                 int&nbsp;pname,
                 <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>glTexParameterfv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)">glTexParameteri</A></B>(int&nbsp;target,
                int&nbsp;pname,
                int&nbsp;param)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>glTexParameterf</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)">glTexParameteriv</A></B>(int&nbsp;target,
                 int&nbsp;pname,
                 int[]&nbsp;params,
                 int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>glTexParameteri</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)">glTexParameteriv</A></B>(int&nbsp;target,
                 int&nbsp;pname,
                 <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>glTexParameteriv</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)">glTexSubImage2D</A></B>(int&nbsp;target,
                int&nbsp;level,
                int&nbsp;xoffset,
                int&nbsp;yoffset,
                int&nbsp;width,
                int&nbsp;height,
                int&nbsp;format,
                int&nbsp;type,
                <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify a two-dimensional texture subimage.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)">glUniform1f</A></B>(int&nbsp;location,
            float&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify the value of a uniform variable for the current program object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, float[], int)">glUniform1fv</A></B>(int&nbsp;location,
             int&nbsp;count,
             float[]&nbsp;v,
             int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 1 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, java.nio.FloatBuffer)">glUniform1fv</A></B>(int&nbsp;location,
             int&nbsp;count,
             <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 1 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1i(int, int)">glUniform1i</A></B>(int&nbsp;location,
            int&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer 1 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, int[], int)">glUniform1iv</A></B>(int&nbsp;location,
             int&nbsp;count,
             int[]&nbsp;v,
             int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ingteger 1 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, java.nio.IntBuffer)">glUniform1iv</A></B>(int&nbsp;location,
             int&nbsp;count,
             <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer 1 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2f(int, float, float)">glUniform2f</A></B>(int&nbsp;location,
            float&nbsp;x,
            float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 2 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, float[], int)">glUniform2fv</A></B>(int&nbsp;location,
             int&nbsp;count,
             float[]&nbsp;v,
             int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 2 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, java.nio.FloatBuffer)">glUniform2fv</A></B>(int&nbsp;location,
             int&nbsp;count,
             <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 2 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2i(int, int, int)">glUniform2i</A></B>(int&nbsp;location,
            int&nbsp;x,
            int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer 2 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, int[], int)">glUniform2iv</A></B>(int&nbsp;location,
             int&nbsp;count,
             int[]&nbsp;v,
             int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ingteger 2 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, java.nio.IntBuffer)">glUniform2iv</A></B>(int&nbsp;location,
             int&nbsp;count,
             <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer 2 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3f(int, float, float, float)">glUniform3f</A></B>(int&nbsp;location,
            float&nbsp;x,
            float&nbsp;y,
            float&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 3 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, float[], int)">glUniform3fv</A></B>(int&nbsp;location,
             int&nbsp;count,
             float[]&nbsp;v,
             int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 3 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, java.nio.FloatBuffer)">glUniform3fv</A></B>(int&nbsp;location,
             int&nbsp;count,
             <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 3 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3i(int, int, int, int)">glUniform3i</A></B>(int&nbsp;location,
            int&nbsp;x,
            int&nbsp;y,
            int&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer 3 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, int[], int)">glUniform3iv</A></B>(int&nbsp;location,
             int&nbsp;count,
             int[]&nbsp;v,
             int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ingteger 3 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, java.nio.IntBuffer)">glUniform3iv</A></B>(int&nbsp;location,
             int&nbsp;count,
             <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer 3 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4f(int, float, float, float, float)">glUniform4f</A></B>(int&nbsp;location,
            float&nbsp;x,
            float&nbsp;y,
            float&nbsp;z,
            float&nbsp;w)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 4 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, float[], int)">glUniform4fv</A></B>(int&nbsp;location,
             int&nbsp;count,
             float[]&nbsp;v,
             int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 4 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, java.nio.FloatBuffer)">glUniform4fv</A></B>(int&nbsp;location,
             int&nbsp;count,
             <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 4 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4i(int, int, int, int, int)">glUniform4i</A></B>(int&nbsp;location,
            int&nbsp;x,
            int&nbsp;y,
            int&nbsp;z,
            int&nbsp;w)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer 4 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, int[], int)">glUniform4iv</A></B>(int&nbsp;location,
             int&nbsp;count,
             int[]&nbsp;v,
             int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer 4 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, java.nio.IntBuffer)">glUniform4iv</A></B>(int&nbsp;location,
             int&nbsp;count,
             <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer 4 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, float[], int)">glUniformMatrix2fv</A></B>(int&nbsp;location,
                   int&nbsp;count,
                   boolean&nbsp;transpose,
                   float[]&nbsp;value,
                   int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 2x2 matrix array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, java.nio.FloatBuffer)">glUniformMatrix2fv</A></B>(int&nbsp;location,
                   int&nbsp;count,
                   boolean&nbsp;transpose,
                   <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 2x2 matrix <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, float[], int)">glUniformMatrix3fv</A></B>(int&nbsp;location,
                   int&nbsp;count,
                   boolean&nbsp;transpose,
                   float[]&nbsp;value,
                   int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 3x3 matrix array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, java.nio.FloatBuffer)">glUniformMatrix3fv</A></B>(int&nbsp;location,
                   int&nbsp;count,
                   boolean&nbsp;transpose,
                   <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 3x3 matrix <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, float[], int)">glUniformMatrix4fv</A></B>(int&nbsp;location,
                   int&nbsp;count,
                   boolean&nbsp;transpose,
                   float[]&nbsp;value,
                   int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 4x4 matrix array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, java.nio.FloatBuffer)">glUniformMatrix4fv</A></B>(int&nbsp;location,
                   int&nbsp;count,
                   boolean&nbsp;transpose,
                   <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 4x4 matrix <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)">glUseProgram</A></B>(int&nbsp;program)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Install a program object as part of current rendering state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glValidateProgram(int)">glValidateProgram</A></B>(int&nbsp;program)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Validate a program object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)">glVertexAttrib1f</A></B>(int&nbsp;index,
                 float&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify the value of a generic vertex attribute.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, float[], int)">glVertexAttrib1fv</A></B>(int&nbsp;index,
                  float[]&nbsp;values,
                  int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 1 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, java.nio.FloatBuffer)">glVertexAttrib1fv</A></B>(int&nbsp;index,
                  <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;values)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 1 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2f(int, float, float)">glVertexAttrib2f</A></B>(int&nbsp;index,
                 float&nbsp;x,
                 float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 2 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, float[], int)">glVertexAttrib2fv</A></B>(int&nbsp;index,
                  float[]&nbsp;values,
                  int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 2 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, java.nio.FloatBuffer)">glVertexAttrib2fv</A></B>(int&nbsp;index,
                  <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;values)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 2 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3f(int, float, float, float)">glVertexAttrib3f</A></B>(int&nbsp;index,
                 float&nbsp;x,
                 float&nbsp;y,
                 float&nbsp;z)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 3 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, float[], int)">glVertexAttrib3fv</A></B>(int&nbsp;index,
                  float[]&nbsp;values,
                  int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 3 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, java.nio.FloatBuffer)">glVertexAttrib3fv</A></B>(int&nbsp;index,
                  <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;values)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 3 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4f(int, float, float, float, float)">glVertexAttrib4f</A></B>(int&nbsp;index,
                 float&nbsp;x,
                 float&nbsp;y,
                 float&nbsp;z,
                 float&nbsp;w)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 4 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, float[], int)">glVertexAttrib4fv</A></B>(int&nbsp;index,
                  float[]&nbsp;values,
                  int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 4 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, java.nio.FloatBuffer)">glVertexAttrib4fv</A></B>(int&nbsp;index,
                  <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;values)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Floating-point 4 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, int)">glVertexAttribPointer</A></B>(int&nbsp;index,
                      int&nbsp;size,
                      int&nbsp;type,
                      boolean&nbsp;normalized,
                      int&nbsp;stride,
                      int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;VBO version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><CODE>glVertexAttribPointer</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)">glVertexAttribPointer</A></B>(int&nbsp;index,
                      int&nbsp;size,
                      int&nbsp;type,
                      boolean&nbsp;normalized,
                      int&nbsp;stride,
                      <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define an array of generic vertex attribute data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glViewport(int, int, int, int)">glViewport</A></B>(int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the viewport.</TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<BR>

<BR>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF">
<TH ALIGN="left" COLSPAN="1" CLASS="TableHeadingColor"><FONT SIZE="+0">
Field Detail</FONT></TH>
</TR>
</TABLE>
<A NAME="GL_ES_VERSION_2_0"><!-- --></A><H3>
GL_ES_VERSION_2_0</H3>
<PRE>
static final int <B>GL_ES_VERSION_2_0</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ES_VERSION_2_0">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DEPTH_BUFFER_BIT"><!-- --></A><H3>
GL_DEPTH_BUFFER_BIT</H3>
<PRE>
static final int <B>GL_DEPTH_BUFFER_BIT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DEPTH_BUFFER_BIT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_BUFFER_BIT"><!-- --></A><H3>
GL_STENCIL_BUFFER_BIT</H3>
<PRE>
static final int <B>GL_STENCIL_BUFFER_BIT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_BUFFER_BIT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_COLOR_BUFFER_BIT"><!-- --></A><H3>
GL_COLOR_BUFFER_BIT</H3>
<PRE>
static final int <B>GL_COLOR_BUFFER_BIT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_COLOR_BUFFER_BIT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FALSE"><!-- --></A><H3>
GL_FALSE</H3>
<PRE>
static final int <B>GL_FALSE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FALSE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TRUE"><!-- --></A><H3>
GL_TRUE</H3>
<PRE>
static final int <B>GL_TRUE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TRUE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_POINTS"><!-- --></A><H3>
GL_POINTS</H3>
<PRE>
static final int <B>GL_POINTS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_POINTS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_LINES"><!-- --></A><H3>
GL_LINES</H3>
<PRE>
static final int <B>GL_LINES</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_LINES">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_LINE_LOOP"><!-- --></A><H3>
GL_LINE_LOOP</H3>
<PRE>
static final int <B>GL_LINE_LOOP</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_LINE_LOOP">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_LINE_STRIP"><!-- --></A><H3>
GL_LINE_STRIP</H3>
<PRE>
static final int <B>GL_LINE_STRIP</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_LINE_STRIP">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TRIANGLES"><!-- --></A><H3>
GL_TRIANGLES</H3>
<PRE>
static final int <B>GL_TRIANGLES</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TRIANGLES">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TRIANGLE_STRIP"><!-- --></A><H3>
GL_TRIANGLE_STRIP</H3>
<PRE>
static final int <B>GL_TRIANGLE_STRIP</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TRIANGLE_STRIP">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TRIANGLE_FAN"><!-- --></A><H3>
GL_TRIANGLE_FAN</H3>
<PRE>
static final int <B>GL_TRIANGLE_FAN</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TRIANGLE_FAN">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ZERO"><!-- --></A><H3>
GL_ZERO</H3>
<PRE>
static final int <B>GL_ZERO</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ZERO">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ONE"><!-- --></A><H3>
GL_ONE</H3>
<PRE>
static final int <B>GL_ONE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ONE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SRC_COLOR"><!-- --></A><H3>
GL_SRC_COLOR</H3>
<PRE>
static final int <B>GL_SRC_COLOR</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SRC_COLOR">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ONE_MINUS_SRC_COLOR"><!-- --></A><H3>
GL_ONE_MINUS_SRC_COLOR</H3>
<PRE>
static final int <B>GL_ONE_MINUS_SRC_COLOR</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ONE_MINUS_SRC_COLOR">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SRC_ALPHA"><!-- --></A><H3>
GL_SRC_ALPHA</H3>
<PRE>
static final int <B>GL_SRC_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SRC_ALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ONE_MINUS_SRC_ALPHA"><!-- --></A><H3>
GL_ONE_MINUS_SRC_ALPHA</H3>
<PRE>
static final int <B>GL_ONE_MINUS_SRC_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ONE_MINUS_SRC_ALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DST_ALPHA"><!-- --></A><H3>
GL_DST_ALPHA</H3>
<PRE>
static final int <B>GL_DST_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DST_ALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ONE_MINUS_DST_ALPHA"><!-- --></A><H3>
GL_ONE_MINUS_DST_ALPHA</H3>
<PRE>
static final int <B>GL_ONE_MINUS_DST_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ONE_MINUS_DST_ALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DST_COLOR"><!-- --></A><H3>
GL_DST_COLOR</H3>
<PRE>
static final int <B>GL_DST_COLOR</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DST_COLOR">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ONE_MINUS_DST_COLOR"><!-- --></A><H3>
GL_ONE_MINUS_DST_COLOR</H3>
<PRE>
static final int <B>GL_ONE_MINUS_DST_COLOR</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ONE_MINUS_DST_COLOR">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SRC_ALPHA_SATURATE"><!-- --></A><H3>
GL_SRC_ALPHA_SATURATE</H3>
<PRE>
static final int <B>GL_SRC_ALPHA_SATURATE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SRC_ALPHA_SATURATE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FUNC_ADD"><!-- --></A><H3>
GL_FUNC_ADD</H3>
<PRE>
static final int <B>GL_FUNC_ADD</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FUNC_ADD">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BLEND_EQUATION"><!-- --></A><H3>
GL_BLEND_EQUATION</H3>
<PRE>
static final int <B>GL_BLEND_EQUATION</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BLEND_EQUATION">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BLEND_EQUATION_RGB"><!-- --></A><H3>
GL_BLEND_EQUATION_RGB</H3>
<PRE>
static final int <B>GL_BLEND_EQUATION_RGB</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BLEND_EQUATION_RGB">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BLEND_EQUATION_ALPHA"><!-- --></A><H3>
GL_BLEND_EQUATION_ALPHA</H3>
<PRE>
static final int <B>GL_BLEND_EQUATION_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BLEND_EQUATION_ALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FUNC_SUBTRACT"><!-- --></A><H3>
GL_FUNC_SUBTRACT</H3>
<PRE>
static final int <B>GL_FUNC_SUBTRACT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FUNC_SUBTRACT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FUNC_REVERSE_SUBTRACT"><!-- --></A><H3>
GL_FUNC_REVERSE_SUBTRACT</H3>
<PRE>
static final int <B>GL_FUNC_REVERSE_SUBTRACT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FUNC_REVERSE_SUBTRACT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BLEND_DST_RGB"><!-- --></A><H3>
GL_BLEND_DST_RGB</H3>
<PRE>
static final int <B>GL_BLEND_DST_RGB</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BLEND_DST_RGB">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BLEND_SRC_RGB"><!-- --></A><H3>
GL_BLEND_SRC_RGB</H3>
<PRE>
static final int <B>GL_BLEND_SRC_RGB</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BLEND_SRC_RGB">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BLEND_DST_ALPHA"><!-- --></A><H3>
GL_BLEND_DST_ALPHA</H3>
<PRE>
static final int <B>GL_BLEND_DST_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BLEND_DST_ALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BLEND_SRC_ALPHA"><!-- --></A><H3>
GL_BLEND_SRC_ALPHA</H3>
<PRE>
static final int <B>GL_BLEND_SRC_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BLEND_SRC_ALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_CONSTANT_COLOR"><!-- --></A><H3>
GL_CONSTANT_COLOR</H3>
<PRE>
static final int <B>GL_CONSTANT_COLOR</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_CONSTANT_COLOR">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ONE_MINUS_CONSTANT_COLOR"><!-- --></A><H3>
GL_ONE_MINUS_CONSTANT_COLOR</H3>
<PRE>
static final int <B>GL_ONE_MINUS_CONSTANT_COLOR</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ONE_MINUS_CONSTANT_COLOR">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_CONSTANT_ALPHA"><!-- --></A><H3>
GL_CONSTANT_ALPHA</H3>
<PRE>
static final int <B>GL_CONSTANT_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_CONSTANT_ALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ONE_MINUS_CONSTANT_ALPHA"><!-- --></A><H3>
GL_ONE_MINUS_CONSTANT_ALPHA</H3>
<PRE>
static final int <B>GL_ONE_MINUS_CONSTANT_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ONE_MINUS_CONSTANT_ALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BLEND_COLOR"><!-- --></A><H3>
GL_BLEND_COLOR</H3>
<PRE>
static final int <B>GL_BLEND_COLOR</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BLEND_COLOR">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ARRAY_BUFFER"><!-- --></A><H3>
GL_ARRAY_BUFFER</H3>
<PRE>
static final int <B>GL_ARRAY_BUFFER</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ARRAY_BUFFER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ELEMENT_ARRAY_BUFFER"><!-- --></A><H3>
GL_ELEMENT_ARRAY_BUFFER</H3>
<PRE>
static final int <B>GL_ELEMENT_ARRAY_BUFFER</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ELEMENT_ARRAY_BUFFER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ARRAY_BUFFER_BINDING"><!-- --></A><H3>
GL_ARRAY_BUFFER_BINDING</H3>
<PRE>
static final int <B>GL_ARRAY_BUFFER_BINDING</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ARRAY_BUFFER_BINDING">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ELEMENT_ARRAY_BUFFER_BINDING"><!-- --></A><H3>
GL_ELEMENT_ARRAY_BUFFER_BINDING</H3>
<PRE>
static final int <B>GL_ELEMENT_ARRAY_BUFFER_BINDING</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ELEMENT_ARRAY_BUFFER_BINDING">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STREAM_DRAW"><!-- --></A><H3>
GL_STREAM_DRAW</H3>
<PRE>
static final int <B>GL_STREAM_DRAW</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STREAM_DRAW">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STATIC_DRAW"><!-- --></A><H3>
GL_STATIC_DRAW</H3>
<PRE>
static final int <B>GL_STATIC_DRAW</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STATIC_DRAW">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DYNAMIC_DRAW"><!-- --></A><H3>
GL_DYNAMIC_DRAW</H3>
<PRE>
static final int <B>GL_DYNAMIC_DRAW</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DYNAMIC_DRAW">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BUFFER_SIZE"><!-- --></A><H3>
GL_BUFFER_SIZE</H3>
<PRE>
static final int <B>GL_BUFFER_SIZE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BUFFER_SIZE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BUFFER_USAGE"><!-- --></A><H3>
GL_BUFFER_USAGE</H3>
<PRE>
static final int <B>GL_BUFFER_USAGE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BUFFER_USAGE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_CURRENT_VERTEX_ATTRIB"><!-- --></A><H3>
GL_CURRENT_VERTEX_ATTRIB</H3>
<PRE>
static final int <B>GL_CURRENT_VERTEX_ATTRIB</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_CURRENT_VERTEX_ATTRIB">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FRONT"><!-- --></A><H3>
GL_FRONT</H3>
<PRE>
static final int <B>GL_FRONT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FRONT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BACK"><!-- --></A><H3>
GL_BACK</H3>
<PRE>
static final int <B>GL_BACK</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BACK">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FRONT_AND_BACK"><!-- --></A><H3>
GL_FRONT_AND_BACK</H3>
<PRE>
static final int <B>GL_FRONT_AND_BACK</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FRONT_AND_BACK">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_2D"><!-- --></A><H3>
GL_TEXTURE_2D</H3>
<PRE>
static final int <B>GL_TEXTURE_2D</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE_2D">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_CULL_FACE"><!-- --></A><H3>
GL_CULL_FACE</H3>
<PRE>
static final int <B>GL_CULL_FACE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_CULL_FACE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BLEND"><!-- --></A><H3>
GL_BLEND</H3>
<PRE>
static final int <B>GL_BLEND</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BLEND">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DITHER"><!-- --></A><H3>
GL_DITHER</H3>
<PRE>
static final int <B>GL_DITHER</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DITHER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_TEST"><!-- --></A><H3>
GL_STENCIL_TEST</H3>
<PRE>
static final int <B>GL_STENCIL_TEST</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_TEST">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DEPTH_TEST"><!-- --></A><H3>
GL_DEPTH_TEST</H3>
<PRE>
static final int <B>GL_DEPTH_TEST</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DEPTH_TEST">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SCISSOR_TEST"><!-- --></A><H3>
GL_SCISSOR_TEST</H3>
<PRE>
static final int <B>GL_SCISSOR_TEST</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SCISSOR_TEST">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_POLYGON_OFFSET_FILL"><!-- --></A><H3>
GL_POLYGON_OFFSET_FILL</H3>
<PRE>
static final int <B>GL_POLYGON_OFFSET_FILL</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_POLYGON_OFFSET_FILL">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SAMPLE_ALPHA_TO_COVERAGE"><!-- --></A><H3>
GL_SAMPLE_ALPHA_TO_COVERAGE</H3>
<PRE>
static final int <B>GL_SAMPLE_ALPHA_TO_COVERAGE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SAMPLE_ALPHA_TO_COVERAGE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SAMPLE_COVERAGE"><!-- --></A><H3>
GL_SAMPLE_COVERAGE</H3>
<PRE>
static final int <B>GL_SAMPLE_COVERAGE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SAMPLE_COVERAGE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_NO_ERROR"><!-- --></A><H3>
GL_NO_ERROR</H3>
<PRE>
static final int <B>GL_NO_ERROR</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_NO_ERROR">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_INVALID_ENUM"><!-- --></A><H3>
GL_INVALID_ENUM</H3>
<PRE>
static final int <B>GL_INVALID_ENUM</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_INVALID_ENUM">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_INVALID_VALUE"><!-- --></A><H3>
GL_INVALID_VALUE</H3>
<PRE>
static final int <B>GL_INVALID_VALUE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_INVALID_VALUE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_INVALID_OPERATION"><!-- --></A><H3>
GL_INVALID_OPERATION</H3>
<PRE>
static final int <B>GL_INVALID_OPERATION</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_INVALID_OPERATION">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_OUT_OF_MEMORY"><!-- --></A><H3>
GL_OUT_OF_MEMORY</H3>
<PRE>
static final int <B>GL_OUT_OF_MEMORY</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_OUT_OF_MEMORY">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_CW"><!-- --></A><H3>
GL_CW</H3>
<PRE>
static final int <B>GL_CW</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_CW">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_CCW"><!-- --></A><H3>
GL_CCW</H3>
<PRE>
static final int <B>GL_CCW</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_CCW">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_LINE_WIDTH"><!-- --></A><H3>
GL_LINE_WIDTH</H3>
<PRE>
static final int <B>GL_LINE_WIDTH</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_LINE_WIDTH">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ALIASED_POINT_SIZE_RANGE"><!-- --></A><H3>
GL_ALIASED_POINT_SIZE_RANGE</H3>
<PRE>
static final int <B>GL_ALIASED_POINT_SIZE_RANGE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ALIASED_POINT_SIZE_RANGE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ALIASED_LINE_WIDTH_RANGE"><!-- --></A><H3>
GL_ALIASED_LINE_WIDTH_RANGE</H3>
<PRE>
static final int <B>GL_ALIASED_LINE_WIDTH_RANGE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ALIASED_LINE_WIDTH_RANGE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_CULL_FACE_MODE"><!-- --></A><H3>
GL_CULL_FACE_MODE</H3>
<PRE>
static final int <B>GL_CULL_FACE_MODE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_CULL_FACE_MODE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FRONT_FACE"><!-- --></A><H3>
GL_FRONT_FACE</H3>
<PRE>
static final int <B>GL_FRONT_FACE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FRONT_FACE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DEPTH_RANGE"><!-- --></A><H3>
GL_DEPTH_RANGE</H3>
<PRE>
static final int <B>GL_DEPTH_RANGE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DEPTH_RANGE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DEPTH_WRITEMASK"><!-- --></A><H3>
GL_DEPTH_WRITEMASK</H3>
<PRE>
static final int <B>GL_DEPTH_WRITEMASK</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DEPTH_WRITEMASK">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DEPTH_CLEAR_VALUE"><!-- --></A><H3>
GL_DEPTH_CLEAR_VALUE</H3>
<PRE>
static final int <B>GL_DEPTH_CLEAR_VALUE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DEPTH_CLEAR_VALUE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DEPTH_FUNC"><!-- --></A><H3>
GL_DEPTH_FUNC</H3>
<PRE>
static final int <B>GL_DEPTH_FUNC</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DEPTH_FUNC">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_CLEAR_VALUE"><!-- --></A><H3>
GL_STENCIL_CLEAR_VALUE</H3>
<PRE>
static final int <B>GL_STENCIL_CLEAR_VALUE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_CLEAR_VALUE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_FUNC"><!-- --></A><H3>
GL_STENCIL_FUNC</H3>
<PRE>
static final int <B>GL_STENCIL_FUNC</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_FUNC">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_FAIL"><!-- --></A><H3>
GL_STENCIL_FAIL</H3>
<PRE>
static final int <B>GL_STENCIL_FAIL</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_FAIL">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_PASS_DEPTH_FAIL"><!-- --></A><H3>
GL_STENCIL_PASS_DEPTH_FAIL</H3>
<PRE>
static final int <B>GL_STENCIL_PASS_DEPTH_FAIL</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_PASS_DEPTH_FAIL">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_PASS_DEPTH_PASS"><!-- --></A><H3>
GL_STENCIL_PASS_DEPTH_PASS</H3>
<PRE>
static final int <B>GL_STENCIL_PASS_DEPTH_PASS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_PASS_DEPTH_PASS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_REF"><!-- --></A><H3>
GL_STENCIL_REF</H3>
<PRE>
static final int <B>GL_STENCIL_REF</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_REF">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_VALUE_MASK"><!-- --></A><H3>
GL_STENCIL_VALUE_MASK</H3>
<PRE>
static final int <B>GL_STENCIL_VALUE_MASK</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_VALUE_MASK">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_WRITEMASK"><!-- --></A><H3>
GL_STENCIL_WRITEMASK</H3>
<PRE>
static final int <B>GL_STENCIL_WRITEMASK</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_WRITEMASK">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_BACK_FUNC"><!-- --></A><H3>
GL_STENCIL_BACK_FUNC</H3>
<PRE>
static final int <B>GL_STENCIL_BACK_FUNC</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_BACK_FUNC">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_BACK_FAIL"><!-- --></A><H3>
GL_STENCIL_BACK_FAIL</H3>
<PRE>
static final int <B>GL_STENCIL_BACK_FAIL</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_BACK_FAIL">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_BACK_PASS_DEPTH_FAIL"><!-- --></A><H3>
GL_STENCIL_BACK_PASS_DEPTH_FAIL</H3>
<PRE>
static final int <B>GL_STENCIL_BACK_PASS_DEPTH_FAIL</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_BACK_PASS_DEPTH_FAIL">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_BACK_PASS_DEPTH_PASS"><!-- --></A><H3>
GL_STENCIL_BACK_PASS_DEPTH_PASS</H3>
<PRE>
static final int <B>GL_STENCIL_BACK_PASS_DEPTH_PASS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_BACK_PASS_DEPTH_PASS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_BACK_REF"><!-- --></A><H3>
GL_STENCIL_BACK_REF</H3>
<PRE>
static final int <B>GL_STENCIL_BACK_REF</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_BACK_REF">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_BACK_VALUE_MASK"><!-- --></A><H3>
GL_STENCIL_BACK_VALUE_MASK</H3>
<PRE>
static final int <B>GL_STENCIL_BACK_VALUE_MASK</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_BACK_VALUE_MASK">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_BACK_WRITEMASK"><!-- --></A><H3>
GL_STENCIL_BACK_WRITEMASK</H3>
<PRE>
static final int <B>GL_STENCIL_BACK_WRITEMASK</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_BACK_WRITEMASK">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_VIEWPORT"><!-- --></A><H3>
GL_VIEWPORT</H3>
<PRE>
static final int <B>GL_VIEWPORT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_VIEWPORT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SCISSOR_BOX"><!-- --></A><H3>
GL_SCISSOR_BOX</H3>
<PRE>
static final int <B>GL_SCISSOR_BOX</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SCISSOR_BOX">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_COLOR_CLEAR_VALUE"><!-- --></A><H3>
GL_COLOR_CLEAR_VALUE</H3>
<PRE>
static final int <B>GL_COLOR_CLEAR_VALUE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_COLOR_CLEAR_VALUE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_COLOR_WRITEMASK"><!-- --></A><H3>
GL_COLOR_WRITEMASK</H3>
<PRE>
static final int <B>GL_COLOR_WRITEMASK</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_COLOR_WRITEMASK">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_UNPACK_ALIGNMENT"><!-- --></A><H3>
GL_UNPACK_ALIGNMENT</H3>
<PRE>
static final int <B>GL_UNPACK_ALIGNMENT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_UNPACK_ALIGNMENT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_PACK_ALIGNMENT"><!-- --></A><H3>
GL_PACK_ALIGNMENT</H3>
<PRE>
static final int <B>GL_PACK_ALIGNMENT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_PACK_ALIGNMENT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_MAX_TEXTURE_SIZE"><!-- --></A><H3>
GL_MAX_TEXTURE_SIZE</H3>
<PRE>
static final int <B>GL_MAX_TEXTURE_SIZE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_MAX_TEXTURE_SIZE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_MAX_VIEWPORT_DIMS"><!-- --></A><H3>
GL_MAX_VIEWPORT_DIMS</H3>
<PRE>
static final int <B>GL_MAX_VIEWPORT_DIMS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_MAX_VIEWPORT_DIMS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SUBPIXEL_BITS"><!-- --></A><H3>
GL_SUBPIXEL_BITS</H3>
<PRE>
static final int <B>GL_SUBPIXEL_BITS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SUBPIXEL_BITS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RED_BITS"><!-- --></A><H3>
GL_RED_BITS</H3>
<PRE>
static final int <B>GL_RED_BITS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RED_BITS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_GREEN_BITS"><!-- --></A><H3>
GL_GREEN_BITS</H3>
<PRE>
static final int <B>GL_GREEN_BITS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_GREEN_BITS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BLUE_BITS"><!-- --></A><H3>
GL_BLUE_BITS</H3>
<PRE>
static final int <B>GL_BLUE_BITS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BLUE_BITS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ALPHA_BITS"><!-- --></A><H3>
GL_ALPHA_BITS</H3>
<PRE>
static final int <B>GL_ALPHA_BITS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ALPHA_BITS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DEPTH_BITS"><!-- --></A><H3>
GL_DEPTH_BITS</H3>
<PRE>
static final int <B>GL_DEPTH_BITS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DEPTH_BITS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_BITS"><!-- --></A><H3>
GL_STENCIL_BITS</H3>
<PRE>
static final int <B>GL_STENCIL_BITS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_BITS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_POLYGON_OFFSET_UNITS"><!-- --></A><H3>
GL_POLYGON_OFFSET_UNITS</H3>
<PRE>
static final int <B>GL_POLYGON_OFFSET_UNITS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_POLYGON_OFFSET_UNITS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_POLYGON_OFFSET_FACTOR"><!-- --></A><H3>
GL_POLYGON_OFFSET_FACTOR</H3>
<PRE>
static final int <B>GL_POLYGON_OFFSET_FACTOR</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_POLYGON_OFFSET_FACTOR">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_BINDING_2D"><!-- --></A><H3>
GL_TEXTURE_BINDING_2D</H3>
<PRE>
static final int <B>GL_TEXTURE_BINDING_2D</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE_BINDING_2D">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SAMPLE_BUFFERS"><!-- --></A><H3>
GL_SAMPLE_BUFFERS</H3>
<PRE>
static final int <B>GL_SAMPLE_BUFFERS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SAMPLE_BUFFERS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SAMPLES"><!-- --></A><H3>
GL_SAMPLES</H3>
<PRE>
static final int <B>GL_SAMPLES</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SAMPLES">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SAMPLE_COVERAGE_VALUE"><!-- --></A><H3>
GL_SAMPLE_COVERAGE_VALUE</H3>
<PRE>
static final int <B>GL_SAMPLE_COVERAGE_VALUE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SAMPLE_COVERAGE_VALUE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SAMPLE_COVERAGE_INVERT"><!-- --></A><H3>
GL_SAMPLE_COVERAGE_INVERT</H3>
<PRE>
static final int <B>GL_SAMPLE_COVERAGE_INVERT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SAMPLE_COVERAGE_INVERT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_NUM_COMPRESSED_TEXTURE_FORMATS"><!-- --></A><H3>
GL_NUM_COMPRESSED_TEXTURE_FORMATS</H3>
<PRE>
static final int <B>GL_NUM_COMPRESSED_TEXTURE_FORMATS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_NUM_COMPRESSED_TEXTURE_FORMATS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_COMPRESSED_TEXTURE_FORMATS"><!-- --></A><H3>
GL_COMPRESSED_TEXTURE_FORMATS</H3>
<PRE>
static final int <B>GL_COMPRESSED_TEXTURE_FORMATS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_COMPRESSED_TEXTURE_FORMATS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DONT_CARE"><!-- --></A><H3>
GL_DONT_CARE</H3>
<PRE>
static final int <B>GL_DONT_CARE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DONT_CARE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FASTEST"><!-- --></A><H3>
GL_FASTEST</H3>
<PRE>
static final int <B>GL_FASTEST</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FASTEST">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_NICEST"><!-- --></A><H3>
GL_NICEST</H3>
<PRE>
static final int <B>GL_NICEST</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_NICEST">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_GENERATE_MIPMAP_HINT"><!-- --></A><H3>
GL_GENERATE_MIPMAP_HINT</H3>
<PRE>
static final int <B>GL_GENERATE_MIPMAP_HINT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_GENERATE_MIPMAP_HINT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BYTE"><!-- --></A><H3>
GL_BYTE</H3>
<PRE>
static final int <B>GL_BYTE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BYTE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_UNSIGNED_BYTE"><!-- --></A><H3>
GL_UNSIGNED_BYTE</H3>
<PRE>
static final int <B>GL_UNSIGNED_BYTE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_UNSIGNED_BYTE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SHORT"><!-- --></A><H3>
GL_SHORT</H3>
<PRE>
static final int <B>GL_SHORT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SHORT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_UNSIGNED_SHORT"><!-- --></A><H3>
GL_UNSIGNED_SHORT</H3>
<PRE>
static final int <B>GL_UNSIGNED_SHORT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_UNSIGNED_SHORT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_INT"><!-- --></A><H3>
GL_INT</H3>
<PRE>
static final int <B>GL_INT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_INT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_UNSIGNED_INT"><!-- --></A><H3>
GL_UNSIGNED_INT</H3>
<PRE>
static final int <B>GL_UNSIGNED_INT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_UNSIGNED_INT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FLOAT"><!-- --></A><H3>
GL_FLOAT</H3>
<PRE>
static final int <B>GL_FLOAT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FLOAT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FIXED"><!-- --></A><H3>
GL_FIXED</H3>
<PRE>
static final int <B>GL_FIXED</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FIXED">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DEPTH_COMPONENT"><!-- --></A><H3>
GL_DEPTH_COMPONENT</H3>
<PRE>
static final int <B>GL_DEPTH_COMPONENT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DEPTH_COMPONENT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ALPHA"><!-- --></A><H3>
GL_ALPHA</H3>
<PRE>
static final int <B>GL_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RGB"><!-- --></A><H3>
GL_RGB</H3>
<PRE>
static final int <B>GL_RGB</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RGB">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RGBA"><!-- --></A><H3>
GL_RGBA</H3>
<PRE>
static final int <B>GL_RGBA</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RGBA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_LUMINANCE"><!-- --></A><H3>
GL_LUMINANCE</H3>
<PRE>
static final int <B>GL_LUMINANCE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_LUMINANCE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_LUMINANCE_ALPHA"><!-- --></A><H3>
GL_LUMINANCE_ALPHA</H3>
<PRE>
static final int <B>GL_LUMINANCE_ALPHA</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_LUMINANCE_ALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_UNSIGNED_SHORT_4_4_4_4"><!-- --></A><H3>
GL_UNSIGNED_SHORT_4_4_4_4</H3>
<PRE>
static final int <B>GL_UNSIGNED_SHORT_4_4_4_4</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_UNSIGNED_SHORT_4_4_4_4">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_UNSIGNED_SHORT_5_5_5_1"><!-- --></A><H3>
GL_UNSIGNED_SHORT_5_5_5_1</H3>
<PRE>
static final int <B>GL_UNSIGNED_SHORT_5_5_5_1</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_UNSIGNED_SHORT_5_5_5_1">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_UNSIGNED_SHORT_5_6_5"><!-- --></A><H3>
GL_UNSIGNED_SHORT_5_6_5</H3>
<PRE>
static final int <B>GL_UNSIGNED_SHORT_5_6_5</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_UNSIGNED_SHORT_5_6_5">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FRAGMENT_SHADER"><!-- --></A><H3>
GL_FRAGMENT_SHADER</H3>
<PRE>
static final int <B>GL_FRAGMENT_SHADER</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FRAGMENT_SHADER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_VERTEX_SHADER"><!-- --></A><H3>
GL_VERTEX_SHADER</H3>
<PRE>
static final int <B>GL_VERTEX_SHADER</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_VERTEX_SHADER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_MAX_VERTEX_ATTRIBS"><!-- --></A><H3>
GL_MAX_VERTEX_ATTRIBS</H3>
<PRE>
static final int <B>GL_MAX_VERTEX_ATTRIBS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_MAX_VERTEX_ATTRIBS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_MAX_VERTEX_UNIFORM_VECTORS"><!-- --></A><H3>
GL_MAX_VERTEX_UNIFORM_VECTORS</H3>
<PRE>
static final int <B>GL_MAX_VERTEX_UNIFORM_VECTORS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_MAX_VERTEX_UNIFORM_VECTORS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_MAX_VARYING_VECTORS"><!-- --></A><H3>
GL_MAX_VARYING_VECTORS</H3>
<PRE>
static final int <B>GL_MAX_VARYING_VECTORS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_MAX_VARYING_VECTORS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS"><!-- --></A><H3>
GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</H3>
<PRE>
static final int <B>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS"><!-- --></A><H3>
GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS</H3>
<PRE>
static final int <B>GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_MAX_TEXTURE_IMAGE_UNITS"><!-- --></A><H3>
GL_MAX_TEXTURE_IMAGE_UNITS</H3>
<PRE>
static final int <B>GL_MAX_TEXTURE_IMAGE_UNITS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_MAX_TEXTURE_IMAGE_UNITS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_MAX_FRAGMENT_UNIFORM_VECTORS"><!-- --></A><H3>
GL_MAX_FRAGMENT_UNIFORM_VECTORS</H3>
<PRE>
static final int <B>GL_MAX_FRAGMENT_UNIFORM_VECTORS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_MAX_FRAGMENT_UNIFORM_VECTORS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SHADER_TYPE"><!-- --></A><H3>
GL_SHADER_TYPE</H3>
<PRE>
static final int <B>GL_SHADER_TYPE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SHADER_TYPE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DELETE_STATUS"><!-- --></A><H3>
GL_DELETE_STATUS</H3>
<PRE>
static final int <B>GL_DELETE_STATUS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DELETE_STATUS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_LINK_STATUS"><!-- --></A><H3>
GL_LINK_STATUS</H3>
<PRE>
static final int <B>GL_LINK_STATUS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_LINK_STATUS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_VALIDATE_STATUS"><!-- --></A><H3>
GL_VALIDATE_STATUS</H3>
<PRE>
static final int <B>GL_VALIDATE_STATUS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_VALIDATE_STATUS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ATTACHED_SHADERS"><!-- --></A><H3>
GL_ATTACHED_SHADERS</H3>
<PRE>
static final int <B>GL_ATTACHED_SHADERS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ATTACHED_SHADERS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ACTIVE_UNIFORMS"><!-- --></A><H3>
GL_ACTIVE_UNIFORMS</H3>
<PRE>
static final int <B>GL_ACTIVE_UNIFORMS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ACTIVE_UNIFORMS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ACTIVE_UNIFORM_MAX_LENGTH"><!-- --></A><H3>
GL_ACTIVE_UNIFORM_MAX_LENGTH</H3>
<PRE>
static final int <B>GL_ACTIVE_UNIFORM_MAX_LENGTH</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ACTIVE_UNIFORM_MAX_LENGTH">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ACTIVE_ATTRIBUTES"><!-- --></A><H3>
GL_ACTIVE_ATTRIBUTES</H3>
<PRE>
static final int <B>GL_ACTIVE_ATTRIBUTES</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ACTIVE_ATTRIBUTES">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ACTIVE_ATTRIBUTE_MAX_LENGTH"><!-- --></A><H3>
GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</H3>
<PRE>
static final int <B>GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ACTIVE_ATTRIBUTE_MAX_LENGTH">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SHADING_LANGUAGE_VERSION"><!-- --></A><H3>
GL_SHADING_LANGUAGE_VERSION</H3>
<PRE>
static final int <B>GL_SHADING_LANGUAGE_VERSION</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SHADING_LANGUAGE_VERSION">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_CURRENT_PROGRAM"><!-- --></A><H3>
GL_CURRENT_PROGRAM</H3>
<PRE>
static final int <B>GL_CURRENT_PROGRAM</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_CURRENT_PROGRAM">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_NEVER"><!-- --></A><H3>
GL_NEVER</H3>
<PRE>
static final int <B>GL_NEVER</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_NEVER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_LESS"><!-- --></A><H3>
GL_LESS</H3>
<PRE>
static final int <B>GL_LESS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_LESS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_EQUAL"><!-- --></A><H3>
GL_EQUAL</H3>
<PRE>
static final int <B>GL_EQUAL</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_EQUAL">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_LEQUAL"><!-- --></A><H3>
GL_LEQUAL</H3>
<PRE>
static final int <B>GL_LEQUAL</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_LEQUAL">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_GREATER"><!-- --></A><H3>
GL_GREATER</H3>
<PRE>
static final int <B>GL_GREATER</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_GREATER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_NOTEQUAL"><!-- --></A><H3>
GL_NOTEQUAL</H3>
<PRE>
static final int <B>GL_NOTEQUAL</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_NOTEQUAL">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_GEQUAL"><!-- --></A><H3>
GL_GEQUAL</H3>
<PRE>
static final int <B>GL_GEQUAL</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_GEQUAL">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ALWAYS"><!-- --></A><H3>
GL_ALWAYS</H3>
<PRE>
static final int <B>GL_ALWAYS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ALWAYS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_KEEP"><!-- --></A><H3>
GL_KEEP</H3>
<PRE>
static final int <B>GL_KEEP</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_KEEP">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_REPLACE"><!-- --></A><H3>
GL_REPLACE</H3>
<PRE>
static final int <B>GL_REPLACE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_REPLACE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_INCR"><!-- --></A><H3>
GL_INCR</H3>
<PRE>
static final int <B>GL_INCR</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_INCR">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DECR"><!-- --></A><H3>
GL_DECR</H3>
<PRE>
static final int <B>GL_DECR</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DECR">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_INVERT"><!-- --></A><H3>
GL_INVERT</H3>
<PRE>
static final int <B>GL_INVERT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_INVERT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_INCR_WRAP"><!-- --></A><H3>
GL_INCR_WRAP</H3>
<PRE>
static final int <B>GL_INCR_WRAP</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_INCR_WRAP">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DECR_WRAP"><!-- --></A><H3>
GL_DECR_WRAP</H3>
<PRE>
static final int <B>GL_DECR_WRAP</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DECR_WRAP">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_VENDOR"><!-- --></A><H3>
GL_VENDOR</H3>
<PRE>
static final int <B>GL_VENDOR</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_VENDOR">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RENDERER"><!-- --></A><H3>
GL_RENDERER</H3>
<PRE>
static final int <B>GL_RENDERER</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RENDERER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_VERSION"><!-- --></A><H3>
GL_VERSION</H3>
<PRE>
static final int <B>GL_VERSION</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_VERSION">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_EXTENSIONS"><!-- --></A><H3>
GL_EXTENSIONS</H3>
<PRE>
static final int <B>GL_EXTENSIONS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_EXTENSIONS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_NEAREST"><!-- --></A><H3>
GL_NEAREST</H3>
<PRE>
static final int <B>GL_NEAREST</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_NEAREST">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_LINEAR"><!-- --></A><H3>
GL_LINEAR</H3>
<PRE>
static final int <B>GL_LINEAR</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_LINEAR">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_NEAREST_MIPMAP_NEAREST"><!-- --></A><H3>
GL_NEAREST_MIPMAP_NEAREST</H3>
<PRE>
static final int <B>GL_NEAREST_MIPMAP_NEAREST</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_NEAREST_MIPMAP_NEAREST">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_LINEAR_MIPMAP_NEAREST"><!-- --></A><H3>
GL_LINEAR_MIPMAP_NEAREST</H3>
<PRE>
static final int <B>GL_LINEAR_MIPMAP_NEAREST</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_LINEAR_MIPMAP_NEAREST">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_NEAREST_MIPMAP_LINEAR"><!-- --></A><H3>
GL_NEAREST_MIPMAP_LINEAR</H3>
<PRE>
static final int <B>GL_NEAREST_MIPMAP_LINEAR</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_NEAREST_MIPMAP_LINEAR">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_LINEAR_MIPMAP_LINEAR"><!-- --></A><H3>
GL_LINEAR_MIPMAP_LINEAR</H3>
<PRE>
static final int <B>GL_LINEAR_MIPMAP_LINEAR</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_LINEAR_MIPMAP_LINEAR">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_MAG_FILTER"><!-- --></A><H3>
GL_TEXTURE_MAG_FILTER</H3>
<PRE>
static final int <B>GL_TEXTURE_MAG_FILTER</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE_MAG_FILTER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_MIN_FILTER"><!-- --></A><H3>
GL_TEXTURE_MIN_FILTER</H3>
<PRE>
static final int <B>GL_TEXTURE_MIN_FILTER</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE_MIN_FILTER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_WRAP_S"><!-- --></A><H3>
GL_TEXTURE_WRAP_S</H3>
<PRE>
static final int <B>GL_TEXTURE_WRAP_S</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE_WRAP_S">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_WRAP_T"><!-- --></A><H3>
GL_TEXTURE_WRAP_T</H3>
<PRE>
static final int <B>GL_TEXTURE_WRAP_T</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE_WRAP_T">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE"><!-- --></A><H3>
GL_TEXTURE</H3>
<PRE>
static final int <B>GL_TEXTURE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_CUBE_MAP"><!-- --></A><H3>
GL_TEXTURE_CUBE_MAP</H3>
<PRE>
static final int <B>GL_TEXTURE_CUBE_MAP</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE_CUBE_MAP">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_BINDING_CUBE_MAP"><!-- --></A><H3>
GL_TEXTURE_BINDING_CUBE_MAP</H3>
<PRE>
static final int <B>GL_TEXTURE_BINDING_CUBE_MAP</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE_BINDING_CUBE_MAP">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_CUBE_MAP_POSITIVE_X"><!-- --></A><H3>
GL_TEXTURE_CUBE_MAP_POSITIVE_X</H3>
<PRE>
static final int <B>GL_TEXTURE_CUBE_MAP_POSITIVE_X</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_X">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_CUBE_MAP_NEGATIVE_X"><!-- --></A><H3>
GL_TEXTURE_CUBE_MAP_NEGATIVE_X</H3>
<PRE>
static final int <B>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE_CUBE_MAP_NEGATIVE_X">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_CUBE_MAP_POSITIVE_Y"><!-- --></A><H3>
GL_TEXTURE_CUBE_MAP_POSITIVE_Y</H3>
<PRE>
static final int <B>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_Y">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_CUBE_MAP_NEGATIVE_Y"><!-- --></A><H3>
GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</H3>
<PRE>
static final int <B>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE_CUBE_MAP_NEGATIVE_Y">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_CUBE_MAP_POSITIVE_Z"><!-- --></A><H3>
GL_TEXTURE_CUBE_MAP_POSITIVE_Z</H3>
<PRE>
static final int <B>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE_CUBE_MAP_POSITIVE_Z">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE_CUBE_MAP_NEGATIVE_Z"><!-- --></A><H3>
GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</H3>
<PRE>
static final int <B>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE_CUBE_MAP_NEGATIVE_Z">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_MAX_CUBE_MAP_TEXTURE_SIZE"><!-- --></A><H3>
GL_MAX_CUBE_MAP_TEXTURE_SIZE</H3>
<PRE>
static final int <B>GL_MAX_CUBE_MAP_TEXTURE_SIZE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_MAX_CUBE_MAP_TEXTURE_SIZE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE0"><!-- --></A><H3>
GL_TEXTURE0</H3>
<PRE>
static final int <B>GL_TEXTURE0</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE0">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE1"><!-- --></A><H3>
GL_TEXTURE1</H3>
<PRE>
static final int <B>GL_TEXTURE1</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE1">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE2"><!-- --></A><H3>
GL_TEXTURE2</H3>
<PRE>
static final int <B>GL_TEXTURE2</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE2">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE3"><!-- --></A><H3>
GL_TEXTURE3</H3>
<PRE>
static final int <B>GL_TEXTURE3</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE3">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE4"><!-- --></A><H3>
GL_TEXTURE4</H3>
<PRE>
static final int <B>GL_TEXTURE4</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE4">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE5"><!-- --></A><H3>
GL_TEXTURE5</H3>
<PRE>
static final int <B>GL_TEXTURE5</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE5">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE6"><!-- --></A><H3>
GL_TEXTURE6</H3>
<PRE>
static final int <B>GL_TEXTURE6</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE6">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE7"><!-- --></A><H3>
GL_TEXTURE7</H3>
<PRE>
static final int <B>GL_TEXTURE7</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE7">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE8"><!-- --></A><H3>
GL_TEXTURE8</H3>
<PRE>
static final int <B>GL_TEXTURE8</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE8">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE9"><!-- --></A><H3>
GL_TEXTURE9</H3>
<PRE>
static final int <B>GL_TEXTURE9</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE9">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE10"><!-- --></A><H3>
GL_TEXTURE10</H3>
<PRE>
static final int <B>GL_TEXTURE10</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE10">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE11"><!-- --></A><H3>
GL_TEXTURE11</H3>
<PRE>
static final int <B>GL_TEXTURE11</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE11">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE12"><!-- --></A><H3>
GL_TEXTURE12</H3>
<PRE>
static final int <B>GL_TEXTURE12</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE12">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE13"><!-- --></A><H3>
GL_TEXTURE13</H3>
<PRE>
static final int <B>GL_TEXTURE13</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE13">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE14"><!-- --></A><H3>
GL_TEXTURE14</H3>
<PRE>
static final int <B>GL_TEXTURE14</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE14">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE15"><!-- --></A><H3>
GL_TEXTURE15</H3>
<PRE>
static final int <B>GL_TEXTURE15</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE15">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE16"><!-- --></A><H3>
GL_TEXTURE16</H3>
<PRE>
static final int <B>GL_TEXTURE16</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE16">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE17"><!-- --></A><H3>
GL_TEXTURE17</H3>
<PRE>
static final int <B>GL_TEXTURE17</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE17">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE18"><!-- --></A><H3>
GL_TEXTURE18</H3>
<PRE>
static final int <B>GL_TEXTURE18</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE18">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE19"><!-- --></A><H3>
GL_TEXTURE19</H3>
<PRE>
static final int <B>GL_TEXTURE19</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE19">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE20"><!-- --></A><H3>
GL_TEXTURE20</H3>
<PRE>
static final int <B>GL_TEXTURE20</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE20">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE21"><!-- --></A><H3>
GL_TEXTURE21</H3>
<PRE>
static final int <B>GL_TEXTURE21</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE21">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE22"><!-- --></A><H3>
GL_TEXTURE22</H3>
<PRE>
static final int <B>GL_TEXTURE22</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE22">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE23"><!-- --></A><H3>
GL_TEXTURE23</H3>
<PRE>
static final int <B>GL_TEXTURE23</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE23">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE24"><!-- --></A><H3>
GL_TEXTURE24</H3>
<PRE>
static final int <B>GL_TEXTURE24</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE24">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE25"><!-- --></A><H3>
GL_TEXTURE25</H3>
<PRE>
static final int <B>GL_TEXTURE25</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE25">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE26"><!-- --></A><H3>
GL_TEXTURE26</H3>
<PRE>
static final int <B>GL_TEXTURE26</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE26">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE27"><!-- --></A><H3>
GL_TEXTURE27</H3>
<PRE>
static final int <B>GL_TEXTURE27</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE27">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE28"><!-- --></A><H3>
GL_TEXTURE28</H3>
<PRE>
static final int <B>GL_TEXTURE28</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE28">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE29"><!-- --></A><H3>
GL_TEXTURE29</H3>
<PRE>
static final int <B>GL_TEXTURE29</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE29">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE30"><!-- --></A><H3>
GL_TEXTURE30</H3>
<PRE>
static final int <B>GL_TEXTURE30</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE30">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_TEXTURE31"><!-- --></A><H3>
GL_TEXTURE31</H3>
<PRE>
static final int <B>GL_TEXTURE31</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_TEXTURE31">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_ACTIVE_TEXTURE"><!-- --></A><H3>
GL_ACTIVE_TEXTURE</H3>
<PRE>
static final int <B>GL_ACTIVE_TEXTURE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_ACTIVE_TEXTURE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_REPEAT"><!-- --></A><H3>
GL_REPEAT</H3>
<PRE>
static final int <B>GL_REPEAT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_REPEAT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_CLAMP_TO_EDGE"><!-- --></A><H3>
GL_CLAMP_TO_EDGE</H3>
<PRE>
static final int <B>GL_CLAMP_TO_EDGE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_CLAMP_TO_EDGE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_MIRRORED_REPEAT"><!-- --></A><H3>
GL_MIRRORED_REPEAT</H3>
<PRE>
static final int <B>GL_MIRRORED_REPEAT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_MIRRORED_REPEAT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FLOAT_VEC2"><!-- --></A><H3>
GL_FLOAT_VEC2</H3>
<PRE>
static final int <B>GL_FLOAT_VEC2</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FLOAT_VEC2">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FLOAT_VEC3"><!-- --></A><H3>
GL_FLOAT_VEC3</H3>
<PRE>
static final int <B>GL_FLOAT_VEC3</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FLOAT_VEC3">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FLOAT_VEC4"><!-- --></A><H3>
GL_FLOAT_VEC4</H3>
<PRE>
static final int <B>GL_FLOAT_VEC4</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FLOAT_VEC4">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_INT_VEC2"><!-- --></A><H3>
GL_INT_VEC2</H3>
<PRE>
static final int <B>GL_INT_VEC2</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_INT_VEC2">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_INT_VEC3"><!-- --></A><H3>
GL_INT_VEC3</H3>
<PRE>
static final int <B>GL_INT_VEC3</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_INT_VEC3">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_INT_VEC4"><!-- --></A><H3>
GL_INT_VEC4</H3>
<PRE>
static final int <B>GL_INT_VEC4</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_INT_VEC4">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BOOL"><!-- --></A><H3>
GL_BOOL</H3>
<PRE>
static final int <B>GL_BOOL</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BOOL">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BOOL_VEC2"><!-- --></A><H3>
GL_BOOL_VEC2</H3>
<PRE>
static final int <B>GL_BOOL_VEC2</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BOOL_VEC2">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BOOL_VEC3"><!-- --></A><H3>
GL_BOOL_VEC3</H3>
<PRE>
static final int <B>GL_BOOL_VEC3</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BOOL_VEC3">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_BOOL_VEC4"><!-- --></A><H3>
GL_BOOL_VEC4</H3>
<PRE>
static final int <B>GL_BOOL_VEC4</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_BOOL_VEC4">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FLOAT_MAT2"><!-- --></A><H3>
GL_FLOAT_MAT2</H3>
<PRE>
static final int <B>GL_FLOAT_MAT2</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FLOAT_MAT2">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FLOAT_MAT3"><!-- --></A><H3>
GL_FLOAT_MAT3</H3>
<PRE>
static final int <B>GL_FLOAT_MAT3</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FLOAT_MAT3">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FLOAT_MAT4"><!-- --></A><H3>
GL_FLOAT_MAT4</H3>
<PRE>
static final int <B>GL_FLOAT_MAT4</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FLOAT_MAT4">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SAMPLER_2D"><!-- --></A><H3>
GL_SAMPLER_2D</H3>
<PRE>
static final int <B>GL_SAMPLER_2D</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SAMPLER_2D">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SAMPLER_CUBE"><!-- --></A><H3>
GL_SAMPLER_CUBE</H3>
<PRE>
static final int <B>GL_SAMPLER_CUBE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SAMPLER_CUBE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_VERTEX_ATTRIB_ARRAY_ENABLED"><!-- --></A><H3>
GL_VERTEX_ATTRIB_ARRAY_ENABLED</H3>
<PRE>
static final int <B>GL_VERTEX_ATTRIB_ARRAY_ENABLED</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_VERTEX_ATTRIB_ARRAY_ENABLED">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_VERTEX_ATTRIB_ARRAY_SIZE"><!-- --></A><H3>
GL_VERTEX_ATTRIB_ARRAY_SIZE</H3>
<PRE>
static final int <B>GL_VERTEX_ATTRIB_ARRAY_SIZE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_VERTEX_ATTRIB_ARRAY_SIZE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_VERTEX_ATTRIB_ARRAY_STRIDE"><!-- --></A><H3>
GL_VERTEX_ATTRIB_ARRAY_STRIDE</H3>
<PRE>
static final int <B>GL_VERTEX_ATTRIB_ARRAY_STRIDE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_VERTEX_ATTRIB_ARRAY_STRIDE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_VERTEX_ATTRIB_ARRAY_TYPE"><!-- --></A><H3>
GL_VERTEX_ATTRIB_ARRAY_TYPE</H3>
<PRE>
static final int <B>GL_VERTEX_ATTRIB_ARRAY_TYPE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_VERTEX_ATTRIB_ARRAY_TYPE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_VERTEX_ATTRIB_ARRAY_NORMALIZED"><!-- --></A><H3>
GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</H3>
<PRE>
static final int <B>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_VERTEX_ATTRIB_ARRAY_NORMALIZED">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_VERTEX_ATTRIB_ARRAY_POINTER"><!-- --></A><H3>
GL_VERTEX_ATTRIB_ARRAY_POINTER</H3>
<PRE>
static final int <B>GL_VERTEX_ATTRIB_ARRAY_POINTER</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_VERTEX_ATTRIB_ARRAY_POINTER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"><!-- --></A><H3>
GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</H3>
<PRE>
static final int <B>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_IMPLEMENTATION_COLOR_READ_TYPE"><!-- --></A><H3>
GL_IMPLEMENTATION_COLOR_READ_TYPE</H3>
<PRE>
static final int <B>GL_IMPLEMENTATION_COLOR_READ_TYPE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_IMPLEMENTATION_COLOR_READ_TYPE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_IMPLEMENTATION_COLOR_READ_FORMAT"><!-- --></A><H3>
GL_IMPLEMENTATION_COLOR_READ_FORMAT</H3>
<PRE>
static final int <B>GL_IMPLEMENTATION_COLOR_READ_FORMAT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_IMPLEMENTATION_COLOR_READ_FORMAT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_COMPILE_STATUS"><!-- --></A><H3>
GL_COMPILE_STATUS</H3>
<PRE>
static final int <B>GL_COMPILE_STATUS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_COMPILE_STATUS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_INFO_LOG_LENGTH"><!-- --></A><H3>
GL_INFO_LOG_LENGTH</H3>
<PRE>
static final int <B>GL_INFO_LOG_LENGTH</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_INFO_LOG_LENGTH">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SHADER_SOURCE_LENGTH"><!-- --></A><H3>
GL_SHADER_SOURCE_LENGTH</H3>
<PRE>
static final int <B>GL_SHADER_SOURCE_LENGTH</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SHADER_SOURCE_LENGTH">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SHADER_COMPILER"><!-- --></A><H3>
GL_SHADER_COMPILER</H3>
<PRE>
static final int <B>GL_SHADER_COMPILER</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SHADER_COMPILER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_SHADER_BINARY_FORMATS"><!-- --></A><H3>
GL_SHADER_BINARY_FORMATS</H3>
<PRE>
static final int <B>GL_SHADER_BINARY_FORMATS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_SHADER_BINARY_FORMATS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_NUM_SHADER_BINARY_FORMATS"><!-- --></A><H3>
GL_NUM_SHADER_BINARY_FORMATS</H3>
<PRE>
static final int <B>GL_NUM_SHADER_BINARY_FORMATS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_NUM_SHADER_BINARY_FORMATS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_LOW_FLOAT"><!-- --></A><H3>
GL_LOW_FLOAT</H3>
<PRE>
static final int <B>GL_LOW_FLOAT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_LOW_FLOAT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_MEDIUM_FLOAT"><!-- --></A><H3>
GL_MEDIUM_FLOAT</H3>
<PRE>
static final int <B>GL_MEDIUM_FLOAT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_MEDIUM_FLOAT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_HIGH_FLOAT"><!-- --></A><H3>
GL_HIGH_FLOAT</H3>
<PRE>
static final int <B>GL_HIGH_FLOAT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_HIGH_FLOAT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_LOW_INT"><!-- --></A><H3>
GL_LOW_INT</H3>
<PRE>
static final int <B>GL_LOW_INT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_LOW_INT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_MEDIUM_INT"><!-- --></A><H3>
GL_MEDIUM_INT</H3>
<PRE>
static final int <B>GL_MEDIUM_INT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_MEDIUM_INT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_HIGH_INT"><!-- --></A><H3>
GL_HIGH_INT</H3>
<PRE>
static final int <B>GL_HIGH_INT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_HIGH_INT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FRAMEBUFFER"><!-- --></A><H3>
GL_FRAMEBUFFER</H3>
<PRE>
static final int <B>GL_FRAMEBUFFER</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FRAMEBUFFER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RENDERBUFFER"><!-- --></A><H3>
GL_RENDERBUFFER</H3>
<PRE>
static final int <B>GL_RENDERBUFFER</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RENDERBUFFER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RGBA4"><!-- --></A><H3>
GL_RGBA4</H3>
<PRE>
static final int <B>GL_RGBA4</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RGBA4">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RGB5_A1"><!-- --></A><H3>
GL_RGB5_A1</H3>
<PRE>
static final int <B>GL_RGB5_A1</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RGB5_A1">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RGB565"><!-- --></A><H3>
GL_RGB565</H3>
<PRE>
static final int <B>GL_RGB565</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RGB565">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DEPTH_COMPONENT16"><!-- --></A><H3>
GL_DEPTH_COMPONENT16</H3>
<PRE>
static final int <B>GL_DEPTH_COMPONENT16</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DEPTH_COMPONENT16">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_INDEX"><!-- --></A><H3>
GL_STENCIL_INDEX</H3>
<PRE>
static final int <B>GL_STENCIL_INDEX</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_INDEX">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_INDEX8"><!-- --></A><H3>
GL_STENCIL_INDEX8</H3>
<PRE>
static final int <B>GL_STENCIL_INDEX8</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_INDEX8">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RENDERBUFFER_WIDTH"><!-- --></A><H3>
GL_RENDERBUFFER_WIDTH</H3>
<PRE>
static final int <B>GL_RENDERBUFFER_WIDTH</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RENDERBUFFER_WIDTH">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RENDERBUFFER_HEIGHT"><!-- --></A><H3>
GL_RENDERBUFFER_HEIGHT</H3>
<PRE>
static final int <B>GL_RENDERBUFFER_HEIGHT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RENDERBUFFER_HEIGHT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RENDERBUFFER_INTERNAL_FORMAT"><!-- --></A><H3>
GL_RENDERBUFFER_INTERNAL_FORMAT</H3>
<PRE>
static final int <B>GL_RENDERBUFFER_INTERNAL_FORMAT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RENDERBUFFER_INTERNAL_FORMAT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RENDERBUFFER_RED_SIZE"><!-- --></A><H3>
GL_RENDERBUFFER_RED_SIZE</H3>
<PRE>
static final int <B>GL_RENDERBUFFER_RED_SIZE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RENDERBUFFER_RED_SIZE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RENDERBUFFER_GREEN_SIZE"><!-- --></A><H3>
GL_RENDERBUFFER_GREEN_SIZE</H3>
<PRE>
static final int <B>GL_RENDERBUFFER_GREEN_SIZE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RENDERBUFFER_GREEN_SIZE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RENDERBUFFER_BLUE_SIZE"><!-- --></A><H3>
GL_RENDERBUFFER_BLUE_SIZE</H3>
<PRE>
static final int <B>GL_RENDERBUFFER_BLUE_SIZE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RENDERBUFFER_BLUE_SIZE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RENDERBUFFER_ALPHA_SIZE"><!-- --></A><H3>
GL_RENDERBUFFER_ALPHA_SIZE</H3>
<PRE>
static final int <B>GL_RENDERBUFFER_ALPHA_SIZE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RENDERBUFFER_ALPHA_SIZE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RENDERBUFFER_DEPTH_SIZE"><!-- --></A><H3>
GL_RENDERBUFFER_DEPTH_SIZE</H3>
<PRE>
static final int <B>GL_RENDERBUFFER_DEPTH_SIZE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RENDERBUFFER_DEPTH_SIZE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RENDERBUFFER_STENCIL_SIZE"><!-- --></A><H3>
GL_RENDERBUFFER_STENCIL_SIZE</H3>
<PRE>
static final int <B>GL_RENDERBUFFER_STENCIL_SIZE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RENDERBUFFER_STENCIL_SIZE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"><!-- --></A><H3>
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</H3>
<PRE>
static final int <B>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"><!-- --></A><H3>
GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</H3>
<PRE>
static final int <B>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"><!-- --></A><H3>
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</H3>
<PRE>
static final int <B>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"><!-- --></A><H3>
GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</H3>
<PRE>
static final int <B>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_COLOR_ATTACHMENT0"><!-- --></A><H3>
GL_COLOR_ATTACHMENT0</H3>
<PRE>
static final int <B>GL_COLOR_ATTACHMENT0</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_COLOR_ATTACHMENT0">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_DEPTH_ATTACHMENT"><!-- --></A><H3>
GL_DEPTH_ATTACHMENT</H3>
<PRE>
static final int <B>GL_DEPTH_ATTACHMENT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_DEPTH_ATTACHMENT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_STENCIL_ATTACHMENT"><!-- --></A><H3>
GL_STENCIL_ATTACHMENT</H3>
<PRE>
static final int <B>GL_STENCIL_ATTACHMENT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_STENCIL_ATTACHMENT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_NONE"><!-- --></A><H3>
GL_NONE</H3>
<PRE>
static final int <B>GL_NONE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_NONE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FRAMEBUFFER_COMPLETE"><!-- --></A><H3>
GL_FRAMEBUFFER_COMPLETE</H3>
<PRE>
static final int <B>GL_FRAMEBUFFER_COMPLETE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FRAMEBUFFER_COMPLETE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT"><!-- --></A><H3>
GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT</H3>
<PRE>
static final int <B>GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"><!-- --></A><H3>
GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT</H3>
<PRE>
static final int <B>GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS"><!-- --></A><H3>
GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS</H3>
<PRE>
static final int <B>GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FRAMEBUFFER_UNSUPPORTED"><!-- --></A><H3>
GL_FRAMEBUFFER_UNSUPPORTED</H3>
<PRE>
static final int <B>GL_FRAMEBUFFER_UNSUPPORTED</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FRAMEBUFFER_UNSUPPORTED">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_FRAMEBUFFER_BINDING"><!-- --></A><H3>
GL_FRAMEBUFFER_BINDING</H3>
<PRE>
static final int <B>GL_FRAMEBUFFER_BINDING</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_FRAMEBUFFER_BINDING">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_RENDERBUFFER_BINDING"><!-- --></A><H3>
GL_RENDERBUFFER_BINDING</H3>
<PRE>
static final int <B>GL_RENDERBUFFER_BINDING</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_RENDERBUFFER_BINDING">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_MAX_RENDERBUFFER_SIZE"><!-- --></A><H3>
GL_MAX_RENDERBUFFER_SIZE</H3>
<PRE>
static final int <B>GL_MAX_RENDERBUFFER_SIZE</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_MAX_RENDERBUFFER_SIZE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="GL_INVALID_FRAMEBUFFER_OPERATION"><!-- --></A><H3>
GL_INVALID_FRAMEBUFFER_OPERATION</H3>
<PRE>
static final int <B>GL_INVALID_FRAMEBUFFER_OPERATION</B></PRE>
<DL>
<DD>OpenGL ES 2.0 constant.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.opengles.GL20.GL_INVALID_FRAMEBUFFER_OPERATION">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<BR>

<BR>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF">
<TH ALIGN="left" COLSPAN="1" CLASS="TableHeadingColor"><FONT SIZE="+0">
Method Detail</FONT></TH>
</TR>
</TABLE>

<A NAME="glActiveTexture(int)"><!-- --></A><H3>
glActiveTexture</H3>
<PRE>
void <B>glActiveTexture</B>(int&nbsp;texture)</PRE>
<DL>
<DD>Select active texture unit.
 <p>
 <h4>Description</h4>
 <code>glActiveTexture</code> selects which texture unit subsequent 
 texture state calls will affect. The number of texture units an 
 implementation supports is implementation dependent, 
 but must be at least 2.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>texture</code></i> is not one 
  of <code>GL_TEXTURE</code>i, where i ranges from 0 to 
  (<code>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</code> - 1).
 <p>
 <h4>Associated Gets</h4>
 <p>
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_ACTIVE_TEXTURE</code> or <code>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texture</CODE> - Specifies which texture unit to make active. 
  The number of texture units is implementation dependent, 
  but must be at least two. <i><code>texture</code></i> must be one of <code>GL_TEXTURE</code>i, 
  where i ranges from 0 to (<code>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</code> - 1). 
  The initial value is <code>GL_TEXTURE0</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glAttachShader(int, int)"><!-- --></A><H3>
glAttachShader</H3>
<PRE>
void <B>glAttachShader</B>(int&nbsp;program,
                    int&nbsp;shader)</PRE>
<DL>
<DD>Attach a shader object to a program object.
 <p>
 <h4>Description</h4>
 <p>
 In order to create an executable, there must be a way to specify the list of 
 things that will be linked together. Program objects provide this mechanism. 
 Shaders that are to be linked together in a program object must first be attached 
 to that program object. <code>glAttachShader</code> attaches the shader object specified by 
 <i><code>shader</code></i> to the program object specified by <i><code>program</code></i>. 
 This indicates that <i><code>shader</code></i> will be included in link operations
 that will be performed on <i><code>program</code></i>.
 <p>
 All operations that can be performed on a shader object are valid whether or not 
 the shader object is attached to a program object. It is permissible to attach a 
 shader object to a program object before source code has been loaded into the 
 shader object or before the shader object has been compiled. It is permissible to 
 attach multiple shader objects of the same type because each may contain a portion 
 of the complete shader. It is also permissible to attach a shader object to more 
 than one program object. If a shader object is deleted while it is attached to a 
 program object, it will be flagged for deletion, and deletion will not occur until 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDetachShader(int, int)"><CODE>glDetachShader</CODE></A> is called to detach it from all program objects to which it is attached.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if either <i><code>program</code></i> or
  <i><code>shader</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>shader</code></i> is not a shader object.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>shader</code></i> is already attached to
  <i><code>program</code></i>.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, java.nio.IntBuffer, java.nio.IntBuffer)"><CODE>glGetAttachedShaders</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, int[], int, int[], int)"><CODE>glGetAttachedShaders</CODE></A>
  with the handle of a valid program object.
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsShader(int)"><CODE>glIsShader</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to which a shader object will be attached.<DD><CODE>shader</CODE> - Specifies the shader object that is to be attached.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>GL20.glCompileShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDetachShader(int, int)"><CODE>GL20.glDetachShader(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>GL20.glShaderSource(int, int, String[], int[])</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, java.nio.IntBuffer, int, java.nio.Buffer, int)"><CODE>GL20.glShaderBinary(int, IntBuffer, int, Buffer, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><CODE>GL20.glShaderBinary(int, int[], int, int, Buffer, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glBindAttribLocation(int, int, java.lang.String)"><!-- --></A><H3>
glBindAttribLocation</H3>
<PRE>
void <B>glBindAttribLocation</B>(int&nbsp;program,
                          int&nbsp;index,
                          <A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;name)</PRE>
<DL>
<DD>Associate a generic vertex attribute index with a named attribute variable.
 <p>
 <h4>Description</h4>
 <code>glBindAttribLocation</code> is used to associate a user-defined 
 attribute variable in the program object specified by <i><code>program</code></i> with a 
 generic vertex attribute index. The name of the user-defined attribute 
 variable is passed as a string in <i><code>name</code></i>. The generic vertex 
 attribute index to be bound to this variable is specified by <i><code>index</code></i>.
 When <i><code>program</code></i> is made part of current state, values provided via the 
 generic vertex attribute <i><code>index</code></i> will modify the value of the user-defined 
 attribute variable specified by <i><code>name</code></i>.
 <p>
 If <i><code>name</code></i> refers to a matrix attribute variable, 
 <i><code>index</code></i> refers to the first column 
 of the matrix. Other matrix columns are then automatically bound to locations 
 <i><code>index+1</code></i> for a matrix of type mat2; <i><code>index+1</code></i>
 and <i><code>index+2</code></i> for a matrix of type mat3; and <i><code>index+1</code></i>,
 <i><code>index+2</code></i>, and <i><code>index+3</code></i> for a matrix of type mat4.
 <p>
 This command makes it possible for vertex shaders to use descriptive names 
 for attribute variables rather than generic variables that are numbered 
 from 0 to <code>GL_MAX_VERTEX_ATTRIBS</code> -1. The values sent to each generic attribute 
 index are part of current state, just like standard vertex attributes such as 
 color, normal, and vertex position. If a different program object is made current 
 by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>glUseProgram</CODE></A>, the generic vertex attributes are tracked in such a way 
 that the same values will be observed by attributes in the new program object 
 that are also bound to <i><code>index</code></i>.
 <p>
 Attribute variable name-to-generic attribute index bindings for a program object 
 can be explicitly assigned at any time by calling <code>glBindAttribLocation</code>. Attribute 
 bindings do not go into effect until <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>glLinkProgram</CODE></A> is called. After a program object 
 has been linked successfully, the index values for generic attributes remain 
 fixed (and their values can be queried) until the next link command occurs.
 <p>
 Applications are not allowed to bind any of the standard OpenGL vertex attributes 
 using this command, as they are bound automatically when needed. Any attribute 
 binding that occurs after the program object has been linked will not take effect 
 until the next time the program object is linked.
 <p>
 <h4>Notes</h4>
 <p>
 <code>glBindAttribLocation</code> can be called before any vertex shader objects are bound to the 
 specified program object. It is also permissible to bind a generic attribute index to 
 an attribute variable name that is never used in a vertex shader.
 <p>
 If <i><code>name</code></i> was bound previously, that information is lost. Thus you cannot bind one 
 user-defined attribute variable to multiple indices, but you can bind multiple 
 user-defined attribute variables to the same index.
 <p>
 Applications are allowed to bind more than one user-defined attribute variable to the 
 same generic vertex attribute index. This is called <i>aliasing</i>, and it is allowed only if 
 just one of the aliased attributes is active in the executable program, or if no path 
 through the shader consumes more than one attribute of a set of attributes 
 aliased to the same location. The compiler and linker are allowed to assume that no aliasing 
 is done and are free to employ optimizations that work only in the absence of aliasing. 
 OpenGL implementations are not required to do error checking to detect aliasing. 
 Because there is no way to bind standard attributes, it is not possible to alias generic 
 attributes with conventional ones (except for generic attribute 0).
 <p>
 Active attributes that are not explicitly bound will be bound by the linker 
 when <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>glLinkProgram</CODE></A> is called. The locations assigned can be 
 queried by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttribLocation(int, java.lang.String)"><CODE>glGetAttribLocation</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is greater than or equal
  to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>name</code></i> starts with the reserved prefix "gl_".
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_MAX_VERTEX_ATTRIBS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveAttrib(int, int, int[], int, int[], int)"><CODE>glGetActiveAttrib</CODE></A>
  with argument <i><code>program</code></i>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttribLocation(int, java.lang.String)"><CODE>glGetAttribLocation</CODE></A> with arguments
  <i><code>program</code></i> and <i><code>name</code></i>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the handle of the program object in which the association is to be made.<DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be bound.<DD><CODE>name</CODE> - Specifies a string containing the name of the vertex 
  shader attribute variable to which <i><code>index</code></i> is to be bound.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisableVertexAttribArray(int)"><CODE>GL20.glDisableVertexAttribArray(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnableVertexAttribArray(int)"><CODE>GL20.glEnableVertexAttribArray(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>GL20.glUseProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib1fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, float[], int)"><CODE>GL20.glVertexAttrib1fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2f(int, float, float)"><CODE>GL20.glVertexAttrib2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib2fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, float[], int)"><CODE>GL20.glVertexAttrib2fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3f(int, float, float, float)"><CODE>GL20.glVertexAttrib3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib3fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, float[], int)"><CODE>GL20.glVertexAttrib3fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4f(int, float, float, float, float)"><CODE>GL20.glVertexAttrib4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib4fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, float[], int)"><CODE>GL20.glVertexAttrib4fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, int)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glBindBuffer(int, int)"><!-- --></A><H3>
glBindBuffer</H3>
<PRE>
void <B>glBindBuffer</B>(int&nbsp;target,
                  int&nbsp;buffer)</PRE>
<DL>
<DD>Bind a named buffer object.
 <p>
 <h4>Description</h4>
 <code>glBindBuffer</code> lets you create or use a named buffer object. 
 Calling <code>glBindBuffer</code> with <i><code>target</code></i> set to 
 <code>GL_ARRAY_BUFFER</code> or <code>GL_ELEMENT_ARRAY_BUFFER</code> 
 and <i><code>buffer</code></i> set to the name of the new buffer object binds the buffer object name 
 to the target. When a buffer object is bound to a target, the previous binding 
 for that target is automatically broken.
 <p>
 Buffer object names are unsigned integers. The value zero is reserved, 
 but there is no default buffer object for each buffer object target. 
 Instead, <i><code>buffer</code></i> set to zero effectively unbinds any buffer object 
 previously bound, and restores client memory usage for that buffer 
 object target. Buffer object names and the corresponding buffer object contents 
 are local to the shared object space of the current GL rendering context.
 <p>
 You may use <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, java.nio.IntBuffer)"><CODE>glGenBuffers</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, int[], int)"><CODE>glGenBuffers</CODE></A> 
 to generate a set of new buffer object names.
 <p>
 The state of a buffer object immediately after it is first bound is a zero-sized 
 memory buffer with <code>GL_STATIC_DRAW</code> usage.
 <p>
 While a non-zero buffer object name is bound, GL operations on the target 
 to which it is bound affect the bound buffer object, and queries of the target to which 
 it is bound return state from the bound buffer object. While buffer object name zero is bound, 
 as in the initial state, attempts to modify or query state on the target to which it is 
 bound generates an <code>GL_INVALID_OPERATION</code> error.
 <p>
 When vertex array pointer state is changed by a call to 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><CODE>glVertexAttribPointer</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, int)"><CODE>glVertexAttribPointer</CODE></A>, 
 the current buffer object binding (<code>GL_ARRAY_BUFFER_BINDING</code>) is copied into the 
 corresponding client state for the vertex attrib array being changed, one of the 
 indexed <code>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</code>s. While a non-zero buffer object is 
 bound to the <code>GL_ARRAY_BUFFER</code> target, the vertex array pointer parameter that is 
 traditionally interpreted as a pointer to client-side memory is instead interpreted 
 as an offset within the buffer object measured in basic machine units.
 <p>
 While a non-zero buffer object is bound to the <code>GL_ELEMENT_ARRAY_BUFFER</code> target, 
 the indices parameter of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>glDrawElements</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)"><CODE>glDrawElements</CODE></A> that is traditionally interpreted as a 
 pointer to client-side memory is instead interpreted as an offset within the buffer 
 object measured in basic machine units.
 <p>
 A buffer object binding created with <code>glBindBuffer</code> remains active until a 
 different buffer object name is bound to the same target, or until the 
 bound buffer object is deleted with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, java.nio.IntBuffer)"><CODE>glDeleteBuffers</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, int[], int)"><CODE>glDeleteBuffers</CODE></A>.
 <p>
 Once created, a named buffer object may be re-bound to any target as often as needed. 
 However, the GL implementation may make choices about how to optimize the storage 
 of a buffer object based on its initial binding target.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not one of the allowable values.
 <p>
 <h4>Associated Gets</h4>
 <p>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A> 
  with argument <code>GL_ARRAY_BUFFER_BINDING</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_ELEMENT_ARRAY_BUFFER_BINDING</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target to which the buffer object is bound. 
  The symbolic constant must be <code>GL_ARRAY_BUFFER</code> or <code>GL_ELEMENT_ARRAY_BUFFER</code>.<DD><CODE>buffer</CODE> - Specifies the name of a buffer object.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteBuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, int[], int)"><CODE>GL20.glDeleteBuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, java.nio.IntBuffer)"><CODE>GL20.glGenBuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, int[], int)"><CODE>GL20.glGenBuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>GL20.glGetIntegerv(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>GL20.glGetIntegerv(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsBuffer(int)"><CODE>GL20.glIsBuffer(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glBindFramebuffer(int, int)"><!-- --></A><H3>
glBindFramebuffer</H3>
<PRE>
void <B>glBindFramebuffer</B>(int&nbsp;target,
                       int&nbsp;framebuffer)</PRE>
<DL>
<DD>Bind a named framebuffer object.
 <p>
 <h4>Description</h4>
 <code>glBindFramebuffer</code> lets you create or use a named framebuffer object. 
 Calling <code>glBindFramebuffer</code> with <i><code>target</code></i> set to
 <code>GL_FRAMEBUFFER</code> and <i><code>framebuffer</code></i> 
 set to the name of the new framebuffer object binds the framebuffer object name. 
 When a framebuffer object is bound, the previous binding is automatically broken.
 <p>
 Framebuffer object names are unsigned integers. The value zero is reserved to 
 represent the default framebuffer provided by the windowing system. 
 Framebuffer object names and the corresponding framebuffer object contents are 
 local to the shared object space of the current GL rendering context.
 <p>
 You may use <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, java.nio.IntBuffer)"><CODE>glGenFramebuffers</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, int[], int)"><CODE>glGenFramebuffers</CODE></A> to generate 
 a set of new framebuffer object names.
 <p>
 The state of a framebuffer object immediately after it is first bound is 
 three attachment points (<code>GL_COLOR_ATTACHMENT0</code>, <code>GL_DEPTH_ATTACHMENT</code>, 
 and <code>GL_STENCIL_ATTACHMENT</code>) each with <code>GL_NONE</code> as the object type.
 <p>
 While a non-zero framebuffer object name is bound, GL operations on 
 target <code>GL_FRAMEBUFFER</code> affect the bound framebuffer object, and queries 
 of target <code>GL_FRAMEBUFFER</code> or of framebuffer details such as <code>GL_DEPTH_BITS</code> 
 return state from the bound framebuffer object. While framebuffer object 
 name zero is bound, as in the initial state, attempts to modify or query 
 state on target <code>GL_FRAMEBUFFER</code> generates an <code>GL_INVALID_OPERATION</code> error.
 <p>
 While a non-zero framebuffer object name is bound, all rendering to the 
 framebuffer (with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawArrays(int, int, int)"><CODE>glDrawArrays</CODE></A> and 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>glDrawElements</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)"><CODE>glDrawElements</CODE></A>) and reading from the 
 framebuffer (with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReadPixels(int, int, int, int, int, int, java.nio.Buffer)"><CODE>glReadPixels</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)"><CODE>glCopyTexImage2D</CODE></A>, or 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexSubImage2D(int, int, int, int, int, int, int, int)"><CODE>glCopyTexSubImage2D</CODE></A>)
 use the images attached to the application-created framebuffer object rather 
 than the default window-system-provided framebuffer.
 <p>
 Application created framebuffer objects (i.e. those with a non-zero name) 
 differ from the default window-system-provided framebuffer in a few important ways. 
 First, they have modifiable attachment points for a color buffer, a depth buffer, 
 and a stencil buffer to which framebuffer attachable images may be attached and detached. 
 Second, the size and format of the attached images are controlled entirely within the GL 
 and are not affected by window-system events, such as pixel format selection, window resizes, 
 and display mode changes. Third, when rendering to or reading from an application created 
 framebuffer object, the pixel ownership test always succeeds (i.e. they own all their pixels). 
 Fourth, there are no visible color buffer bitplanes, only a single "off-screen" color image attachment, 
 so there is no sense of front and back buffers or swapping. Finally, there is no 
 multisample buffer, so the value of the implementation-dependent state 
 variables <code>GL_SAMPLES</code> and <code>GL_SAMPLE_BUFFERS</code> are both zero for application 
 created framebuffer objects.
 <p>
 A framebuffer object binding created with <code>glBindFramebuffer</code> remains active 
 until a different framebuffer object name is bound, or until the bound 
 framebuffer object is deleted with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, java.nio.IntBuffer)"><CODE>glDeleteFramebuffers</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, int[], int)"><CODE>glDeleteFramebuffers</CODE></A>.
 <p>
 <h4>Notes</h4>
 <p>
 Queries of implementation-dependent pixel depths and related state are derived from the currently 
 bound framebuffer object. These include <code>GL_RED_BITS</code>, <code>GL_GREEN_BITS</code>, 
 <code>GL_BLUE_BITS</code>, <code>GL_ALPHA_BITS</code>, <code>GL_DEPTH_BITS</code>, 
 <code>GL_STENCIL_BITS</code>, <code>GL_IMPLEMENTATION_COLOR_READ_TYPE</code>, 
 <code>GL_IMPLEMENTATION_COLOR_READ_FORMAT</code>, <code>GL_SAMPLES</code>, and <code>GL_SAMPLE_BUFFERS</code>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not <code>GL_FRAMEBUFFER</code>.
 <p>
 <h4>Associated Gets</h4>
 <p>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_FRAMEBUFFER_BINDING</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target to which the framebuffer object is bound. 
  The symbolic constant must be <code>GL_FRAMEBUFFER</code>.<DD><CODE>framebuffer</CODE> - Specifies the name of a framebuffer object.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteFramebuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, int[], int)"><CODE>GL20.glDeleteFramebuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFramebufferRenderbuffer(int, int, int, int)"><CODE>GL20.glFramebufferRenderbuffer(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFramebufferTexture2D(int, int, int, int, int)"><CODE>GL20.glFramebufferTexture2D(int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, java.nio.IntBuffer)"><CODE>GL20.glGenFramebuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, int[], int)"><CODE>GL20.glGenFramebuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>GL20.glGetIntegerv(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>GL20.glGetIntegerv(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, java.nio.IntBuffer)"><CODE>GL20.glGetFramebufferAttachmentParameteriv(int, int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)"><CODE>GL20.glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsFramebuffer(int)"><CODE>GL20.glIsFramebuffer(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glBindRenderbuffer(int, int)"><!-- --></A><H3>
glBindRenderbuffer</H3>
<PRE>
void <B>glBindRenderbuffer</B>(int&nbsp;target,
                        int&nbsp;renderbuffer)</PRE>
<DL>
<DD>Bind a named renderbuffer object.
 <p>
 <h4>Description</h4>
 A renderbuffer is a data storage object containing a single image of a 
 renderable internal format. A renderbuffer's image may be 
 attached to a framebuffer object to use as a destination for 
 rendering and as a source for reading.
 <p>
 <code>glBindRenderbuffer</code> lets you create or use a named renderbuffer object. 
 Calling <code>glBindRenderbuffer</code> with <i><code>target</code></i> set to
 <code>GL_RENDERBUFFER</code> and <i><code>renderbuffer</code></i>
 set to the name of the new renderbuffer object 
 binds the renderbuffer object name. When a renderbuffer object is 
 bound, the previous binding is automatically broken.
 <p>
 Renderbuffer object names are unsigned integers. 
 The value zero is reserved, but there is no default renderbuffer object. 
 Instead, <i><code>renderbuffer</code></i> set to zero effectively unbinds any renderbuffer 
 object previously bound. Renderbuffer object names and the corresponding 
 renderbuffer object contents are local to the shared object space of the 
 current GL rendering context.
 <p>
 You may use <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, java.nio.IntBuffer)"><CODE>glGenRenderbuffers</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, int[], int)"><CODE>glGenRenderbuffers</CODE></A>
 to generate a set of new renderbuffer object names.
 <p>
 The state of a renderbuffer object immediately after it is first 
 bound is a zero-sized memory buffer with format <code>GL_RGBA4</code> and 
 zero-sized red, green, blue, alpha, depth, and stencil pixel depths.
 <p>
 While a non-zero renderbuffer object name is bound, GL operations on 
 target <code>GL_RENDERBUFFER</code> affect the bound renderbuffer object, and queries 
 of target <code>GL_RENDERBUFFER</code> return state from the bound renderbuffer object. 
 While renderbuffer object name zero is bound, as in the initial state, 
 attempts to modify or query state on target <code>GL_RENDERBUFFER</code> generates 
 an <code>GL_INVALID_OPERATION</code> error.
 <p>
 A renderbuffer object binding created with <code>glBindRenderbuffer</code> remains 
 active until a different renderbuffer object name is bound, or until 
 the bound renderbuffer object is deleted with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, java.nio.IntBuffer)"><CODE>glDeleteRenderbuffers</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, int[], int)"><CODE>glDeleteRenderbuffers</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not <code>GL_RENDERBUFFER</code>.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_RENDERBUFFER_BINDING</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target to which the renderbuffer object is bound. 
  The symbolic constant must be <code>GL_RENDERBUFFER</code>.<DD><CODE>renderbuffer</CODE> - Specifies the name of a renderbuffer object.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteRenderbuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, int[], int)"><CODE>GL20.glDeleteRenderbuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFramebufferRenderbuffer(int, int, int, int)"><CODE>GL20.glFramebufferRenderbuffer(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, java.nio.IntBuffer)"><CODE>GL20.glGenRenderbuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, int[], int)"><CODE>GL20.glGenRenderbuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>GL20.glGetIntegerv(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>GL20.glGetIntegerv(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetRenderbufferParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, int[], int)"><CODE>GL20.glGetRenderbufferParameteriv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsRenderbuffer(int)"><CODE>GL20.glIsRenderbuffer(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glRenderbufferStorage(int, int, int, int)"><CODE>GL20.glRenderbufferStorage(int, int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glBindTexture(int, int)"><!-- --></A><H3>
glBindTexture</H3>
<PRE>
void <B>glBindTexture</B>(int&nbsp;target,
                   int&nbsp;texture)</PRE>
<DL>
<DD>Bind a named texture to a texturing target.
 <p>
 <h4>Description</h4>
 <code>glBindTexture</code> lets you create or use a named texture. 
 Calling <code>glBindTexture</code> with <i><code>target</code></i> set to 
 <code>GL_TEXTURE_2D</code> or <code>GL_TEXTURE_CUBE_MAP</code> and <i><code>texture</code></i> set to the name 
 of the new texture binds the texture name to the target. 
 When a texture is bound to a target, the previous binding 
 for that target is automatically broken.
 <p>
 Texture names are unsigned integers. The value zero is reserved to 
 represent the default texture for each texture target. Texture names 
 and the corresponding texture contents are local to the shared object 
 space of the current GL rendering context.
 <p>
 You may use <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, java.nio.IntBuffer)"><CODE>glGenTextures</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, int[], int)"><CODE>glGenTextures</CODE></A> to generate a set of new texture names.
 <p>
 When a texture is first bound, it assumes the specified target: 
 A texture first bound to <code>GL_TEXTURE_2D</code> becomes a two-dimensional 
 texture and a texture first bound to <code>GL_TEXTURE_CUBE_MAP</code> becomes 
 a cube-mapped texture. The state of a two-dimensional texture 
 immediately after it is first bound is equivalent to the state of 
 the default <code>GL_TEXTURE_2D</code> at GL initialization, and similarly for 
 cube-mapped textures.
 <p>
 While a texture is bound, GL operations on the target to which 
 it is bound affect the bound texture, and queries of the target 
 to which it is bound return state from the bound texture. 
 If texture mapping is active on the target to which a texture 
 is bound, the bound texture is used. In effect, the texture 
 targets become aliases for the textures currently bound to them, 
 and the texture name zero refers to the default textures that 
 were bound to them at initialization.
 <p>
 A texture binding created with <code>glBindTexture</code> remains active 
 until a different texture is bound to the same target, or 
 until the bound texture is deleted with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, java.nio.IntBuffer)"><CODE>glDeleteTextures</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, int[], int)"><CODE>glDeleteTextures</CODE></A>.
 <p>
 Once created, a named texture may be re-bound to its same 
 original target as often as needed. It is usually much 
 faster to use <code>glBindTexture</code> to bind an existing named 
 texture to one of the texture targets than it is to 
 reload the texture image using 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glTexImage2D</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not one 
  of the allowable values.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>texture</code></i> was 
  previously created with a target that doesn't match that of <i><code>target</code></i>.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_TEXTURE_BINDING_2D</code> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target of the active texture unit to which the texture is bound.
  Must be either <code>GL_TEXTURE_2D</code> or <code>GL_TEXTURE_CUBE_MAP</code>.<DD><CODE>texture</CODE> - Specifies the name of a texture.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteTextures(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, int[], int)"><CODE>GL20.glDeleteTextures(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, java.nio.IntBuffer)"><CODE>GL20.glGenTextures(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, int[], int)"><CODE>GL20.glGenTextures(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>GL20.glGetIntegerv(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>GL20.glGetIntegerv(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, float[], int)"><CODE>GL20.glGetTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, int[], int)"><CODE>GL20.glGetTexParameteriv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsTexture(int)"><CODE>GL20.glIsTexture(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glBlendColor(float, float, float, float)"><!-- --></A><H3>
glBlendColor</H3>
<PRE>
void <B>glBlendColor</B>(float&nbsp;red,
                  float&nbsp;green,
                  float&nbsp;blue,
                  float&nbsp;alpha)</PRE>
<DL>
<DD>Set the blend color.
 <p>
 The <code>GL_BLEND_COLOR</code> may be used to calculate the source and destination 
 blending factors. The color components are clamped to the range <code>[0, 1]</code> 
 before being stored. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>glBlendFunc</CODE></A> for a complete description of 
 the blending operations. Initially the <code>GL_BLEND_COLOR</code> is set 
 to (0, 0, 0, 0).
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A> with an argument of <code>GL_BLEND_COLOR</code> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>red</CODE> - Specifies the red component of <code>GL_BLEND_COLOR</code>.<DD><CODE>green</CODE> - Specifies the green component of <code>GL_BLEND_COLOR</code>.<DD><CODE>blue</CODE> - Specifies the blue component of <code>GL_BLEND_COLOR</code>.<DD><CODE>alpha</CODE> - Specifies the alpha component of <code>GL_BLEND_COLOR</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendEquation(int)"><CODE>GL20.glBlendEquation(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>GL20.glBlendFunc(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetString(int)"><CODE>GL20.glGetString(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glBlendEquation(int)"><!-- --></A><H3>
glBlendEquation</H3>
<PRE>
void <B>glBlendEquation</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Specify the equation used for both the RGB blend equation and the Alpha blend equation.
 <p>
 <h4>Description</h4>
 The blend equations determine how a new pixel (the "source" color) 
 is combined with a pixel already in the framebuffer 
 (the "destination" color). This function sets both the RGB 
 blend equation and the alpha blend equation to a single equation.
 <p>
 These equations use the source and destination blend factors 
 specified by either <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>glBlendFunc</CODE></A> or 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFuncSeparate(int, int, int, int)"><CODE>glBlendFuncSeparate</CODE></A>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>glBlendFunc</CODE></A> or 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFuncSeparate(int, int, int, int)"><CODE>glBlendFuncSeparate</CODE></A>
 for a description of the various blend factors.
 <p>
 In the equations that follow, source and destination color 
 components are referred to as <code>(Rs, Gs, Bs, As)</code> and <code>(Rd, Gd, Bd, Ad)</code>, 
 respectively. The result color is referred to as <code>(Rr, Gr, Br, Ar)</code>. 
 The source and destination blend factors are 
 denoted <code>(sR, sG, sB, sA)</code> and <code>(dR, dG, dB, dA)</code>, respectively. 
 For these equations all color components are understood 
 to have values in the range <code>[0, 1]</code>.
 <p>
 <table border=1><tbody>
 <tr>
 <td><b>Mode</b></td><td><b>RGB Components</b></td><td><b>Alpha Component</b></td>
 </tr>
 <tr>
  <td><code>GL_FUNC_ADD</code></td>
  <td><pre>
  Rr = Rs*sR + Rd*dR      
  Gr = Gs*sG + Gd*dG
  Br = Bs*sB + Bd*dB
  </pre></td>
  <td><pre>Ar = As*sA + Ad*dA</pre></td>
 <tr>
  <td><code>GL_FUNC_SUBTRACT</code></td>
  <td><pre>
  Rr = Rs*sR - Rd*dR
  Gr = Gs*sG - Gd*dG
  Br = Bs*sB - Bd*dB
  </pre></td>
  <td><pre>Ar = As*sA - Ad*dA</pre></td>
 </tr>
 <tr>
  <td><code>GL_FUNC_REVERSE_SUBTRACT</code></td>
  <td><pre>
  Rr = Rd*dR - Rs*sR
  Gr = Gd*dG - Gs*sG
  Br = Bd*dB - Bs*sB
  </pre></td>
  <td><pre>Ar = Ad*dA - As*sA</pre></td>
 </tr>
 </tbody></table>
 <p>
 The results of these equations are clamped to the range <code>[0, 1]</code>.
 <p>
 The <code>GL_FUNC_ADD</code> equation is useful for antialiasing and transparency, among other things.
 <p>
 Initially, both the RGB blend equation and the alpha blend equation are set to <code>GL_FUNC_ADD</code>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>mode</code></i> is not one of 
  <code>GL_FUNC_ADD</code>, <code>GL_FUNC_SUBTRACT</code>, or <code>GL_FUNC_REVERSE_SUBTRACT</code>.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with an argument of <code>GL_BLEND_EQUATION_RGB</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with an argument of <code>GL_BLEND_EQUATION_ALPHA</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - Specifies how source and destination colors are combined. 
  It must be <code>GL_FUNC_ADD</code>, <code>GL_FUNC_SUBTRACT</code>, or <code>GL_FUNC_REVERSE_SUBTRACT</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetString(int)"><CODE>GL20.glGetString(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendColor(float, float, float, float)"><CODE>GL20.glBlendColor(float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendEquationSeparate(int, int)"><CODE>GL20.glBlendEquationSeparate(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>GL20.glBlendFunc(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFuncSeparate(int, int, int, int)"><CODE>GL20.glBlendFuncSeparate(int, int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glBlendEquationSeparate(int, int)"><!-- --></A><H3>
glBlendEquationSeparate</H3>
<PRE>
void <B>glBlendEquationSeparate</B>(int&nbsp;modeRGB,
                             int&nbsp;modeAlpha)</PRE>
<DL>
<DD>Set the RGB blend equation and the alpha blend equation separately.
 <p>
 <h4>Description</h4>
 The blend equations determines how a new pixel (the "source" color) is 
 combined with a pixel already in the framebuffer (the "destination" color). 
 This function specifies one blend equation for the RGB-color components and 
 one blend equation for the alpha component.
 <p>
 The blend equations use the source and destination blend factors specified 
 by either <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>glBlendFunc</CODE></A> or 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFuncSeparate(int, int, int, int)"><CODE>glBlendFuncSeparate</CODE></A>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>glBlendFunc</CODE></A> or 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFuncSeparate(int, int, int, int)"><CODE>glBlendFuncSeparate</CODE></A> 
 for a description of the various blend factors.
 <p>
 In the equations that follow, source and destination color components 
 are referred to as <code>(Rs, Gs, Bs, As)</code> and <code>(Rd, Gd, Bd, Ad)</code>, respectively. 
 The result color is referred to as <code>(Rr, Gr, Br, Ar)</code>. The source and destination 
 blend factors are denoted <code>(sR, sG, sB, sA)</code> and <code>(dR, dG, dB, dA)</code>, respectively. 
 For these equations all color components are understood to have values in the range <code>[0, 1]</code>.
 <p>
 <table border=1><tbody>
 <tr>
 <td><b>Mode</b></td><td><b>RGB Components</b></td><td><b>Alpha Component</b></td>
 </tr>
 <tr>
  <td><code>GL_FUNC_ADD</code></td>
  <td><pre>
  Rr = Rs*sR + Rd*dR      
  Gr = Gs*sG + Gd*dG
  Br = Bs*sB + Bd*dB
  </pre></td>
  <td><pre>Ar = As*sA + Ad*dA</pre></td>
 <tr>
  <td><code>GL_FUNC_SUBTRACT</code></td>
  <td><pre>
  Rr = Rs*sR - Rd*dR
  Gr = Gs*sG - Gd*dG
  Br = Bs*sB - Bd*dB
  </pre></td>
  <td><pre>Ar = As*sA - Ad*dA</pre></td>
 </tr>
 <tr>
  <td><code>GL_FUNC_REVERSE_SUBTRACT</code></td>
  <td><pre>
  Rr = Rd*dR - Rs*sR
  Gr = Gd*dG - Gs*sG
  Br = Bd*dB - Bs*sB
  </pre></td>
  <td><pre>Ar = Ad*dA - As*sA</pre></td>
 </tr>
 </tbody></table>
 <p>
 The results of these equations are clamped to the range <code>[0, 1]</code>.
 <p>
 The <code>GL_FUNC_ADD</code> equation is useful for antialiasing and transparency, among other things.
 <p>
 Initially, both the RGB blend equation and the alpha blend equation are set to <code>GL_FUNC_ADD</code>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if either <i><code>modeRGB</code></i> or
  <i><code>modeAlpha</code></i> is not one of <code>GL_FUNC_ADD</code>, <code>GL_FUNC_SUBTRACT</code>,
  or <code>GL_FUNC_REVERSE_SUBTRACT</code>.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with an argument of <code>GL_BLEND_EQUATION_RGB</code> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with an argument of <code>GL_BLEND_EQUATION_ALPHA</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>modeRGB</CODE> - Specifies the RGB blend equation, how the red, green, and blue components of 
  the source and destination colors are combined. It must be <code>GL_FUNC_ADD</code>,
  <code>GL_FUNC_SUBTRACT</code>, or <code>GL_FUNC_REVERSE_SUBTRACT</code>.<DD><CODE>modeAlpha</CODE> - Specifies the alpha blend equation, how the alpha component of 
  the source and destination colors are combined. It must be <code>GL_FUNC_ADD</code>,
  <code>GL_FUNC_SUBTRACT</code>, or <code>GL_FUNC_REVERSE_SUBTRACT</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetString(int)"><CODE>GL20.glGetString(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendColor(float, float, float, float)"><CODE>GL20.glBlendColor(float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendEquation(int)"><CODE>GL20.glBlendEquation(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>GL20.glBlendFunc(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFuncSeparate(int, int, int, int)"><CODE>GL20.glBlendFuncSeparate(int, int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glBlendFunc(int, int)"><!-- --></A><H3>
glBlendFunc</H3>
<PRE>
void <B>glBlendFunc</B>(int&nbsp;sfactor,
                 int&nbsp;dfactor)</PRE>
<DL>
<DD>Specify pixel arithmetic.
 <p>
 <h4>Description</h4>
 Pixels can be drawn using a function that blends the incoming (source) RGBA values with 
 the RGBA values that are already in the frame buffer (the destination values). 
 Blending is initially disabled. Use <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>glEnable</CODE></A> and 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisable(int)"><CODE>glDisable</CODE></A> with argument <code>GL_BLEND</code> to 
 enable and disable blending.
 <p>
 <code>glBlendFunc</code> defines the operation of blending when it is enabled.
 <i><code>sfactor</code></i> specifies which method is used to scale the
 source color components. <i><code>dfactor</code></i> specifies 
 which method is used to scale the destination color components. 
 The possible methods are described in the following table. Each method defines 
 four scale factors, one each for red, green, blue, and alpha. In the 
 table and in subsequent equations, source and destination color components 
 are referred to as <code>(Rs, Gs, Bs, As)</code> and <code>(Rd, Gd, Bd, Ad)</code>. 
 The color specified by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendColor(float, float, float, float)"><CODE>glBlendColor</CODE></A>
 is referred to as <code>(Rc, Gc, Bc, Ac)</code>. 
 They are understood to have integer values between 0 and <code>(kR, kG, kB, kA)</code>, 
 where 
 <p><code>kc = 2^mc - 1</code>
 <p> and <code>(mR, mG, mB, mA)</code> is the number of 
 red, green, blue, and alpha bitplanes.
 <p>
 Source and destination scale factors are referred to as <code>(sR, sG, sB, sA)</code> and <code>(dR, dG, dB, dA)</code>. 
 The scale factors described in the table, denoted <code>(fR, fG, fB, fA)</code>, represent either 
 source or destination factors. All scale factors have range <code>[0, 1]</code>.
 <p>
 <table border=1><tbody>
 <tr>
  <td><b>Parameter</b></td><td><b><pre>(fR, fG, fB, fA)</pre></b></td>
 </tr><tr>
  <td><pre>GL_ZERO</pre></td><td><pre>(0, 0, 0, 0)</pre></td>
 </tr><tr>
  <td><pre>GL_ONE</pre></td><td><pre>(1, 1, 1, 1)</pre></td>
 </tr><tr>         
  <td><pre>GL_SRC_COLOR</pre></td><td><pre>(Rs/kR, Gs/kG, Bs/kB, As/kA)</pre></td>
 </tr><tr>
  <td><pre>GL_ONE_MINUS_SRC_COLOR</pre></td><td><pre>(1, 1, 1, 1) - (Rs/kR, Gs/kG, Bs/kB, As/kA)</pre></td>
 </tr><tr>
  <td><pre>GL_DST_COLOR</pre></td><td><pre>(Rd/kR, Gd/kG, Bd/kB, Ad/kA)</pre></td>
 </tr><tr>
  <td><pre>GL_ONE_MINUS_DST_COLOR</pre></td><td><pre>(1, 1, 1, 1) - (Rd/kR, Gd/kG, Bd/kB, Ad/kA)</pre></td>
 </tr><tr>
  <td><pre>GL_SRC_ALPHA</pre></td><td><pre>(As/kA, As/kA, As/kA, As/kA)</pre></td>
 </tr><tr>
  <td><pre>GL_ONE_MINUS_SRC_ALPHA</pre></td><td><pre>(1, 1, 1, 1) - (As/kA, As/kA, As/kA, As/kA)</pre></td>
 </tr><tr>
  <td><pre>GL_DST_ALPHA</pre></td><td><pre>(Ad/kA, Ad/kA, Ad/kA, Ad/kA)</pre></td>
 </tr><tr>
  <td><pre>GL_ONE_MINUS_DST_ALPHA</pre></td><td><pre>(1, 1, 1, 1) - (Ad/kA, Ad/kA, Ad/kA, Ad/kA)</pre></td>
 </tr><tr>
  <td><pre>GL_CONSTANT_COLOR</pre></td><td><pre>(Rc, Gc, Bc, Ac)</pre></td>
 </tr><tr>
  <td><pre>GL_ONE_MINUS_CONSTANT_COLOR</pre></td><td><pre>(1, 1, 1, 1) - (Rc, Gc, Bc, Ac)</pre></td>
 </tr><tr>
  <td><pre>GL_CONSTANT_ALPHA</pre></td><td><pre>(Ac, Ac, Ac, Ac)</pre></td>
 </tr><tr>
  <td><pre>GL_ONE_MINUS_CONSTANT_ALPHA</pre></td><td><pre>(1, 1, 1, 1) - (Ac, Ac, Ac, Ac)</pre></td>
 </tr><tr>
  <td><pre>GL_SRC_ALPHA_SATURATE</pre></td><td><pre>(i, i, i, 1)</pre></td>
 </tr><tr>
 </tbody></table>
 <p>
 In the table, 
 <p>
 <code>i = min(As, kA - Ad) / kA</code>.
 <p>
 To determine the blended RGBA values of a pixel, the system uses one of the 
 equations set by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendEquation(int)"><CODE>glBlendEquation</CODE></A> or 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendEquationSeparate(int, int)"><CODE>glBlendEquationSeparate</CODE></A>.
 <p>
 Blending arithmetic is not exactly specified, because blending operates with 
 imprecise integer color values. However, a blend factor that should be equal 
 to 1 is guaranteed not to modify its multiplicand, and a blend factor equal 
 to 0 reduces its multiplicand to 0.
 <p>
 <h4>Notes</h4>
 <p>
 Incoming (source) alpha is correctly thought of as a material opacity, ranging 
 from 1.0 <code>(KA)</code>, representing complete opacity, to 0.0 <code>(0)</code>, representing 
 complete transparency.
 <p>
 Transparency is best implemented using blend function (<code>GL_SRC_ALPHA</code>, <code>GL_ONE_MINUS_SRC_ALPHA</code>) 
 with primitives sorted from farthest to nearest. Note that this transparency calculation does 
 not require the presence of alpha bitplanes in the frame buffer.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if either <i><code>sfactor</code></i> or 
  <i><code>dfactor</code></i> is not an accepted value.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_BLEND_SRC_RGB</code> or <code>GL_BLEND_SRC_ALPHA</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_BLEND_DST_RGB</code> or <code>GL_BLEND_DST_ALPHA</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A> with argument <code>GL_BLEND</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sfactor</CODE> - Specifies how the red, green, blue, and alpha source blending factors are computed. 
  The following symbolic constants are accepted: <code>GL_ZERO</code>, <code>GL_ONE</code>, 
  <code>GL_SRC_COLOR</code>, <code>GL_ONE_MINUS_SRC_COLOR</code>, 
  <code>GL_DST_COLOR</code>, <code>GL_ONE_MINUS_DST_COLOR</code>, 
  <code>GL_SRC_ALPHA</code>, <code>GL_ONE_MINUS_SRC_ALPHA</code>, 
  <code>GL_DST_ALPHA</code>, <code>GL_ONE_MINUS_DST_ALPHA</code>, 
  <code>GL_CONSTANT_COLOR</code>, <code>GL_ONE_MINUS_CONSTANT_COLOR</code>,
  <code>GL_CONSTANT_ALPHA</code>, <code>GL_ONE_MINUS_CONSTANT_ALPHA</code>, and <code>GL_SRC_ALPHA_SATURATE</code>.
  The initial value is <code>GL_ONE</code>.<DD><CODE>dfactor</CODE> - Specifies how the red, green, blue, and alpha destination blending factors are computed. 
  The following symbolic constants are accepted: <code>GL_ZERO</code>, <code>GL_ONE</code>, 
  <code>GL_SRC_COLOR</code>, <code>GL_ONE_MINUS_SRC_COLOR</code>, 
  <code>GL_DST_COLOR</code>, <code>GL_ONE_MINUS_DST_COLOR</code>, 
  <code>GL_SRC_ALPHA</code>, <code>GL_ONE_MINUS_SRC_ALPHA</code>, 
  <code>GL_DST_ALPHA</code>, <code>GL_ONE_MINUS_DST_ALPHA</code>, 
  <code>GL_CONSTANT_COLOR</code>, <code>GL_ONE_MINUS_CONSTANT_COLOR</code>, 
  <code>GL_CONSTANT_ALPHA</code>, and <code>GL_ONE_MINUS_CONSTANT_ALPHA</code>. 
  The initial value is <code>GL_ZERO</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendColor(float, float, float, float)"><CODE>GL20.glBlendColor(float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendEquation(int)"><CODE>GL20.glBlendEquation(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendEquationSeparate(int, int)"><CODE>GL20.glBlendEquationSeparate(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFuncSeparate(int, int, int, int)"><CODE>GL20.glBlendFuncSeparate(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClear(int)"><CODE>GL20.glClear(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>GL20.glEnable(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>GL20.glStencilFunc(int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glBlendFuncSeparate(int, int, int, int)"><!-- --></A><H3>
glBlendFuncSeparate</H3>
<PRE>
void <B>glBlendFuncSeparate</B>(int&nbsp;srcRGB,
                         int&nbsp;dstRGB,
                         int&nbsp;srcAlpha,
                         int&nbsp;dstAlpha)</PRE>
<DL>
<DD>Specify pixel arithmetic for RGB and alpha components separately.
 <p>
 <h4>Description</h4>
 Pixels can be drawn using a function that blends the incoming (source) 
 RGBA values with the RGBA values that are already in the frame buffer (the destination values). 
 Blending is initially disabled. Use <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>glEnable</CODE></A> and
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisable(int)"><CODE>glDisable</CODE></A> with argument <code>GL_BLEND</code> to enable and disable blending.
 <p>
 <code>glBlendFuncSeparate</code> defines the operation of blending when it is enabled. 
 <i><code>srcRGB</code></i> specifies which method is used to scale the source RGB-color components. 
 <i><code>dstRGB</code></i> specifies which method is used to scale the destination RGB-color components. 
 Likewise, <i><code>srcAlpha</code></i> specifies which method is used to scale the source alpha color component, 
 and <i><code>dstAlpha</code></i> specifies which method is used to scale the destination alpha component. 
 The possible methods are described in the following table. Each method defines 
 four scale factors, one each for red, green, blue, and alpha.
 <p>
 In the table and in subsequent equations, source and destination color components 
 are referred to as <code>(Rs, Gs, Bs, As)</code> and <code>(Rd, Gd, Bd, Ad)</code>. 
 The color specified by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendColor(float, float, float, float)"><CODE>glBlendColor</CODE></A>
 is referred to as <code>(Rc, Gc, Bc, Ac)</code>. 
 They are understood to have integer values between 0 and <code>(kR, kG, kB, kA)</code>, 
 where 
 <p><code>kc = 2^mc - 1</code>
 <p> and <code>(mR, mG, mB, mA)</code> is the number of 
 red, green, blue, and alpha bitplanes.
 <p>
 Source and destination scale factors are referred to as <code>(sR, sG, sB, sA)</code>
 and <code>(dR, dG, dB, dA)</code>. All scale factors have range <code>[0, 1]</code>.
 <p>
 <table border=1><tbody>
 <tr>
  <td><b>Parameter</b></td>
  <td><b>RGB Factor</b></td>
  <td><b>Alpha Factor</b></td>
 </tr><tr>
  <td><pre>GL_ZERO</pre></td>
  <td><pre>(0, 0, 0)</pre></td>
  <td><pre>0</pre></td>
 </tr><tr>
  <td><pre>GL_ONE</pre></td>
  <td><pre>(1, 1, 1)</pre></td>
  <td><pre>1</pre></td>
 </tr><tr>         
  <td><pre>GL_SRC_COLOR</pre></td>
  <td><pre>(Rs/kR, Gs/kG, Bs/kB)</pre></td>
  <td><pre>As/kA</pre></td>
 </tr><tr>
  <td><pre>GL_ONE_MINUS_SRC_COLOR</pre></td>
  <td><pre>(1, 1, 1) - (Rs/kR, Gs/kG, Bs/kB)</pre></td>
  <td><pre>1 - As/kA</pre></td>
 </tr><tr>
  <td><pre>GL_DST_COLOR</pre></td>
  <td><pre>(Rd/kR, Gd/kG, Bd/kB)</pre></td>
  <td><pre>Ad/kA</pre></td>
 </tr><tr>
  <td><pre>GL_ONE_MINUS_DST_COLOR</pre></td>
  <td><pre>(1, 1, 1) - (Rd/kR, Gd/kG, Bd/kB)</pre></td>
  <td><pre>1 - Ad/kA</pre></td>
 </tr><tr>
  <td><pre>GL_SRC_ALPHA</pre></td>
  <td><pre>(As/kA, As/kA, As/kA)</pre></td>
  <td><pre>As/kA</pre></td>
 </tr><tr>
  <td><pre>GL_ONE_MINUS_SRC_ALPHA</pre></td>
  <td><pre>(1, 1, 1) - (As/kA, As/kA, As/kA)</pre></td>
  <td><pre>1 - As/kA</pre></td>
 </tr><tr>
  <td><pre>GL_DST_ALPHA</pre></td>
  <td><pre>(Ad/kA, Ad/kA, Ad/kA)</pre></td>
  <td><pre>Ad/kA</pre></td>
 </tr><tr>
  <td><pre>GL_ONE_MINUS_DST_ALPHA</pre></td>
  <td><pre>(1, 1, 1) - (Ad/kA, Ad/kA, Ad/kA)</pre></td>
  <td><pre>1 - Ad/kA</pre></td>
 </tr><tr>
  <td><pre>GL_CONSTANT_COLOR</pre></td>
  <td><pre>(Rc, Gc, Bc)</pre></td>
  <td><pre>Ac</pre></td>
 </tr><tr>
  <td><pre>GL_ONE_MINUS_CONSTANT_COLOR</pre></td>
  <td><pre>(1, 1, 1) - (Rc, Gc, Bc)</pre></td>
  <td><pre>1 - Ac</pre></td>
 </tr><tr>
  <td><pre>GL_CONSTANT_ALPHA</pre></td>
  <td><pre>(Ac, Ac, Ac)</pre></td>
  <td><pre>Ac</pre></td>
 </tr><tr>
  <td><pre>GL_ONE_MINUS_CONSTANT_ALPHA</pre></td>
  <td><pre>(1, 1, 1) - (Ac, Ac, Ac)</pre></td>
  <td><pre>1 - Ac</pre></td>
 </tr><tr>
  <td><pre>GL_SRC_ALPHA_SATURATE</pre></td>
  <td><pre>(i, i, i)</pre></td>
  <td><pre>1</pre></td>
 </tr><tr>
 </tbody></table>
 <p>
 In the table, 
 <p>
 <code>i = min(As, kA - Ad) / kA</code>.
 <p>
 To determine the blended RGBA values of a pixel, the system uses one of the 
 equations set by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendEquation(int)"><CODE>glBlendEquation</CODE></A> or 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendEquationSeparate(int, int)"><CODE>glBlendEquationSeparate</CODE></A>.
 <p>
 Despite the apparent precision of the above equations, blending arithmetic is not exactly specified, 
 because blending operates with imprecise integer color values. However, a blend factor that should 
 be equal to 1 is guaranteed not to modify its multiplicand, and a blend factor equal to 0 reduces 
 its multiplicand to 0.
 <p>
 <h4>Notes</h4>
 <p>
 Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 <code>(KA)</code>, 
 representing complete opacity, to 0.0 <code>(0)</code>, representing complete transparency.
 <p>
 <h4>Errors</h4>
 <p>
 <code>GL_INVALID_ENUM</code> is generated if <i><code>srcRGB</code></i>, <i><code>dstRGB</code></i>, 
  <i><code>srcAlpha</code></i>, or <i><code>dstAlpha</code></i> is not an accepted value.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_BLEND_SRC_RGB</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_BLEND_SRC_ALPHA</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_BLEND_DST_RGB</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_BLEND_DST_ALPHA</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A> with argument <code>GL_BLEND</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>srcRGB</CODE> - Specifies how the red, green, and blue source blending factors are computed. 
  The following symbolic constants are accepted: <code>GL_ZERO</code>, <code>GL_ONE</code>, 
  <code>GL_SRC_COLOR</code>, <code>GL_ONE_MINUS_SRC_COLOR</code>, 
  <code>GL_DST_COLOR</code>, <code>GL_ONE_MINUS_DST_COLOR</code>, 
  <code>GL_SRC_ALPHA</code>, <code>GL_ONE_MINUS_SRC_ALPHA</code>, 
  <code>GL_DST_ALPHA</code>, <code>GL_ONE_MINUS_DST_ALPHA</code>, 
  <code>GL_CONSTANT_COLOR</code>, <code>GL_ONE_MINUS_CONSTANT_COLOR</code>,
  <code>GL_CONSTANT_ALPHA</code>, <code>GL_ONE_MINUS_CONSTANT_ALPHA</code>, and <code>GL_SRC_ALPHA_SATURATE</code>.
  The initial value is <code>GL_ONE</code>.<DD><CODE>dstRGB</CODE> - Specifies how the red, green, and blue destination blending factors are computed. 
  The following symbolic constants are accepted: <code>GL_ZERO</code>, <code>GL_ONE</code>, 
  <code>GL_SRC_COLOR</code>, <code>GL_ONE_MINUS_SRC_COLOR</code>, 
  <code>GL_DST_COLOR</code>, <code>GL_ONE_MINUS_DST_COLOR</code>, 
  <code>GL_SRC_ALPHA</code>, <code>GL_ONE_MINUS_SRC_ALPHA</code>, 
  <code>GL_DST_ALPHA</code>, <code>GL_ONE_MINUS_DST_ALPHA</code>, 
  <code>GL_CONSTANT_COLOR</code>, <code>GL_ONE_MINUS_CONSTANT_COLOR</code>, 
  <code>GL_CONSTANT_ALPHA</code>, and <code>GL_ONE_MINUS_CONSTANT_ALPHA</code>. 
  The initial value is <code>GL_ZERO</code>.<DD><CODE>srcAlpha</CODE> - Specifies how the alpha source blending factor is computed. 
  The same symbolic constants are accepted as for <i><code>srcRGB</code></i>. The initial value is <code>GL_ONE</code>.<DD><CODE>dstAlpha</CODE> - Specifies how the alpha destination blending factor is computed. 
  The same symbolic constants are accepted as for <i><code>dstRGB</code></i>. The initial value is <code>GL_ZERO</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendColor(float, float, float, float)"><CODE>GL20.glBlendColor(float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendEquation(int)"><CODE>GL20.glBlendEquation(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendEquationSeparate(int, int)"><CODE>GL20.glBlendEquationSeparate(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>GL20.glBlendFunc(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClear(int)"><CODE>GL20.glClear(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>GL20.glEnable(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>GL20.glStencilFunc(int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glBufferData(int, int, java.nio.Buffer, int)"><!-- --></A><H3>
glBufferData</H3>
<PRE>
void <B>glBufferData</B>(int&nbsp;target,
                  int&nbsp;size,
                  <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data,
                  int&nbsp;usage)</PRE>
<DL>
<DD>Create and initialize a buffer object's data store.
 <p>
 <h4>Description</h4>
 <code>glBufferData</code> creates a new data store for the buffer object
 currently bound to <i><code>target</code></i>. 
 Any pre-existing data store is deleted. The new data store is created with the specified 
 <i><code>size</code></i> in bytes and usage. If <i><code>data</code></i> is not 
 <code>null</code>, the data store is initialized with data from this buffer.
 <p>
 <i><code>usage</code></i> is a hint to the GL implementation as to how a buffer object's data store 
 will be accessed. This enables the GL implementation to make more intelligent decisions 
 that may significantly impact buffer object performance. It does not, however, 
 constrain the actual usage of the data store. <i><code>usage</code></i> can be broken
 down into two parts: first, the frequency of access (modification and usage), 
 and second, the nature of that access. The frequency of access may be one of these:
 <p>
 STREAM
 <p>
 The data store contents will be modified once and used at 
 most a few times.
 <p>
 STATIC
 <p>
 The data store contents will be modified once and used many times.
 <p>
 DYNAMIC
 <p>
 The data store contents will be modified repeatedly and used 
 many times.
 <p> 
 The nature of access must be:
 <p>
 DRAW
 <p>
 The data store contents are modified by the application, and used as 
 the source for GL drawing and image specification commands.
 <p>
 <h4>Notes</h4>
 <p>
 If <i><code>data</code></i> is <code>null</code>, a data store of the specified size is still created, 
 but its contents remain uninitialized and thus undefined.
 <p>
 Clients must align data elements consistent with the requirements of the client platform, 
 with an additional base-level requirement that an offset within a buffer to a datum 
 comprising N be a multiple of N.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not 
  <code>GL_ARRAY_BUFFER</code> or <code>GL_ELEMENT_ARRAY_BUFFER</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>usage</code></i> is not 
  <code>GL_STREAM_DRAW</code>, <code>GL_STATIC_DRAW</code>, or <code>GL_DYNAMIC_DRAW</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>size</code></i> is negative.
 <p><code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object 
  name 0 is bound to <i><code>target</code></i>.
 <p><code>GL_OUT_OF_MEMORY</code> is generated if the GL is unable to create a data store 
  with the specified <i><code>size</code></i>.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBufferParameteriv(int, int, java.nio.IntBuffer)"><CODE>glGetBufferParameteriv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBufferParameteriv(int, int, int[], int)"><CODE>glGetBufferParameteriv</CODE></A>
  with argument <code>GL_BUFFER_SIZE</code> or <code>GL_BUFFER_USAGE</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target buffer object. The symbolic constant 
  must be <code>GL_ARRAY_BUFFER</code> or <code>GL_ELEMENT_ARRAY_BUFFER</code>.<DD><CODE>size</CODE> - Specifies the size in bytes of the buffer object's new data store.<DD><CODE>data</CODE> - Specifies the data that will be copied into the data store 
  for initialization, or <code>null</code> if no data is to be copied.<DD><CODE>usage</CODE> - Specifies the expected usage pattern of the data store. 
  The symbolic constant must be <code>GL_STREAM_DRAW</code>, 
  <code>GL_STATIC_DRAW</code>, or <code>GL_DYNAMIC_DRAW</code>.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>data</i>.remaining()</code> is less than
  <i><code>size</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>GL20.glBindBuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBufferSubData(int, int, int, java.nio.Buffer)"><CODE>GL20.glBufferSubData(int, int, int, Buffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glBufferSubData(int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glBufferSubData</H3>
<PRE>
void <B>glBufferSubData</B>(int&nbsp;target,
                     int&nbsp;offset,
                     int&nbsp;size,
                     <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</PRE>
<DL>
<DD>Update a subset of a buffer object's data store.
 <p>
 <h4>Description</h4>
 <code>glBufferSubData</code> redefines some or all of the data store for the buffer 
 object currently bound to <i><code>target</code></i>. Data starting at byte offset <i><code>offset</code></i> 
 and extending for <i><code>size</code></i> bytes is copied to the data store from the data buffer
 <i><code>data</code></i>. An error is thrown if <i><code>offset</code></i> and
 <i><code>size</code></i> together define 
 a range beyond the bounds of the buffer object's data store.
 <p>
 <h4>Notes</h4>
 <p>
 When replacing the entire data store, consider using <code>glBufferSubData</code> rather 
 than completely recreating the data store with <code>glBufferData</code>. This avoids the 
 cost of reallocating the data store.
 <p>
 Consider using multiple buffer objects to avoid stalling the rendering pipeline 
 during data store updates. If any rendering in the pipeline makes reference 
 to data in the buffer object being updated by <code>glBufferSubData</code>, especially 
 from the specific region being updated, that rendering must drain from the
 pipeline before the data store can be updated.
 <p>
 Clients must align data elements consistent with the requirements of the 
 client platform, with an additional base-level requirement that an offset 
 within a buffer to a datum comprising N be a multiple of N.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> if <i><code>target</code></i> is not <code>GL_ARRAY_BUFFER</code>
  or <code>GL_ELEMENT_ARRAY_BUFFER</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>offset</code></i> or
  <i><code>size</code></i> is negative, or if together 
  they define a region of memory that extends beyond the buffer object's allocated data store.
 <p><code>GL_INVALID_OPERATION</code> is generated if the reserved buffer object name 0 is 
  bound to <i><code>target</code></i>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target buffer object. The symbolic constant must be 
  <code>GL_ARRAY_BUFFER</code> or <code>GL_ELEMENT_ARRAY_BUFFER</code>.<DD><CODE>offset</CODE> - Specifies the offset into the buffer object's data store where 
  data replacement will begin, measured in bytes.<DD><CODE>size</CODE> - Specifies the size in bytes of the data store region being replaced.<DD><CODE>data</CODE> - Specifies the new data that will be copied into the data store.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>data</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>data</i>.remaining()</code> is less than <i><code>size</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>GL20.glBindBuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBufferData(int, int, java.nio.Buffer, int)"><CODE>GL20.glBufferData(int, int, Buffer, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glCheckFramebufferStatus(int)"><!-- --></A><H3>
glCheckFramebufferStatus</H3>
<PRE>
int <B>glCheckFramebufferStatus</B>(int&nbsp;target)</PRE>
<DL>
<DD>Return the framebuffer completeness status of a framebuffer object.
 <p>
 <code>glCheckFramebufferStatus</code> returns a symbolic constant that 
 identifies whether or not the currently bound framebuffer is framebuffer complete, 
 and if not, which of the rules of framebuffer completeness is violated.
 <p>
 If the framebuffer is complete, then <code>GL_FRAMEBUFFER_COMPLETE</code> is returned. 
 If the framebuffer is not complete, the return values are as follows:
 <p>
 <code>GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT</code>
 <p>
 Not all framebuffer attachment points are framebuffer attachment complete. 
 This means that at least one attachment point with a renderbuffer or texture 
 attached has its attached object no longer in existence or has an attached 
 image with a width or height of zero, or the color attachment point has a 
 non-color-renderable image attached, or the depth attachment point has a 
 non-depth-renderable image attached, or the stencil attachment point has a 
 non-stencil-renderable image attached.
 <p>
 Color-renderable formats include <code>GL_RGBA4</code>, <code>GL_RGB5_A1</code>, and <code>GL_RGB565</code>.
 <code>GL_DEPTH_COMPONENT16</code> is the only depth-renderable format. <code>GL_STENCIL_INDEX8</code>
 is the only stencil-renderable format.
 <p>
 <code>GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS</code>
 <p>
 Not all attached images have the same width and height.
 <p>
 <code>GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT</code>
 <p>
 No images are attached to the framebuffer.
 <p>
 <code>GL_FRAMEBUFFER_UNSUPPORTED</code>
 <p>
 The combination of internal formats of the attached images violates 
 an implementation-dependent set of restrictions.
 <p>
 If the currently bound framebuffer is not framebuffer complete, 
 then it is an error to attempt to use the framebuffer for writing or reading. 
 This means that rendering commands (<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawArrays(int, int, int)"><CODE>glDrawArrays</CODE></A>
 and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>glDrawElements</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)"><CODE>glDrawElements</CODE></A>) as well as 
 commands that read the framebuffer (<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReadPixels(int, int, int, int, int, int, java.nio.Buffer)"><CODE>glReadPixels</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)"><CODE>glCopyTexImage2D</CODE></A>, and 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexSubImage2D(int, int, int, int, int, int, int, int)"><CODE>glCopyTexSubImage2D</CODE></A>) 
 will generate the error <code>GL_INVALID_FRAMEBUFFER_OPERATION</code> if called while the framebuffer 
 is not framebuffer complete.
 <p>
 <h4>Notes</h4>
 <p>
 It is strongly advised, thought not required, that an application call 
 <code>glCheckFramebufferStatus</code> to see if the framebuffer is complete prior to rendering. 
 This is because some implementations may not support rendering to particular combinations of 
 internal formats. In this case, <code>GL_FRAMEBUFFER_UNSUPPORTED</code> is returned.
 <p>
 The default window-system-provided framebuffer is always framebuffer complete, 
 and thus <code>GL_FRAMEBUFFER_COMPLETE</code> is returned when <code>GL_FRAMEBUFFER_BINDING</code> is 0.
 <p>
 If an error is generated, no change is made to the contents of <i><code>params</code></i>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not <code>GL_FRAMEBUFFER</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target framebuffer object. 
  The symbolic constant must be <code>GL_FRAMEBUFFER</code>.
<DT><B>Returns:</B><DD>The framebuffer completeness status of a framebuffer object.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindRenderbuffer(int, int)"><CODE>GL20.glBindRenderbuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexSubImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexSubImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawArrays(int, int, int)"><CODE>GL20.glDrawArrays(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>GL20.glDrawElements(int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)"><CODE>GL20.glDrawElements(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReadPixels(int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glReadPixels(int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glRenderbufferStorage(int, int, int, int)"><CODE>GL20.glRenderbufferStorage(int, int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glClear(int)"><!-- --></A><H3>
glClear</H3>
<PRE>
void <B>glClear</B>(int&nbsp;mask)</PRE>
<DL>
<DD>Clear buffers to preset values.
 <p>
 <h4>Description</h4>
 <code>glClear</code> sets the bitplane area of the window to values 
 previously selected by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClearColor(float, float, float, float)"><CODE>glClearColor</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClearDepthf(float)"><CODE>glClearDepthf</CODE></A>, and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClearStencil(int)"><CODE>glClearStencil</CODE></A>.
 <p>
 The pixel ownership test, the scissor test, dithering, and the buffer writemasks affect 
 the operation of <code>glClear</code>. The scissor box bounds the cleared region. Blend function, 
 stenciling, fragment shading, and depth-buffering are ignored by <code>glClear</code>.
 <p>
 <code>glClear</code> takes a single argument that is the bitwise OR of 
 several values indicating which buffer is to be cleared.
 <p>
 The values are as follows:
 <p>
 <code>GL_COLOR_BUFFER_BIT</code>
 <p>
 Indicates the buffers currently enabled for color writing.
 <p>
 <code>GL_DEPTH_BUFFER_BIT</code>
 <p>
 Indicates the depth buffer.
 <p>
 <code>GL_STENCIL_BUFFER_BIT</code>
 <p>
 Indicates the stencil buffer.
 <p>
 The value to which each buffer is cleared depends on the setting 
 of the clear value for that buffer.
 <p>
 <h4>Notes</h4>
 <p>
 If a buffer is not present, then a <code>glClear</code> directed at that buffer has no effect.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if any bit other than the 
  three defined bits is set in <i><code>mask</code></i>.
 <p>
 <h4>Associated Gets</h4>
 <p>
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_DEPTH_CLEAR_VALUE</code>
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_COLOR_CLEAR_VALUE</code>
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_STENCIL_CLEAR_VALUE</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mask</CODE> - Bitwise OR of masks that indicate the buffers to be cleared. 
  The three masks are <code>GL_COLOR_BUFFER_BIT</code>, <code>GL_DEPTH_BUFFER_BIT</code>,
  and <code>GL_STENCIL_BUFFER_BIT</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClearColor(float, float, float, float)"><CODE>GL20.glClearColor(float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClearDepthf(float)"><CODE>GL20.glClearDepthf(float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClearStencil(int)"><CODE>GL20.glClearStencil(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glColorMask(boolean, boolean, boolean, boolean)"><CODE>GL20.glColorMask(boolean, boolean, boolean, boolean)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthMask(boolean)"><CODE>GL20.glDepthMask(boolean)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glScissor(int, int, int, int)"><CODE>GL20.glScissor(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMask(int)"><CODE>GL20.glStencilMask(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glClearColor(float, float, float, float)"><!-- --></A><H3>
glClearColor</H3>
<PRE>
void <B>glClearColor</B>(float&nbsp;red,
                  float&nbsp;green,
                  float&nbsp;blue,
                  float&nbsp;alpha)</PRE>
<DL>
<DD>Specify clear values for the color buffers.
 <p>
 <h4>Description</h4>
 <code>glClearColor</code> specifies the red, green, blue, and 
 alpha values used by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClear(int)"><CODE>glClear</CODE></A> to clear the color buffers. 
 Values specified by <code>glClearColor</code> are clamped to the range <code>[0, 1]</code>.
 <p>
 <h4>Associated Gets</h4>
 <p>
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_COLOR_CLEAR_VALUE</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>red</CODE> - Specifies the red value used when the color buffers are cleared. 
  The initial value is 0.<DD><CODE>green</CODE> - Specifies the green value used when the color buffers are cleared. 
  The initial value is 0.<DD><CODE>blue</CODE> - Specifies the blue value used when the color buffers are cleared. 
  The initial value is 0.<DD><CODE>alpha</CODE> - Specifies the alpha value used when the color buffers are cleared. 
  The initial value is 0.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClear(int)"><CODE>GL20.glClear(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glClearDepthf(float)"><!-- --></A><H3>
glClearDepthf</H3>
<PRE>
void <B>glClearDepthf</B>(float&nbsp;depth)</PRE>
<DL>
<DD>Specify the clear value for the depth buffer.
 <p>
 <h4>Description</h4>
 <code>glClearDepthf</code> specifies the depth value used by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClear(int)"><CODE>glClear</CODE></A> 
 to clear the depth buffer. Values specified by <code>glClearDepthf</code> are 
 clamped to the range <code>[0, 1]</code>.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_DEPTH_CLEAR_VALUE</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>depth</CODE> - Specifies the depth value used when the depth buffer is cleared. 
  The initial value is 1.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClear(int)"><CODE>GL20.glClear(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glClearStencil(int)"><!-- --></A><H3>
glClearStencil</H3>
<PRE>
void <B>glClearStencil</B>(int&nbsp;s)</PRE>
<DL>
<DD>Specify the clear value for the stencil buffer.
 <p>
 <h4>Description</h4>
 <code>glClearStencil</code> specifies the index used by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClear(int)"><CODE>glClear</CODE></A> 
 to clear the stencil buffer. <i><code>s</code></i> is masked with <code>2^m - 1</code>, 
 where <code>m</code> is the number of bits in the stencil buffer.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_STENCIL_CLEAR_VALUE</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_STENCIL_BITS</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>s</CODE> - Specifies the index used when the stencil buffer is cleared. 
  The initial value is 0.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClear(int)"><CODE>GL20.glClear(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>GL20.glStencilFunc(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>GL20.glStencilFuncSeparate(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMask(int)"><CODE>GL20.glStencilMask(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMaskSeparate(int, int)"><CODE>GL20.glStencilMaskSeparate(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>GL20.glStencilOp(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>GL20.glStencilOpSeparate(int, int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glColorMask(boolean, boolean, boolean, boolean)"><!-- --></A><H3>
glColorMask</H3>
<PRE>
void <B>glColorMask</B>(boolean&nbsp;red,
                 boolean&nbsp;green,
                 boolean&nbsp;blue,
                 boolean&nbsp;alpha)</PRE>
<DL>
<DD>Enable and disable writing of frame buffer color components.
 <p>
 <h4>Description</h4>
 <code>glColorMask</code> specifies whether the individual color 
 components in the frame buffer can or cannot be written. 
 If <i><code>red</code></i> is <code>GL_FALSE</code>, for example, no change is made to the red component 
 of any pixel in any of the color buffers, regardless of the drawing 
 operation attempted.
 <p>
 Changes to individual bits of components cannot be controlled. 
 Rather, changes are either enabled or disabled for entire color components.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_COLOR_WRITEMASK</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>red</CODE> - Specifies whether red can or cannot be written into the frame buffer. 
  The initial value is <code>GL_TRUE</code>, indicating that the color component can be written.<DD><CODE>green</CODE> - Specifies whether green can or cannot be written into the frame buffer. 
  The initial value is <code>GL_TRUE</code>, indicating that the color component can be written.<DD><CODE>blue</CODE> - Specifies whether blue can or cannot be written into the frame buffer. 
  The initial value is <code>GL_TRUE</code>, indicating that the color component can be written.<DD><CODE>alpha</CODE> - Specifies whether alpha can or cannot be written into the frame buffer. 
  The initial value is <code>GL_TRUE</code>, indicating that the color component can be written.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClear(int)"><CODE>GL20.glClear(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthMask(boolean)"><CODE>GL20.glDepthMask(boolean)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMask(int)"><CODE>GL20.glStencilMask(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glCompileShader(int)"><!-- --></A><H3>
glCompileShader</H3>
<PRE>
void <B>glCompileShader</B>(int&nbsp;shader)</PRE>
<DL>
<DD>Compile a shader object.
 <p>
 <h4>Description</h4>
 For implementations that support a shader compiler, <code>glCompileShader</code> 
 compiles the source code strings that have been stored in the shader 
 object specified by <i><code>shader</code></i>.
 <p>
 The compilation status will be stored as part of the shader object's state.
 This value will be set to <code>GL_TRUE</code> if the shader was compiled without errors 
 and is ready for use, and <code>GL_FALSE</code> otherwise. It can be queried by calling 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>glGetShaderiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A>
 with arguments <i><code>shader</code></i> and <code>GL_COMPILE_STATUS</code>.
 <p>
 Compilation of a shader can fail for a number of reasons as 
 specified by the <i>OpenGL ES Shading Language Specification</i>. 
 Whether or not the compilation was successful, information 
 about the compilation can be obtained from the shader object's 
 information log by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderInfoLog(int)"><CODE>glGetShaderInfoLog</CODE></A>.
 <p>
 <h4>Notes</h4>
 <p>
 Shader compiler support is optional, and thus must be queried before 
 use by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A> with argument <code>GL_SHADER_COMPILER</code>.
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>glShaderSource</CODE></A>, <code>glCompileShader</code>,
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderPrecisionFormat(int, int, int[], int, int[], int)"><CODE>glGetShaderPrecisionFormat</CODE></A>,
 and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReleaseShaderCompiler()"><CODE>glReleaseShaderCompiler</CODE></A>
 will each generate <code>GL_INVALID_OPERATION</code> on implementations that do not 
 support a shader compiler. Such implementations instead offer the 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, java.nio.IntBuffer, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A>
 alternative for supplying a pre-compiled shader binary.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_OPERATION</code> is generated if a shader compiler is not supported.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>shader</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>shader</code></i> is not a shader object.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_SHADER_COMPILER</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderInfoLog(int)"><CODE>glGetShaderInfoLog</CODE></A>
  with argument <i><code>shader</code></i>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>glGetShaderiv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A>
  with arguments <i><code>shader</code></i> and <code>GL_COMPILE_STATUS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsShader(int)"><CODE>glIsShader</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shader</CODE> - Specifies the shader object to be compiled.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateShader(int)"><CODE>GL20.glCreateShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReleaseShaderCompiler()"><CODE>GL20.glReleaseShaderCompiler()</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>GL20.glShaderSource(int, int, String[], int[])</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderPrecisionFormat(int, int, int[], int, int[], int)"><CODE>GL20.glGetShaderPrecisionFormat(int, int, int[], int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glCompressedTexImage2D(int, int, int, int, int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glCompressedTexImage2D</H3>
<PRE>
void <B>glCompressedTexImage2D</B>(int&nbsp;target,
                            int&nbsp;level,
                            int&nbsp;internalformat,
                            int&nbsp;width,
                            int&nbsp;height,
                            int&nbsp;border,
                            int&nbsp;imageSize,
                            <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</PRE>
<DL>
<DD>Specify a two-dimensional texture image in a compressed format.
 <p>
 <h4>Description</h4>
 Texturing maps a portion of a specified texture image onto each graphical 
 primitive for which texturing is active. Texturing is active when the current 
 fragment shader or vertex shader makes use of built-in texture lookup functions.
 <p>
 <code>glCompressedTexImage2D</code> defines a two-dimensional texture image or 
 cube-map texture image using compressed image data from client memory. 
 The texture image is decoded according to the extension specification 
 defining the specified <i><code>internalformat</code></i>. OpenGL ES defines no specific 
 compressed texture formats, but does provide a mechanism to obtain 
 symbolic constants for such formats provided by extensions. The number of 
 compressed texture formats supported can be obtained by querying the value 
 of <code>GL_NUM_COMPRESSED_TEXTURE_FORMATS</code>. The list of specific compressed 
 texture formats supported can be obtained by querying the value of 
 <code>GL_COMPRESSED_TEXTURE_FORMATS</code>.
 <p>
 <h4>Notes</h4>
 <p>
 A GL implementation may choose to store the texture array at any internal resolution it chooses.
 <p>
 <code>glCompressedTexImage2D</code> specifies a two-dimensional or cube-map texture for the current 
 texture unit, specified with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>glActiveTexture</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not 
  <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>internalformat</code></i> is not a supported format 
  returned in <code>GL_COMPRESSED_TEXTURE_FORMATS</code>.
 <p><code>GL_INVALID_VALUE </code> is generated if <i><code>level</code></i> is less than 0.
 <p><code>GL_INVALID_VALUE </code> may be generated if <i><code>level</code></i> is greater than <code>log_2(max)</code>, 
  where <code>max</code> is the returned value of <code>GL_MAX_TEXTURE_SIZE</code> when <i><code>target</code></i> is 
  <code>GL_TEXTURE_2D</code> or <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code> when <i><code>target</code></i>
  is not <code>GL_TEXTURE_2D</code>.
 <p><code>GL_INVALID_VALUE </code> is generated if <i><code>width</code></i> or <i><code>height</code></i>
  is less than 0 or greater than <code>GL_MAX_TEXTURE_SIZE</code> when <i><code>target</code></i> is
  <code>GL_TEXTURE_2D</code> or <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code> when <i><code>target</code></i>
  is not <code>GL_TEXTURE_2D</code>.
 <p><code>GL_INVALID_VALUE </code> is generated if <i><code>border</code></i> is not 0.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>imageSize</code></i> is not consistent with the 
  format, dimensions, and contents of the specified compressed image data.
 <p><code>GL_INVALID_OPERATION</code> is generated if parameter combinations are not supported 
  by the specific compressed internal format as specified in the specific texture compression 
  extension.
  <p>
  Undefined results, including abnormal program termination, 
  are generated if <i><code>data</code></i> is not encoded in a manner consistent 
  with the extension specification defining the internal compression format.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with arguments <code>GL_NUM_COMPRESSED_TEXTURE_FORMATS</code> and <code>GL_COMPRESSED_TEXTURE_FORMATS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_MAX_TEXTURE_SIZE</code> or <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture of the active texture unit. Must be 
  <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.<DD><CODE>level</CODE> - Specifies the level-of-detail number. Level 0 is the base image level. 
  Level <i>n</i> is the <i>n</i>th mipmap reduction image.<DD><CODE>internalformat</CODE> - Specifies the format of the compressed image data stored at address <i><code>data</code></i>.<DD><CODE>width</CODE> - Specifies the width of the texture image. All implementations 
  support 2D texture images that are at least 64 texels wide and cube-mapped texture 
  images that are at least 16 texels wide.<DD><CODE>height</CODE> - Specifies the height of the texture image. All implementations 
  support 2D texture images that are at least 64 texels high and cube-mapped texture 
  images that are at least 16 texels high.<DD><CODE>border</CODE> - Specifies the width of the border. Must be 0.<DD><CODE>imageSize</CODE> - Specifies the number of unsigned bytes of image data starting at the address
  specified by <i><code>data</code></i>.<DD><CODE>data</CODE> - Specifies the compressed image data as a buffer.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>data</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>data</i>.remaining()</code> is less than
  <i><code>imageSize</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>GL20.glActiveTexture(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glCompressedTexSubImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexSubImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexSubImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexSubImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glCompressedTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glCompressedTexSubImage2D</H3>
<PRE>
void <B>glCompressedTexSubImage2D</B>(int&nbsp;target,
                               int&nbsp;level,
                               int&nbsp;xoffset,
                               int&nbsp;yoffset,
                               int&nbsp;width,
                               int&nbsp;height,
                               int&nbsp;format,
                               int&nbsp;imageSize,
                               <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</PRE>
<DL>
<DD>Specify a two-dimensional texture subimage in a compressed format.
 <p>
 <h4>Description</h4>
 Texturing maps a portion of a specified texture image onto each graphical 
 primitive for which texturing is active. Texturing is active when the current 
 fragment shader or vertex shader makes use of built-in texture lookup functions.
 <p>
 <code>glCompressedTexSubImage2D</code> redefines a contiguous subregion of an existing 
 two-dimensional texture image. The texels referenced by <i><code>data</code></i> replace the portion 
 of the existing texture array with x indices <i><code>xoffset</code></i> and <code><i>xoffset</i>
 + <i>width</i> - 1</code>, and the y indices <i><code>yoffset</code></i> and <code><i>yoffset</i>
 + <i>height</i> - 1</code>, inclusive. This region may not 
 include any texels outside the range of the texture array as it was originally specified. 
 It is not an error to specify a subtexture with width of 0, but such a specification 
 has no effect.
 <p>
 <i><code>format</code></i> must be the same extension-specified compressed-texture format 
 previously specified by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexImage2D(int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glCompressedTexImage2D</CODE></A>.
 <p>
 <h4>Notes</h4>
 <p>
 <code>glCompressedTexSubImage2D</code> specifies a two-dimensional or cube-map texture 
 for the current texture unit, specified with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>glActiveTexture</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not 
  <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>, 
  <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>, 
  <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or 
  <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>format</code></i> is not a 
  supported format returned in <code>GL_COMPRESSED_TEXTURE_FORMATS</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>level</code></i> is less than 0.
 <p><code>GL_INVALID_VALUE</code> may be generated if <i><code>level</code></i> is 
  greater than <code>log_2(max)</code>, 
  where <code>max</code> is the returned value of <code>GL_MAX_TEXTURE_SIZE</code> when 
  <i><code>target</code></i> is <code>GL_TEXTURE_2D</code> or
  <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code> when <i><code>target</code></i> is not <code>GL_TEXTURE_2D</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if 
  <code><i>xoffset</i> < 0</code>, <code><i>xoffset</i> + <i>width</i> > w</code>, 
  <code><i>yoffset</i> < 0</code>, or <code><i>yoffset</i> + <i>height</i> > h</code>, 
  where <code>w</code> is the width and <code>h</code> is the height of the texture image being modified.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>width</code></i> or <i><code>height</code></i> is less than 0.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>imageSize</code></i> is not consistent with the 
  format, dimensions, and contents of the specified compressed image data.
 <p><code>GL_INVALID_OPERATION</code> is generated if the texture array has not been 
  defined by a previous <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexImage2D(int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glCompressedTexImage2D</CODE></A>
  operation whose <i><code>internalformat</code></i> matches
  the <i><code>format</code></i> of <code>glCompressedTexSubImage2D</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if parameter combinations are not 
  supported by the specific compressed internal format as specified in the specific 
  texture compression extension.
  <p>
  Undefined results, including abnormal program termination, are generated if <i><code>data</code></i> is 
  not encoded in a manner consistent with the extension specification defining the 
  internal compression format.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with arguments <code>GL_NUM_COMPRESSED_TEXTURE_FORMATS</code> and <code>GL_COMPRESSED_TEXTURE_FORMATS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_MAX_TEXTURE_SIZE</code> or <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture of the active texture unit. Must be 
  <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>,
  <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.<DD><CODE>level</CODE> - Specifies the level-of-detail number. Level 0 is the base image level. 
  Level <i>n</i> is the <code>n</code>th mipmap reduction image.<DD><CODE>xoffset</CODE> - Specifies a texel offset in the x direction within the texture array.<DD><CODE>yoffset</CODE> - Specifies a texel offset in the y direction within the texture array.<DD><CODE>width</CODE> - Specifies the width of the texture subimage.<DD><CODE>height</CODE> - Specifies the height of the texture subimage.<DD><CODE>format</CODE> - Specifies the format of the compressed image data stored in the buffer <i><code>data</code></i>.<DD><CODE>imageSize</CODE> - Specifies the number of unsigned bytes of image data in the buffer <i><code>data</code></i>.<DD><CODE>data</CODE> - Specifies the compressed image data as a buffer.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>data</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>data</i>.remaining()</code> is less than
  <i><code>imageSize</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>GL20.glActiveTexture(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexImage2D(int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glCompressedTexImage2D(int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexSubImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexSubImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexSubImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glCopyTexImage2D(int, int, int, int, int, int, int, int)"><!-- --></A><H3>
glCopyTexImage2D</H3>
<PRE>
void <B>glCopyTexImage2D</B>(int&nbsp;target,
                      int&nbsp;level,
                      int&nbsp;internalformat,
                      int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;width,
                      int&nbsp;height,
                      int&nbsp;border)</PRE>
<DL>
<DD>Copy pixels into a 2D texture image.
 <p>
 <h4>Description</h4>
 Texturing maps a portion of a specified texture image onto each 
 graphical primitive for which texturing is active. Texturing is 
 active when the current fragment shader or vertex shader makes 
 use of built-in texture lookup functions.
 <p>
 <code>glCopyTexImage2D</code> defines a two-dimensional texture image or 
 cube-map texture image with pixels from the current framebuffer 
 (rather than from client memory, as is the case for 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glTexImage2D</CODE></A>).
 <p>
 The screen-aligned pixel rectangle with lower left corner at (<i><code>x, y</code></i>) 
 and with a width of <i><code>width</code></i> and a height of <i><code>height</code></i> defines the texture 
 array at the mipmap level specified by <i><code>level</code></i>. <i><code>internalformat</code></i> specifies 
 the internal format of the texture array.
 <p>
 The pixels in the rectangle are processed exactly as 
 if <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReadPixels(int, int, int, int, int, int, java.nio.Buffer)"><CODE>glReadPixels</CODE></A>
 had been called with <i><code>format</code></i> set to <code>GL_RGBA</code>, 
 but the process stops just after conversion of RGBA values. 
 Subsequent processing is identical to that described for 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glTexImage2D</CODE></A>, 
 beginning with the clamping of the R, G, B, and A values to the range <code>[0, 1]</code>
 and then conversion to the texture's internal format for storage in the 
 texel array.
 <p>
 The components required for <i><code>internalformat</code></i> must be a subset of those 
 present in the framebuffer's format. For example, a <code>GL_RGBA</code> framebuffer 
 can be used to supply components for any <i><code>internalformat</code></i>. However, 
 a <code>GL_RGB</code> framebuffer can only be used to supply components for 
 <code>GL_RGB</code> or <code>GL_LUMINANCE</code> base internal format textures, not 
 <code>GL_ALPHA</code>, <code>GL_LUMINANCE_ALPHA</code>, or <code>GL_RGBA</code> textures.
 <p>
 Pixel ordering is such that lower x and y screen coordinates 
 correspond to lower s and t texture coordinates.
 <p>
 If any of the pixels within the specified rectangle are 
 outside the framebuffer associated with the current 
 rendering context, then the values obtained for those 
 pixels are undefined.
 <p>
 <h4>Notes</h4>
 <p>
 A GL implementation may choose to store the texture array at any internal resolution it chooses.
 <p>
 An image with height or width of 0 indicates a <code>null</code> texture.
 <p>
 <code>glCopyTexImage2D</code> specifies a two-dimensional or cube-map texture for 
 the current texture unit, specified with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>glActiveTexture</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not 
  <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>internalformat</code></i> is not an accepted format.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>target</code></i> is one of the six cube map 2D 
  image targets and the width and height parameters are not equal.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>level</code></i> is less than 0.
 <p><code>GL_INVALID_VALUE</code> may be generated if <i><code>level</code></i> is greater than <code>log_2(max)</code>, 
  where <code>max</code> is the returned value of <code>GL_MAX_TEXTURE_SIZE</code> when <i><code>target</code></i> is 
  <code>GL_TEXTURE_2D</code> or <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code> when <i><code>target</code></i>
  is not <code>GL_TEXTURE_2D</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>width</code></i> or <i><code>height</code></i>
  is less than 0 or greater than 
  <code>GL_MAX_TEXTURE_SIZE</code> when <i><code>target</code></i> is <code>GL_TEXTURE_2D</code>
  or <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code> when 
  <i><code>target</code></i> is not <code>GL_TEXTURE_2D</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>border</code></i> is not 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if the currently bound framebuffer's format 
  does not contain a superset of the components required by the base format of <i><code>internalformat</code></i>.
 <p><code>GL_INVALID_FRAMEBUFFER_OPERATION</code> is generated if the currently bound framebuffer 
  is not framebuffer complete (i.e. the return value from <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)"><CODE>glCheckFramebufferStatus</CODE></A> 
  is not <code>GL_FRAMEBUFFER_COMPLETE</code>).
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_MAX_TEXTURE_SIZE</code> or <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture. Must be 
  <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.<DD><CODE>level</CODE> - Specifies the level-of-detail number. Level 0 is the base image level. 
  Level <i>n</i> is the <i>n</i>th mipmap reduction image.<DD><CODE>internalformat</CODE> - Specifies the internal format of the texture. 
  Must be one of the following symbolic constants: 
  <code>GL_ALPHA</code>, <code>GL_LUMINANCE</code>, <code>GL_LUMINANCE_ALPHA</code>, <code>GL_RGB</code>, or <code>GL_RGBA</code>.<DD><CODE>x</CODE> - Specifies the x window coordinate of the lower left corner 
  of the rectangular region of pixels to be copied.<DD><CODE>y</CODE> - Specifies the y window coordinate of the lower left corner 
  of the rectangular region of pixels to be copied.<DD><CODE>width</CODE> - Specifies the width of the texture image. 
  All implementations support 2D texture images that are at 
  least 64 texels wide and cube-mapped texture images that 
  are at least 16 texels wide.<DD><CODE>height</CODE> - Specifies the height of the texture image. 
  All implementations support 2D texture images that are at 
  least 64 texels high and cube-mapped texture images that 
  are at least 16 texels high.<DD><CODE>border</CODE> - Specifies the width of the border. Must be 0.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>GL20.glActiveTexture(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)"><CODE>GL20.glCheckFramebufferStatus(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexImage2D(int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glCompressedTexImage2D(int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glCompressedTexSubImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexSubImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexSubImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexSubImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glCopyTexSubImage2D(int, int, int, int, int, int, int, int)"><!-- --></A><H3>
glCopyTexSubImage2D</H3>
<PRE>
void <B>glCopyTexSubImage2D</B>(int&nbsp;target,
                         int&nbsp;level,
                         int&nbsp;xoffset,
                         int&nbsp;yoffset,
                         int&nbsp;x,
                         int&nbsp;y,
                         int&nbsp;width,
                         int&nbsp;height)</PRE>
<DL>
<DD>Copy a two-dimensional texture subimage.
 <p>
 <h4>Description</h4>
 Texturing maps a portion of a specified texture image onto each 
 graphical primitive for which texturing is active. Texturing 
 is active when the current fragment shader or vertex shader 
 makes use of built-in texture lookup functions.
 <p>
 <code>glCopyTexSubImage2D</code> replaces a rectangular portion of a 
 two-dimensional texture image or cube-map texture image 
 with pixels from the current framebuffer (rather than from 
 client memory, as is the case for 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glTexSubImage2D</CODE></A>).
 <p>
 The screen-aligned pixel rectangle with lower left corner 
 at (<i><code>x, y</code></i>) and with width <i><code>width</code></i> and height <i><code>height</code></i> replaces the 
 portion of the texture array with x indices <i><code>xoffset</code></i> 
 through <code><i>xoffset</i> + <i>width</i> - 1</code>, inclusive, and y indices <i><code>yoffset</code></i> 
 through <code><i>yoffset</i> + <i>height</i> - 1</code>, inclusive, at the mipmap level 
 specified by <i><code>level</code></i>.
 <p>
 The pixels in the rectangle are processed exactly as 
 if <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReadPixels(int, int, int, int, int, int, java.nio.Buffer)"><CODE>glReadPixels</CODE></A>
 had been called with format set to <code>GL_RGBA</code>, 
 but the process stops just after conversion of RGBA values. 
 Subsequent processing is identical to that described 
 for <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glTexSubImage2D</CODE></A>,
 beginning with the clamping of the R, G, B, and A values to the range <code>[0, 1]</code>and then conversion 
 to the texture's internal format for storage in the texel array.
 <p>
 The destination rectangle in the texture array may not include 
 any texels outside the texture array as it was originally specified. 
 It is not an error to specify a subtexture with zero width or height, 
 but such a specification has no effect.
 <p>
 If any of the pixels within the specified rectangle are outside 
 the framebuffer associated with the current rendering context, 
 then the values obtained for those pixels are undefined.
 <p>
 No change is made to the <i>internalformat</i>, <i>width</i>, or <i>height</i> parameters 
 of the specified texture array or to texel values outside the 
 specified subregion.
 <p>
 <h4>Notes</h4>
 <p>
 <code>glCopyTexSubImage2D</code> specifies the two-dimensional or cube-map 
 texture for the current texture unit, specified with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>glActiveTexture</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not 
  <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>level</code></i> is less than 0.
 <p><code>GL_INVALID_VALUE</code> may be generated if <code><i>level</i> > log_2(max)</code> , 
  where <code>max</code> is the returned value of <code>GL_MAX_TEXTURE_SIZE</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if 
  <code><i>xoffset</i> < 0</code>, <code><i>xoffset</i> + <i>width</i> > w</code>, <code><i>yoffset</i> < 0</code>, 
  or <code><i>yoffset</i> + <i>height</i> > h</code>, where <code>w</code> is the width and <code>h</code> 
  is the height of the texture image being modified.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>width</code></i> or <i><code>height</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if the texture array has not been 
  defined by a previous <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glTexImage2D</CODE></A>
  or <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)"><CODE>glCopyTexImage2D</CODE></A> operation.
 <p><code>GL_INVALID_OPERATION</code> is generated if the currently bound 
  framebuffer's format does not contain a superset of the components 
  required by the texture's base internal format.
 <p><code>GL_INVALID_FRAMEBUFFER_OPERATION</code> is generated if the currently bound 
  framebuffer is not framebuffer complete (i.e. the return value from 
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)"><CODE>glCheckFramebufferStatus</CODE></A> is not <code>GL_FRAMEBUFFER_COMPLETE</code>).
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_MAX_TEXTURE_SIZE</code> or <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture. Must be 
  <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>, 
  <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>, 
  <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or 
  <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.<DD><CODE>level</CODE> - Specifies the level-of-detail number. 
  Level 0 is the base image level. Level <i>n</i> is the <i>n</i>th mipmap reduction image.<DD><CODE>xoffset</CODE> - Specifies a texel offset in the x direction within the texture array.<DD><CODE>yoffset</CODE> - Specifies a texel offset in the y direction within the texture array.<DD><CODE>x</CODE> - Specifies the x window coordinate of the lower left corner of the rectangular region of pixels to be copied.<DD><CODE>y</CODE> - Specifies the y window coordinate of the lower left corner of the rectangular region of pixels to be copied.<DD><CODE>width</CODE> - Specifies the width of the texture subimage.<DD><CODE>height</CODE> - Specifies the height of the texture subimage.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>GL20.glActiveTexture(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)"><CODE>GL20.glCheckFramebufferStatus(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexSubImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glCreateProgram()"><!-- --></A><H3>
glCreateProgram</H3>
<PRE>
int <B>glCreateProgram</B>()</PRE>
<DL>
<DD>Create a program object.
 <p>
 <h4>Description</h4>
 <code>glCreateProgram</code> creates an empty program object and returns a 
 non-zero value by which it can be referenced. A program object is an object 
 to which shader objects can be attached. This provides a mechanism to specify 
 the shader objects that will be linked to create a program. 
 It also provides a means for checking the compatibility of the shaders 
 that will be used to create a program (for instance, checking the compatibility 
 between a vertex shader and a fragment shader). When no longer needed as 
 part of a program object, shader objects can be detached.
 <p>
 One or more executables are created in a program object by successfully 
 attaching shader objects to it with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glAttachShader(int, int)"><CODE>glAttachShader</CODE></A>, successfully compiling 
 the shader objects with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>glCompileShader</CODE></A>, and successfully linking the program 
 object with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>glLinkProgram</CODE></A>. These executables are made part of current state 
 when <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>glUseProgram</CODE></A> is called. Program objects can be deleted by 
 calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteProgram(int)"><CODE>glDeleteProgram</CODE></A>. The memory associated with the program object 
 will be deleted when it is no longer part of current rendering state for any context.
 <p>
 <h4>Notes</h4>
 <p>
 Like texture objects, the name space for program objects may be 
 shared across a set of contexts, as long as the server sides of 
 the contexts share the same address space. If the name space is 
 shared across contexts, any attached objects and the data associated 
 with those attached objects are shared as well.
 <p>
 Applications are responsible for providing the synchronization 
 across API calls when objects are accessed from different 
 execution threads.
 <p>
 <h4>Errors</h4>
 <p>
 This function returns 0 if an error occurs creating the program object.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A> with 
  the argument <code>GL_CURRENT_PROGRAM</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveAttrib(int, int, int[], int, int[], int)"><CODE>glGetActiveAttrib</CODE></A> 
  with a valid program object and the index of an active attribute variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveUniform(int, int, int[], int, int[], int)"><CODE>glGetActiveUniform</CODE></A>
  with a valid program object and the index of an active uniform variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, java.nio.IntBuffer, java.nio.IntBuffer)"><CODE>glGetAttachedShaders</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, int[], int, int[], int)"><CODE>glGetAttachedShaders</CODE></A> with a valid program object
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttribLocation(int, java.lang.String)"><CODE>glGetAttribLocation</CODE></A>
  with a valid program object and the name of an attribute variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A>
   with a valid program object and the parameter to be queried
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramInfoLog(int)"><CODE>glGetProgramInfoLog</CODE></A> with a valid program object
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, java.nio.FloatBuffer)"><CODE>glGetUniform</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, float[], int)"><CODE>glGetUniform</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, java.nio.IntBuffer)"><CODE>glGetUniform</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>glGetUniform</CODE></A>
   with a valid program object and the location of a uniform variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformLocation(int, java.lang.String)"><CODE>glGetUniformLocation</CODE></A>
  with a valid program object and the name of a uniform variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>A non-zero value by which it can be referenced; zero if an error occurs.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glAttachShader(int, int)"><CODE>GL20.glAttachShader(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindAttribLocation(int, int, java.lang.String)"><CODE>GL20.glBindAttribLocation(int, int, String)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateShader(int)"><CODE>GL20.glCreateShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteProgram(int)"><CODE>GL20.glDeleteProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDetachShader(int, int)"><CODE>GL20.glDetachShader(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform1fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, float[], int)"><CODE>GL20.glUniform1fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1i(int, int)"><CODE>GL20.glUniform1i(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform1iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, int[], int)"><CODE>GL20.glUniform1iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2f(int, float, float)"><CODE>GL20.glUniform2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform2fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, float[], int)"><CODE>GL20.glUniform2fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2i(int, int, int)"><CODE>GL20.glUniform2i(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform2iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, int[], int)"><CODE>GL20.glUniform2iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3f(int, float, float, float)"><CODE>GL20.glUniform3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform3fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, float[], int)"><CODE>GL20.glUniform3fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3i(int, int, int, int)"><CODE>GL20.glUniform3i(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform3iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, int[], int)"><CODE>GL20.glUniform3iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4f(int, float, float, float, float)"><CODE>GL20.glUniform4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform4fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, float[], int)"><CODE>GL20.glUniform4fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4i(int, int, int, int, int)"><CODE>GL20.glUniform4i(int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform4iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, int[], int)"><CODE>GL20.glUniform4iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix2fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix2fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix3fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix3fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix4fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix4fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>GL20.glUseProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glValidateProgram(int)"><CODE>GL20.glValidateProgram(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glCreateShader(int)"><!-- --></A><H3>
glCreateShader</H3>
<PRE>
int <B>glCreateShader</B>(int&nbsp;type)</PRE>
<DL>
<DD>Create a shader object.
 <p>
 <code>glCreateShader</code> creates an empty shader object and returns a non-zero 
 value by which it can be referenced. A shader object is used to maintain the source 
 code strings that define a shader. <i><code>shaderType</code></i> indicates the type of shader to be created. 
 Two types of shaders are supported. A shader of type <code>GL_VERTEX_SHADER</code> is a shader that is 
 intended to run on the programmable vertex processor. A shader of type <code>GL_FRAGMENT_SHADER</code> 
 is a shader that is intended to run on the programmable fragment processor.
 <p>
 When created, a shader object's <code>GL_SHADER_TYPE</code> parameter is set to either 
 <code>GL_VERTEX_SHADER</code> or <code>GL_FRAGMENT_SHADER</code>, depending on the value of
 <i><code>shaderType</code></i>.
 <p>
 <h4>Notes</h4>
 <p>
 Like texture objects, the name space for shader objects may be shared across a set of contexts, 
 as long as the server sides of the contexts share the same address space. If the name space 
 is shared across contexts, any attached objects and the data associated with those attached 
 objects are shared as well.
 <p>
 Applications are responsible for providing the synchronization across API 
 calls when objects are accessed from different execution threads.
 <p>
 <h4>Errors</h4>
 <p>This function returns 0 if an error occurs creating the shader object.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>shaderType</code></i> is not an accepted value. 
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>glGetShaderiv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A>
  with a valid shader object and the parameter to be queried
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderInfoLog(int)"><CODE>glGetShaderInfoLog</CODE></A> with a valid shader object
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderSource(int, int, int[], byte[])"><CODE>glGetShaderSource</CODE></A> with a valid shader object
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsShader(int)"><CODE>glIsShader</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - Specifies the type of shader to be created. Must be either <code>GL_VERTEX_SHADER</code>
  or <code>GL_FRAGMENT_SHADER</code>.
<DT><B>Returns:</B><DD>A non-zero value by which it can be referenced; zero if an error occurs.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glAttachShader(int, int)"><CODE>GL20.glAttachShader(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>GL20.glCompileShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteShader(int)"><CODE>GL20.glDeleteShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDetachShader(int, int)"><CODE>GL20.glDetachShader(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>GL20.glShaderSource(int, int, String[], int[])</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, java.nio.IntBuffer, int, java.nio.Buffer, int)"><CODE>GL20.glShaderBinary(int, IntBuffer, int, Buffer, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><CODE>GL20.glShaderBinary(int, int[], int, int, Buffer, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glCullFace(int)"><!-- --></A><H3>
glCullFace</H3>
<PRE>
void <B>glCullFace</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Specify whether front- or back-facing facets can be culled.
 <p>
 <h4>Description</h4>
 <code>glCullFace</code> specifies whether front- or back-facing facets are culled 
 (as specified by <i><code>mode</code></i>) when facet culling is enabled. Facet culling 
 is initially disabled. To enable and disable facet culling, call the 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>glEnable</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisable(int)"><CODE>glDisable</CODE></A>
 commands with the argument <code>GL_CULL_FACE</code>. 
 Facets include triangles, quadrilaterals, polygons, and rectangles.
 <p>
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFrontFace(int)"><CODE>glFrontFace</CODE></A> specifies which of the clockwise and counterclockwise 
 facets are front-facing and back-facing. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFrontFace(int)"><CODE>glFrontFace</CODE></A>.
 <p>
 <h4>Notes</h4>
 <p>
 If <i><code>mode</code></i> is <code>GL_FRONT_AND_BACK</code>, no facets are drawn, 
 but other primitives such as points and lines are drawn.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>mode</code></i> is not an accepted value.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A> with argument <code>GL_CULL_FACE</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_CULL_FACE_MODE</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - Specifies whether front- or back-facing facets are candidates for culling. 
  Symbolic constants <code>GL_FRONT</code>, <code>GL_BACK</code>, and <code>GL_FRONT_AND_BACK</code> are accepted. 
  The initial value is <code>GL_BACK</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>GL20.glEnable(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFrontFace(int)"><CODE>GL20.glFrontFace(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDeleteBuffers(int, int[], int)"><!-- --></A><H3>
glDeleteBuffers</H3>
<PRE>
void <B>glDeleteBuffers</B>(int&nbsp;n,
                     int[]&nbsp;buffers,
                     int&nbsp;offset)</PRE>
<DL>
<DD>Delete named buffer objects.
 <p>
 <h4>Description</h4>
 <code>glDeleteBuffers</code> deletes <i><code>n</code></i> buffer objects named by the 
 elements of the array <i><code>buffers</code></i>. After a buffer object is deleted, 
 it has no contents, and its name is free for reuse (for example by 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, java.nio.IntBuffer)"><CODE>glGenBuffers</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, int[], int)"><CODE>glGenBuffers</CODE></A>). 
 If a buffer object that is currently bound is deleted, the binding reverts to 0 
 (the absence of any buffer object, which reverts to client memory usage).
 <p>
 <code>glDeleteBuffers</code> silently ignores 0's and names that do not correspond 
 to existing buffer objects.
 <p>
 <h4>Errors</h4>
 <p>
 <code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> is negative.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsBuffer(int)"><CODE>glIsBuffer</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of buffer objects to be deleted.<DD><CODE>buffers</CODE> - Specifies an array of buffer objects to be deleted.<DD><CODE>offset</CODE> - The starting offset within the <i><code>buffers</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>buffers</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>buffers</i>.length - <i>offset</i></code> is less than
  <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>GL20.glBindBuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, int[], int)"><CODE>GL20.glDeleteBuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, java.nio.IntBuffer)"><CODE>GL20.glGenBuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, int[], int)"><CODE>GL20.glGenBuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsBuffer(int)"><CODE>GL20.glIsBuffer(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDeleteBuffers(int, java.nio.IntBuffer)"><!-- --></A><H3>
glDeleteBuffers</H3>
<PRE>
void <B>glDeleteBuffers</B>(int&nbsp;n,
                     <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;buffers)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, int[], int)"><CODE>glDeleteBuffers</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p>
 <code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> is negative.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of buffer objects to be deleted.<DD><CODE>buffers</CODE> - Specifies the buffer objects to be deleted.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>buffers</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>buffers</i>.remaining()</code> is less than <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteBuffers(int, IntBuffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDeleteFramebuffers(int, int[], int)"><!-- --></A><H3>
glDeleteFramebuffers</H3>
<PRE>
void <B>glDeleteFramebuffers</B>(int&nbsp;n,
                          int[]&nbsp;framebuffers,
                          int&nbsp;offset)</PRE>
<DL>
<DD>Delete named framebuffer objects.
 <p>
 <h4>Description</h4>
 <code>glDeleteFramebuffers</code> deletes <i><code>n</code></i> framebuffer objects named by the 
 elements of the array <i><code>framebuffers</code></i>. After a framebuffer object is deleted, 
 it has no attachments, and its name is free for reuse (for example by 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, java.nio.IntBuffer)"><CODE>glGenFramebuffers</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, int[], int)"><CODE>glGenFramebuffers</CODE></A>). 
 If a framebuffer object that is currently bound is deleted, the binding 
 reverts to 0 (the window-system-provided framebuffer).
 <p>
 <code>glDeleteFramebuffers</code> silently ignores 0's and names 
 that do not correspond to existing framebuffer objects.
 <p>
 <h4>Errors</h4>
 <p>
 <code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> is negative.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsFramebuffer(int)"><CODE>glIsFramebuffer</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of framebuffer objects to be deleted.<DD><CODE>framebuffers</CODE> - Specifies an array of framebuffer objects to be deleted.<DD><CODE>offset</CODE> - The starting offset within the <code>framebuffers</code> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>framebuffers</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>framebuffers</i>.length - <i>offset</i></code> is less than
  <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindFramebuffer(int, int)"><CODE>GL20.glBindFramebuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteFramebuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, java.nio.IntBuffer)"><CODE>GL20.glGenFramebuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, int[], int)"><CODE>GL20.glGenFramebuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsFramebuffer(int)"><CODE>GL20.glIsFramebuffer(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDeleteFramebuffers(int, java.nio.IntBuffer)"><!-- --></A><H3>
glDeleteFramebuffers</H3>
<PRE>
void <B>glDeleteFramebuffers</B>(int&nbsp;n,
                          <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;framebuffers)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, int[], int)"><CODE>glDeleteFramebuffers</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p>
 <code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> is negative.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of framebuffer objects to be deleted.<DD><CODE>framebuffers</CODE> - Specifies the framebuffer objects to be deleted.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>framebuffers</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>framebuffers</i>.remaining()</code> is less than
  <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, int[], int)"><CODE>GL20.glDeleteFramebuffers(int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDeleteProgram(int)"><!-- --></A><H3>
glDeleteProgram</H3>
<PRE>
void <B>glDeleteProgram</B>(int&nbsp;program)</PRE>
<DL>
<DD>Delete a program object.
 <p>
 <h4>Description</h4>
 <code>glDeleteProgram</code> frees the memory and invalidates the name 
 associated with the program object specified by <i><code>program</code></i>. This command 
 effectively undoes the effects of a call to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateProgram()"><CODE>glCreateProgram</CODE></A>.
 <p>
 If a program object is in use as part of current rendering state, 
 it will be flagged for deletion, but it will not be deleted until 
 it is no longer part of current state for any rendering context. 
 If a program object to be deleted has shader objects attached to it, 
 those shader objects will be automatically detached but not deleted 
 unless they have already been flagged for deletion by a previous 
 call to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteShader(int)"><CODE>glDeleteShader</CODE></A>. A value of 0 for 
 <i><code>program</code></i> will be silently ignored.
 <p>
 To determine whether a program object has been flagged for deletion, 
 call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A>
 with arguments <i><code>program</code></i> and <code>GL_DELETE_STATUS</code>.
 <p>
 <h4>Errors</h4>
 <p>
 <code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is not a value generated by OpenGL.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_CURRENT_PROGRAM</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A>
  with arguments <i><code>program</code></i> and <code>GL_DELETE_STATUS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to be deleted.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateShader(int)"><CODE>GL20.glCreateShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDetachShader(int, int)"><CODE>GL20.glDetachShader(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>GL20.glUseProgram(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDeleteRenderbuffers(int, int[], int)"><!-- --></A><H3>
glDeleteRenderbuffers</H3>
<PRE>
void <B>glDeleteRenderbuffers</B>(int&nbsp;n,
                           int[]&nbsp;renderbuffers,
                           int&nbsp;offset)</PRE>
<DL>
<DD>Delete named renderbuffer objects
 <p>
 <h4>Description</h4>
 <code>glDeleteRenderbuffers</code> deletes <i><code>n</code></i> renderbuffer objects 
 named by the elements of the array <i><code>renderbuffers</code></i>. After a renderbuffer 
 object is deleted, it has no contents, and its name is free for 
 reuse (for example by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, java.nio.IntBuffer)"><CODE>glGenRenderBuffers</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, int[], int)"><CODE>glGenRenderbuffers</CODE></A>).
 <p>
 If a renderbuffer object that is currently bound is deleted, 
 the binding reverts to 0 (the absence of any renderbuffer object). 
 Additionally, special care must be taken when deleting a renderbuffer 
 object if the image of the renderbuffer is attached to a framebuffer 
 object. In this case, if the deleted renderbuffer object is attached 
 to the currently bound framebuffer object, it is automatically detached. 
 However, attachments to any other framebuffer objects are the 
 responsibility of the application.
 <p>
 <code>glDeleteRenderbuffers</code> silently ignores 0's and names that do not 
 correspond to existing renderbuffer objects.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> is negative. 
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsRenderbuffer(int)"><CODE>glIsRenderbuffer</CODE></A> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of renderbuffer objects to be deleted.<DD><CODE>renderbuffers</CODE> - Specifies an array of renderbuffer objects to be deleted.<DD><CODE>offset</CODE> - The starting offset within the <i><code>renderbuffers</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>renderbuffers</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>renderbuffers</i>.length - <i>offset</i></code> is less than
  <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindRenderbuffer(int, int)"><CODE>GL20.glBindRenderbuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteRenderbuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, java.nio.IntBuffer)"><CODE>GL20.glGenRenderbuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, int[], int)"><CODE>GL20.glGenRenderbuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsRenderbuffer(int)"><CODE>GL20.glIsRenderbuffer(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDeleteRenderbuffers(int, java.nio.IntBuffer)"><!-- --></A><H3>
glDeleteRenderbuffers</H3>
<PRE>
void <B>glDeleteRenderbuffers</B>(int&nbsp;n,
                           <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;renderbuffers)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, java.nio.IntBuffer)"><CODE>glDeleteRenderbuffers</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p>
 <code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> is negative. 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of renderbuffer objects to be deleted.<DD><CODE>renderbuffers</CODE> - Specifies the renderbuffer objects to be deleted.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>framebuffers</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>framebuffers</i>.remaining()</code> is less than <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, int[], int)"><CODE>GL20.glDeleteRenderbuffers(int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDeleteShader(int)"><!-- --></A><H3>
glDeleteShader</H3>
<PRE>
void <B>glDeleteShader</B>(int&nbsp;shader)</PRE>
<DL>
<DD>Delete a shader object.
 <p>
 <h4>Description</h4>
 <code>glDeleteShader</code> frees the memory and invalidates the name 
 associated with the shader object specified by <i><code>shader</code></i>. This command 
 effectively undoes the effects of a call to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateShader(int)"><CODE>glCreateShader</CODE></A>.
 <p>
 If a shader object to be deleted is attached to a program object, 
 it will be flagged for deletion, but it will not be deleted until 
 it is no longer attached to any program object, for any rendering 
 context (i.e., it must be detached from wherever it was attached 
 before it will be deleted). A value of 0 for <i><code>shader</code></i> will be 
 silently ignored.
 <p>
 To determine whether an object has been flagged for deletion, 
 call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>glGetShaderiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A> with 
 arguments <i><code>shader</code></i> and <code>GL_DELETE_STATUS</code>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>shader</code></i> is
  not a value generated by OpenGL.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, java.nio.IntBuffer, java.nio.IntBuffer)"><CODE>glGetAttachedShaders</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, int[], int, int[], int)"><CODE>glGetAttachedShaders</CODE></A>
  with the program object to be queried
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>glGetShaderiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A>
  with arguments <i><code>shader</code></i> and <code>GL_DELETE_STATUS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsShader(int)"><CODE>glIsShader</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shader</CODE> - Specifies the shader object to be deleted.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateProgram()"><CODE>GL20.glCreateProgram()</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateShader(int)"><CODE>GL20.glCreateShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDetachShader(int, int)"><CODE>GL20.glDetachShader(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>GL20.glUseProgram(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDeleteTextures(int, int[], int)"><!-- --></A><H3>
glDeleteTextures</H3>
<PRE>
void <B>glDeleteTextures</B>(int&nbsp;n,
                      int[]&nbsp;textures,
                      int&nbsp;offset)</PRE>
<DL>
<DD>Delete named textures.
 <p>
 <h4>Description</h4>
 <code>glDeleteTextures</code> deletes <i><code>n</code></i> textures named by the 
 elements of the array <i><code>textures</code></i>. After a texture is deleted, 
 it has no contents or dimensionality, and its name is free for 
 reuse (for example by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, java.nio.IntBuffer)"><CODE>glGenTextures</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, int[], int)"><CODE>glGenTextures</CODE></A>). If a texture that is 
 currently bound is deleted, the binding reverts to 0 (the default texture).
 <p>
 <code>glDeleteTextures</code> silently ignores 0's and names that do 
 not correspond to existing textures.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> is negative. 
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsTexture(int)"><CODE>glIsTexture</CODE></A> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of textures to be deleted.<DD><CODE>textures</CODE> - Specifies an array of textures to be deleted.<DD><CODE>offset</CODE> - The starting offset within the <i><code>textures</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>textures</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>textures</i>.length - <i>offset</i></code> is less than
  <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindTexture(int, int)"><CODE>GL20.glBindTexture(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteTextures(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, java.nio.IntBuffer)"><CODE>GL20.glGenTextures(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, int[], int)"><CODE>GL20.glGenTextures(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsTexture(int)"><CODE>GL20.glIsTexture(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDeleteTextures(int, java.nio.IntBuffer)"><!-- --></A><H3>
glDeleteTextures</H3>
<PRE>
void <B>glDeleteTextures</B>(int&nbsp;n,
                      <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;textures)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, int[], int)"><CODE>glDeleteTextures</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p>
 <code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> is negative. 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of textures to be deleted.<DD><CODE>textures</CODE> - Specifies the textures to be deleted.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>textures</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>textures</i>.remaining()</code> is less than <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, int[], int)"><CODE>GL20.glDeleteTextures(int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDepthFunc(int)"><!-- --></A><H3>
glDepthFunc</H3>
<PRE>
void <B>glDepthFunc</B>(int&nbsp;func)</PRE>
<DL>
<DD>Specify the value used for depth buffer comparisons.
 <p>
 <h4>Description</h4>
 <code>glDepthFunc</code> specifies the function used to 
 compare each incoming pixel depth value with the depth value 
 present in the depth buffer. The comparison is performed 
 only if depth testing is enabled. 
 (See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>glEnable</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisable(int)"><CODE>glDisable</CODE></A> of <code>GL_DEPTH_TEST</code>.)
 <p>
 <i><code>func</code></i> specifies the conditions under which the pixel will be drawn. 
 The comparison functions are as follows:
 <p>
 <code>GL_NEVER</code>
 <p>
 Never passes.
 <p>
 <code>GL_LESS</code>
 <p>
 Passes if the incoming depth value is less than the stored depth value.
 <p>
 <code>GL_EQUAL</code>
 <p>
 Passes if the incoming depth value is equal to the stored depth value.
 <p>
 <code>GL_LEQUAL</code>
 <p>
 Passes if the incoming depth value is less than or equal to the stored depth value.
 <p>
 <code>GL_GREATER</code>
 <p>
 Passes if the incoming depth value is greater than the stored depth value.
 <p>
 <code>GL_NOTEQUAL</code>
 <p>
 Passes if the incoming depth value is not equal to the stored depth value.
 <p>
 <code>GL_GEQUAL</code>
 <p>
 Passes if the incoming depth value is greater than or equal to the stored depth value.
 <p>
 <code>GL_ALWAYS</code>
 <p>
 Always passes.
 <p>
 The initial value of <i><code>func</code></i> is <code>GL_LESS</code>. Initially, depth testing is disabled. 
 If depth testing is disabled or no depth buffer exists, 
 it is as if the depth test always passes.
 <p>
 <h4>Notes</h4>
 <p>
 Even if the depth buffer exists and the depth mask is non-zero, 
 the depth buffer is not updated if the depth test is disabled.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>func</code></i> is not an accepted value.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_DEPTH_FUNC</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A> with argument <code>GL_DEPTH_TEST</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>func</CODE> - Specifies the depth comparison function. 
  Symbolic constants <code>GL_NEVER</code>, <code>GL_LESS</code>, <code>GL_EQUAL</code>, 
  <code>GL_LEQUAL</code>, <code>GL_GREATER</code>, <code>GL_NOTEQUAL</code>, <code>GL_GEQUAL</code>, and 
  <code>GL_ALWAYS</code> are accepted. 
  The initial value is <code>GL_LESS</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthRangef(float, float)"><CODE>GL20.glDepthRangef(float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>GL20.glEnable(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPolygonOffset(float, float)"><CODE>GL20.glPolygonOffset(float, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDepthMask(boolean)"><!-- --></A><H3>
glDepthMask</H3>
<PRE>
void <B>glDepthMask</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>Enable or disable writing into the depth buffer.
 <p>
 <h4>Description</h4>
 <code>glDepthMask</code> specifies whether the depth buffer 
 is enabled for writing. If <i><code>flag</code></i> is <code>GL_FALSE</code>, depth buffer 
 writing is disabled. Otherwise, it is enabled. Initially, 
 depth buffer writing is enabled.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_DEPTH_WRITEMASK</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>flag</CODE> - Specifies whether the depth buffer is enabled for writing. 
  If <i><code>flag</code></i> is <code>GL_FALSE</code>, depth buffer writing is disabled. Otherwise, 
  it is enabled. Initially, depth buffer writing is enabled.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glColorMask(boolean, boolean, boolean, boolean)"><CODE>GL20.glColorMask(boolean, boolean, boolean, boolean)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>GL20.glDepthFunc(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthRangef(float, float)"><CODE>GL20.glDepthRangef(float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMask(int)"><CODE>GL20.glStencilMask(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDepthRangef(float, float)"><!-- --></A><H3>
glDepthRangef</H3>
<PRE>
void <B>glDepthRangef</B>(float&nbsp;zNear,
                   float&nbsp;zFar)</PRE>
<DL>
<DD>Specify mapping of depth values from normalized device coordinates 
 to window coordinates.
 <p>
 <h4>Description</h4>
 After clipping and division by <i>w</i>, depth coordinates range from -1 to 1, 
 corresponding to the near and far clipping planes. <code>glDepthRangef</code> specifies
 a linear mapping of the normalized depth coordinates in this range to window 
 depth coordinates. Regardless of the actual depth buffer implementation, window 
 coordinate depth values are treated as though they range from 0 through 1 
 (like color components). Thus, the values accepted by <code>glDepthRangef</code> are both 
 clamped to this range before they are accepted.
 <p>
 The setting of (0,1) maps the near plane to 0 and the far plane to 1. 
 With this mapping, the depth buffer range is fully utilized.
 <p>
 <h4>Notes</h4>
 <p>
 It is not necessary that <i><code>nearVal</code></i> be less than <i><code>farVal</code></i>. Reverse mappings 
 such as <code><i>nearVal</i> = 1</code>, and <code><i>farVal</i> = 0</code> are acceptable.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_DEPTH_RANGE</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>zNear</CODE> - Specifies the mapping of the near clipping plane to 
  window coordinates. The initial value is 0.<DD><CODE>zFar</CODE> - Specifies the mapping of the far clipping plane to 
  window coordinates. The initial value is 1.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>GL20.glDepthFunc(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPolygonOffset(float, float)"><CODE>GL20.glPolygonOffset(float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glViewport(int, int, int, int)"><CODE>GL20.glViewport(int, int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDetachShader(int, int)"><!-- --></A><H3>
glDetachShader</H3>
<PRE>
void <B>glDetachShader</B>(int&nbsp;program,
                    int&nbsp;shader)</PRE>
<DL>
<DD>Detach a shader object from a program object.
 <p>
 <h4>Description</h4>
 <code>glDetachShader</code> detaches the shader object specified by 
 <i><code>shader</code></i> from the program object specified by <i><code>program</code></i>. This command can 
 be used to undo the effect of the command <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glAttachShader(int, int)"><CODE>glAttachShader</CODE></A>.
 <p>
 If <i><code>shader</code></i> has already been flagged for deletion by a call 
 to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteShader(int)"><CODE>glDeleteShader</CODE></A> and it is not attached to any other program 
 object, it will be deleted after it has been detached.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if either <i><code>program</code></i> or  
  <i><code>shader</code></i> is a value that was not generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>shader</code></i> is not a shader object.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>shader</code></i> is not attached to
 <i><code>program</code></i>.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, java.nio.IntBuffer, java.nio.IntBuffer)"><CODE>glGetAttachedShaders</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, int[], int, int[], int)"><CODE>glGetAttachedShaders</CODE></A>
  with the handle of a valid program object
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>glGetShaderiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A>
  with arguments <i><code>shader</code></i> and <code>GL_DELETE_STATUS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsShader(int)"><CODE>glIsShader</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object from which to detach the shader object.<DD><CODE>shader</CODE> - Specifies the shader object to be detached.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glAttachShader(int, int)"><CODE>GL20.glAttachShader(int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDisable(int)"><!-- --></A><H3>
glDisable</H3>
<PRE>
void <B>glDisable</B>(int&nbsp;cap)</PRE>
<DL>
<DD>Disable server-side GL capabilities.
 <p>
 <h4>Description</h4>
 <code>glDisable</code> disables various capabilities. 
 Use <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A> or 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, java.nio.IntBuffer)"><CODE>glGetBooleanv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, boolean[], int)"><CODE>glGetBooleanv</CODE></A>
 to determine the current setting of any capability. The initial value for each capability 
 with the exception of <code>GL_DITHER</code> is <code>GL_FALSE</code>. 
 The initial value for <code>GL_DITHER</code> is <code>GL_TRUE</code>.
 <p>
 <i><code>cap</code></i> can assume one of the following values:
 <p>
 <code>GL_BLEND</code>
 <p>
 If enabled, blend the computed fragment color values with the 
 values in the color buffers. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>glBlendFunc</CODE></A>.
 <p>
 <code>GL_CULL_FACE</code>
 <p>
 If enabled, cull polygons based on their winding in 
 window coordinates. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCullFace(int)"><CODE>glCullFace</CODE></A>.
 <p>
 <code>GL_DEPTH_TEST</code>
 <p>
 If enabled, do depth comparisons and update the depth buffer. 
 Note that even if the depth buffer exists and the depth mask is non-zero, 
 the depth buffer is not updated if the depth test is 
 disabled. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>glDepthFunc</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthRangef(float, float)"><CODE>glDepthRangef</CODE></A>.
 <p>
 <code>GL_DITHER</code>
 <p>
 If enabled, dither color components or indices before 
 they are written to the color buffer.
 <p>
 <code>GL_POLYGON_OFFSET_FILL</code>
 <p>
 If enabled, an offset is added to depth values of a polygon's 
 fragments produced by rasterization. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPolygonOffset(float, float)"><CODE>glPolygonOffset</CODE></A>.
 <p>
 <code>GL_SAMPLE_ALPHA_TO_COVERAGE</code>
 <p>
 If enabled, compute a temporary coverage value where each bit 
 is determined by the alpha value at the corresponding sample 
 location. The temporary coverage value is then <code>AND</code>ed with the 
 fragment coverage value.
 <p>
 <code>GL_SAMPLE_COVERAGE</code>
 <p>
 If enabled, the fragment's coverage is <code>AND</code>ed with the temporary 
 coverage value. If <code>GL_SAMPLE_COVERAGE_INVERT</code> is set to <code>GL_TRUE</code>, 
 invert the coverage value. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glSampleCoverage(float, boolean)"><CODE>glSampleCoverage</CODE></A>.
 <p>
 <code>GL_SCISSOR_TEST</code>
 <p>
 If enabled, discard fragments that are outside the scissor rectangle. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glScissor(int, int, int, int)"><CODE>glScissor</CODE></A>.
 <p>
 <code>GL_STENCIL_TEST</code>
 <p>
 If enabled, do stencil testing and update the stencil buffer. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>glStencilFunc</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>glStencilOp</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>cap</code></i> is not one of the values listed previously.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, java.nio.IntBuffer)"><CODE>glGetBooleanv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, boolean[], int)"><CODE>glGetBooleanv</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cap</CODE> - Specifies a symbolic constant indicating a GL capability.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>GL20.glActiveTexture(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>GL20.glBlendFunc(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCullFace(int)"><CODE>GL20.glCullFace(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>GL20.glDepthFunc(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthRangef(float, float)"><CODE>GL20.glDepthRangef(float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, java.nio.IntBuffer)"><CODE>GL20.glGetBooleanv(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, boolean[], int)"><CODE>GL20.glGetBooleanv(int, boolean[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>GL20.glIsEnabled(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLineWidth(float)"><CODE>GL20.glLineWidth(float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPolygonOffset(float, float)"><CODE>GL20.glPolygonOffset(float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glScissor(int, int, int, int)"><CODE>GL20.glScissor(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>GL20.glStencilFunc(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>GL20.glStencilOp(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDisableVertexAttribArray(int)"><!-- --></A><H3>
glDisableVertexAttribArray</H3>
<PRE>
void <B>glDisableVertexAttribArray</B>(int&nbsp;index)</PRE>
<DL>
<DD>Disable a generic vertex attribute array.
 <p>
 <h4>Description</h4>
 <code>glDisableVertexAttribArray</code> disables the generic vertex attribute array 
 specified by <i><code>index</code></i>. By default, all client-side capabilities are
 disabled, including all generic vertex attribute arrays. If enabled, the values in the
 generic vertex attribute array will be accessed and used for rendering when calls are
 made to vertex array commands such as <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawArrays(int, int, int)"><CODE>glDrawArrays</CODE></A>
 or <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>glDrawElements</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)"><CODE>glDrawElements</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p>
 <code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is greater than or
  equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_MAX_VERTEX_ATTRIBS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, java.nio.FloatBuffer)"><CODE>glGetVertexAttrib</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, float[], int)"><CODE>glGetVertexAttrib</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><CODE>glGetVertexAttrib</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>glGetVertexAttrib</CODE></A> 
  with arguments <i><code>index</code></i> and <code>GL_VERTEX_ATTRIB_ARRAY_ENABLED</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be disabled.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindAttribLocation(int, int, java.lang.String)"><CODE>GL20.glBindAttribLocation(int, int, String)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawArrays(int, int, int)"><CODE>GL20.glDrawArrays(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>GL20.glDrawElements(int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)"><CODE>GL20.glDrawElements(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib1fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, float[], int)"><CODE>GL20.glVertexAttrib1fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2f(int, float, float)"><CODE>GL20.glVertexAttrib2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib2fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, float[], int)"><CODE>GL20.glVertexAttrib2fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3f(int, float, float, float)"><CODE>GL20.glVertexAttrib3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib3fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, float[], int)"><CODE>GL20.glVertexAttrib3fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4f(int, float, float, float, float)"><CODE>GL20.glVertexAttrib4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib4fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, float[], int)"><CODE>GL20.glVertexAttrib4fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, int)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDrawArrays(int, int, int)"><!-- --></A><H3>
glDrawArrays</H3>
<PRE>
void <B>glDrawArrays</B>(int&nbsp;mode,
                  int&nbsp;first,
                  int&nbsp;count)</PRE>
<DL>
<DD>Render primitives from array data.
 <p>
 <h4>Description</h4>
 <code>glDrawArrays</code> specifies multiple geometric primitives with very few 
 subroutine calls. Instead of calling a GL procedure to pass each individual 
 vertex attribute, you can use 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><CODE>glVertexAttribPointer</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, int)"><CODE>glVertexAttribPointer</CODE></A>
 to prespecify separate arrays of vertices, normals, and colors and use them to construct a 
 sequence of primitives with a single call to <code>glDrawArrays</code>.
 <p>
 When <code>glDrawArrays</code> is called, it uses <i><code>count</code></i> sequential elements from each 
 enabled array to construct a sequence of geometric primitives, beginning 
 with element <i><code>first</code></i>. <i><code>mode</code></i> specifies what kind of primitives are constructed 
 and how the array elements construct those primitives.
 <p>
 To enable and disable a generic vertex attribute array, 
 call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnableVertexAttribArray(int)"><CODE>glEnableVertexAttribArray</CODE></A> and
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisableVertexAttribArray(int)"><CODE>glDisableVertexAttribArray</CODE></A>.
 <p>
 <h4>Notes</h4>
 <p>
 If the current program object, as set by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>glUseProgram</CODE></A>, is invalid, rendering 
 results are undefined. However, no error is generated for this case.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>mode</code></i> is not an accepted value.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is negative.
 <p><code>GL_INVALID_FRAMEBUFFER_OPERATION</code> is generated if the currently bound 
 framebuffer is not framebuffer complete (i.e. the return value 
 from <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)"><CODE>glCheckFramebufferStatus</CODE></A> is not <code>GL_FRAMEBUFFER_COMPLETE</code>).
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - Specifies what kind of primitives to render. 
  Symbolic constants <code>GL_POINTS</code>, <code>GL_LINE_STRIP</code>, 
  <code>GL_LINE_LOOP</code>, <code>GL_LINES</code>, <code>GL_TRIANGLE_STRIP</code>, 
  <code>GL_TRIANGLE_FAN</code>, and <code>GL_TRIANGLES</code> are accepted.<DD><CODE>first</CODE> - Specifies the starting index in the enabled arrays.<DD><CODE>count</CODE> - Specifies the number of indices to be rendered.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</A></CODE> - If any index
             in the sequence <code><i>first</i>, ..., <i>first</i> + <i>count</i> - 1</code> 
             will result in a reference to an entry outside of the
             enabled generic vertex attribute data array(s).<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)"><CODE>GL20.glCheckFramebufferStatus(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisableVertexAttribArray(int)"><CODE>GL20.glDisableVertexAttribArray(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>GL20.glDrawElements(int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)"><CODE>GL20.glDrawElements(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnableVertexAttribArray(int)"><CODE>GL20.glEnableVertexAttribArray(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>GL20.glUseProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, int)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDrawElements(int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glDrawElements</H3>
<PRE>
void <B>glDrawElements</B>(int&nbsp;mode,
                    int&nbsp;count,
                    int&nbsp;type,
                    <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;indices)</PRE>
<DL>
<DD>Render primitives from array data.
 <p>
 <h4>Description</h4>
 <code>glDrawElements</code> specifies multiple geometric primitives with very few subroutine calls. 
 Instead of calling a GL function to pass each vertex attribute, you can 
 use <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><CODE>glVertexAttribPointer</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, int)"><CODE>glVertexAttribPointer</CODE></A>
 to prespecify separate arrays of vertex attributes and use them to construct a sequence
 of primitives with a single call to <code>glDrawElements</code>.
 <p>
 When <code>glDrawElements</code> is called, it uses <i><code>count</code></i> elements from
 an enabled array, accessing the elements specified by <i><code>indices</code></i> to construct
 a sequence of geometric primitives. <i><code>mode</code></i> specifies 
 what kind of primitives are constructed and how the array elements construct these 
 primitives. If more than one array is enabled, each is used.
 <p>
 To enable and disable a generic vertex attribute array, 
 call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnableVertexAttribArray(int)"><CODE>glEnableVertexAttribArray</CODE></A>
 and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisableVertexAttribArray(int)"><CODE>glDisableVertexAttribArray</CODE></A>.
 <p>
 <h4>Notes</h4>
 <p>
 If the current program object, as set by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>glUseProgram</CODE></A>, 
 is invalid, rendering results are undefined. However, no error is generated for this case.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>mode</code></i> is not an accepted value. 
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>type</code></i> is not
  <code>GL_UNSIGNED_BYTE</code> or <code>GL_UNSIGNED_SHORT</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is negative.
 <p><code>GL_INVALID_FRAMEBUFFER_OPERATION</code> is generated if the currently bound framebuffer 
  is not framebuffer complete (i.e. the return value from <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)"><CODE>glCheckFramebufferStatus</CODE></A>
  is not <code>GL_FRAMEBUFFER_COMPLETE</code>).
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - Specifies what kind of primitives to render. 
  Symbolic constants <code>GL_POINTS</code>, <code>GL_LINE_STRIP</code>, 
  <code>GL_LINE_LOOP</code>, <code>GL_LINES</code>, <code>GL_TRIANGLE_STRIP</code>, 
  <code>GL_TRIANGLE_FAN</code>, and <code>GL_TRIANGLES</code> are accepted.<DD><CODE>count</CODE> - Specifies the number of elements to be rendered.<DD><CODE>type</CODE> - Specifies the type of the values in <i><code>indices</code></i>. 
  Must be <code>GL_UNSIGNED_BYTE</code> or <code>GL_UNSIGNED_SHORT</code>.<DD><CODE>indices</CODE> - Specifies the indices as a buffer.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</A></CODE> - If the most recent call
             to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>glBindBuffer</CODE></A> for the
             <code>GL_ELEMENT_ARRAY_BUFFER</code> target had a
             non-zero <code>buffer</code> parameter (i.e., an
             index buffer is bound).
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If
             <i><code>indices</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</A></CODE> - If any index
             in the sequence of indices from <code>0</code> to
             <code><i>count</i> - 1</code> would result in a reference
             to an entry outside of the currently bound index array
             or the enabled generic vertex attribute data array(s).<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)"><CODE>GL20.glCheckFramebufferStatus(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisableVertexAttribArray(int)"><CODE>GL20.glDisableVertexAttribArray(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawArrays(int, int, int)"><CODE>GL20.glDrawArrays(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)"><CODE>GL20.glDrawElements(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnableVertexAttribArray(int)"><CODE>GL20.glEnableVertexAttribArray(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>GL20.glUseProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, int)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glDrawElements(int, int, int, int)"><!-- --></A><H3>
glDrawElements</H3>
<PRE>
void <B>glDrawElements</B>(int&nbsp;mode,
                    int&nbsp;count,
                    int&nbsp;type,
                    int&nbsp;offset)</PRE>
<DL>
<DD>VBO version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>glDrawElements</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>mode</code></i> is not an accepted value. 
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>type</code></i> is not
  <code>GL_UNSIGNED_BYTE</code> or <code>GL_UNSIGNED_SHORT</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is negative.
 <p><code>GL_INVALID_FRAMEBUFFER_OPERATION</code> is generated if the currently bound framebuffer 
  is not framebuffer complete (i.e. the return value from <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)"><CODE>glCheckFramebufferStatus</CODE></A>
  is not <code>GL_FRAMEBUFFER_COMPLETE</code>).
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - Specifies what kind of primitives to render. 
  Symbolic constants <code>GL_POINTS</code>, <code>GL_LINE_STRIP</code>, 
  <code>GL_LINE_LOOP</code>, <code>GL_LINES</code>, <code>GL_TRIANGLE_STRIP</code>, 
  <code>GL_TRIANGLE_FAN</code>, and <code>GL_TRIANGLES</code> are accepted.<DD><CODE>count</CODE> - Specifies the number of elements to be rendered.<DD><CODE>type</CODE> - Specifies the type of the values in currently bound index buffer. 
  Must be <code>GL_UNSIGNED_BYTE</code> or <code>GL_UNSIGNED_SHORT</code>.<DD><CODE>offset</CODE> - Specifies the offset into the currently bound index buffer.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</A></CODE> - If the most recent call to
             <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>glBindBuffer</CODE></A> for the
             <code>GL_ELEMENT_ARRAY_BUFFER</code> target had a
             <code>buffer</code> parameter of 0 (i.e., an index
             buffer is not bound).
<DD><CODE><A HREF="../../../../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</A></CODE> - If any index
             in the sequence of indices from <i><code>offset</code></i>
             to <code><i>offset</i> + <i>count</i> - 1</code> 
             would result in a reference to an entry
             outside of <code>indices</code> or the enabled 
             generic vertex attribute data array(s), where
             <code>indices</code> refers to the set of values
             bound to the <code>GL_ELEMENT_ARRAY_BUFFER</code> target.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>GL20.glDrawElements(int, int, int, Buffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glEnable(int)"><!-- --></A><H3>
glEnable</H3>
<PRE>
void <B>glEnable</B>(int&nbsp;cap)</PRE>
<DL>
<DD>Enable server-side GL capabilities.
 <p>
 <h4>Description</h4>
 <code>glEnable</code> enables various capabilities. 
 Use <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A> or 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, java.nio.IntBuffer)"><CODE>glGetBooleanv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, boolean[], int)"><CODE>glGetBooleanv</CODE></A>
 to determine the current setting of any capability. The initial value for each capability 
 with the exception of <code>GL_DITHER</code> is <code>GL_FALSE</code>. 
 The initial value for <code>GL_DITHER</code> is <code>GL_TRUE</code>.
 <p>
 <i><code>cap</code></i> can assume one of the following values:
 <p>
 <code>GL_BLEND</code>
 <p>
 If enabled, blend the computed fragment color values with the 
 values in the color buffers. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>glBlendFunc</CODE></A>.
 <p>
 <code>GL_CULL_FACE</code>
 <p>
 If enabled, cull polygons based on their winding in 
 window coordinates. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCullFace(int)"><CODE>glCullFace</CODE></A>.
 <p>
 <code>GL_DEPTH_TEST</code>
 <p>
 If enabled, do depth comparisons and update the depth buffer. 
 Note that even if the depth buffer exists and the depth mask is non-zero, 
 the depth buffer is not updated if the depth test is 
 disabled. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>glDepthFunc</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthRangef(float, float)"><CODE>glDepthRangef</CODE></A>.
 <p>
 <code>GL_DITHER</code>
 <p>
 If enabled, dither color components or indices before 
 they are written to the color buffer.
 <p>
 <code>GL_POLYGON_OFFSET_FILL</code>
 <p>
 If enabled, an offset is added to depth values of a polygon's 
 fragments produced by rasterization. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPolygonOffset(float, float)"><CODE>glPolygonOffset</CODE></A>.
 <p>
 <code>GL_SAMPLE_ALPHA_TO_COVERAGE</code>
 <p>
 If enabled, compute a temporary coverage value where each bit 
 is determined by the alpha value at the corresponding sample 
 location. The temporary coverage value is then <code>AND</code>ed with the 
 fragment coverage value.
 <p>
 <code>GL_SAMPLE_COVERAGE</code>
 <p>
 If enabled, the fragment's coverage is <code>AND</code>ed with the temporary 
 coverage value. If <code>GL_SAMPLE_COVERAGE_INVERT</code> is set to <code>GL_TRUE</code>, 
 invert the coverage value. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glSampleCoverage(float, boolean)"><CODE>glSampleCoverage</CODE></A>.
 <p>
 <code>GL_SCISSOR_TEST</code>
 <p>
 If enabled, discard fragments that are outside the scissor rectangle. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glScissor(int, int, int, int)"><CODE>glScissor</CODE></A>.
 <p>
 <code>GL_STENCIL_TEST</code>
 <p>
 If enabled, do stencil testing and update the stencil buffer. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>glStencilFunc</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>glStencilOp</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>cap</code></i> is not one of the values listed previously.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, java.nio.IntBuffer)"><CODE>glGetBooleanv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, boolean[], int)"><CODE>glGetBooleanv</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cap</CODE> - Specifies a symbolic constant indicating a GL capability.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>GL20.glActiveTexture(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>GL20.glBlendFunc(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCullFace(int)"><CODE>GL20.glCullFace(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>GL20.glDepthFunc(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthRangef(float, float)"><CODE>GL20.glDepthRangef(float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, java.nio.IntBuffer)"><CODE>GL20.glGetBooleanv(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, boolean[], int)"><CODE>GL20.glGetBooleanv(int, boolean[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>GL20.glIsEnabled(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLineWidth(float)"><CODE>GL20.glLineWidth(float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPolygonOffset(float, float)"><CODE>GL20.glPolygonOffset(float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glScissor(int, int, int, int)"><CODE>GL20.glScissor(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>GL20.glStencilFunc(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>GL20.glStencilOp(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glEnableVertexAttribArray(int)"><!-- --></A><H3>
glEnableVertexAttribArray</H3>
<PRE>
void <B>glEnableVertexAttribArray</B>(int&nbsp;index)</PRE>
<DL>
<DD>Enables a generic vertex attribute array.
 <p>
 <h4>Description</h4>
 <code>glEnableVertexAttribArray</code> enables the generic vertex attribute array 
 specified by <i><code>index</code></i>. By default, all client-side capabilities are
 disabled, including all generic vertex attribute arrays. If enabled, the values in the
 generic vertex attribute array will be accessed and used for rendering when calls are
 made to vertex array commands such as <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawArrays(int, int, int)"><CODE>glDrawArrays</CODE></A>
 or <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>glDrawElements</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)"><CODE>glDrawElements</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p>
 <code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is greater
  than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_MAX_VERTEX_ATTRIBS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, java.nio.FloatBuffer)"><CODE>glGetVertexAttrib</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, float[], int)"><CODE>glGetVertexAttrib</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><CODE>glGetVertexAttrib</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>glGetVertexAttrib</CODE></A> 
  with arguments <i><code>index</code></i> and <code>GL_VERTEX_ATTRIB_ARRAY_ENABLED</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be enabled.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindAttribLocation(int, int, java.lang.String)"><CODE>GL20.glBindAttribLocation(int, int, String)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawArrays(int, int, int)"><CODE>GL20.glDrawArrays(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>GL20.glDrawElements(int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)"><CODE>GL20.glDrawElements(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib1fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, float[], int)"><CODE>GL20.glVertexAttrib1fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2f(int, float, float)"><CODE>GL20.glVertexAttrib2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib2fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, float[], int)"><CODE>GL20.glVertexAttrib2fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3f(int, float, float, float)"><CODE>GL20.glVertexAttrib3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib3fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, float[], int)"><CODE>GL20.glVertexAttrib3fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4f(int, float, float, float, float)"><CODE>GL20.glVertexAttrib4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib4fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, float[], int)"><CODE>GL20.glVertexAttrib4fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, int)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glFinish()"><!-- --></A><H3>
glFinish</H3>
<PRE>
void <B>glFinish</B>()</PRE>
<DL>
<DD>Block until all GL execution is complete.
 <p>
 <h4>Description</h4>
 <code>glFinish</code> does not return until the effects of all 
 previously called GL commands are complete. Such effects include 
 all changes to GL state, all changes to connection state, and all 
 changes to the frame buffer contents.
 <p>
 <h4>Notes</h4>
 <p>
 <code>glFinish</code> requires a round trip to the server.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFlush()"><CODE>GL20.glFlush()</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glFlush()"><!-- --></A><H3>
glFlush</H3>
<PRE>
void <B>glFlush</B>()</PRE>
<DL>
<DD>Force execution of GL commands in finite time.
 <p>
 <h4>Description</h4>
 Different GL implementations buffer commands in several different locations, 
 including network buffers and the graphics accelerator itself. 
 <code>glFlush</code> empties all of these buffers, causing all issued 
 commands to be executed as quickly as they are accepted by the actual 
 rendering engine. Though this execution may not be completed in any 
 particular time period, it does complete in finite time.
 <p>
 Because any GL program might be executed over a network, 
 or on an accelerator that buffers commands, all programs should 
 call <code>glFlush</code> whenever they count on having all of their 
 previously issued commands completed. For example, call <code>glFlush</code> 
 before waiting for user input that depends on the generated image.
 <p>
 <h4>Notes</h4>
 <p>
 <code>glFlush</code> can return at any time. It does not wait until 
 the execution of all previously issued GL commands is complete.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFinish()"><CODE>GL20.glFinish()</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glFramebufferRenderbuffer(int, int, int, int)"><!-- --></A><H3>
glFramebufferRenderbuffer</H3>
<PRE>
void <B>glFramebufferRenderbuffer</B>(int&nbsp;target,
                               int&nbsp;attachment,
                               int&nbsp;renderbuffertarget,
                               int&nbsp;renderbuffer)</PRE>
<DL>
<DD>Attach a renderbuffer object to a framebuffer object.
 <p>
 <h4>Description</h4>
 <code>glFramebufferRenderbuffer</code> attaches the renderbuffer 
 specified by <i><code>renderbuffer</code></i> as one of the logical buffers of the 
 currently bound framebuffer object. <i><code>attachment</code></i> specifies whether 
 the renderbuffer should be attached to the framebuffer object's 
 color, depth, or stencil buffer. A renderbuffer may not be attached 
 to the default framebuffer object name 0.
 <p>
 If <i><code>renderbuffer</code></i> is not 0, the value of <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code> 
 for the specified attachment point is set to <code>GL_RENDERBUFFER</code> and the value 
 of <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</code> is set to <i><code>renderbuffer</code></i>. 
 <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</code> and <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</code> 
 are set to the default values 0 and <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>, respectively. 
 Any previous attachment to the <i><code>attachment</code></i> logical buffer of the currently bound 
 framebuffer object is broken.
 <p>
 If <i><code>renderbuffer</code></i> is 0, the current image, if any, attached to the <i><code>attachment</code></i> logical 
 buffer of the currently bound framebuffer object is detached. The value of 
 <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code> is set to <code>GL_NONE</code>. 
 The value of <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</code> is set to 0. 
 <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</code> and <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</code> 
 are set to the default values 0 and <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>, respectively.
 <p>
 <h4>Notes</h4>
 <p>
 If a renderbuffer object is deleted while its image is attached to the currently bound framebuffer, 
 then it is as if <code>glFramebufferRenderbuffer</code> had been called with a <i><code>renderbuffer</code></i> of 0 for the 
 attachment point to which this image was attached in the currently bound framebuffer object. 
 In other words, the renderbuffer image is detached from the currently bound framebuffer. 
 Note that the renderbuffer image is specifically <i>not</i> detached from any non-bound framebuffers. 
 Detaching the image from any non-bound framebuffers is the responsibility of the application.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not <code>GL_FRAMEBUFFER</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>renderbuffertarget</code></i> is not
  <code>GL_RENDERBUFFER</code> and <i><code>renderbuffer</code></i> is not 0.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>attachment</code></i> is not an accepted attachment point.
 <p><code>GL_INVALID_OPERATION</code> is generated if the default framebuffer object name 0 is bound.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>renderbuffer</code></i> is neither 0 nor
  the name of an existing renderbuffer object.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, java.nio.IntBuffer)"><CODE>glGetFramebufferAttachmentParameteriv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)"><CODE>glGetFramebufferAttachmentParameteriv</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the framebuffer target. The symbolic 
  constant must be <code>GL_FRAMEBUFFER</code>.<DD><CODE>attachment</CODE> - Specifies the attachment point to which 
  <i><code>renderbuffer</code></i> should be attached. Must be one of the following 
  symbolic constants: <code>GL_COLOR_ATTACHMENT0</code>, 
  <code>GL_DEPTH_ATTACHMENT</code>, or <code>GL_STENCIL_ATTACHMENT</code>.<DD><CODE>renderbuffertarget</CODE> - Specifies the renderbuffer target. 
  The symbolic constant must be <code>GL_RENDERBUFFER</code>.<DD><CODE>renderbuffer</CODE> - Specifies the renderbuffer object that 
  is to be attached.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindFramebuffer(int, int)"><CODE>GL20.glBindFramebuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindRenderbuffer(int, int)"><CODE>GL20.glBindRenderbuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)"><CODE>GL20.glCheckFramebufferStatus(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteFramebuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, int[], int)"><CODE>GL20.glDeleteFramebuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteRenderbuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, int[], int)"><CODE>GL20.glDeleteRenderbuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFramebufferTexture2D(int, int, int, int, int)"><CODE>GL20.glFramebufferTexture2D(int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, java.nio.IntBuffer)"><CODE>GL20.glGetFramebufferAttachmentParameteriv(int, int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)"><CODE>GL20.glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glRenderbufferStorage(int, int, int, int)"><CODE>GL20.glRenderbufferStorage(int, int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glFramebufferTexture2D(int, int, int, int, int)"><!-- --></A><H3>
glFramebufferTexture2D</H3>
<PRE>
void <B>glFramebufferTexture2D</B>(int&nbsp;target,
                            int&nbsp;attachment,
                            int&nbsp;textarget,
                            int&nbsp;texture,
                            int&nbsp;level)</PRE>
<DL>
<DD>Attach a texture image to a framebuffer object.
 <p>
 <h4>Description</h4>
 <code>glFramebufferTexture2D</code> attaches the texture image specified by 
 <i><code>texture</code></i> and <i><code>level</code></i> as one of the logical buffers of the currently bound framebuffer object. 
 <i><code>attachment</code></i> specifies whether the texture image should be attached to the framebuffer 
 object's color, depth, or stencil buffer. A texture image may not be attached to the 
 default framebuffer object name 0.
 <p>
 If <i><code>texture</code></i> is not 0, the value of <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code> 
 for the specified attachment point is set to <code>GL_TEXTURE</code>, the value of 
 <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</code> is set to <i><code>texture</code></i>, and the value of 
 <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</code> is set to <i><code>level</code></i>. If <i><code>texture</code></i> is a 
 cube map texture, the value of <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</code> 
 is set to <i><code>textarget</code></i>; otherwise it is set to the default value 
 <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>. Any previous attachment to the <i><code>attachment</code></i> 
 logical buffer of the currently bound framebuffer object is broken.
 <p>
 If <i><code>texture</code></i> is 0, the current image, if any, attached to the <i><code>attachment</code></i> 
 logical buffer of the currently bound framebuffer object is detached. 
 The value of <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code> is set to <code>GL_NONE</code>. 
 The value of <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</code> is set to 0. 
 <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</code> and <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</code> 
 are set to the default values 0 and <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>, respectively.
 <p>
 <h4>Notes</h4>
 <p>
 Special precautions need to be taken to avoid attaching a texture image to the 
 currently bound framebuffer while the texture object is currently bound and 
 potentially sampled by the current vertex or fragment shader. Doing so could 
 lead to the creation of a "feedback loop" between the writing of pixels by 
 rendering operations and the simultaneous reading of those same pixels when 
 used as texels in the currently bound texture. In this scenario, the framebuffer 
 will be considered framebuffer complete, but the values of fragments rendered 
 while in this state will be undefined. The values of texture samples may be 
 undefined as well.
 <p>
 If a texture object is deleted while its image is attached to the currently bound 
 framebuffer, then it is as if <code>glFramebufferTexture2D</code> had been called with a 
 <i><code>texture</code></i> of 0 for the attachment point to which this image was attached in 
 the currently bound framebuffer object. In other words, the texture image 
 is detached from the currently bound framebuffer. Note that the texture image 
 is specifically <i>not</i> detached from any non-bound framebuffers. 
 Detaching the image from any non-bound framebuffers is the responsibility 
 of the application.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not <code>GL_FRAMEBUFFER</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>textarget</code></i> is
  not an accepted texture target and <i><code>texture</code></i> is not 0.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>attachment</code></i> is not
  an accepted attachment point.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>level</code></i> is not 0 and
  <i><code>texture</code></i> is not 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if the default framebuffer object name 0 is bound.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>texture</code></i> is neither 0
  nor the name of an existing texture object.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>texture</code></i> is the name of
  an existing two-dimensional texture object but 
  <i><code>textarget</code></i> is not <code>GL_TEXTURE_2D</code> or if <i><code>texture</code></i>
  is the name of an existing cube map texture object but <i><code>textarget</code></i> is <code>GL_TEXTURE_2D</code>.
 <p>
 <h4>Associated Gets</h4>
 <p>
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, java.nio.IntBuffer)"><CODE>glGetFramebufferAttachmentParameteriv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)"><CODE>glGetFramebufferAttachmentParameteriv</CODE></A> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the framebuffer target. 
  The symbolic constant must be <code>GL_FRAMEBUFFER</code>.<DD><CODE>attachment</CODE> - Specifies the attachment point to 
  which an image from <i><code>texture</code></i> should be attached. 
  Must be one of the following symbolic constants: 
  <code>GL_COLOR_ATTACHMENT0</code>, <code>GL_DEPTH_ATTACHMENT</code>, or 
  <code>GL_STENCIL_ATTACHMENT</code>.<DD><CODE>textarget</CODE> - Specifies the texture target. 
  Must be one of the following symbolic constants: 
      <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>, 
      <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>, 
      <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or 
      <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.<DD><CODE>texture</CODE> - Specifies the texture object whose image is to be attached.<DD><CODE>level</CODE> - Specifies the mipmap level of the texture image to be attached, which must be 0.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindFramebuffer(int, int)"><CODE>GL20.glBindFramebuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindTexture(int, int)"><CODE>GL20.glBindTexture(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)"><CODE>GL20.glCheckFramebufferStatus(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteFramebuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, int[], int)"><CODE>GL20.glDeleteFramebuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteTextures(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, int[], int)"><CODE>GL20.glDeleteTextures(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFramebufferRenderbuffer(int, int, int, int)"><CODE>GL20.glFramebufferRenderbuffer(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenerateMipmap(int)"><CODE>GL20.glGenerateMipmap(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, java.nio.IntBuffer)"><CODE>GL20.glGetFramebufferAttachmentParameteriv(int, int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)"><CODE>GL20.glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glFrontFace(int)"><!-- --></A><H3>
glFrontFace</H3>
<PRE>
void <B>glFrontFace</B>(int&nbsp;mode)</PRE>
<DL>
<DD>Define front- and back-facing polygons.
 <p>
 <h4>Description</h4>
 In a scene composed entirely of opaque closed surfaces, 
 back-facing polygons are never visible. Eliminating these 
 invisible polygons has the obvious benefit of speeding up 
 the rendering of the image. To enable and disable elimination 
 of back-facing polygons, call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>glEnable</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisable(int)"><CODE>glDisable</CODE></A> with 
 argument <code>GL_CULL_FACE</code>.
 <p>
 The projection of a polygon to window coordinates is said to 
 have clockwise winding if an imaginary object following the 
 path from its first vertex, its second vertex, and so on, 
 to its last vertex, and finally back to its first vertex, 
 moves in a clockwise direction about the interior of the polygon. 
 The polygon's winding is said to be counterclockwise if the imaginary 
 object following the same path moves in a counterclockwise direction 
 about the interior of the polygon. <code>glFrontFace</code> specifies whether 
 polygons with clockwise winding in window coordinates, or counterclockwise 
 winding in window coordinates, are taken to be front-facing. 
 Passing <code>GL_CCW</code> to <i><code>mode</code></i> selects counterclockwise polygons as front-facing; 
 <code>GL_CW</code> selects clockwise polygons as front-facing. 
 By default, counterclockwise polygons are taken to be front-facing.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>mode</code></i> is not an accepted value.
 <p>
 <h4>Associated Gets</h4>
 <p>
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_FRONT_FACE</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mode</CODE> - Specifies the orientation of front-facing polygons. 
  <code>GL_CW</code> and <code>GL_CCW</code> are accepted. The initial value is <code>GL_CCW</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCullFace(int)"><CODE>GL20.glCullFace(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGenBuffers(int, int[], int)"><!-- --></A><H3>
glGenBuffers</H3>
<PRE>
void <B>glGenBuffers</B>(int&nbsp;n,
                  int[]&nbsp;buffers,
                  int&nbsp;offset)</PRE>
<DL>
<DD>Generate buffer object names.
 <p>
 <h4>Description</h4>
 <code>glGenBuffers</code> returns <i><code>n</code></i> buffer object names in <i><code>buffers</code></i>. 
 There is no guarantee that the names form a contiguous set of integers; 
 however, it is guaranteed that none of the returned names was in use 
 immediately before the call to <code>glGenBuffers</code>.
 <p>
 Buffer object names returned by a call to <code>glGenBuffers</code> are not 
 returned by subsequent calls, unless they are first deleted 
 with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, java.nio.IntBuffer)"><CODE>glDeleteBuffers</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, int[], int)"><CODE>glDeleteBuffers</CODE></A>.
 <p>
 No buffer objects are associated with the returned buffer object 
 names until they are first bound by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>glBindBuffer</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> is negative.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsBuffer(int)"><CODE>glIsBuffer</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of buffer object names to be generated.<DD><CODE>buffers</CODE> - Specifies an array in which the generated buffer object names are stored.<DD><CODE>offset</CODE> - The starting offset within the <i><code>buffers</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>buffers</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>buffers</i>.length -
              <i>offset</i></code> is less than <code>n</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>GL20.glBindBuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteBuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, int[], int)"><CODE>GL20.glDeleteBuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, java.nio.IntBuffer)"><CODE>GL20.glGenBuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>GL20.glGetIntegerv(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>GL20.glGetIntegerv(int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGenBuffers(int, java.nio.IntBuffer)"><!-- --></A><H3>
glGenBuffers</H3>
<PRE>
void <B>glGenBuffers</B>(int&nbsp;n,
                  <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;buffers)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <code>glGenBuffers</code>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> is negative.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of buffer object names to be generated.<DD><CODE>buffers</CODE> - Specifies a buffer in which the generated buffer object names are stored.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>buffers</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>buffers</i>.remaining()</code> is less than <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, int[], int)"><CODE>GL20.glGenBuffers(int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGenFramebuffers(int, int[], int)"><!-- --></A><H3>
glGenFramebuffers</H3>
<PRE>
void <B>glGenFramebuffers</B>(int&nbsp;n,
                       int[]&nbsp;framebuffers,
                       int&nbsp;offset)</PRE>
<DL>
<DD>Generate framebuffer object names
 <p>
 <h4>Description</h4>
 <code>glGenFramebuffers</code> returns <i><code>n</code></i> framebuffer object names in <i><code>framebuffers</code></i>. 
 There is no guarantee that the names form a contiguous set of integers; 
 however, it is guaranteed that none of the returned names was in use 
 immediately before the call to <code>glGenFramebuffers</code>.
 <p>
 Framebuffer object names returned by a call to <code>glGenFramebuffers</code> 
 are not returned by subsequent calls, unless they are first deleted 
 with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, java.nio.IntBuffer)"><CODE>glDeleteFramebuffers</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, int[], int)"><CODE>glDeleteFramebuffers</CODE></A>.
 <p>
 No framebuffer objects are associated with the returned 
 framebuffer object names until they are first bound by 
 calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindFramebuffer(int, int)"><CODE>glBindFramebuffer</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> is negative.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsFramebuffer(int)"><CODE>glIsFramebuffer</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of framebuffer object names to be generated.<DD><CODE>framebuffers</CODE> - Specifies an array in which the generated framebuffer object names are stored.<DD><CODE>offset</CODE> - The starting offset within the <i><code>framebuffers</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>framebuffers</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>framebuffers</i>.length -
              <i>offset</i></code> is less than <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindFramebuffer(int, int)"><CODE>GL20.glBindFramebuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteFramebuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, int[], int)"><CODE>GL20.glDeleteFramebuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, java.nio.IntBuffer)"><CODE>GL20.glGenFramebuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsFramebuffer(int)"><CODE>GL20.glIsFramebuffer(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGenFramebuffers(int, java.nio.IntBuffer)"><!-- --></A><H3>
glGenFramebuffers</H3>
<PRE>
void <B>glGenFramebuffers</B>(int&nbsp;n,
                       <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;framebuffers)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, int[], int)"><CODE>glGenBuffers</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i>n</i> is negative.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of framebuffer object names to be generated.<DD><CODE>framebuffers</CODE> - Specifies the buffer in which the generated framebuffer object names are stored.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>framebuffers</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>framebuffers</i>.remaining()</code> is less than <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, int[], int)"><CODE>GL20.glGenFramebuffers(int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGenRenderbuffers(int, int[], int)"><!-- --></A><H3>
glGenRenderbuffers</H3>
<PRE>
void <B>glGenRenderbuffers</B>(int&nbsp;n,
                        int[]&nbsp;renderbuffers,
                        int&nbsp;offset)</PRE>
<DL>
<DD>Generate renderbuffer object names.
 <p>
 <h4>Description</h4>
 <code>glGenRenderbuffers</code> returns <i><code>n</code></i> renderbuffer object names in <i><code>renderbuffers</code></i>. 
 There is no guarantee that the names form a contiguous set of integers; 
 however, it is guaranteed that none of the returned names was in use immediately 
 before the call to <code>glGenRenderbuffers</code>.
 <p>
 Renderbuffer object names returned by a call to <code>glGenRenderbuffers</code> 
 are not returned by subsequent calls, unless they are first deleted 
 with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, java.nio.IntBuffer)"><CODE>glDeleteRenderbuffers</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, int[], int)"><CODE>glDeleteRenderbuffers</CODE></A>.
 <p>
 No renderbuffer objects are associated with the returned renderbuffer 
 object names until they are first bound by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindRenderbuffer(int, int)"><CODE>glBindRenderbuffer</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> is negative.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsRenderbuffer(int)"><CODE>glIsRenderbuffer</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of renderbuffer object names to be generated.<DD><CODE>renderbuffers</CODE> - Specifies an array in which the generated renderbuffer object names are stored.<DD><CODE>offset</CODE> - The starting offset within the <i><code>renderbuffers</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>renderbuffers</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>renderbuffers</i>.length -
              <i>offset</i></code> is less than <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindRenderbuffer(int, int)"><CODE>GL20.glBindRenderbuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteRenderbuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, int[], int)"><CODE>GL20.glDeleteRenderbuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, java.nio.IntBuffer)"><CODE>GL20.glGenRenderbuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsRenderbuffer(int)"><CODE>GL20.glIsRenderbuffer(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGenRenderbuffers(int, java.nio.IntBuffer)"><!-- --></A><H3>
glGenRenderbuffers</H3>
<PRE>
void <B>glGenRenderbuffers</B>(int&nbsp;n,
                        <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;renderbuffers)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, int[], int)"><CODE>glGenRenderbuffers</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> is negative.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies Specifies the number of renderbuffer object names to be generated.<DD><CODE>renderbuffers</CODE> - Specifies the buffer in which the generated renderbuffer object names are stored.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>renderbuffers</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>renderbuffers</i>.remaining()</code> is less than <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, int[], int)"><CODE>GL20.glGenRenderbuffers(int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGenTextures(int, int[], int)"><!-- --></A><H3>
glGenTextures</H3>
<PRE>
void <B>glGenTextures</B>(int&nbsp;n,
                   int[]&nbsp;textures,
                   int&nbsp;offset)</PRE>
<DL>
<DD>Generate texture names.
 <h4>Description</h4>
 <p>
 <code>glGenTextures</code> returns <i><code>n</code></i> texture names in <i><code>textures</code></i>. There is no guarantee 
 that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was 
 in use immediately before the call to <code>glGenTextures</code>.
 </p>
 <p>
 The generated textures have no dimensionality; they assume the dimensionality of the texture target to which 
 they are first bound (see <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindTexture(int, int)"><CODE>glBindTexture</CODE></A>).
 </p>
 <p>
 Texture names returned by a call to <code>glGenTextures</code> are not returned by subsequent calls, unless they are first
 deleted with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, java.nio.IntBuffer)"><CODE>glDeleteTextures</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, int[], int)"><CODE>glDeleteTextures</CODE></A>.
 </p>
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> is negative.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsTexture(int)"><CODE>glIsTexture</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of texture names to be generated.<DD><CODE>textures</CODE> - Specifies an array in which the generated texture names are stored.<DD><CODE>offset</CODE> - The starting offset within the <i><code>textures</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>textures</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>textures</i>.length -
              <i>offset</i></code> is less than <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindTexture(int, int)"><CODE>GL20.glBindTexture(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteTextures(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, int[], int)"><CODE>GL20.glDeleteTextures(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>GL20.glGetIntegerv(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>GL20.glGetIntegerv(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, float[], int)"><CODE>GL20.glGetTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, int[], int)"><CODE>GL20.glGetTexParameteriv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, java.nio.IntBuffer)"><CODE>GL20.glGenTextures(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGenTextures(int, java.nio.IntBuffer)"><!-- --></A><H3>
glGenTextures</H3>
<PRE>
void <B>glGenTextures</B>(int&nbsp;n,
                   <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;textures)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, int[], int)"><CODE>glGenTextures</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> is negative.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of texture names to be generated.<DD><CODE>textures</CODE> - Specifies the buffer in which the generated texture names are stored.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>textures</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>textures</i>.remaining()</code> is less than <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, int[], int)"><CODE>GL20.glGenTextures(int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGenerateMipmap(int)"><!-- --></A><H3>
glGenerateMipmap</H3>
<PRE>
void <B>glGenerateMipmap</B>(int&nbsp;target)</PRE>
<DL>
<DD>Generate a complete set of mipmaps for a texture object.
 <p>
 <h4>Description</h4>
 <code>glGenerateMipmap</code> computes a complete set of 
 mipmap arrays derived from the zero level array. Array levels 
 up to and including the 1x1 dimension texture image are replaced 
 with the derived arrays, regardless of previous contents. 
 The zero level texture image is left unchanged.
 <p>
 The internal formats of the derived mipmap arrays all 
 match those of the zero level texture image. 
 The dimensions of the derived arrays are computed by 
 halving the width and height of the zero level 
 texture image, then in turn halving the dimensions 
 of each array level until the 1x1 dimension texture 
 image is reached.
 <p>
 The contents of the derived arrays are computed 
 by repeated filtered reduction of the zero level array. 
 No particular filter algorithm is required, 
 though a box filter is recommended. <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glHint(int, int)"><CODE>glHint</CODE></A> may 
 be called to express a preference for speed or 
 quality of filtering.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is 
  not <code>GL_TEXTURE_2D</code> or <code>GL_TEXTURE_CUBE_MAP</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if the texture bound to <i><code>target</code></i> is a cube map, 
  but its six faces do not share indentical widths, heights, formats, and types.
 <p><code>GL_INVALID_OPERATION</code> is generated if either the width or height 
  of the zero level array is not a power of two.
 <p><code>GL_INVALID_OPERATION</code> is generated if the zero level array is stored 
  in a compressed internal format.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the texture target of the texture object whose mipmaps 
  will be generated. Must be one of the following symbolic 
  constants: <code>GL_TEXTURE_2D</code> or <code>GL_TEXTURE_CUBE_MAP</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindTexture(int, int)"><CODE>GL20.glBindTexture(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFramebufferTexture2D(int, int, int, int, int)"><CODE>GL20.glFramebufferTexture2D(int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glHint(int, int)"><CODE>GL20.glHint(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetActiveAttrib(int, int, int[], int, int[], int)"><!-- --></A><H3>
glGetActiveAttrib</H3>
<PRE>
<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A> <B>glGetActiveAttrib</B>(int&nbsp;program,
                         int&nbsp;index,
                         int[]&nbsp;size,
                         int&nbsp;sizeOffset,
                         int[]&nbsp;type,
                         int&nbsp;typeOffset)</PRE>
<DL>
<DD>Return information about an active attribute variable.
 <p>
 <h4>Description</h4>
 <code>glGetActiveAttrib</code> returns information about an 
 active attribute variable in the program object specified 
 by <i><code>program</code></i>. The number of active attributes can be obtained 
 by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A> with the value <code>GL_ACTIVE_ATTRIBUTES</code>. 
 A value of 0 for <i><code>index</code></i> selects the first active attribute variable. 
 Permissible values for <i><code>index</code></i> range from 0 to the number of active 
 attribute variables minus 1.
 <p>
 Attribute variables have arbitrary names and obtain their values 
 through numbered generic vertex attributes. An attribute variable 
 is considered active if it is determined during the link operation 
 that it may be accessed during program execution. 
 Therefore, <i><code>program</code></i> should have previously been the target 
 of a call to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>glLinkProgram</CODE></A>, but it is not necessary for it 
 to have been linked successfully.
 <p>
 <code>glGetActiveAttrib</code> returns the name of the attribute variable indicated 
 by <i><code>index</code></i>.
 <p>
 The <i><code>type</code></i> argument will return the attribute variable's data type. 
 The symbolic constants <code>GL_FLOAT</code>, <code>GL_FLOAT_VEC2</code>, <code>GL_FLOAT_VEC3</code>, 
 <code>GL_FLOAT_VEC4</code>, <code>GL_FLOAT_MAT2</code>, <code>GL_FLOAT_MAT3</code>, or <code>GL_FLOAT_MAT4</code> 
 may be returned. The <i><code>size</code></i> argument will return the size of the attribute,
 in units of the type returned in <i><code>type</code></i>.
 <p>
 This function will return as much information as it can about the specified 
 active attribute variable. If no information is available then an empty string wil be returned.
 This situation could occur if this function 
 is called after a link operation that failed. If an error occurs, the return 
 values <i><code>size</code></i> and <i><code>type</code></i> will be unmodified
 and an empty string will be returned.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is greater than or equal to the 
  number of active attribute variables in <i><code>program</code></i>.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <i><code>GL_MAX_VERTEX_ATTRIBS</code></i>.
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A> 
  with argument <code>GL_ACTIVE_ATTRIBUTES</code> or <code>GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</code>.
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to be queried.<DD><CODE>index</CODE> - Specifies the index of the attribute variable to be queried.<DD><CODE>size</CODE> - An <code>int</code> array of length at least 1.
  Returns the size of the attribute variable. May be <code>null</code>.<DD><CODE>sizeOffset</CODE> - The starting offset within the <i><code>size</code></i> array.<DD><CODE>type</CODE> - An <code>int</code> array of length at least 1.
  Returns the data type of the attribute variable. May be <code>null</code>.<DD><CODE>typeOffset</CODE> - The starting offset within the <i><code>type</code></i> array.
<DT><B>Returns:</B><DD>A <A HREF="../../../../../java/lang/String.html" title="class in java.lang"><CODE>String</CODE></A> containing the name of the attribute variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>size</code></i> is
  non-<code>null</code> but <i><code>size</code></i>.length - <i><code>sizeOffset</code></i> is smaller than 1.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>sizeOffset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>type</code></i> is
  non-<code>null</code> but <i><code>type</code></i>.length - <i><code>typeOffset</code></i> is smaller than 1.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>typeOffset</code></i> is less than 0.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveAttrib(int, int, int, int[], int, int[], int, int[], int, byte[], int)"><CODE>GL20.glGetActiveAttrib(int, int, int, int[], int, int[], int, int[], int, byte[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindAttribLocation(int, int, java.lang.String)"><CODE>GL20.glBindAttribLocation(int, int, String)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveUniform(int, int, int[], int, int[], int)"><CODE>GL20.glGetActiveUniform(int, int, int[], int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib1fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, float[], int)"><CODE>GL20.glVertexAttrib1fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2f(int, float, float)"><CODE>GL20.glVertexAttrib2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib2fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, float[], int)"><CODE>GL20.glVertexAttrib2fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3f(int, float, float, float)"><CODE>GL20.glVertexAttrib3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib3fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, float[], int)"><CODE>GL20.glVertexAttrib3fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4f(int, float, float, float, float)"><CODE>GL20.glVertexAttrib4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib4fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, float[], int)"><CODE>GL20.glVertexAttrib4fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, int)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetActiveAttrib(int, int, int, int[], int, int[], int, int[], int, byte[], int)"><!-- --></A><H3>
glGetActiveAttrib</H3>
<PRE>
void <B>glGetActiveAttrib</B>(int&nbsp;program,
                       int&nbsp;index,
                       int&nbsp;bufSize,
                       int[]&nbsp;length,
                       int&nbsp;lengthOffset,
                       int[]&nbsp;size,
                       int&nbsp;sizeOffset,
                       int[]&nbsp;type,
                       int&nbsp;typeOffset,
                       byte[]&nbsp;name,
                       int&nbsp;nameOffset)</PRE>
<DL>
<DD>Return information about an active attribute variable.
 <p>
 <h4>Description</h4>
 <code>glGetActiveAttrib</code> returns information about an 
 active attribute variable in the program object specified 
 by <i><code>program</code></i>. The number of active attributes can be obtained 
 by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A> with the value <code>GL_ACTIVE_ATTRIBUTES</code>. 
 A value of 0 for <i><code>index</code></i> selects the first active attribute variable. 
 Permissible values for <i><code>index</code></i> range from 0 to the number of active 
 attribute variables minus 1.
 <p>
 Attribute variables have arbitrary names and obtain their values 
 through numbered generic vertex attributes. An attribute variable 
 is considered active if it is determined during the link operation 
 that it may be accessed during program execution. 
 Therefore, <i><code>program</code></i> should have previously been the target 
 of a call to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>glLinkProgram</CODE></A>, but it is not necessary for it 
 to have been linked successfully.
 <p>
 The size of the character buffer required to store the longest 
 attribute variable name in <i><code>program</code></i> can be obtained by 
 calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A> with the 
 value <code>GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</code>. 
 This value should be used to allocate a buffer of sufficient size to 
 store the returned attribute name. The size of this character buffer is 
 passed in <i><code>bufSize</code></i>, and the character buffer is passed in <i><code>name</code></i>.
 <p>
 <code>glGetActiveAttrib</code> returns the name of the attribute variable indicated 
 by <i><code>index</code></i>, storing it in the character buffer specified by <i><code>name</code></i>. 
 The actual number of characters written into this buffer is returned in <i><code>length</code></i>. If the length 
 of the returned string is not required, a value of <code>null</code> can be passed 
 in the <i><code>length</code></i> argument.
 <p>
 The <i><code>type</code></i> argument will return the attribute variable's data type. 
 The symbolic constants <code>GL_FLOAT</code>, <code>GL_FLOAT_VEC2</code>, <code>GL_FLOAT_VEC3</code>, 
 <code>GL_FLOAT_VEC4</code>, <code>GL_FLOAT_MAT2</code>, <code>GL_FLOAT_MAT3</code>, or <code>GL_FLOAT_MAT4</code> 
 may be returned. The <i><code>size</code></i> argument will return the size of the attribute,
 in units of the type returned in <i><code>type</code></i>.
 <p>
 This function will return as much information as it can about the specified 
 active attribute variable. If no information is available, <i><code>length</code></i> will be 0, 
 and <i><code>name</code></i> will be an empty string. This situation could occur if this function 
 is called after a link operation that failed. If an error occurs, the return 
 values <i><code>length</code></i>, <i><code>size</code></i>, <i><code>type</code></i>,
 and <i><code>name</code></i> will be unmodified.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is greater than or equal to the 
  number of active attribute variables in <i><code>program</code></i>.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>bufSize</code></i> is less than 0.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <i><code>GL_MAX_VERTEX_ATTRIBS</code></i>.
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A> 
  with argument <code>GL_ACTIVE_ATTRIBUTES</code> or <code>GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</code>.
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to be queried.<DD><CODE>index</CODE> - Specifies the index of the attribute variable to be queried.<DD><CODE>bufSize</CODE> - Specifies the maximum number of characters OpenGL is allowed to 
  write in the character buffer indicated by <i><code>name</code></i>.<DD><CODE>length</CODE> - An <code>int</code> array of length at least 1. 
  Returns the number of characters actually written by OpenGL 
  in the string indicated by <i><code>name</code></i> 
  if a value other than <code>null</code> is passed. May be <code>null</code>.<DD><CODE>lengthOffset</CODE> - The starting offset within the <i><code>length</code></i> array.<DD><CODE>size</CODE> - An <code>int</code> array of length at least 1.
  Returns the size of the attribute variable. May be <code>null</code>.<DD><CODE>sizeOffset</CODE> - The starting offset within the <i><code>size</code></i> array.<DD><CODE>type</CODE> - An <code>int</code> array of length at least 1.
  Returns the data type of the attribute variable. May be <code>null</code>.<DD><CODE>typeOffset</CODE> - The starting offset within the <i><code>type</code></i> array.<DD><CODE>name</CODE> - Returns a <code>byte[]</code> containing the name of the attribute variable.<DD><CODE>nameOffset</CODE> - The starting offset within the <i><code>name</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>length</code></i> is
  non-<code>null</code> but but <i><code>length</code></i>.length - <i><code>lengthOffset</code></i> is smaller than 1.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>lengthOffset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>size</code></i> is
  non-<code>null</code> but <i><code>size</code></i>.length - <i><code>sizeOffset</code></i> is smaller than 1.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>sizeOffset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>type</code></i> is
  non-<code>null</code> but <i><code>type</code></i>.length - <i><code>typeOffset</code></i> is smaller than 1.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>typeOffset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>name</code></i> is null.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>nameOffset</code></i> is less than 0.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveAttrib(int, int, int[], int, int[], int)"><CODE>GL20.glGetActiveAttrib(int, int, int[], int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindAttribLocation(int, int, java.lang.String)"><CODE>GL20.glBindAttribLocation(int, int, String)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveUniform(int, int, int[], int, int[], int)"><CODE>GL20.glGetActiveUniform(int, int, int[], int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib1fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, float[], int)"><CODE>GL20.glVertexAttrib1fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2f(int, float, float)"><CODE>GL20.glVertexAttrib2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib2fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, float[], int)"><CODE>GL20.glVertexAttrib2fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3f(int, float, float, float)"><CODE>GL20.glVertexAttrib3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib3fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, float[], int)"><CODE>GL20.glVertexAttrib3fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4f(int, float, float, float, float)"><CODE>GL20.glVertexAttrib4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib4fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, float[], int)"><CODE>GL20.glVertexAttrib4fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, int)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetActiveUniform(int, int, int[], int, int[], int)"><!-- --></A><H3>
glGetActiveUniform</H3>
<PRE>
<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A> <B>glGetActiveUniform</B>(int&nbsp;program,
                          int&nbsp;index,
                          int[]&nbsp;size,
                          int&nbsp;sizeOffset,
                          int[]&nbsp;type,
                          int&nbsp;typeOffset)</PRE>
<DL>
<DD>Return information about an active uniform variable.
 <p>
 <h4>Description</h4>
 <code>glGetActiveUniform</code> returns information about an active 
 uniform variable in the program object specified by <i><code>program</code></i>. 
 The number of active uniform variables can be obtained by 
 calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A> 
 with the value <code>GL_ACTIVE_UNIFORMS</code>. 
 A value of 0 for <i><code>index</code></i> selects the first active uniform variable. 
 Permissible values for <i><code>index</code></i> range from 0 to the number of 
 active uniform variables minus 1.
 <p>
 Shaders may use either built-in uniform variables, 
 user-defined uniform variables, or both. Built-in uniform 
 variables have a prefix of "gl_" and reference existing OpenGL state 
 or values derived from such state (e.g., <i><code>gl_DepthRange</code></i>). 
 User-defined uniform variables have arbitrary names and obtain 
 their values from the application through calls to 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform1fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, float[], int)"><CODE>glUniform1fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1i(int, int)"><CODE>glUniform1i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, java.nio.IntBuffer)"><CODE>glUniform1iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, int[], int)"><CODE>glUniform1iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2f(int, float, float)"><CODE>glUniform2f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, float[], int)"><CODE>glUniform2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2i(int, int, int)"><CODE>glUniform2i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, java.nio.IntBuffer)"><CODE>glUniform2iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, int[], int)"><CODE>glUniform2iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3f(int, float, float, float)"><CODE>glUniform3f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, float[], int)"><CODE>glUniform3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3i(int, int, int, int)"><CODE>glUniform3i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, java.nio.IntBuffer)"><CODE>glUniform3iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, int[], int)"><CODE>glUniform3iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4f(int, float, float, float, float)"><CODE>glUniform4f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, float[], int)"><CODE>glUniform4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4i(int, int, int, int, int)"><CODE>glUniform4i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, java.nio.IntBuffer)"><CODE>glUniform4iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, int[], int)"><CODE>glUniform4iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>glUniformMatrix2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, float[], int)"><CODE>glUniformMatrix2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>glUniformMatrix3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, float[], int)"><CODE>glUniformMatrix3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>glUniformMatrix4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, float[], int)"><CODE>glUniformMatrix4fv</CODE></A>. 
 A uniform variable (either built-in or user-defined) is considered 
 active if it is determined during the link operation that it may be 
 accessed during program execution. Therefore, <i><code>program</code></i> should have 
 previously been the target of a call to 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>glLinkProgram</CODE></A>, but it is not 
 necessary for it to have been linked successfully.
 <p>
 <code>glGetActiveUniform</code> returns the name of the uniform variable 
 indicated by <i><code>index</code></i>.
 <p>
 The <i><code>type</code></i> argument will return the uniform variable's 
 data type. The symbolic constants <code>GL_FLOAT</code>, <code>GL_FLOAT_VEC2</code>, 
 <code>GL_FLOAT_VEC3</code>, <code>GL_FLOAT_VEC4</code>, <code>GL_INT</code>, <code>GL_INT_VEC2</code>, 
 <code>GL_INT_VEC3</code>, <code>GL_INT_VEC4</code>, <code>GL_BOOL</code>, <code>GL_BOOL_VEC2</code>, 
 <code>GL_BOOL_VEC3</code>, <code>GL_BOOL_VEC4</code>, <code>GL_FLOAT_MAT2</code>, <code>GL_FLOAT_MAT3</code>, 
 <code>GL_FLOAT_MAT4</code>, <code>GL_SAMPLER_2D</code>, or <code>GL_SAMPLER_CUBE</code> 
 may be returned.
 <p>
 If one or more elements of an array are active, the name of 
 the array is returned, the type is returned in <i><code>type</code></i>, 
 and the <i><code>size</code></i> parameter returns the highest array element 
 index used, plus one, as determined by the compiler and/or linker. 
 Only one active uniform variable will be reported for a uniform array.
 <p>
 Uniform variables that are declared as structures or arrays of 
 structures will not be returned directly by this function. Instead, 
 each of these uniform variables will be reduced to its fundamental 
 components containing the "." and "[]" operators such that each 
 of the names is valid as an argument to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformLocation(int, java.lang.String)"><CODE>glGetUniformLocation</CODE></A>. 
 Each of these reduced uniform variables is counted as one active 
 uniform variable and is assigned an index. A valid name cannot 
 be a structure, an array of structures, or a subcomponent of a 
 vector or matrix.
 <p>
 The size of the uniform variable will be returned in <i><code>size</code></i>. 
 Uniform variables other than arrays will have a size of 1. 
 Structures and arrays of structures will be reduced as described earlier, 
 such that each of the names returned will be a data type in the earlier list. 
 If this reduction results in an array, the size returned will be as described 
 for uniform arrays; otherwise, the size returned will be 1.
 <p>
 The list of active uniform variables may include both built-in uniform 
 variables (which begin with the prefix "gl_") as well as user-defined 
 uniform variable names.
 <p>
 This function will return as much information as it can about the 
 specified active uniform variable. If no information is available then  
 an empty string will be returned. This situation 
 could occur if this function is called after a link 
 operation that failed. If an error occurs, the return values 
 <i><code>size</code></i> and <i><code>type</code></i>
 will be unmodified and an empty string will be returned.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is greater than or equal to 
        the number of active uniform variables in <i><code>program</code></i>.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_MAX_VERTEX_UNIFORM_VECTORS</code> or <code>GL_MAX_FRAGMENT_UNIFORM_VECTORS</code>.
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A> 
  with argument <code>GL_ACTIVE_UNIFORMS</code> or <code>GL_ACTIVE_UNIFORM_MAX_LENGTH</code>.
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to be queried.<DD><CODE>index</CODE> - Specifies the index of the uniform variable to be queried.<DD><CODE>size</CODE> - An <code>int</code> array of length at least 1. 
  Returns the size of the uniform variable. May be <code>null</code>.<DD><CODE>sizeOffset</CODE> - The starting offset within the <i><code>size</code></i> array.<DD><CODE>type</CODE> - An <code>int</code> array of length at least 1.
  Returns the data type of the uniform variable. May be <code>null</code>.<DD><CODE>typeOffset</CODE> - The starting offset within the <i><code>type</code></i> array.
<DT><B>Returns:</B><DD>A <A HREF="../../../../../java/lang/String.html" title="class in java.lang"><CODE>String</CODE></A> containing the name of the uniform variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>size</code></i> is
  non-<code>null</code> but <i><code>size</code></i>.length - <i><code>sizeOffset</code></i> is smaller than 1.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>sizeOffset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>type</code></i> is
  non-<code>null</code> but <i><code>type</code></i>.length - <i><code>typeOffset</code></i> is smaller than 1.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>typeOffset</code></i> is less than 0.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveUniform(int, int, int, int[], int, int[], int, int[], int, byte[], int)"><CODE>GL20.glGetActiveUniform(int, int, int, int[], int, int[], int, int[], int, byte[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveAttrib(int, int, int[], int, int[], int)"><CODE>GL20.glGetActiveAttrib(int, int, int[], int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetUniformfv(int, int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, float[], int)"><CODE>GL20.glGetUniformfv(int, int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, java.nio.IntBuffer)"><CODE>GL20.glGetUniformiv(int, int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>GL20.glGetUniformiv(int, int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformLocation(int, java.lang.String)"><CODE>GL20.glGetUniformLocation(int, String)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform1fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, float[], int)"><CODE>GL20.glUniform1fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1i(int, int)"><CODE>GL20.glUniform1i(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform1iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, int[], int)"><CODE>GL20.glUniform1iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2f(int, float, float)"><CODE>GL20.glUniform2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform2fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, float[], int)"><CODE>GL20.glUniform2fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2i(int, int, int)"><CODE>GL20.glUniform2i(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform2iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, int[], int)"><CODE>GL20.glUniform2iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3f(int, float, float, float)"><CODE>GL20.glUniform3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform3fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, float[], int)"><CODE>GL20.glUniform3fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3i(int, int, int, int)"><CODE>GL20.glUniform3i(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform3iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, int[], int)"><CODE>GL20.glUniform3iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4f(int, float, float, float, float)"><CODE>GL20.glUniform4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform4fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, float[], int)"><CODE>GL20.glUniform4fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4i(int, int, int, int, int)"><CODE>GL20.glUniform4i(int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform4iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, int[], int)"><CODE>GL20.glUniform4iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix2fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix2fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix3fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix3fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix4fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix4fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>GL20.glUseProgram(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetActiveUniform(int, int, int, int[], int, int[], int, int[], int, byte[], int)"><!-- --></A><H3>
glGetActiveUniform</H3>
<PRE>
void <B>glGetActiveUniform</B>(int&nbsp;program,
                        int&nbsp;index,
                        int&nbsp;bufSize,
                        int[]&nbsp;length,
                        int&nbsp;lengthOffset,
                        int[]&nbsp;size,
                        int&nbsp;sizeOffset,
                        int[]&nbsp;type,
                        int&nbsp;typeOffset,
                        byte[]&nbsp;name,
                        int&nbsp;nameOffset)</PRE>
<DL>
<DD>Return information about an active uniform variable.
 <p>
 <h4>Description</h4>
 <code>glGetActiveUniform</code> returns information about an active 
 uniform variable in the program object specified by <i><code>program</code></i>. 
 The number of active uniform variables can be obtained by 
 calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A> 
 with the value <code>GL_ACTIVE_UNIFORMS</code>. 
 A value of 0 for <i><code>index</code></i> selects the first active uniform variable. 
 Permissible values for <i><code>index</code></i> range from 0 to the number of 
 active uniform variables minus 1.
 <p>
 Shaders may use either built-in uniform variables, 
 user-defined uniform variables, or both. Built-in uniform 
 variables have a prefix of "gl_" and reference existing OpenGL state 
 or values derived from such state (e.g., <i><code>gl_DepthRange</code></i>). 
 User-defined uniform variables have arbitrary names and obtain 
 their values from the application through calls to 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform1fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, float[], int)"><CODE>glUniform1fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1i(int, int)"><CODE>glUniform1i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, java.nio.IntBuffer)"><CODE>glUniform1iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, int[], int)"><CODE>glUniform1iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2f(int, float, float)"><CODE>glUniform2f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, float[], int)"><CODE>glUniform2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2i(int, int, int)"><CODE>glUniform2i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, java.nio.IntBuffer)"><CODE>glUniform2iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, int[], int)"><CODE>glUniform2iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3f(int, float, float, float)"><CODE>glUniform3f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, float[], int)"><CODE>glUniform3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3i(int, int, int, int)"><CODE>glUniform3i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, java.nio.IntBuffer)"><CODE>glUniform3iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, int[], int)"><CODE>glUniform3iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4f(int, float, float, float, float)"><CODE>glUniform4f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, float[], int)"><CODE>glUniform4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4i(int, int, int, int, int)"><CODE>glUniform4i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, java.nio.IntBuffer)"><CODE>glUniform4iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, int[], int)"><CODE>glUniform4iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>glUniformMatrix2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, float[], int)"><CODE>glUniformMatrix2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>glUniformMatrix3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, float[], int)"><CODE>glUniformMatrix3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>glUniformMatrix4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, float[], int)"><CODE>glUniformMatrix4fv</CODE></A>. 
 A uniform variable (either built-in or user-defined) is considered 
 active if it is determined during the link operation that it may be 
 accessed during program execution. Therefore, <i><code>program</code></i> should have 
 previously been the target of a call to 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>glLinkProgram</CODE></A>, but it is not 
 necessary for it to have been linked successfully.
 <p>
 The size of the character buffer required to store the longest 
 uniform variable name in <i><code>program</code></i> can be obtained by 
 calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A> 
 with the value <code>GL_ACTIVE_UNIFORM_MAX_LENGTH</code>. 
 This value should be used to allocate a buffer of sufficient size to 
 store the returned uniform variable name. The size of this character 
 buffer is passed in <i><code>bufSize</code></i>, and the character 
 buffer itself is passed in <i><code>name</code></i>.
 <p>
 <code>glGetActiveUniform</code> returns the name of the uniform variable 
 indicated by <i><code>index</code></i>, storing it in the character buffer 
 specified by <i><code>name</code></i>.
 The actual number of characters written into this buffer is 
 returned in <i><code>length</code></i>. If the length of the returned string 
 is not required, a value of <code>null</code> can be passed in the 
 <i><code>length</code></i> argument.
 <p>
 The <i><code>type</code></i> argument will return the uniform variable's 
 data type. The symbolic constants <code>GL_FLOAT</code>, <code>GL_FLOAT_VEC2</code>, 
 <code>GL_FLOAT_VEC3</code>, <code>GL_FLOAT_VEC4</code>, <code>GL_INT</code>, <code>GL_INT_VEC2</code>, 
 <code>GL_INT_VEC3</code>, <code>GL_INT_VEC4</code>, <code>GL_BOOL</code>, <code>GL_BOOL_VEC2</code>, 
 <code>GL_BOOL_VEC3</code>, <code>GL_BOOL_VEC4</code>, <code>GL_FLOAT_MAT2</code>, <code>GL_FLOAT_MAT3</code>, 
 <code>GL_FLOAT_MAT4</code>, <code>GL_SAMPLER_2D</code>, or <code>GL_SAMPLER_CUBE</code> 
 may be returned.
 <p>
 If one or more elements of an array are active, the name of 
 the array is returned in <i><code>name</code></i>, the type is returned in <i><code>type</code></i>, 
 and the <i><code>size</code></i> parameter returns the highest array element 
 index used, plus one, as determined by the compiler and/or linker. 
 Only one active uniform variable will be reported for a uniform array.
 <p>
 Uniform variables that are declared as structures or arrays of 
 structures will not be returned directly by this function. Instead, 
 each of these uniform variables will be reduced to its fundamental 
 components containing the "." and "[]" operators such that each 
 of the names is valid as an argument to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformLocation(int, java.lang.String)"><CODE>glGetUniformLocation</CODE></A>. 
 Each of these reduced uniform variables is counted as one active 
 uniform variable and is assigned an index. A valid name cannot 
 be a structure, an array of structures, or a subcomponent of a 
 vector or matrix.
 <p>
 The size of the uniform variable will be returned in <i><code>size</code></i>. 
 Uniform variables other than arrays will have a size of 1. 
 Structures and arrays of structures will be reduced as described earlier, 
 such that each of the names returned will be a data type in the earlier list. 
 If this reduction results in an array, the size returned will be as described 
 for uniform arrays; otherwise, the size returned will be 1.
 <p>
 The list of active uniform variables may include both built-in uniform 
 variables (which begin with the prefix "gl_") as well as user-defined 
 uniform variable names.
 <p>
 This function will return as much information as it can about the 
 specified active uniform variable. If no information is available, 
 <i><code>length</code></i> will be 0, and <i><code>name</code></i>
 will be an empty string. This situation 
 could occur if this function is called after a link 
 operation that failed. If an error occurs, the return values 
 <i><code>length</code></i>, <i><code>size</code></i>, <i><code>type</code></i>,
 and <i><code>name</code></i> will be unmodified.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is greater than or equal to 
        the number of active uniform variables in <i><code>program</code></i>.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>bufSize</code></i> is less than 0.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_MAX_VERTEX_UNIFORM_VECTORS</code> or <code>GL_MAX_FRAGMENT_UNIFORM_VECTORS</code>.
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A> 
  with argument <code>GL_ACTIVE_UNIFORMS</code> or <code>GL_ACTIVE_UNIFORM_MAX_LENGTH</code>.
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to be queried.<DD><CODE>index</CODE> - Specifies the index of the uniform variable to be queried.<DD><CODE>bufSize</CODE> - Specifies the maximum number of characters OpenGL is 
  allowed to write in the character buffer indicated by <i><code>name</code></i>.<DD><CODE>length</CODE> - An <code>int</code> array of length at least 1.
  Returns the number of characters actually written by OpenGL in the string indicated
  by <i><code>name</code></i> if a value other than <code>null</code> is passed. May be <code>null</code>.<DD><CODE>lengthOffset</CODE> - The starting offset within the <i><code>length</code></i> array.<DD><CODE>size</CODE> - An <code>int</code> array of length at least 1. 
  Returns the size of the uniform variable. May be <code>null</code>.<DD><CODE>sizeOffset</CODE> - The starting offset within the <i><code>size</code></i> array.<DD><CODE>type</CODE> - An <code>int</code> array of length at least 1.
  Returns the data type of the uniform variable. May be <code>null</code>.<DD><CODE>typeOffset</CODE> - The starting offset within the <i><code>type</code></i> array.<DD><CODE>name</CODE> - Returns a <code>byte[]</code> containing the name of the uniform variable.<DD><CODE>nameOffset</CODE> - The starting offset within the <i><code>name</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>length</code></i> is
  non-<code>null</code> but <i><code>length</code></i>.length - <i><code>lengthOffset</code></i> is smaller than 1.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>lengthOffset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>size</code></i> is
  non-<code>null</code> but <i><code>size</code></i>.length - <i><code>sizeOffset</code></i> is smaller than 1.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>sizeOffset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>type</code></i> is
  non-<code>null</code> but <i><code>type</code></i>.length - <i><code>typeOffset</code></i> is smaller than 1.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>typeOffset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>name</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>nameOffset</code></i> is less than 0.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveUniform(int, int, int[], int, int[], int)"><CODE>GL20.glGetActiveUniform(int, int, int[], int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveAttrib(int, int, int[], int, int[], int)"><CODE>GL20.glGetActiveAttrib(int, int, int[], int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetUniformfv(int, int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, float[], int)"><CODE>GL20.glGetUniformfv(int, int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, java.nio.IntBuffer)"><CODE>GL20.glGetUniformiv(int, int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>GL20.glGetUniformiv(int, int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformLocation(int, java.lang.String)"><CODE>GL20.glGetUniformLocation(int, String)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform1fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, float[], int)"><CODE>GL20.glUniform1fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1i(int, int)"><CODE>GL20.glUniform1i(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform1iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, int[], int)"><CODE>GL20.glUniform1iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2f(int, float, float)"><CODE>GL20.glUniform2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform2fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, float[], int)"><CODE>GL20.glUniform2fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2i(int, int, int)"><CODE>GL20.glUniform2i(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform2iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, int[], int)"><CODE>GL20.glUniform2iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3f(int, float, float, float)"><CODE>GL20.glUniform3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform3fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, float[], int)"><CODE>GL20.glUniform3fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3i(int, int, int, int)"><CODE>GL20.glUniform3i(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform3iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, int[], int)"><CODE>GL20.glUniform3iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4f(int, float, float, float, float)"><CODE>GL20.glUniform4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform4fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, float[], int)"><CODE>GL20.glUniform4fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4i(int, int, int, int, int)"><CODE>GL20.glUniform4i(int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform4iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, int[], int)"><CODE>GL20.glUniform4iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix2fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix2fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix3fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix3fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix4fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix4fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>GL20.glUseProgram(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetAttachedShaders(int, int, int[], int, int[], int)"><!-- --></A><H3>
glGetAttachedShaders</H3>
<PRE>
void <B>glGetAttachedShaders</B>(int&nbsp;program,
                          int&nbsp;maxcount,
                          int[]&nbsp;count,
                          int&nbsp;countOffset,
                          int[]&nbsp;shaders,
                          int&nbsp;shadersOffset)</PRE>
<DL>
<DD>Return the handles of the shader objects attached to a program object
 <p>
 <h4>Description</h4>
 <code>glGetAttachedShaders</code> returns the names of the shader 
 objects attached to <i><code>program</code></i>. The names of shader objects that are 
 attached to <i><code>program</code></i> will be returned in <i><code>shaders</code></i>.
 The actual number of shader names written into <i><code>shaders</code></i>
 is returned in <i><code>count</code></i>. If no shader objects are 
 attached to <i><code>program</code></i>, <i><code>count</code></i> is set to 0. 
 The maximum number of shader names that may be returned in <i><code>shaders</code></i> 
 is specified by <i><code>maxcount</code></i>.
 <p>
 If the number of names actually returned is not required 
 (for instance, if it has just been obtained by calling 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A>), 
 a value of <code>null</code> may be passed for <i><code>count</code></i>.
 If no shader objects are attached to <i><code>program</code></i>, a value
 of 0 will be returned in <i><code>count</code></i>. 
 The actual number of attached shaders can be obtained by 
 calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A> with the value <code>GL_ATTACHED_SHADERS</code>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is not a value generated by OpenGL. 
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>maxcount</code></i> is less than 0.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A> with argument <code>GL_ATTACHED_SHADERS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to be queried.<DD><CODE>maxcount</CODE> - Specifies the size of the array for storing the 
  returned object names.<DD><CODE>count</CODE> - An <code>int</code> array of length at least 1. 
  Returns the number of names actually returned in <i><code>shaders</code></i>.
  May be <code>null</code>.<DD><CODE>countOffset</CODE> - The starting offset within the <i><code>count</code></i> array.<DD><CODE>shaders</CODE> - Specifies an array that is used to return the 
  names of attached shader objects.<DD><CODE>shadersOffset</CODE> - The starting offset within the <i><code>shaders</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>countOffset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>count</code></i> is
  non-<code>null</code> but <i><code>count</code></i>.length - <i><code>countOffset</code></i> is smaller than 1.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>shaders</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>shadersOffset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>shaders</i>.length -
              <i><code>shadersOffset</i></code> is less than <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glAttachShader(int, int)"><CODE>GL20.glAttachShader(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDetachShader(int, int)"><CODE>GL20.glDetachShader(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, java.nio.IntBuffer, java.nio.IntBuffer)"><CODE>GL20.glGetAttachedShaders(int, int, IntBuffer, IntBuffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetAttachedShaders(int, int, java.nio.IntBuffer, java.nio.IntBuffer)"><!-- --></A><H3>
glGetAttachedShaders</H3>
<PRE>
void <B>glGetAttachedShaders</B>(int&nbsp;program,
                          int&nbsp;maxcount,
                          <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;count,
                          <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;shaders)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, int[], int, int[], int)"><CODE>glGetAttachedShaders</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is not a value generated by OpenGL. 
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>maxcount</code></i> is less than 0.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to be queried.<DD><CODE>maxcount</CODE> - Specifies the size of the array for storing the 
  returned object names.<DD><CODE>count</CODE> - Specifies the buffer that is used to
  return the number of names actually returned in <i><code>shaders</code></i>.
  May be <code>null</code>.<DD><CODE>shaders</CODE> - Specifies the buffer that is used to return the 
  names of attached shader objects.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>count</code></i> is
  non-<code>null</code> but <code><i>count</i>.remaining()</code> is less than 1.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>shaders</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>shaders</i>.remaining()</code> is less than <i><code>n</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, int[], int, int[], int)"><CODE>GL20.glGetAttachedShaders(int, int, int[], int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetAttribLocation(int, java.lang.String)"><!-- --></A><H3>
glGetAttribLocation</H3>
<PRE>
int <B>glGetAttribLocation</B>(int&nbsp;program,
                        <A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;name)</PRE>
<DL>
<DD>Return the location of an attribute variable.
 <p>
 <h4>Description</h4>
 <code>glGetAttribLocation</code> queries the previously linked program object 
 specified by <i><code>program</code></i> for the attribute variable specified by <i><code>name</code></i> and returns 
 the index of the generic vertex attribute that is bound to that attribute variable. 
 If <i><code>name</code></i> is a matrix attribute variable, the index of the first column of the 
 matrix is returned. If the named attribute variable is not an active 
 attribute in the specified program object or if <i><code>name</code></i> starts with the 
 reserved prefix "gl_", a value of -1 is returned.
 <p>
 The association between an attribute variable name and a generic 
 attribute index can be specified at any time by calling
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindAttribLocation(int, int, java.lang.String)"><CODE>glBindAttribLocation</CODE></A>.
 Attribute bindings do not go into effect until 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>glLinkProgram</CODE></A> is called. After a program 
 object has been linked successfully, the index values for attribute 
 variables remain fixed until the next link command occurs. 
 The attribute values can only be queried after a link if the 
 link was successful. <code>glGetAttribLocation</code> returns the binding 
 that actually went into effect the last time <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>glLinkProgram</CODE></A> was 
 called for the specified program object. Attribute bindings that 
 have been specified since the last link operation are not 
 returned by <code>glGetAttribLocation</code>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> has not been successfully linked.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveAttrib(int, int, int[], int, int[], int)"><CODE>glGetActiveAttrib</CODE></A>
  with argument <i><code>program</code></i> and the index of an active attribute
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to be queried.<DD><CODE>name</CODE> - A string containing the name of the attribute variable whose location is to be queried.
<DT><B>Returns:</B><DD>The location of an attribute variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>name</code></i> is <code>null</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindAttribLocation(int, int, java.lang.String)"><CODE>GL20.glBindAttribLocation(int, int, String)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib1fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, float[], int)"><CODE>GL20.glVertexAttrib1fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2f(int, float, float)"><CODE>GL20.glVertexAttrib2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib2fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, float[], int)"><CODE>GL20.glVertexAttrib2fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3f(int, float, float, float)"><CODE>GL20.glVertexAttrib3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib3fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, float[], int)"><CODE>GL20.glVertexAttrib3fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4f(int, float, float, float, float)"><CODE>GL20.glVertexAttrib4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib4fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, float[], int)"><CODE>GL20.glVertexAttrib4fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, int)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetBooleanv(int, boolean[], int)"><!-- --></A><H3>
glGetBooleanv</H3>
<PRE>
void <B>glGetBooleanv</B>(int&nbsp;pname,
                   boolean[]&nbsp;params,
                   int&nbsp;offset)</PRE>
<DL>
<DD>Boolean version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>.
 <p>
 <b>Note:</b>
 Type conversion is performed if <i><code>params</code></i> has a different type 
 than the state variable value being requested. When <code>glGetBooleanv</code> 
 is called, a floating-point (or integer) value is converted 
 to <code>GL_FALSE</code> if and only if it is 0.0 (or 0). Otherwise, 
 it is converted to <code>GL_TRUE</code>.
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not one of the
  values listed in the documention for <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>GL20.glGetIntegerv(int, int[], int)</CODE></A>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pname</CODE> - Specifies the parameter value to be returned. 
  The symbolic constants in the list above are accepted.<DD><CODE>params</CODE> - Returns the value or values of the specified parameter.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length -
              <i>offset</i></code> is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>GL20.glGetIntegerv(int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetBooleanv(int, java.nio.IntBuffer)"><!-- --></A><H3>
glGetBooleanv</H3>
<PRE>
void <B>glGetBooleanv</B>(int&nbsp;pname,
                   <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Boolean version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>. A
 value of 0 represents <code>false</code> and a value of 1
 represents <code>true</code>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not one of the 
  values listed in the documention for <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>GL20.glGetIntegerv(int, int[], int)</CODE></A>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pname</CODE> - Specifies the parameter value to be returned. 
  The symbolic constants in the list above are accepted.<DD><CODE>params</CODE> - Returns the value or values of the specified parameter.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> 
             is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>GL20.glGetIntegerv(int, IntBuffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetBufferParameteriv(int, int, int[], int)"><!-- --></A><H3>
glGetBufferParameteriv</H3>
<PRE>
void <B>glGetBufferParameteriv</B>(int&nbsp;target,
                            int&nbsp;pname,
                            int[]&nbsp;params,
                            int&nbsp;offset)</PRE>
<DL>
<DD>Return parameters of a buffer object.
 <p>
 <h4>Description</h4>
 <code>glGetBufferParameteriv</code> returns in <i><code>data</code></i> a selected 
 parameter of the buffer object specified by <i><code>target</code></i>.
 <p>
 <i><code>value</code></i> names a specific buffer object parameter, as follows:
 <p>
 <code>GL_BUFFER_SIZE</code>
 <p>
 <i><code>params</code></i> returns the size of the buffer object, measured in bytes. The initial value is 0.
 <p>
 <code>GL_BUFFER_USAGE</code>
 <p>
 <i><code>params</code></i> returns the buffer object's usage pattern. The initial value is <code>GL_STATIC_DRAW</code>.
 <p>
 <h4>Notes</h4>
 <p>
 If an error is generated, no change is made to the contents of <i><code>data</code></i>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i>
  or <i><code>pname</code></i> is not an accepted value.
 <p><code>GL_INVALID_OPERATION</code> is generated if the reserved buffer
  object name 0 is bound to <i><code>target</code></i>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target buffer object. 
  The symbolic constant must be <code>GL_ARRAY_BUFFER</code> or <code>GL_ELEMENT_ARRAY_BUFFER</code>.<DD><CODE>pname</CODE> - Specifies the symbolic name of a buffer object parameter. 
  Accepted values are <code>GL_BUFFER_SIZE</code> or <code>GL_BUFFER_USAGE</code>.<DD><CODE>params</CODE> - Returns the requested parameter.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length -
                  <i>offset</i></code> is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>GL20.glBindBuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBufferData(int, int, java.nio.Buffer, int)"><CODE>GL20.glBufferData(int, int, Buffer, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBufferParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetBufferParameteriv(int, int, IntBuffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetBufferParameteriv(int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glGetBufferParameteriv</H3>
<PRE>
void <B>glGetBufferParameteriv</B>(int&nbsp;target,
                            int&nbsp;pname,
                            <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBufferParameteriv(int, int, int[], int)"><CODE>glGetBufferParameteriv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i>
  or <i><code>pname</code></i> is not an accepted value.
 <p><code>GL_INVALID_OPERATION</code> is generated if the reserved buffer 
  object name 0 is bound to <i><code>target</code></i>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target buffer object. 
  The symbolic constant must be <code>GL_ARRAY_BUFFER</code> or <code>GL_ELEMENT_ARRAY_BUFFER</code>.<DD><CODE>pname</CODE> - Specifies the symbolic name of a buffer object parameter. 
  Accepted values are <code>GL_BUFFER_SIZE</code> or <code>GL_BUFFER_USAGE</code>.<DD><CODE>params</CODE> - Returns the requested parameter.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> 
             is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>GL20.glBindBuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBufferData(int, int, java.nio.Buffer, int)"><CODE>GL20.glBufferData(int, int, Buffer, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBufferParameteriv(int, int, int[], int)"><CODE>GL20.glGetBufferParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetError()"><!-- --></A><H3>
glGetError</H3>
<PRE>
int <B>glGetError</B>()</PRE>
<DL>
<DD>Return error information.
 <p>
 <h4>Description</h4>
 <code>glGetError</code> returns the value of the error flag. Each detectable 
 error is assigned a numeric code and symbolic name. When an error occurs, 
 the error flag is set to the appropriate error code value. No other errors are 
 recorded until <code>glGetError</code> is called, the error code is returned, and the flag 
 is reset to <code>GL_NO_ERROR</code>. If a call to <code>glGetError</code> returns <code>GL_NO_ERROR</code>, 
 there has been no detectable error since the last call to <code>glGetError</code>, 
 or since the GL was initialized.
 <p>
 To allow for distributed implementations, there may be several error flags. 
 If any single error flag has recorded an error, the value of that flag is 
 returned and that flag is reset to <code>GL_NO_ERROR</code> when <code>glGetError</code> is called. 
 If more than one flag has recorded an error, <code>glGetError</code> returns and clears 
 an arbitrary error flag value. Thus, <code>glGetError</code> should always be 
 called in a loop, until it returns <code>GL_NO_ERROR</code>, if all error 
 flags are to be reset.
 <p>
 Initially, all error flags are set to <code>GL_NO_ERROR</code>.
 <p>
 The following errors are currently defined:
 <p>
 <code>GL_NO_ERROR</code>
 <p>
 No error has been recorded. The value of this symbolic constant is guaranteed to be 0.
 <p>
 <code>GL_INVALID_ENUM</code>
 <p>
 An unacceptable value is specified for an enumerated argument. 
 The offending command is ignored and has no other side effect than to set the error flag.
 <p>
 <code>GL_INVALID_VALUE</code>
 <p>
 A numeric argument is out of range. The offending command is ignored and 
 has no other side effect than to set the error flag.
 <p>
 <code>GL_INVALID_OPERATION</code>
 <p>
 The specified operation is not allowed in the current state. 
 The offending command is ignored and has no other side effect than to set the error flag.
 <p>
 <code>GL_INVALID_FRAMEBUFFER_OPERATION</code>
 <p>
 The command is trying to render to or read from the framebuffer while the currently 
 bound framebuffer is not framebuffer complete (i.e. the return value 
 from <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)"><CODE>glCheckFramebufferStatus</CODE></A>
 is not <code>GL_FRAMEBUFFER_COMPLETE</code>). The offending command 
 is ignored and has no other side effect than to set the error flag.
 <p>
 <code>GL_OUT_OF_MEMORY</code>
 <p>
 There is not enough memory left to execute the command. 
 The state of the GL is undefined, except for the state of the error flags, 
 after this error is recorded.
 <p>
 When an error flag is set, results of a GL operation are undefined 
 only if <code>GL_OUT_OF_MEMORY</code> has occurred. In all other cases, the command generating 
 the error is ignored and has no effect on the GL state or frame buffer contents. 
 If the generating command returns a value, it returns 0.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>The value of the error flag.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)"><CODE>GL20.glCheckFramebufferStatus(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetFloatv(int, float[], int)"><!-- --></A><H3>
glGetFloatv</H3>
<PRE>
void <B>glGetFloatv</B>(int&nbsp;pname,
                 float[]&nbsp;params,
                 int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>.
 <p>
 <b>Note:</b>
 Type conversion is performed if <i><code>params</code></i> has a different type 
 than the state variable value being requested. When <code>glGetFloatv</code> is called, boolean values are 
 returned as <code>GL_TRUE</code> or <code>GL_FALSE</code>, and integer values are 
 converted to floating-point values. 
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not one of the
  values listed in the documention for <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pname</CODE> - Specifies the parameter value to be returned. 
  The symbolic constants in the list above are accepted.<DD><CODE>params</CODE> - Returns the value or values of the specified parameter.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length -
                  <i>offset</i></code> is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>GL20.glGetIntegerv(int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetFloatv(int, java.nio.FloatBuffer)"><!-- --></A><H3>
glGetFloatv</H3>
<PRE>
void <B>glGetFloatv</B>(int&nbsp;pname,
                 <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not one of the
  values listed in the documention for <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pname</CODE> - Specifies the parameter value to be returned. 
  The symbolic constants in the list above are accepted.<DD><CODE>params</CODE> - Returns the value or values of the specified parameter.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> 
              is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>GL20.glGetIntegerv(int, IntBuffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)"><!-- --></A><H3>
glGetFramebufferAttachmentParameteriv</H3>
<PRE>
void <B>glGetFramebufferAttachmentParameteriv</B>(int&nbsp;target,
                                           int&nbsp;attachment,
                                           int&nbsp;pname,
                                           int[]&nbsp;params,
                                           int&nbsp;offset)</PRE>
<DL>
<DD>Return attachment parameters of a framebuffer object.
 <p>
 <h4>Description</h4>
 <code>glGetFramebufferAttachmentParameteriv</code> returns in <i><code>params</code></i> a 
 selected attachment parameter of the attachpoint point <i><code>attachment</code></i> of 
 the currently bound framebuffer object.
 <p>
 <i><code>pname</code></i> names a specific framebuffer object attachment parameter, 
 as follows:
 <p>
 <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code>
 <p>
 <i><code>params</code></i> returns the type of object which contains the attached image, 
 either <code>GL_RENDERBUFFER</code>, <code>GL_TEXTURE</code>, or if no image is attached, <code>GL_NONE</code>. 
 The initial value is <code>GL_NONE</code>.
 <p>
 <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</code>
 <p>
 If the value of <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code> is <code>GL_RENDERBUFFER</code>, 
 <i><code>params</code></i> returns the name of the renderbuffer object which contains the attached image. 
 If the value of <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code> is <code>GL_TEXTURE</code>, 
 <i><code>params</code></i> returns the name of the texture object which contains the attached image. 
 The initial value is zero.
 <p>
 <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</code>
 <p>
 If the value of <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code> is <code>GL_TEXTURE</code>, 
 <i><code>params</code></i> returns the mipmap level of the texture object which contains 
 the attached image. The initial value is zero.
 <p>
 <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</code>
 <p>
 If the value of <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code> is <code>GL_TEXTURE</code> and 
 <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</code> is the name of a cube-map texture, 
 <i><code>params</code></i> returns the cube map face of the cube-map texture object which 
 contains the attached image. If the attached image is from a texture 
 object but not a cube-map, <i><code>params</code></i> returns 0. The initial value is 
 <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>.
 <p>
 <h4>Notes</h4>
 <p>
 If an error is generated, no change is made to the contents of <i><code>params</code></i>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not <code>GL_FRAMEBUFFER</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>attachment</code></i> is not 
  <code>GL_COLOR_ATTACHMENT0</code>, <code>GL_DEPTH_ATTACHMENT</code>, or <code>GL_STENCIL_ATTACHMENT</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if the attached object at the named 
  attachment point is <code>GL_RENDERBUFFER</code> and <i><code>pname</code></i> is not 
  <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code> or <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if the attached object at the named 
  attachment point is <code>GL_TEXTURE</code> and <i><code>pname</code></i> is not 
  <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code>, <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</code>, 
  <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</code>, or 
  <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if there is no attached object 
  at the named attachment point and <i><code>pname</code></i> is not 
  <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if the default 
  framebuffer object name 0 is bound.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target framebuffer object. 
  The symbolic constant must be <code>GL_FRAMEBUFFER</code>.<DD><CODE>attachment</CODE> - Specifies the symbolic name of a framebuffer object attachment point. 
  Accepted values are <code>GL_COLOR_ATTACHMENT0</code>, <code>GL_DEPTH_ATTACHMENT</code>,
  and <code>GL_STENCIL_ATTACHMENT</code>.<DD><CODE>pname</CODE> - Specifies the symbolic name of a framebuffer object attachment parameter. 
  Accepted values are <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code>, 
  <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</code>, <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</code>, and 
  <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</code>.<DD><CODE>params</CODE> - Returns the requested parameter.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length -
                  <i>offset</i></code> is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindFramebuffer(int, int)"><CODE>GL20.glBindFramebuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFramebufferRenderbuffer(int, int, int, int)"><CODE>GL20.glFramebufferRenderbuffer(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFramebufferTexture2D(int, int, int, int, int)"><CODE>GL20.glFramebufferTexture2D(int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, java.nio.IntBuffer)"><CODE>GL20.glGetFramebufferAttachmentParameteriv(int, int, int, IntBuffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetFramebufferAttachmentParameteriv(int, int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glGetFramebufferAttachmentParameteriv</H3>
<PRE>
void <B>glGetFramebufferAttachmentParameteriv</B>(int&nbsp;target,
                                           int&nbsp;attachment,
                                           int&nbsp;pname,
                                           <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)"><CODE>glGetFramebufferAttachmentParameteriv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not <code>GL_FRAMEBUFFER</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>attachment</code></i> is not 
  <code>GL_COLOR_ATTACHMENT0</code>, <code>GL_DEPTH_ATTACHMENT</code>, or <code>GL_STENCIL_ATTACHMENT</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if the attached object at the named 
  attachment point is <code>GL_RENDERBUFFER</code> and <i><code>pname</code></i> is not 
  <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code> or <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if the attached object at the named 
  attachment point is <code>GL_TEXTURE</code> and <i><code>pname</code></i> is not 
  <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code>, <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</code>, 
  <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</code>, or 
  <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if there is no attached object 
  at the named attachment point and <i><code>pname</code></i> is not 
  <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if the default 
  framebuffer object name 0 is bound.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target framebuffer object. 
  The symbolic constant must be <code>GL_FRAMEBUFFER</code>.<DD><CODE>attachment</CODE> - Specifies the symbolic name of a framebuffer object attachment point. 
  Accepted values are <code>GL_COLOR_ATTACHMENT0</code>, <code>GL_DEPTH_ATTACHMENT</code>,
  and <code>GL_STENCIL_ATTACHMENT</code>.<DD><CODE>pname</CODE> - Specifies the symbolic name of a framebuffer object attachment parameter. 
  Accepted values are <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE</code>, 
  <code>GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME</code>, <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL</code>, and 
  <code>GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE</code>.<DD><CODE>params</CODE> - Returns the requested parameter.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> 
                  is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindFramebuffer(int, int)"><CODE>GL20.glBindFramebuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFramebufferRenderbuffer(int, int, int, int)"><CODE>GL20.glFramebufferRenderbuffer(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFramebufferTexture2D(int, int, int, int, int)"><CODE>GL20.glFramebufferTexture2D(int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)"><CODE>GL20.glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetIntegerv(int, int[], int)"><!-- --></A><H3>
glGetIntegerv</H3>
<PRE>
void <B>glGetIntegerv</B>(int&nbsp;pname,
                   int[]&nbsp;params,
                   int&nbsp;offset)</PRE>
<DL>
<DD>Return the value or values of a selected parameter.
 <p>
 <h4>Description</h4>
 This command (and its corresponding boolean, float, and buffer commands)
 return values for simple state variables in GL. 
 <i><code>pname</code></i> is a symbolic constant indicating the state variable to be 
 returned, and <i><code>params</code></i> is an array in which to place the returned data.
 <p>
 Type conversion is performed if <i><code>params</code></i> has a different type 
 than the state variable value being requested. When <code>glGetIntegerv</code> is called, 
 boolean values are returned as <code>GL_TRUE</code> or <code>GL_FALSE</code>, and most 
 floating-point values are rounded to the nearest integer value. 
 Floating-point colors and normals, however, are returned with a 
 linear mapping that maps 1.0 to the most positive representable 
 integer value and -1.0 to the most negative representable 
 integer value.
 <p>
 The following symbolic constants are accepted by <i><code>pname</code></i>:
 <p>
 <code>GL_ACTIVE_TEXTURE</code>
 <p>
 <i><code>params</code></i> returns a single value indicating the active multitexture unit. 
 The initial value is <code>GL_TEXTURE0</code>. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>glActiveTexture</CODE></A>.
 <p>
 <code>GL_ALIASED_LINE_WIDTH_RANGE</code>
 <p>
 <i><code>params</code></i> returns two values, the smallest and largest supported 
 widths for aliased lines. The range must include width 1.
 <p>
 <code>GL_ALIASED_POINT_SIZE_RANGE</code>
 <p>
 <i><code>params</code></i> returns two values, the smallest and largest supported 
 sizes for aliased points. The range must include size 1.
 <p>
 <code>GL_ALPHA_BITS</code>
 <p>
 <i><code>params</code></i> returns one value, the number of alpha bitplanes in the 
 color buffer of the currently bound framebuffer.
 <p>
 <code>GL_ARRAY_BUFFER_BINDING</code>
 <p>
 <i><code>params</code></i> returns a single value, the name of the buffer object 
 currently bound to the target <code>GL_ARRAY_BUFFER</code>. If no buffer object 
 is bound to this target, 0 is returned. The initial value is 0. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>glBindBuffer</CODE></A>.
 <p>
 <code>GL_BLEND</code>
 <p>
 <i><code>params</code></i> returns a single boolean value indicating whether blending 
 is enabled. The initial value is <code>GL_FALSE</code>. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>glBlendFunc</CODE></A>.
 <p>
 <code>GL_BLEND_COLOR</code>
 <p>
 <i><code>params</code></i> returns four values, the red, green, blue, and alpha values 
 which are the components of the blend color. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendColor(float, float, float, float)"><CODE>glBlendColor</CODE></A>.
 <p>
 <code>GL_BLEND_DST_ALPHA</code>
 <p>
 <i><code>params</code></i> returns one value, the symbolic constant identifying the 
 alpha destination blend function. The initial value is <code>GL_ZERO</code>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>glBlendFunc</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFuncSeparate(int, int, int, int)"><CODE>glBlendFuncSeparate</CODE></A>.
 <p>
 <code>GL_BLEND_DST_RGB</code>
 <p>
 <i><code>params</code></i> returns one value, the symbolic constant identifying the RGB 
 destination blend function. The initial value is <code>GL_ZERO</code>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>glBlendFunc</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFuncSeparate(int, int, int, int)"><CODE>glBlendFuncSeparate</CODE></A>.
 <p>
 <code>GL_BLEND_EQUATION_ALPHA</code>
 <p>
 <i><code>params</code></i> returns one value, a symbolic constant indicating whether 
 the Alpha blend equation is <code>GL_FUNC_ADD</code>, <code>GL_FUNC_SUBTRACT</code>, or 
 <code>GL_FUNC_REVERSE_SUBTRACT</code>. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendEquationSeparate(int, int)"><CODE>glBlendEquationSeparate</CODE></A>.
 <p>
 <code>GL_BLEND_EQUATION_RGB</code>
 <p>
 <i><code>params</code></i> returns one value, a symbolic constant indicating whether 
 the RGB blend equation is <code>GL_FUNC_ADD</code>, <code>GL_FUNC_SUBTRACT</code>, or 
 <code>GL_FUNC_REVERSE_SUBTRACT</code>. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendEquationSeparate(int, int)"><CODE>glBlendEquationSeparate</CODE></A>.
 <p>
 <code>GL_BLEND_SRC_ALPHA</code>
 <p>
 <i><code>params</code></i> returns one value, the symbolic constant identifying 
 the alpha source blend function. The initial value is <code>GL_ONE</code>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>glBlendFunc</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFuncSeparate(int, int, int, int)"><CODE>glBlendFuncSeparate</CODE></A>.
 <p>
 <code>GL_BLEND_SRC_RGB</code>
 <p>
 <i><code>params</code></i> returns one value, the symbolic constant identifying 
 the RGB source blend function. The initial value is <code>GL_ONE</code>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>glBlendFunc</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFuncSeparate(int, int, int, int)"><CODE>glBlendFuncSeparate</CODE></A>.
 <p>
 <code>GL_BLUE_BITS</code>
 <p>
 <i><code>params</code></i> returns one value, the number of blue bitplanes in 
 the color buffer of the currently bound framebuffer.
 <p>
 <code>GL_COLOR_CLEAR_VALUE</code>
 <p>
 <i><code>params</code></i> returns four values: the red, green, blue, and alpha values 
 used to clear the color buffers. Integer values, if requested, 
 are linearly mapped from the internal floating-point representation 
 such that 1.0 returns the most positive representable integer 
 value, and -1.0 returns the most negative representable integer value. 
 The initial value is <code>(0, 0, 0, 0)</code>. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClearColor(float, float, float, float)"><CODE>glClearColor</CODE></A>.
 <p>
 <code>GL_COLOR_WRITEMASK</code>
 <p>
 <i><code>params</code></i> returns four boolean values: the red, green, blue, and alpha 
 write enables for the color buffers. The initial value 
 is <code>(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE)</code>. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glColorMask(boolean, boolean, boolean, boolean)"><CODE>glColorMask</CODE></A>.
 <p>
 <code>GL_COMPRESSED_TEXTURE_FORMATS</code>
 <p>     
 <i><code>params</code></i> returns a list of symbolic constants of length 
 <code>GL_NUM_COMPRESSED_TEXTURE_FORMATS</code> indicating which 
 compressed texture formats are available. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexImage2D(int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glCompressedTexImage2D</CODE></A>.
 <p>
 <code>GL_CULL_FACE</code>
 <p>
 <i><code>params</code></i> returns a single boolean value indicating whether 
 polygon culling is enabled. The initial value is <code>GL_FALSE</code>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCullFace(int)"><CODE>glCullFace</CODE></A>.
 <p>
 <code>GL_CULL_FACE_MODE</code>
 <p>
 <i><code>params</code></i> returns one value, a symbolic constant indicating 
 which polygon faces are to be culled. The initial value 
 is <code>GL_BACK</code>. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCullFace(int)"><CODE>glCullFace</CODE></A>.
 <p>
 <code>GL_CURRENT_PROGRAM</code>
 <p>
 <i><code>params</code></i> returns one value, the name of the program object that is 
 currently active, or 0 if no program object is active. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>glUseProgram</CODE></A>.
 <p>
 <code>GL_DEPTH_BITS</code>
 <p>     
 <i><code>params</code></i> returns one value, the number of bitplanes in the 
 depth buffer of the currently bound framebuffer.
 <p>
 <code>GL_DEPTH_CLEAR_VALUE</code>
 <p>
 <i><code>params</code></i> returns one value, the value that is used to clear 
 the depth buffer. Integer values, if requested, are linearly 
 mapped from the internal floating-point representation such 
 that 1.0 returns the most positive representable integer value, 
 and -1.0 returns the most negative representable integer value. 
 The initial value is 1. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClearDepthf(float)"><CODE>glClearDepthf</CODE></A>.
 <p>
 <code>GL_DEPTH_FUNC</code>
 <p>
 <i><code>params</code></i> returns one value, the symbolic constant that indicates 
 the depth comparison function. The initial value is <code>GL_LESS</code>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>glDepthFunc</CODE></A>.
 <p>
 <code>GL_DEPTH_RANGE</code>
 <p>
 <i><code>params</code></i> returns two values: the near and far mapping limits for 
 the depth buffer. Integer values, if requested, are linearly 
 mapped from the internal floating-point representation such 
 that 1.0 returns the most positive representable integer value, 
 and -1.0 returns the most negative representable integer value. 
 The initial value is <code>(0, 1)</code>. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthRangef(float, float)"><CODE>glDepthRangef</CODE></A>.
 <p>
 <code>GL_DEPTH_TEST</code>
 <p>
 <i><code>params</code></i> returns a single boolean value indicating whether depth 
 testing of fragments is enabled. The initial value is <code>GL_FALSE</code>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>glDepthFunc</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthRangef(float, float)"><CODE>glDepthRangef</CODE></A>.
 <p>
 <code>GL_DEPTH_WRITEMASK</code>
 <p>
 <i><code>params</code></i> returns a single boolean value indicating if the depth buffer 
 is enabled for writing. The initial value is <code>GL_TRUE</code>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthMask(boolean)"><CODE>glDepthMask</CODE></A>.
 <p>
 <code>GL_DITHER</code>
 <p>
 <i><code>params</code></i> returns a single boolean value indicating whether 
 dithering of fragment colors and indices is enabled. 
 The initial value is <code>GL_TRUE</code>.
 <p>
 <code>GL_ELEMENT_ARRAY_BUFFER_BINDING</code>
 <p>
 <i><code>params</code></i> returns a single value, the name of the buffer object 
 currently bound to the target <code>GL_ELEMENT_ARRAY_BUFFER</code>. 
 If no buffer object is bound to this target, 0 is returned. 
 The initial value is 0. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>glBindBuffer</CODE></A>.
 <p>
 <code>GL_FRAMEBUFFER_BINDING</code>
 <p>
 <i><code>params</code></i> returns a single value, the name of the currently 
 bound framebuffer. The initial value is 0, indicating 
 the default framebuffer. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindFramebuffer(int, int)"><CODE>glBindFramebuffer</CODE></A>.
 <p>
 <code>GL_FRONT_FACE</code>
 <p>
 <i><code>params</code></i> returns one value, a symbolic constant indicating 
 whether clockwise or counterclockwise polygon winding is 
 treated as front-facing. The initial value is <code>GL_CCW</code>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFrontFace(int)"><CODE>glFrontFace</CODE></A>.
 <p>
 <code>GL_GENERATE_MIPMAP_HINT</code>
 <p>
 <i><code>params</code></i> returns one value, a symbolic constant indicating 
 the mode of the mipmap generation filtering hint. 
 The initial value is <code>GL_DONT_CARE</code>. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glHint(int, int)"><CODE>glHint</CODE></A>.
 <p>
 <code>GL_GREEN_BITS</code>
 <p>
 <i><code>params</code></i> returns one value, the number of green 
 bitplanes in the color buffer of the currently 
 bound framebuffer.
 <p>
 <code>GL_IMPLEMENTATION_COLOR_READ_FORMAT</code>
 <p>
 <i><code>params</code></i> returns one value, the format chosen by the 
 implementation in which pixels may be read from the 
 color buffer of the currently bound framebuffer in 
 conjunction with <code>GL_IMPLEMENTATION_COLOR_READ_TYPE</code>. 
 In addition to this implementation-dependent format/type pair, 
 format <code>GL_RGBA</code> in conjunction with type <code>GL_UNSIGNED_BYTE</code> 
 is always allowed by every implementation, regardless 
 of the currently bound render surface. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReadPixels(int, int, int, int, int, int, java.nio.Buffer)"><CODE>glReadPixels</CODE></A>.
 <p>
 <code>GL_IMPLEMENTATION_COLOR_READ_TYPE</code>
 <p>
 <i><code>params</code></i> returns one value, the type chosen by the implementation 
 with which pixels may be read from the color buffer of the currently 
 bound framebuffer in conjunction with <code>GL_IMPLEMENTATION_COLOR_READ_FORMAT</code>. 
 In addition to this implementation-dependent format/type pair, 
 format <code>GL_RGBA</code> in conjunction with type <code>GL_UNSIGNED_BYTE</code> is 
 always allowed by every implementation, regardless of the 
 currently bound render surface. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReadPixels(int, int, int, int, int, int, java.nio.Buffer)"><CODE>glReadPixels</CODE></A>.
 <p>
 <code>GL_LINE_WIDTH</code>
 <p>
 <i><code>params</code></i> returns one value, the line width as specified 
 with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLineWidth(float)"><CODE>glLineWidth</CODE></A>. The initial value is 1.
 <p>
 <code>GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS</code>
 <p>
 <i><code>params</code></i> returns one value, the maximum supported 
 texture image units that can be used to access texture 
 maps from the vertex shader and the fragment processor combined. 
 If both the vertex shader and the fragment processing stage access 
 the same texture image unit, then that counts as using two texture 
 image units against this limit. The value must be at least 8. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>glActiveTexture</CODE></A>.
 <p>
 <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code>
 <p>
 <i><code>params</code></i> returns one value. The value gives a rough estimate of the 
 largest cube-map texture that the GL can handle.
 The value must be at least 16. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glTexImage2D</CODE></A>.
 <p>
 <code>GL_MAX_FRAGMENT_UNIFORM_VECTORS</code>
 <p>
 <i><code>params</code></i> returns one value, the maximum number of four-element 
 floating-point, integer, or boolean vectors that can be held 
 in uniform variable storage for a fragment shader. 
 The value must be at least 16. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform1fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, float[], int)"><CODE>glUniform1fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1i(int, int)"><CODE>glUniform1i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, java.nio.IntBuffer)"><CODE>glUniform1iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, int[], int)"><CODE>glUniform1iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2f(int, float, float)"><CODE>glUniform2f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, float[], int)"><CODE>glUniform2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2i(int, int, int)"><CODE>glUniform2i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, java.nio.IntBuffer)"><CODE>glUniform2iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, int[], int)"><CODE>glUniform2iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3f(int, float, float, float)"><CODE>glUniform3f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, float[], int)"><CODE>glUniform3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3i(int, int, int, int)"><CODE>glUniform3i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, java.nio.IntBuffer)"><CODE>glUniform3iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, int[], int)"><CODE>glUniform3iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4f(int, float, float, float, float)"><CODE>glUniform4f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, float[], int)"><CODE>glUniform4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4i(int, int, int, int, int)"><CODE>glUniform4i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, java.nio.IntBuffer)"><CODE>glUniform4iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, int[], int)"><CODE>glUniform4iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>glUniformMatrix2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, float[], int)"><CODE>glUniformMatrix2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>glUniformMatrix3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, float[], int)"><CODE>glUniformMatrix3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>glUniformMatrix4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, float[], int)"><CODE>glUniformMatrix4fv</CODE></A>.
 <p>
 <code>GL_MAX_RENDERBUFFER_SIZE</code>
 <p>
 <i><code>params</code></i> returns one value. The value indicates the largest 
 renderbuffer width and height that the GL can handle. 
 The value must be at least 1. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glRenderbufferStorage(int, int, int, int)"><CODE>glRenderbufferStorage</CODE></A>.
 <p>
 <code>GL_MAX_TEXTURE_IMAGE_UNITS</code>
 <p>
 <i><code>params</code></i> returns one value, the maximum supported texture image units 
 that can be used to access texture maps from the fragment shader. 
 The value must be at least 8. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>glActiveTexture</CODE></A>.
 <p>
 <code>GL_MAX_TEXTURE_SIZE</code>
 <p>
 <i><code>params</code></i> returns one value. The value gives a rough estimate of the 
 largest texture that the GL can handle. The value must be at least 64. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glTexImage2D</CODE></A>.
 <p>
 <code>GL_MAX_VARYING_VECTORS</code>
 <p>
 <i><code>params</code></i> returns one value, the maximum number four-element 
 floating-point vectors available for interpolating varying 
 variables used by vertex and fragment shaders. Varying variables 
 declared as matrices or arrays will consume multiple interpolators. 
 The value must be at least 8.
 <p>
 <code>GL_MAX_VERTEX_ATTRIBS</code>
 <p>
 <i><code>params</code></i> returns one value, the maximum number of 4-component 
 generic vertex attributes accessible to a vertex shader. 
 The value must be at least 8. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, java.nio.FloatBuffer)"><CODE>glVertexAttrib1fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, float[], int)"><CODE>glVertexAttrib1fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2f(int, float, float)"><CODE>glVertexAttrib2f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, java.nio.FloatBuffer)"><CODE>glVertexAttrib2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, float[], int)"><CODE>glVertexAttrib2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3f(int, float, float, float)"><CODE>glVertexAttrib3f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, java.nio.FloatBuffer)"><CODE>glVertexAttrib3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, float[], int)"><CODE>glVertexAttrib3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4f(int, float, float, float, float)"><CODE>glVertexAttrib4f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, java.nio.FloatBuffer)"><CODE>glVertexAttrib4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, float[], int)"><CODE>glVertexAttrib4fv</CODE></A>.
 <p>
 <code>GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS</code>
 <p>
 <i><code>params</code></i> returns one value, the maximum supported texture image 
 units that can be used to access texture maps from the vertex shader. 
 The value may be 0. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>glActiveTexture</CODE></A>.
 <p>
 <code>GL_MAX_VERTEX_UNIFORM_VECTORS</code>
 <p>
 <i><code>params</code></i> returns one value, the maximum number of four-element 
 floating-point, integer, or boolean vectors that can be held in 
 uniform variable storage for a vertex shader. 
 The value must be at least 128. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform1fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, float[], int)"><CODE>glUniform1fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1i(int, int)"><CODE>glUniform1i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, java.nio.IntBuffer)"><CODE>glUniform1iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, int[], int)"><CODE>glUniform1iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2f(int, float, float)"><CODE>glUniform2f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, float[], int)"><CODE>glUniform2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2i(int, int, int)"><CODE>glUniform2i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, java.nio.IntBuffer)"><CODE>glUniform2iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, int[], int)"><CODE>glUniform2iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3f(int, float, float, float)"><CODE>glUniform3f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, float[], int)"><CODE>glUniform3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3i(int, int, int, int)"><CODE>glUniform3i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, java.nio.IntBuffer)"><CODE>glUniform3iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, int[], int)"><CODE>glUniform3iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4f(int, float, float, float, float)"><CODE>glUniform4f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, float[], int)"><CODE>glUniform4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4i(int, int, int, int, int)"><CODE>glUniform4i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, java.nio.IntBuffer)"><CODE>glUniform4iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, int[], int)"><CODE>glUniform4iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>glUniformMatrix2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, float[], int)"><CODE>glUniformMatrix2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>glUniformMatrix3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, float[], int)"><CODE>glUniformMatrix3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>glUniformMatrix4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, float[], int)"><CODE>glUniformMatrix4fv</CODE></A>.
 <p>
 <code>GL_MAX_VIEWPORT_DIMS</code>
 <p>
 <i><code>params</code></i> returns two values: the maximum supported 
 width and height of the viewport. These must be at 
 least as large as the visible dimensions of the display 
 being rendered to. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glViewport(int, int, int, int)"><CODE>glViewport</CODE></A>.
 <p>
 <code>GL_NUM_COMPRESSED_TEXTURE_FORMATS</code>
 <p>
 <i><code>params</code></i> returns a single integer value indicating the 
 number of available compressed texture formats. 
 The minimum value is 0. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexImage2D(int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glCompressedTexImage2D</CODE></A>.
 <p>
 <code>GL_NUM_SHADER_BINARY_FORMATS</code>
 <p>
 <i><code>params</code></i> returns a single integer value indicating the 
 number of available shader binary formats. 
 The minimum value is 0. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, java.nio.IntBuffer, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A>.
 <p>
 <code>GL_PACK_ALIGNMENT</code>
 <p>
 <i><code>params</code></i> returns one value, the byte alignment used for 
 writing pixel data to memory. The initial value is 4. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPixelStorei(int, int)"><CODE>glPixelStorei</CODE></A>.
 <p>
 <code>GL_POLYGON_OFFSET_FACTOR</code>
 <p>
 <i><code>params</code></i> returns one value, the scaling factor used to determine 
 the variable offset that is added to the depth value of each fragment 
 generated when a polygon is rasterized. The initial value is 0. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPolygonOffset(float, float)"><CODE>glPolygonOffset</CODE></A>.
 <p>
 <code>GL_POLYGON_OFFSET_FILL</code>
 <p>
 <i><code>params</code></i> returns a single boolean value indicating whether polygon 
 offset is enabled for polygons in fill mode. The initial value is <code>GL_FALSE</code>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPolygonOffset(float, float)"><CODE>glPolygonOffset</CODE></A>.
 <p>
 <code>GL_POLYGON_OFFSET_UNITS</code>
 <p>
 <i><code>params</code></i> returns one value. This value is multiplied by an implementation-specific 
 value and then added to the depth value of each fragment generated when a polygon 
 is rasterized. The initial value is 0. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPolygonOffset(float, float)"><CODE>glPolygonOffset</CODE></A>.
 <p>
 <code>GL_RED_BITS</code>
 <p>
 <i><code>params</code></i> returns one value, the number of red bitplanes in the 
 color buffer of the currently bound framebuffer.
 <p>
 <code>GL_RENDERBUFFER_BINDING</code>
 <p>
 <i><code>params</code></i> returns a single value, the name of the currently bound renderbuffer. 
 The initial value is 0, indicating no renderbuffer is bound. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindRenderbuffer(int, int)"><CODE>glBindRenderbuffer</CODE></A>.
 <p>
 <code>GL_SAMPLE_ALPHA_TO_COVERAGE</code>
 <p>
 <i><code>params</code></i> returns a single boolean value indicating if the fragment coverage value
 should be <code>AND</code>ed with a temporary coverage value based on the fragment's alpha value. 
 The initial value is <code>GL_FALSE</code>. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glSampleCoverage(float, boolean)"><CODE>glSampleCoverage</CODE></A>.
 <p>
 <code>GL_SAMPLE_BUFFERS</code>
 <p>
 <i><code>params</code></i> returns a single integer value indicating the number of sample buffers 
 associated with the currently bound framebuffer. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glSampleCoverage(float, boolean)"><CODE>glSampleCoverage</CODE></A>.
 <p>
 <code>GL_SAMPLE_COVERAGE</code>
 <p>
 <i><code>params</code></i>  returns a single boolean value indicating if the fragment coverage value
 should be <code>AND</code>ed with a temporary coverage value based on the current sample coverage value. 
 The initial value is <code>GL_FALSE</code>. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glSampleCoverage(float, boolean)"><CODE>glSampleCoverage</CODE></A>.
 <p>
 <code>GL_SAMPLE_COVERAGE_INVERT</code>
 <p>
 <i><code>params</code></i> returns a single boolean value indicating if the 
 temporary coverage value should be inverted. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glSampleCoverage(float, boolean)"><CODE>glSampleCoverage</CODE></A>.
 <p>
 <code>GL_SAMPLE_COVERAGE_VALUE</code>
 <p>
 <i><code>params</code></i> returns a single positive floating-point value indicating 
 the current sample coverage value. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glSampleCoverage(float, boolean)"><CODE>glSampleCoverage</CODE></A>.
 <p>
 <code>GL_SAMPLES</code>
 <p>
 <i><code>params</code></i> returns a single integer value indicating the coverage mask 
 size of the currently bound framebuffer. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glSampleCoverage(float, boolean)"><CODE>glSampleCoverage</CODE></A>.
 <p>
 <code>GL_SCISSOR_BOX</code>
 <p>
 <i><code>params</code></i> returns four values: the x and y window coordinates of the scissor box, 
 followed by its width and height. Initially the x and y window coordinates are 
 both 0 and the width and height are set to the size of the window. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glScissor(int, int, int, int)"><CODE>glScissor</CODE></A>.
 <p>
 <code>GL_SCISSOR_TEST</code>
 <p>
 <i><code>params</code></i> returns a single boolean value indicating whether scissoring is enabled. 
 The initial value is <code>GL_FALSE</code>. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glScissor(int, int, int, int)"><CODE>glScissor</CODE></A>.
 <p>
 <code>GL_SHADER_BINARY_FORMATS</code>
 <p>
 <i><code>params</code></i> returns a list of symbolic constants of length <code>GL_NUM_SHADER_BINARY_FORMATS</code> 
 indicating which shader binary formats are available.
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, java.nio.IntBuffer, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A>.
 <p>
 <code>GL_SHADER_COMPILER</code>
 <p>
 <i><code>params</code></i> returns a single boolean value indicating whether a shader compiler 
 is supported. <code>GL_FALSE</code> indicates that any call to 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>glShaderSource</CODE></A>, <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>glCompileShader</CODE></A>,
 or <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReleaseShaderCompiler()"><CODE>glReleaseShaderCompiler</CODE></A> will 
 result in a <code>GL_INVALID_OPERATION</code> error being generated.
 <p>
 <code>GL_STENCIL_BACK_FAIL</code>
 <p>
 <i><code>params</code></i> returns one value, a symbolic constant indicating what action 
 is taken for back-facing polygons when the stencil test fails. 
 The initial value is <code>GL_KEEP</code>. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>glStencilOpSeparate</CODE></A>.
 <p>
 <code>GL_STENCIL_BACK_FUNC</code>
 <p> 
 <i><code>params</code></i> returns one value, a symbolic constant indicating what 
 function is used for back-facing polygons to compare the stencil reference 
 value with the stencil buffer value. The initial value is <code>GL_ALWAYS</code>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>glStencilFuncSeparate</CODE></A>.
 <p>
 <code>GL_STENCIL_BACK_PASS_DEPTH_FAIL</code>
 <p>
 <i><code>params</code></i> returns one value, a symbolic constant indicating what action is 
 taken for back-facing polygons when the stencil test passes, but the depth 
 test fails. The initial value is <code>GL_KEEP</code>.
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>glStencilOpSeparate</CODE></A>.
 <p>
 <code>GL_STENCIL_BACK_PASS_DEPTH_PASS</code>
 <p>
 <i><code>params</code></i> returns one value, a symbolic constant indicating what action is 
 taken for back-facing polygons when the stencil test passes and the 
 depth test passes. The initial value is <code>GL_KEEP</code>.
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>glStencilOpSeparate</CODE></A>.
 <p>
 <code>GL_STENCIL_BACK_REF</code>
 <p>
 <i><code>params</code></i> returns one value, the reference value that is compared 
 with the contents of the stencil buffer for back-facing polygons. 
 The initial value is 0. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>glStencilFuncSeparate</CODE></A>.
 <p>
 <code>GL_STENCIL_BACK_VALUE_MASK</code>
 <p>
 <i><code>params</code></i> returns one value, the mask that is used for back-facing 
 polygons to mask both the stencil reference value and the stencil 
 buffer value before they are compared. 
 The initial value is all 1's. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>glStencilFuncSeparate</CODE></A>.
 <p>
 <code>GL_STENCIL_BACK_WRITEMASK</code>
 <p>
 <i><code>params</code></i> returns one value, the mask that controls writing of the 
 stencil bitplanes for back-facing polygons. The initial value 
 is all 1's. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMaskSeparate(int, int)"><CODE>glStencilMaskSeparate</CODE></A>.
 <p>
 <code>GL_STENCIL_BITS</code>
 <p>
 <i><code>params</code></i> returns one value, the number of bitplanes in 
 the stencil buffer of the currently bound framebuffer.
 <p>
 <code>GL_STENCIL_CLEAR_VALUE</code>
 <p>
 <i><code>params</code></i> returns one value, the index to which the stencil 
 bitplanes are cleared. The initial value is 0. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glClearStencil(int)"><CODE>glClearStencil</CODE></A>.
 <p>
 <code>GL_STENCIL_FAIL</code>
 <p>
 <i><code>params</code></i> returns one value, a symbolic constant indicating what 
 action is taken when the stencil test fails for front-facing 
 polygons and non-polygons. The initial value is <code>GL_KEEP</code>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>glStencilOp</CODE></A> and
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>glStencilOpSeparate</CODE></A>.
 <p>
 <code>GL_STENCIL_FUNC</code>
 <p>
 <i><code>params</code></i> returns one value, a symbolic constant indicating what 
 function is used to compare the stencil reference value with 
 the stencil buffer value for front-facing polygons and non-polygons. 
 The initial value is <code>GL_ALWAYS</code>. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>glStencilFunc</CODE></A>
 and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>glStencilFuncSeparate</CODE></A>.
 <p>
 <code>GL_STENCIL_PASS_DEPTH_FAIL</code>
 <p> 
 <i><code>params</code></i> returns one value, a symbolic constant indicating what action is 
 taken when the stencil test passes, but the depth test fails for 
 front-facing polygons and non-polygons. The initial value is <code>GL_KEEP</code>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>glStencilOp</CODE></A> and
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>glStencilOpSeparate</CODE></A>.
 <p>
 <code>GL_STENCIL_PASS_DEPTH_PASS</code>
 <p>
 <i><code>params</code></i> returns one value, a symbolic constant indicating what action 
 is taken when the stencil test passes and the depth test passes for 
 front-facing polygons and non-polygons. The initial value is <code>GL_KEEP</code>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>glStencilOp</CODE></A> and
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>glStencilOpSeparate</CODE></A>.
 <p>
 <code>GL_STENCIL_REF</code>
 <p>     
 <i><code>params</code></i> returns one value, the reference value that is 
 compared with the contents of the stencil buffer for front-facing 
 polygons and non-polygons. The initial value is 0. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>glStencilFunc</CODE></A> and
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>glStencilFuncSeparate</CODE></A>.
 <p>
 <code>GL_STENCIL_TEST</code>
 <p>
 <i><code>params</code></i> returns a single boolean value indicating whether stencil 
 testing of fragments is enabled. The initial value is <code>GL_FALSE</code>. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>glStencilFunc</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>glStencilOp</CODE></A>.
 <p>
 <code>GL_STENCIL_VALUE_MASK</code>
 <p>
 <i><code>params</code></i> returns one value, the mask that is used to mask both 
 the stencil reference value and the stencil buffer value before 
 they are compared for front-facing polygons and non-polygons. 
 The initial value is all 1's. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>glStencilFunc</CODE></A> and
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>glStencilFuncSeparate</CODE></A>.
 <p>
 <code>GL_STENCIL_WRITEMASK</code>
 <p>
 <i><code>params</code></i> returns one value, the mask that controls writing of the 
 stencil bitplanes for front-facing polygons and non-polygons. 
 The initial value is all 1's. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMask(int)"><CODE>glStencilMask</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMaskSeparate(int, int)"><CODE>glStencilMaskSeparate</CODE></A>.
 <p>
 <code>GL_SUBPIXEL_BITS</code>
 <p>
 <i><code>params</code></i> returns one value, an estimate of the number of 
 bits of subpixel resolution that are used to position 
 rasterized geometry in window coordinates. 
 The value must be at least 4.
 <p>
 <code>GL_TEXTURE_BINDING_2D</code>
 <p>
 <i><code>params</code></i> returns a single value, the name of the texture 
 currently bound to the target <code>GL_TEXTURE_2D</code> for the active 
 multitexture unit. The initial value is 0. See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindTexture(int, int)"><CODE>glBindTexture</CODE></A>.
 <p>
 <code>GL_TEXTURE_BINDING_CUBE_MAP</code>
 <p> 
 <i><code>params</code></i> returns a single value, the name of the texture 
 currently bound to the target <code>GL_TEXTURE_CUBE_MAP</code> for 
 the active multitexture unit. The initial value is 0. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindTexture(int, int)"><CODE>glBindTexture</CODE></A>.
 <p>
 <code>GL_UNPACK_ALIGNMENT</code>
 <p>
 <i><code>params</code></i> returns one value, the byte alignment used for 
 reading pixel data from memory. The initial value is 4. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPixelStorei(int, int)"><CODE>glPixelStorei</CODE></A>.
 <p>
 <code>GL_VIEWPORT</code>
 <p>
 <i><code>params</code></i> returns four values: the x and y window coordinates 
 of the viewport, followed by its width and height. 
 Initially the x and y window coordinates are both set to 0, 
 and the width and height are set to the width and height 
 of the window into which the GL will do its rendering. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glViewport(int, int, int, int)"><CODE>glViewport</CODE></A>.
 <p>
 Many of the boolean parameters can also be queried more 
 easily using <code>glIsEnabled</code>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not one of the values listed previously.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pname</CODE> - Specifies the parameter value to be returned. 
  The symbolic constants in the list above are accepted.<DD><CODE>params</CODE> - Returns the value or values of the specified parameter.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length -
             <i>offset</i></code> is smaller than the number of values
             required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveAttrib(int, int, int[], int, int[], int)"><CODE>GL20.glGetActiveAttrib(int, int, int[], int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveUniform(int, int, int[], int, int[], int)"><CODE>GL20.glGetActiveUniform(int, int, int[], int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, java.nio.IntBuffer, java.nio.IntBuffer)"><CODE>GL20.glGetAttachedShaders(int, int, IntBuffer, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, int[], int, int[], int)"><CODE>GL20.glGetAttachedShaders(int, int, int[], int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttribLocation(int, java.lang.String)"><CODE>GL20.glGetAttribLocation(int, String)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBufferParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetBufferParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBufferParameteriv(int, int, int[], int)"><CODE>GL20.glGetBufferParameteriv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetError()"><CODE>GL20.glGetError()</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, java.nio.IntBuffer)"><CODE>GL20.glGetFramebufferAttachmentParameteriv(int, int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)"><CODE>GL20.glGetFramebufferAttachmentParameteriv(int, int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetProgramiv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>GL20.glGetProgramiv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramInfoLog(int)"><CODE>GL20.glGetProgramInfoLog(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetRenderbufferParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, int[], int)"><CODE>GL20.glGetRenderbufferParameteriv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetShaderiv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>GL20.glGetShaderiv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderInfoLog(int)"><CODE>GL20.glGetShaderInfoLog(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderSource(int, int, int[], byte[])"><CODE>GL20.glGetShaderSource(int, int, int[], byte[])</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetString(int)"><CODE>GL20.glGetString(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, float[], int)"><CODE>GL20.glGetTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, int[], int)"><CODE>GL20.glGetTexParameteriv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetUniformfv(int, int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, float[], int)"><CODE>GL20.glGetUniformfv(int, int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, java.nio.IntBuffer)"><CODE>GL20.glGetUniformiv(int, int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>GL20.glGetUniformiv(int, int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformLocation(int, java.lang.String)"><CODE>GL20.glGetUniformLocation(int, String)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetVertexAttribfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, float[], int)"><CODE>GL20.glGetVertexAttribfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetVertexAttribiv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>GL20.glGetVertexAttribiv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>GL20.glIsEnabled(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetIntegerv(int, java.nio.IntBuffer)"><!-- --></A><H3>
glGetIntegerv</H3>
<PRE>
void <B>glGetIntegerv</B>(int&nbsp;pname,
                   <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not one of the
  values listed in the documention for <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pname</CODE> - Specifies the parameter value to be returned. 
  The symbolic constants in the list above are accepted.<DD><CODE>params</CODE> - Returns the value or values of the specified parameter.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> is smaller than the
             number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>GL20.glGetIntegerv(int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetProgramiv(int, int, int[], int)"><!-- --></A><H3>
glGetProgramiv</H3>
<PRE>
void <B>glGetProgramiv</B>(int&nbsp;program,
                    int&nbsp;pname,
                    int[]&nbsp;params,
                    int&nbsp;offset)</PRE>
<DL>
<DD>Return a parameter from a program object.
 <p>
 <h4>Description</h4>
 <code>glGetProgramiv</code> returns in <i><code>params</code></i> the value of a parameter 
 for a specific program object. The following parameters are defined:
 <p>
 <code>GL_DELETE_STATUS</code>
 <p>
 <i><code>params</code></i> returns <code>GL_TRUE</code> if <i><code>program</code></i> is currently flagged 
 for deletion, and <code>GL_FALSE</code> otherwise.
 <p>
 <code>GL_LINK_STATUS</code>
 <p>
 <i><code>params</code></i> returns <code>GL_TRUE</code> if the last link operation on <i><code>program</code></i> 
 was successful, and <code>GL_FALSE</code> otherwise.
 <p>
 <code>GL_VALIDATE_STATUS</code>
 <p>
 <i><code>params</code></i> returns <code>GL_TRUE</code> or if the last validation operation 
 on <i><code>program</code></i> was successful, and <code>GL_FALSE</code> otherwise.
 <p>
 <code>GL_INFO_LOG_LENGTH</code>
 <p>
 <i><code>params</code></i> returns the number of characters in the information log for 
 <i><code>program</code></i> (i.e., the size of the 
 character buffer required to store the information log). 
 If <i><code>program</code></i> has no information log, a value of 0 is returned.
 <p>
 <code>GL_ATTACHED_SHADERS</code>
 <p>
 <i><code>params</code></i> returns the number of shader objects attached to <i><code>program</code></i>.
 <p>
 <code>GL_ACTIVE_ATTRIBUTES</code>
 <p>
 <i><code>params</code></i> returns the number of active attribute variables for <i><code>program</code></i>.
 <p>
 <code>GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</code>
 <p>
 <i><code>params</code></i> returns the length of the longest active attribute name for <i><code>program</code></i>, 
 (i.e., the size of the character buffer required to store the longest attribute name). 
 If no active attributes exist, 0 is returned.
 <p>
 <code>GL_ACTIVE_UNIFORMS</code>
 <p>
 <i><code>params</code></i> returns the number of active uniform variables for <i><code>program</code></i>.
 <p>
 <code>GL_ACTIVE_UNIFORM_MAX_LENGTH</code>
 <p>
 <i><code>params</code></i> returns the length of the longest active uniform variable name 
 for <i><code>program</code></i>, (i.e., the 
 size of the character buffer required to store the longest uniform 
 variable name). If no active uniform variables exist, 0 is returned.
 <p>
 <h4>Notes</h4>
 <p>
 If an error is generated, no change is made to the contents of <i><code>params</code></i>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not an 
  accepted value.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is 
  not a value generated by OpenGL. 
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> 
  does not refer to a program object.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveAttrib(int, int, int[], int, int[], int)"><CODE>glGetActiveAttrib</CODE></A>
  with argument <i><code>program</code></i>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveUniform(int, int, int[], int, int[], int)"><CODE>glGetActiveUniform</CODE></A>
  with argument <i><code>program</code></i>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, java.nio.IntBuffer, java.nio.IntBuffer)"><CODE>glGetAttachedShaders</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, int[], int, int[], int)"><CODE>glGetAttachedShaders</CODE></A>
  with argument <i><code>program</code></i>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramInfoLog(int)"><CODE>glGetProgramInfoLog</CODE></A>
  with argument <i><code>program</code></i>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to be queried.<DD><CODE>pname</CODE> - Specifies the object parameter. Accepted symbolic names are 
  <code>GL_DELETE_STATUS</code>, <code>GL_LINK_STATUS</code>, <code>GL_VALIDATE_STATUS</code>, <code>GL_INFO_LOG_LENGTH</code>, 
  <code>GL_ATTACHED_SHADERS</code>, <code>GL_ACTIVE_ATTRIBUTES</code>, <code>GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</code>, 
  <code>GL_ACTIVE_UNIFORMS</code>, <code>GL_ACTIVE_UNIFORM_MAX_LENGTH</code>.<DD><CODE>params</CODE> - Returns the requested object parameter.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length -
             <i>offset</i></code> is smaller than the number of values
             required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glAttachShader(int, int)"><CODE>GL20.glAttachShader(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateProgram()"><CODE>GL20.glCreateProgram()</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteProgram(int)"><CODE>GL20.glDeleteProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetProgramiv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetShaderiv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>GL20.glGetShaderiv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glValidateProgram(int)"><CODE>GL20.glValidateProgram(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetProgramiv(int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glGetProgramiv</H3>
<PRE>
void <B>glGetProgramiv</B>(int&nbsp;program,
                    int&nbsp;pname,
                    <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not an 
  accepted value.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is 
  not a value generated by OpenGL. 
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> 
  does not refer to a program object.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to be queried.<DD><CODE>pname</CODE> - Specifies the object parameter. Accepted symbolic names are 
  <code>GL_DELETE_STATUS</code>, <code>GL_LINK_STATUS</code>, <code>GL_VALIDATE_STATUS</code>, <code>GL_INFO_LOG_LENGTH</code>, 
  <code>GL_ATTACHED_SHADERS</code>, <code>GL_ACTIVE_ATTRIBUTES</code>, <code>GL_ACTIVE_ATTRIBUTE_MAX_LENGTH</code>, 
  <code>GL_ACTIVE_UNIFORMS</code>, <code>GL_ACTIVE_UNIFORM_MAX_LENGTH</code>.<DD><CODE>params</CODE> - Returns the requested object parameter.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> is smaller than the
             number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>GL20.glGetProgramiv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetProgramInfoLog(int)"><!-- --></A><H3>
glGetProgramInfoLog</H3>
<PRE>
<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A> <B>glGetProgramInfoLog</B>(int&nbsp;program)</PRE>
<DL>
<DD>Return the information log for a program object.
 <p>
 <h4>Description</h4>
 <code>glGetProgramInfoLog</code> returns the information log for 
 the specified program object. The information log for a program 
 object is modified when the program object is linked or validated.
 <p>
 The information log for a program object is either an empty string, 
 or a string containing information about the last link operation, 
 or a string containing information about the last validation operation. 
 It may contain diagnostic messages, warning messages, and other information. 
 When a program object is created, its information log will be a string of length 0.
 <p>
 <h4>Notes</h4>
 <p>
 The information log for a program object is the OpenGL implementer's primary 
 mechanism for conveying information about linking and validating. 
 Therefore, the information log can be helpful to application developers 
 during the development process, even when these operations are successful. 
 Application developers should not expect different OpenGL implementations 
 to produce identical information logs.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> if <i><code>program</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A>
  with argument <code>GL_INFO_LOG_LENGTH</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object whose information log is to be queried.
<DT><B>Returns:</B><DD>A <A HREF="../../../../../java/lang/String.html" title="class in java.lang"><CODE>String</CODE></A> containing the information log.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>GL20.glCompileShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderInfoLog(int)"><CODE>GL20.glGetShaderInfoLog(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glValidateProgram(int)"><CODE>GL20.glValidateProgram(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetProgramInfoLog(int, int, int[], byte[])"><!-- --></A><H3>
glGetProgramInfoLog</H3>
<PRE>
void <B>glGetProgramInfoLog</B>(int&nbsp;program,
                         int&nbsp;maxsize,
                         int[]&nbsp;length,
                         byte[]&nbsp;infolog)</PRE>
<DL>
<DD>Return the information log for a program object.
 <p>
 <h4>Description</h4>
 <code>glGetProgramInfoLog</code> returns the information log for 
 the specified program object. The information log for a program 
 object is modified when the program object is linked or validated.
 <p>
 <code>glGetProgramInfoLog</code> returns in <i><code>infolog</code></i> as much of the 
 information log as it can, up to a maximum of <i><code>maxsize</code></i> characters. 
 The number of characters actually returned is specified by <i><code>length</code></i>. 
 If the length of the returned string is not required, a value of <code>null</code> can be passed in 
 the <i><code>length</code></i> argument. The size of the buffer required to store  
 the returned information log can be obtained by 
 calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A> with the value <code>GL_INFO_LOG_LENGTH</code>.
 <p>
 The information log for a program object is either an empty string, 
 or a string containing information about the last link operation, 
 or a string containing information about the last validation operation. 
 It may contain diagnostic messages, warning messages, and other information. 
 When a program object is created, its information log will be a string of length 0.
 <p>
 <h4>Notes</h4>
 <p>
 The information log for a program object is the OpenGL implementer's primary 
 mechanism for conveying information about linking and validating. 
 Therefore, the information log can be helpful to application developers 
 during the development process, even when these operations are successful. 
 Application developers should not expect different OpenGL implementations 
 to produce identical information logs.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> if <i><code>program</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>maxsize</code></i> is less than 0.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A>
  with argument <code>GL_INFO_LOG_LENGTH</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object whose information log is to be queried.<DD><CODE>maxsize</CODE> - Specifies the size of the character buffer for storing the returned information log.<DD><CODE>length</CODE> - Returns (in the first element of the array) the length of the string returned in <i><code>infolog</code></i>.
  If non-<code>null</code>, it must have length at least 1. May be <code>null</code>.<DD><CODE>infolog</CODE> - Specifies an array of characters that is used to return the information log.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code>length</code> is
  non-<code>null</code> but has length less than 1.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code>infolog</code> is <code>null</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>GL20.glCompileShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderInfoLog(int, int, int[], byte[])"><CODE>GL20.glGetShaderInfoLog(int, int, int[], byte[])</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glValidateProgram(int)"><CODE>GL20.glValidateProgram(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetRenderbufferParameteriv(int, int, int[], int)"><!-- --></A><H3>
glGetRenderbufferParameteriv</H3>
<PRE>
void <B>glGetRenderbufferParameteriv</B>(int&nbsp;target,
                                  int&nbsp;pname,
                                  int[]&nbsp;params,
                                  int&nbsp;offset)</PRE>
<DL>
<DD>Return parameters of a renderbuffer object.
 <p>
 <h4>Description</h4>
 <code>glGetRenderbufferParameteriv</code> returns in <i><code>params</code></i> a selected 
 parameter of the currently bound renderbuffer object.
 <p>
 <i><code>pname</code></i> names a specific renderbuffer object parameter, as follows:
 <p>
 <code>GL_RENDERBUFFER_WIDTH</code>
 <p>
 <i><code>params</code></i> returns the width in pixels of the image of the currently 
 bound renderbuffer. The initial value is 0.
 <p>
 <code>GL_RENDERBUFFER_HEIGHT</code>
 <p>
 <i><code>params</code></i> returns the height in pixels of the image of the currently 
 bound renderbuffer. The initial value is 0.
 <p>
 <code>GL_RENDERBUFFER_INTERNAL_FORMAT</code>
 <p>
 <i><code>params</code></i> returns the internal format of the image of the currently 
 bound renderbuffer. The initial value is <code>GL_RGBA4</code>.
 <p>
 <code>GL_RENDERBUFFER_RED_SIZE</code>
 <p>
 <i><code>params</code></i> returns the resolution in bits for the red component of the 
 image of the currently bound renderbuffer. The initial value is 0.
 <p>
 <code>GL_RENDERBUFFER_GREEN_SIZE</code>
 <p>
 <i><code>params</code></i> returns the resolution in bits for the green component of the 
 image of the currently bound renderbuffer. The initial value is 0.
 <p>
 <code>GL_RENDERBUFFER_BLUE_SIZE</code>
 <p>
 <i><code>params</code></i> returns the resolution in bits for the blue component of the 
 image of the currently bound renderbuffer. The initial value is 0.
 <p>
 <code>GL_RENDERBUFFER_ALPHA_SIZE</code>
 <p>
 <i><code>params</code></i> returns the resolution in bits for the alpha component of the 
 image of the currently bound renderbuffer. The initial value is 0.
 <p>
 <code>GL_RENDERBUFFER_DEPTH_SIZE</code>
 <p>
 <i><code>params</code></i> returns the resolution in bits for the depth component of the 
 image of the currently bound renderbuffer. The initial value is 0.
 <p>
 <code>GL_RENDERBUFFER_STENCIL_SIZE</code>
 <p>
 <i><code>params</code></i> returns the resolution in bits for the stencil component of the 
 image of the currently bound renderbuffer. The initial value is 0.
 <p>
 <h4>Notes</h4>
 <p>
 The resolution of components reported by <code>glGetRenderbufferParameteriv</code> 
 are the actual resolutions at which the components are stored, 
 which may be different than those requested by the <i><code>internalformat</code></i> 
 parameter of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glRenderbufferStorage(int, int, int, int)"><CODE>glRenderbufferStorage</CODE></A>.
 <p>
 If an error is generated, no change is made to the contents of <i><code>params</code></i>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not <code>GL_RENDERBUFFER</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not <code>GL_RENDERBUFFER_WIDTH</code>, 
  <code>GL_RENDERBUFFER_HEIGHT</code>, <code>GL_RENDERBUFFER_INTERNAL_FORMAT</code>, 
  <code>GL_RENDERBUFFER_RED_SIZE</code>, <code>GL_RENDERBUFFER_GREEN_SIZE</code>, 
  <code>GL_RENDERBUFFER_BLUE_SIZE</code>, <code>GL_RENDERBUFFER_ALPHA_SIZE</code>, 
  <code>GL_RENDERBUFFER_DEPTH_SIZE</code>, or <code>GL_RENDERBUFFER_STENCIL_SIZE</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if the reserved 
  renderbuffer object name 0 is bound.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target renderbuffer object. 
  The symbolic constant must be <code>GL_RENDERBUFFER</code>.<DD><CODE>pname</CODE> - Specifies the symbolic name of a renderbuffer 
  object parameter. Accepted values are <code>GL_RENDERBUFFER_WIDTH</code>, 
  <code>GL_RENDERBUFFER_HEIGHT</code>, <code>GL_RENDERBUFFER_INTERNAL_FORMAT</code>, 
  <code>GL_RENDERBUFFER_RED_SIZE</code>, <code>GL_RENDERBUFFER_GREEN_SIZE</code>, 
  <code>GL_RENDERBUFFER_BLUE_SIZE</code>, <code>GL_RENDERBUFFER_ALPHA_SIZE</code>, 
  <code>GL_RENDERBUFFER_DEPTH_SIZE</code>, or <code>GL_RENDERBUFFER_STENCIL_SIZE</code><DD><CODE>params</CODE> - Returns the requested parameter.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length -
             <i>offset</i></code> is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindRenderbuffer(int, int)"><CODE>GL20.glBindRenderbuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetRenderbufferParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glRenderbufferStorage(int, int, int, int)"><CODE>GL20.glRenderbufferStorage(int, int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetRenderbufferParameteriv(int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glGetRenderbufferParameteriv</H3>
<PRE>
void <B>glGetRenderbufferParameteriv</B>(int&nbsp;target,
                                  int&nbsp;pname,
                                  <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, int[], int)"><CODE>glGetRenderbufferParameteriv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not <code>GL_RENDERBUFFER</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not <code>GL_RENDERBUFFER_WIDTH</code>, 
  <code>GL_RENDERBUFFER_HEIGHT</code>, <code>GL_RENDERBUFFER_INTERNAL_FORMAT</code>, 
  <code>GL_RENDERBUFFER_RED_SIZE</code>, <code>GL_RENDERBUFFER_GREEN_SIZE</code>, 
  <code>GL_RENDERBUFFER_BLUE_SIZE</code>, <code>GL_RENDERBUFFER_ALPHA_SIZE</code>, 
  <code>GL_RENDERBUFFER_DEPTH_SIZE</code>, or <code>GL_RENDERBUFFER_STENCIL_SIZE</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if the reserved 
  renderbuffer object name 0 is bound.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target renderbuffer object. 
  The symbolic constant must be <code>GL_RENDERBUFFER</code>.<DD><CODE>pname</CODE> - Specifies the symbolic name of a renderbuffer 
  object parameter. Accepted values are <code>GL_RENDERBUFFER_WIDTH</code>, 
  <code>GL_RENDERBUFFER_HEIGHT</code>, <code>GL_RENDERBUFFER_INTERNAL_FORMAT</code>, 
  <code>GL_RENDERBUFFER_RED_SIZE</code>, <code>GL_RENDERBUFFER_GREEN_SIZE</code>, 
  <code>GL_RENDERBUFFER_BLUE_SIZE</code>, <code>GL_RENDERBUFFER_ALPHA_SIZE</code>, 
  <code>GL_RENDERBUFFER_DEPTH_SIZE</code>, or <code>GL_RENDERBUFFER_STENCIL_SIZE</code><DD><CODE>params</CODE> - Returns the requested parameter.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> is smaller than the
             number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, int[], int)"><CODE>GL20.glGetRenderbufferParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetShaderiv(int, int, int[], int)"><!-- --></A><H3>
glGetShaderiv</H3>
<PRE>
void <B>glGetShaderiv</B>(int&nbsp;shader,
                   int&nbsp;pname,
                   int[]&nbsp;params,
                   int&nbsp;offset)</PRE>
<DL>
<DD>Return a parameter from a shader object
 <p>
 <h4>Description</h4>
 <code>glGetShaderiv</code> returns in <i><code>params</code></i> the value of a parameter
 for a specific shader object. The following parameters are defined:
 <p>
 <code>GL_SHADER_TYPE</code>
 <p>
 <i><code>params</code></i> returns <code>GL_VERTEX_SHADER</code> if <i><code>shader</code></i> is a vertex shader object, 
 and <code>GL_FRAGMENT_SHADER</code> if <i><code>shader</code></i> is a fragment shader object.
 <p>
 <code>GL_DELETE_STATUS</code>
 <p>
 <i><code>params</code></i> returns <code>GL_TRUE</code> if <i><code>shader</code></i> is currently flagged for deletion, 
 and <code>GL_FALSE</code> otherwise.
 <p>
 <code>GL_COMPILE_STATUS</code>
 <p>
 For implementations that support a shader compiler, <i><code>params</code></i> returns 
 <code>GL_TRUE</code> if the last compile operation on <i><code>shader</code></i> was successful, 
 and <code>GL_FALSE</code> otherwise.
 <p>
 <code>GL_INFO_LOG_LENGTH</code>
 <p>
 For implementations that support a shader compiler, 
 <i><code>params</code></i> returns the number of characters in the information log for 
 <i><code>shader</code></i> (i.e., the size of 
 the character buffer required to store the information log). 
 If <i><code>shader</code></i> has no information log, a value of 0 is returned.
 <p>
 <code>GL_SHADER_SOURCE_LENGTH</code>
 <p>
 For implementations that support a shader compiler, 
 <i><code>params</code></i> returns the length of the concatenation of the source 
 strings that make up the shader source for <i><code>shader</code></i> (i.e., the size of the 
 character buffer required to store the shader source). 
 If no source code exists, 0 is returned.
 <p>
 <h4>Notes</h4>
 <p>
 Shader compiler support is optional, and thus must be queried before use by calling 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
 with argument <code>GL_SHADER_COMPILER</code>. <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>glShaderSource</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>glCompileShader</CODE></A>, 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderPrecisionFormat(int, int, int[], int, int[], int)"><CODE>glGetShaderPrecisionFormat</CODE></A>, 
 and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReleaseShaderCompiler()"><CODE>glReleaseShaderCompiler</CODE></A> will each generate <code>GL_INVALID_OPERATION</code> 
 on implementations that do not support a shader compiler, as 
 will <code>glGetShaderiv</code> queries of <code>GL_COMPILE_STATUS</code>, <code>GL_INFO_LOG_LENGTH</code>, 
 and <code>GL_SHADER_SOURCE_LENGTH</code>. Such implementations instead offer 
 the <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, java.nio.IntBuffer, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A> alternative for supplying a pre-compiled shader binary.
 <p>
 If an error is generated, no change is made to the contents of <i><code>params</code></i>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not an accepted value.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>shader</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code>  is generated if <i><code>pname</code></i> is <code>GL_COMPILE_STATUS</code>, 
  <code>GL_INFO_LOG_LENGTH</code>, or <code>GL_SHADER_SOURCE_LENGTH</code> 
  but a shader compiler is not supported.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>shader</code></i> does not 
  refer to a shader object.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_SHADER_COMPILER</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderInfoLog(int)"><CODE>glGetShaderInfoLog</CODE></A> with argument <i><code>shader</code></i>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderSource(int, int, int[], byte[])"><CODE>glGetShaderSource</CODE></A> with argument <i><code>shader</code></i>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsShader(int)"><CODE>glIsShader</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shader</CODE> - Specifies the shader object to be queried.<DD><CODE>pname</CODE> - Specifies the object parameter. Accepted symbolic 
  names are <code>GL_SHADER_TYPE</code>, <code>GL_DELETE_STATUS</code>, <code>GL_COMPILE_STATUS</code>, 
  <code>GL_INFO_LOG_LENGTH</code>, <code>GL_SHADER_SOURCE_LENGTH</code>.<DD><CODE>params</CODE> - Returns the requested object parameter.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length -
             <i>offset</i></code> is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>GL20.glCompileShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateShader(int)"><CODE>GL20.glCreateShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteShader(int)"><CODE>GL20.glDeleteShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetProgramiv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>GL20.glGetProgramiv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>GL20.glShaderSource(int, int, String[], int[])</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, java.nio.IntBuffer, int, java.nio.Buffer, int)"><CODE>GL20.glShaderBinary(int, IntBuffer, int, Buffer, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><CODE>GL20.glShaderBinary(int, int[], int, int, Buffer, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetShaderiv(int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glGetShaderiv</H3>
<PRE>
void <B>glGetShaderiv</B>(int&nbsp;shader,
                   int&nbsp;pname,
                   <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not an accepted value.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>shader</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>pname</code></i> is <code>GL_COMPILE_STATUS</code>, 
  <code>GL_INFO_LOG_LENGTH</code>, or <code>GL_SHADER_SOURCE_LENGTH</code> 
  but a shader compiler is not supported.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>shader</code></i> does not 
  refer to a shader object.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shader</CODE> - Specifies the shader object to be queried.<DD><CODE>pname</CODE> - Specifies the object parameter. Accepted symbolic 
  names are <code>GL_SHADER_TYPE</code>, <code>GL_DELETE_STATUS</code>, <code>GL_COMPILE_STATUS</code>, 
  <code>GL_INFO_LOG_LENGTH</code>, <code>GL_SHADER_SOURCE_LENGTH</code>.<DD><CODE>params</CODE> - Returns the requested object parameter.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> is smaller than the
             number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>GL20.glGetShaderiv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetShaderInfoLog(int)"><!-- --></A><H3>
glGetShaderInfoLog</H3>
<PRE>
<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A> <B>glGetShaderInfoLog</B>(int&nbsp;shader)</PRE>
<DL>
<DD>Return the information log for a shader object.
 <p>
 <h4>Description</h4>
 <code>glGetShaderInfoLog</code> returns the information log for the 
 specified shader object. The information log for a shader object is 
 modified when the shader is compiled.
 <p>
 The information log for a shader object is a string that 
 may contain diagnostic messages, warning messages, and 
 other information about the last compile operation. 
 When a shader object is created, its information 
 log will be a string of length 0.
 <p>
 <h4>Notes</h4>
 <p>
 The information log for a shader object is the OpenGL 
 implementer's primary mechanism for conveying information 
 about the compilation process. Therefore, the information 
 log can be helpful to application developers during the 
 development process, even when compilation is successful. 
 Application developers should not expect different OpenGL 
 implementations to produce identical information logs.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>shader</code></i> is not a 
  value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>shader</code></i> is 
  not a shader object.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>glGetShaderiv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A>
  with argument <code>GL_INFO_LOG_LENGTH</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsShader(int)"><CODE>glIsShader</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shader</CODE> - Specifies the shader object whose 
  information log is to be queried.
<DT><B>Returns:</B><DD>A <A HREF="../../../../../java/lang/String.html" title="class in java.lang"><CODE>String</CODE></A> containing the information log.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>GL20.glCompileShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramInfoLog(int)"><CODE>GL20.glGetProgramInfoLog(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glValidateProgram(int)"><CODE>GL20.glValidateProgram(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetShaderInfoLog(int, int, int[], byte[])"><!-- --></A><H3>
glGetShaderInfoLog</H3>
<PRE>
void <B>glGetShaderInfoLog</B>(int&nbsp;shader,
                        int&nbsp;maxsize,
                        int[]&nbsp;length,
                        byte[]&nbsp;infolog)</PRE>
<DL>
<DD>Return the information log for a shader object.
 <p>
 <h4>Description</h4>
 <code>glGetShaderInfoLog</code> returns the information log for the 
 specified shader object. The information log for a shader object is 
 modified when the shader is compiled.
 <p>
 <code>glGetShaderInfoLog</code> returns in <i><code>infolog</code></i> as much of the 
 information log as it can, up to a maximum of <i><code>maxsize</code></i> characters. 
 The number of characters actually returned is specified by <i><code>length</code></i>. If the length of the  
 returned string is not required, a value of <code>null</code> can be passed in the 
 <i><code>length</code></i> argument. The size of the buffer required to store the 
 returned information log can be obtained by 
 calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>glGetShaderiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A> with the value <code>GL_INFO_LOG_LENGTH</code>.
 <p>
 The information log for a shader object is a string that 
 may contain diagnostic messages, warning messages, and 
 other information about the last compile operation. 
 When a shader object is created, its information 
 log will be a string of length 0.
 <p>
 <h4>Notes</h4>
 <p>
 The information log for a shader object is the OpenGL 
 implementer's primary mechanism for conveying information 
 about the compilation process. Therefore, the information 
 log can be helpful to application developers during the 
 development process, even when compilation is successful. 
 Application developers should not expect different OpenGL 
 implementations to produce identical information logs.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>shader</code></i> is not a 
  value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>shader</code></i> is 
  not a shader object.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>maxsize</code></i> is less than 0.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>glGetShaderiv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A>
  with argument <code>GL_INFO_LOG_LENGTH</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsShader(int)"><CODE>glIsShader</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shader</CODE> - Specifies the shader object whose 
  information log is to be queried.<DD><CODE>maxsize</CODE> - Specifies the size of the character 
  buffer for storing the returned information log.<DD><CODE>length</CODE> - Returns the length of the string returned in <i><code>infolog</code></i>.
  If non-<code>null</code>, it must have length at least 1. May be <code>null</code>.<DD><CODE>infolog</CODE> - Specifies an array of characters 
  that is used to return the information log.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code>length</code> is
  non-<code>null</code> but has length less than 1.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code>infolog</code> is <code>null</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>GL20.glCompileShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramInfoLog(int, int, int[], byte[])"><CODE>GL20.glGetProgramInfoLog(int, int, int[], byte[])</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glValidateProgram(int)"><CODE>GL20.glValidateProgram(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetShaderPrecisionFormat(int, int, int[], int, int[], int)"><!-- --></A><H3>
glGetShaderPrecisionFormat</H3>
<PRE>
void <B>glGetShaderPrecisionFormat</B>(int&nbsp;shadertype,
                                int&nbsp;precisiontype,
                                int[]&nbsp;range,
                                int&nbsp;rangeOffset,
                                int[]&nbsp;precision,
                                int&nbsp;precisionOffset)</PRE>
<DL>
<DD>Return the range and precision for different shader numeric formats.
 <p>
 <h4>Description</h4>
 <code>glGetShaderPrecisionFormat</code> returns range and precision 
 limits for floating-point and integer shader variable formats with 
 low, medium, and high precision qualifiers. When <code>minRep</code> and <code>maxRep</code> 
 are the minimum and maximum representable values of the format, 
 <code>floor(log_2(|minRep|))</code> and <code>floor(log_2(|maxRep|))</code> are returned in 
 <i><code>range</code></i> as the first and second elements, respectively.
 <p>
 If the smallest representable value greater 
 than 1 is <code>(1 + &#x03f5)</code> then <code>floor(-log_2(&#x03f5))</code> is returned in <i><code>precision</code></i>. 
 An integer format will have an <code>&#x03f5</code> of 1, and thus will return 0. 
 Floating-point formats will return values greater than 0.
 <p>
 <h4>Notes</h4>
 <p>
 The minimum range and precision required for different formats is 
 described in the <i>OpenGL ES Shading Language Specification</i>.
 <p>
 If a high precision floating-point format is not supported for 
 fragment shaders, calling <code>glGetShaderPrecisionFormat</code> with 
 arguments <code>GL_FRAGMENT_SHADER</code> and <code>GL_HIGH_FLOAT</code> will return 0 
 for both <i><code>range</code></i> and <i><code>precision</code></i>. Support for a high precision 
 floating-point format is mandatory for vertex shaders.
 <p>
 Shader compiler support is optional, and thus must be 
 queried before use by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A> with argument 
 <code>GL_SHADER_COMPILER</code>. <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>glShaderSource</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>glCompileShader</CODE></A>, <code>glGetShaderPrecisionFormat</code>,
 and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReleaseShaderCompiler()"><CODE>glReleaseShaderCompiler</CODE></A> 
 will each generate <code>GL_INVALID_OPERATION</code> on implementations 
 that do not support a shader compiler. Such implementations 
 instead offer the <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, java.nio.IntBuffer, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A> alternative for supplying 
 a pre-compiled shader binary.
 <p>
 If an error is generated, no change is made to the 
 contents of <i><code>range</code></i> or <i><code>precision</code></i>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_OPERATION</code> is generated if a 
  shader compiler is not supported.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>shadertype</code></i> or 
  <i><code>precisiontype</code></i> is not an accepted value.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_SHADER_COMPILER</code> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shadertype</CODE> - Specifies the type of shader to query. 
  Must be either <code>GL_VERTEX_SHADER</code> or <code>GL_FRAGMENT_SHADER</code>.<DD><CODE>precisiontype</CODE> - Specifies the numeric format to query, 
  corresponding to a shader precision qualifier and variable type. 
  Must be one of <code>GL_LOW_FLOAT</code>, <code>GL_MEDIUM_FLOAT</code>, <code>GL_HIGH_FLOAT</code>, 
  <code>GL_LOW_INT</code>, <code>GL_MEDIUM_INT</code>, or <code>GL_HIGH_INT</code>.<DD><CODE>range</CODE> - An <code>int</code> array of length at least 2. 
  Specifies the two-element array in which the <code>log_2</code> of the minimum and maximum representable 
  magnitudes of the format are returned. May be <code>null</code>.<DD><CODE>rangeOffset</CODE> - The starting offset within the <i><code>range</code></i> array.<DD><CODE>precision</CODE> - An <code>int</code> array of length at least 1. 
  Specifies the one-element array in which the <code>log_2</code> of the 
  precision of the format is returned. May be <code>null</code>.<DD><CODE>precisionOffset</CODE> - The starting offset within the <i><code>precision</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>rangeOffset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code>range</code> is
  non-<code>null</code> but <i><code>range</code></i>.length - <i><code>rangeOffset</code></i> is smaller than 2.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>precisionOffset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code>precision</code> is
  non-<code>null</code> but but <i><code>precision</code></i>.length - <i><code>precisionOffset</code></i> is smaller than 1.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>GL20.glCompileShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>GL20.glShaderSource(int, int, String[], int[])</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetShaderSource(int)"><!-- --></A><H3>
glGetShaderSource</H3>
<PRE>
<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A> <B>glGetShaderSource</B>(int&nbsp;shader)</PRE>
<DL>
<DD>Return the source code string from a shader object.
 <p>
 <h4>Description</h4>
 <code>glGetShaderSource</code> returns the concatenation of the source  
 code strings from the shader object specified by <i><code>shader</code></i>. The source 
 code strings for a shader object are the result of a previous 
 call to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>glShaderSource</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>shader</code></i> is not a 
  value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>shader</code></i> is not a 
  shader object.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>glGetShaderiv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A>
  with argument <code>GL_SHADER_SOURCE_LENGTH</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsShader(int)"><CODE>glIsShader</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shader</CODE> - Specifies the shader object to be queried.
<DT><B>Returns:</B><DD>A <A HREF="../../../../../java/lang/String.html" title="class in java.lang"><CODE>String</CODE></A> containing the shader source.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateShader(int)"><CODE>GL20.glCreateShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>GL20.glShaderSource(int, int, String[], int[])</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetShaderSource(int, int, int[], byte[])"><!-- --></A><H3>
glGetShaderSource</H3>
<PRE>
void <B>glGetShaderSource</B>(int&nbsp;shader,
                       int&nbsp;bufSize,
                       int[]&nbsp;length,
                       byte[]&nbsp;source)</PRE>
<DL>
<DD>Return the source code string from a shader object.
 <p>
 <h4>Description</h4>
 <code>glGetShaderSource</code> returns the concatenation of the source  
 code strings from the shader object specified by <i><code>shader</code></i>. The source 
 code strings for a shader object are the result of a previous 
 call to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>glShaderSource</CODE></A>.
 <p>
 <code>glGetShaderSource</code> returns in <i><code>source</code></i> as much of the source 
 code string as it can, up to a maximum of <i><code>bufSize</code></i> characters. 
 The number of characters actually returned is specified by <i><code>length</code></i>. 
 If the length of the returned string is not required, a 
 value of <code>null</code> can be passed in the <i><code>length</code></i> argument. 
 The size of the buffer required to store the returned 
 source code string can be obtained by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>glGetShaderiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A> 
 with the value <code>GL_SHADER_SOURCE_LENGTH</code>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>shader</code></i> is not a 
  value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>shader</code></i> is not a 
  shader object.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>bufSize</code></i> is 
  less than 0.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>glGetShaderiv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A>
  with argument <code>GL_SHADER_SOURCE_LENGTH</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsShader(int)"><CODE>glIsShader</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shader</CODE> - Specifies the shader object to be queried.<DD><CODE>bufSize</CODE> - Specifies the size of the character buffer for 
  storing the returned source code string.<DD><CODE>length</CODE> - Returns the length of the string returned in <i><code>source</code></i>.
  If non-<code>null</code>, it must have length at least 1. May be <code>null</code>.<DD><CODE>source</CODE> - Specifies an array of characters that is used to 
  return the source code string.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code>length</code> is
  non-<code>null</code> but has length less than 1.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code>source</code> is <code>null</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateShader(int)"><CODE>GL20.glCreateShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>GL20.glShaderSource(int, int, String[], int[])</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetString(int)"><!-- --></A><H3>
glGetString</H3>
<PRE>
<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A> <B>glGetString</B>(int&nbsp;name)</PRE>
<DL>
<DD>Return a string describing the current GL connection.
 <p>
 <h4>Description</h4>
 The GL string is converted to UTF8 format to produce a standard
 Java <A HREF="../../../../../java/lang/String.html" title="class in java.lang"><CODE>String</CODE></A> object.
 <p>
 <code>glGetString</code> returns a string describing some aspect 
 of the current GL connection. <i><code>name</code></i> can be one of the following:
 <p>
 <code>GL_VENDOR</code>
 <p>
 Returns the company responsible for this GL implementation. 
 This name does not change from release to release.
 <p>
 <code>GL_RENDERER</code>
 <p>
 Returns the name of the renderer. This name is typically specific 
 to a particular configuration of a hardware platform. 
 It does not change from release to release.
 <p>
 <code>GL_VERSION</code>
 <p>
 Returns a version or release number of the form
 <code>OpenGL&lt;space&gt;ES&lt;space&gt;&lt;version number&gt;&lt;space&gt;&lt;vendor-specific information&gt;</code>.
 <p>
 <code>GL_SHADING_LANGUAGE_VERSION</code>
 <p>
 Returns a version or release number for the shading language of the form
 <code>OpenGL&lt;space&gt;ES&lt;space&gt;GLSL&lt;space&gt;ES&lt;space&gt;&lt;version number&gt;&lt;space&gt;&lt;vendor-specific information&gt;</code>.
 <p>
 <code>GL_EXTENSIONS</code>
 <p>
 Returns a space-separated list of supported extensions to GL.
 <p>
 Because the GL does not include queries for the performance 
 characteristics of an implementation, some applications are 
 written to recognize known platforms and modify their GL usage 
 based on known performance characteristics of these platforms. 
 Strings <code>GL_VENDOR</code> and <code>GL_RENDERER</code> together uniquely specify a platform. 
 They do not change from release to release and should be used by 
 platform-recognition algorithms.
 <p>
 Some applications want to make use of features that are not 
 part of the standard GL. These features may be implemented as 
 extensions to the standard GL. The <code>GL_EXTENSIONS</code> string is a 
 space-separated list of supported GL extensions. 
 (Extension names never contain a space character.)
 <p>
 <h4>Notes</h4>
 <p>
 If an error is generated, <code>glGetString</code> returns <code>null</code>.
 <p>
 The client and server may support different versions or extensions. 
 <code>glGetString</code> always returns a compatible version number or list 
 of extensions. The release number always describes the server.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>name</code></i> is not an accepted value.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - Specifies a symbolic constant, one of 
  <code>GL_VENDOR</code>, <code>GL_RENDERER</code>, <code>GL_VERSION</code>, 
  <code>GL_SHADING_LANGUAGE_VERSION</code>, or <code>GL_EXTENSIONS</code>.
<DT><B>Returns:</B><DD>A <A HREF="../../../../../java/lang/String.html" title="class in java.lang"><CODE>String</CODE></A> formatted as described above.<DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetTexParameterfv(int, int, float[], int)"><!-- --></A><H3>
glGetTexParameterfv</H3>
<PRE>
void <B>glGetTexParameterfv</B>(int&nbsp;target,
                         int&nbsp;pname,
                         float[]&nbsp;params,
                         int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, int[], int)"><CODE>glGetTexParameteriv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> or <i><code>pname</code></i> 
  is not an accepted value.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the symbolic name of the target texture. 
  <code>GL_TEXTURE_2D</code> and <code>GL_TEXTURE_CUBE_MAP</code> are accepted.<DD><CODE>pname</CODE> - Specifies the symbolic name of a texture parameter. 
  <code>GL_TEXTURE_MAG_FILTER</code>, <code>GL_TEXTURE_MIN_FILTER</code>, 
  <code>GL_TEXTURE_WRAP_S</code>, and <code>GL_TEXTURE_WRAP_T</code> are accepted.<DD><CODE>params</CODE> - Returns the texture parameter.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length -
             <i>offset</i></code> is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, int[], int)"><CODE>GL20.glGetTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetTexParameterfv(int, int, java.nio.FloatBuffer)"><!-- --></A><H3>
glGetTexParameterfv</H3>
<PRE>
void <B>glGetTexParameterfv</B>(int&nbsp;target,
                         int&nbsp;pname,
                         <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>glGetTexParameteriv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> or <i><code>pname</code></i> 
  is not an accepted value.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the symbolic name of the target texture. 
  <code>GL_TEXTURE_2D</code> and <code>GL_TEXTURE_CUBE_MAP</code> are accepted.<DD><CODE>pname</CODE> - Specifies the symbolic name of a texture parameter. 
  <code>GL_TEXTURE_MAG_FILTER</code>, <code>GL_TEXTURE_MIN_FILTER</code>, 
  <code>GL_TEXTURE_WRAP_S</code>, and <code>GL_TEXTURE_WRAP_T</code> are accepted.<DD><CODE>params</CODE> - Returns the texture parameter.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> is smaller than the
             number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, float[], int)"><CODE>GL20.glGetTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, int[], int)"><CODE>GL20.glGetTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetTexParameteriv(int, int, int[], int)"><!-- --></A><H3>
glGetTexParameteriv</H3>
<PRE>
void <B>glGetTexParameteriv</B>(int&nbsp;target,
                         int&nbsp;pname,
                         int[]&nbsp;params,
                         int&nbsp;offset)</PRE>
<DL>
<DD>Return texture parameter values.
 <p>
 <code>glGetTexParameter</code> returns in <i><code>params</code></i> the value of the texture 
 parameter specified as <i><code>pname</code></i>. <i><code>target</code></i> defines the target texture, 
 either <code>GL_TEXTURE_2D</code> or <code>GL_TEXTURE_CUBE_MAP</code>, to specify 
 two-dimensional or cube-mapped texturing. <i><code>pname</code></i> accepts the 
 same symbols as <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>glTexParameterf</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>glTexParameterfv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>glTexParameterfv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>glTexParameteri</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>glTexParameteriv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>glTexParameteriv</CODE></A>, with the same interpretations:
 <p>
 <code>GL_TEXTURE_MAG_FILTER</code>
 <p>
 Returns the single-valued texture magnification filter, 
 a symbolic constant. The initial value is <code>GL_LINEAR</code>.
 <p>
 <code>GL_TEXTURE_MIN_FILTER</code>
 <p>
 Returns the single-valued texture minification filter, a symbolic constant. 
 The initial value is <code>GL_NEAREST_MIPMAP_LINEAR</code>.
 <p>
 <code>GL_TEXTURE_WRAP_S</code>
 <p>
 Returns the single-valued wrapping function for texture coordinate s, 
 a symbolic constant. The initial value is <code>GL_REPEAT</code>.
 <p>
 <code>GL_TEXTURE_WRAP_T</code>
 <p>
 Returns the single-valued wrapping function for texture coordinate t, 
 a symbolic constant. The initial value is <code>GL_REPEAT</code>.
 <p>
 <h4>Notes</h4>
 <p>
 If an error is generated, no change is made to the contents of <i><code>params</code></i>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> or <i><code>pname</code></i> 
  is not an accepted value.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the symbolic name of the target texture. 
  <code>GL_TEXTURE_2D</code> and <code>GL_TEXTURE_CUBE_MAP</code> are accepted.<DD><CODE>pname</CODE> - Specifies the symbolic name of a texture parameter. 
  <code>GL_TEXTURE_MAG_FILTER</code>, <code>GL_TEXTURE_MIN_FILTER</code>, 
  <code>GL_TEXTURE_WRAP_S</code>, and <code>GL_TEXTURE_WRAP_T</code> are accepted.<DD><CODE>params</CODE> - Returns the texture parameter.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length -
             <i>offset</i></code> is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, float[], int)"><CODE>GL20.glGetTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetTexParameteriv(int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glGetTexParameteriv</H3>
<PRE>
void <B>glGetTexParameteriv</B>(int&nbsp;target,
                         int&nbsp;pname,
                         <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, int[], int)"><CODE>glGetTexParameteriv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> or <i><code>pname</code></i> 
  is not an accepted value.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the symbolic name of the target texture. 
  <code>GL_TEXTURE_2D</code> and <code>GL_TEXTURE_CUBE_MAP</code> are accepted.<DD><CODE>pname</CODE> - Specifies the symbolic name of a texture parameter. 
  <code>GL_TEXTURE_MAG_FILTER</code>, <code>GL_TEXTURE_MIN_FILTER</code>, 
  <code>GL_TEXTURE_WRAP_S</code>, and <code>GL_TEXTURE_WRAP_T</code> are accepted.<DD><CODE>params</CODE> - Returns the texture parameter.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> is smaller than the
             number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, float[], int)"><CODE>GL20.glGetTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, int[], int)"><CODE>GL20.glGetTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetUniformfv(int, int, int, float[], int)"><!-- --></A><H3>
glGetUniformfv</H3>
<PRE>
void <B>glGetUniformfv</B>(int&nbsp;program,
                    int&nbsp;location,
                    int&nbsp;count,
                    float[]&nbsp;params,
                    int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>glGetUniformiv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> has not been successfully linked.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> does not correspond to a valid 
  uniform variable location for the specified program object.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to be queried.<DD><CODE>location</CODE> - Specifies the location of the uniform variable to be queried.<DD><CODE>count</CODE> - Specifies the number of values to be returned.<DD><CODE>params</CODE> - Returns the value of the specified uniform variable.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length -
             <i>offset</i></code> is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetUniformfv(int, int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, java.nio.IntBuffer)"><CODE>GL20.glGetUniformiv(int, int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>GL20.glGetUniformiv(int, int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetUniformfv(int, int, int, java.nio.FloatBuffer)"><!-- --></A><H3>
glGetUniformfv</H3>
<PRE>
void <B>glGetUniformfv</B>(int&nbsp;program,
                    int&nbsp;location,
                    int&nbsp;count,
                    <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, java.nio.IntBuffer)"><CODE>glGetUniformiv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> has not been successfully linked.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> does not correspond to a valid 
  uniform variable location for the specified program object.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to be queried.<DD><CODE>location</CODE> - Specifies the location of the uniform variable to be queried.<DD><CODE>count</CODE> - Specifies the number of values to be returned.<DD><CODE>params</CODE> - Returns the value of the specified uniform variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> is smaller than the
             number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetUniformfv(int, int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, float[], int)"><CODE>GL20.glGetUniformfv(int, int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>GL20.glGetUniformiv(int, int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetUniformiv(int, int, int, int[], int)"><!-- --></A><H3>
glGetUniformiv</H3>
<PRE>
void <B>glGetUniformiv</B>(int&nbsp;program,
                    int&nbsp;location,
                    int&nbsp;count,
                    int[]&nbsp;params,
                    int&nbsp;offset)</PRE>
<DL>
<DD>Return the value of a uniform variable.
 <p>
 <h4>Description</h4>
 <code>glGetUniform</code> returns in <i><code>params</code></i> the value(s) of the 
 specified uniform variable. The type of the uniform variable 
 specified by <i><code>location</code></i> determines the number of values returned. 
 If the uniform variable is defined in the shader as a 
 boolean, int, or float, a single value will be returned. 
 If it is defined as a vec2, ivec2, or bvec2, two values 
 will be returned. If it is defined as a vec3, ivec3, or bvec3, 
 three values will be returned, and so on. To query values 
 stored in uniform variables declared as arrays, 
 call <code>glGetUniform</code> for each element of the array. 
 To query values stored in uniform variables declared as 
 structures, call <code>glGetUniform</code> for each field in the 
 structure. The values for uniform variables declared 
 as a matrix will be returned in column major order.
 <p>
 The locations assigned to uniform variables are not 
 known until the program object is linked. 
 After linking has occurred, the command <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformLocation(int, java.lang.String)"><CODE>glGetUniformLocation</CODE></A> 
 can be used to obtain the location of a uniform variable. 
 This location value can then be passed to <code>glGetUniform</code> 
 in order to query the current value of the uniform variable. 
 After a program object has been linked successfully, the index 
 values for uniform variables remain fixed until the next 
 link command occurs. The uniform variable values can 
 only be queried after a link if the link was successful.
 <p>
 <h4>Notes</h4>
 <p>
 If an error is generated, no change is made to the contents of <i><code>params</code></i>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> has not been successfully linked.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> does not correspond to a valid 
  uniform variable location for the specified program object.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveUniform(int, int, int[], int, int[], int)"><CODE>glGetActiveUniform</CODE></A>
  with arguments <i><code>program</code></i> and the index of an active uniform variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A>
  with arguments <i><code>program</code></i> and <code>GL_ACTIVE_UNIFORMS</code> or <code>GL_ACTIVE_UNIFORM_MAX_LENGTH</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformLocation(int, java.lang.String)"><CODE>glGetUniformLocation</CODE></A> with arguments
  <i><code>program</code></i> and the name of a uniform variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to be queried.<DD><CODE>location</CODE> - Specifies the location of the uniform variable to be queried.<DD><CODE>count</CODE> - Specifies the number of values to be returned.<DD><CODE>params</CODE> - Returns the value of the specified uniform variable.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length -
             <i>offset</i></code> is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateProgram()"><CODE>GL20.glCreateProgram()</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetUniformfv(int, int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, float[], int)"><CODE>GL20.glGetUniformfv(int, int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, java.nio.IntBuffer)"><CODE>GL20.glGetUniformiv(int, int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform1fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, float[], int)"><CODE>GL20.glUniform1fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1i(int, int)"><CODE>GL20.glUniform1i(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform1iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, int[], int)"><CODE>GL20.glUniform1iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2f(int, float, float)"><CODE>GL20.glUniform2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform2fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, float[], int)"><CODE>GL20.glUniform2fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2i(int, int, int)"><CODE>GL20.glUniform2i(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform2iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, int[], int)"><CODE>GL20.glUniform2iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3f(int, float, float, float)"><CODE>GL20.glUniform3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform3fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, float[], int)"><CODE>GL20.glUniform3fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3i(int, int, int, int)"><CODE>GL20.glUniform3i(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform3iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, int[], int)"><CODE>GL20.glUniform3iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4f(int, float, float, float, float)"><CODE>GL20.glUniform4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform4fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, float[], int)"><CODE>GL20.glUniform4fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4i(int, int, int, int, int)"><CODE>GL20.glUniform4i(int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform4iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, int[], int)"><CODE>GL20.glUniform4iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix2fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix2fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix3fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix3fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix4fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix4fv(int, int, boolean, float[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetUniformiv(int, int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glGetUniformiv</H3>
<PRE>
void <B>glGetUniformiv</B>(int&nbsp;program,
                    int&nbsp;location,
                    int&nbsp;count,
                    <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Int <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>glGetUniformiv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> has not been successfully linked.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> does not correspond to a valid 
  uniform variable location for the specified program object.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to be queried.<DD><CODE>location</CODE> - Specifies the location of the uniform variable to be queried.<DD><CODE>count</CODE> - Specifies the number of values to be returned.<DD><CODE>params</CODE> - Returns the value of the specified uniform variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> is smaller than the
             number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetUniformfv(int, int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, float[], int)"><CODE>GL20.glGetUniformfv(int, int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>GL20.glGetUniformiv(int, int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetUniformLocation(int, java.lang.String)"><!-- --></A><H3>
glGetUniformLocation</H3>
<PRE>
int <B>glGetUniformLocation</B>(int&nbsp;program,
                         <A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;name)</PRE>
<DL>
<DD>Return the location of a uniform variable.
 <p>
 <h4>Description</h4>
 <code>glGetUniformLocation</code> returns an integer that represents the location of a 
 specific uniform variable within a program object. <i><code>name</code></i> must be a 
 string that contains no white space. <i><code>name</code></i> must be an active uniform variable name 
 in <i><code>program</code></i> that is not a structure, an array of structures, or a subcomponent of 
 a vector or a matrix. This function returns -1 if <i><code>name</code></i> does not correspond to an 
 active uniform variable in <i><code>program</code></i> or if <i><code>name</code></i> starts with
 the reserved prefix "gl_".
 <p>
 Uniform variables that are structures or arrays of structures may be queried by calling 
 <code>glGetUniformLocation</code> for each field within the structure. The array element operator "[]" 
 and the structure field operator "." may be used in <i><code>name</code></i> in order to select elements within 
 an array or fields within a structure. The result of using these operators is not allowed 
 to be another structure, an array of structures, or a subcomponent of a vector or a matrix. 
 Except if the last part of <i><code>name</code></i> indicates a uniform variable array, the location of the first 
 element of an array can be retrieved by using the name of the array, or by using the name 
 appended by "[0]".
 <p>
 The actual locations assigned to uniform variables are not known until the program 
 object is linked successfully. After linking has occurred, the command <code>glGetUniformLocation</code> 
 can be used to obtain the location of a uniform variable. This location value can then
 be passed to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform1fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, float[], int)"><CODE>glUniform1fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1i(int, int)"><CODE>glUniform1i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, java.nio.IntBuffer)"><CODE>glUniform1iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, int[], int)"><CODE>glUniform1iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2f(int, float, float)"><CODE>glUniform2f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, float[], int)"><CODE>glUniform2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2i(int, int, int)"><CODE>glUniform2i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, java.nio.IntBuffer)"><CODE>glUniform2iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, int[], int)"><CODE>glUniform2iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3f(int, float, float, float)"><CODE>glUniform3f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, float[], int)"><CODE>glUniform3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3i(int, int, int, int)"><CODE>glUniform3i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, java.nio.IntBuffer)"><CODE>glUniform3iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, int[], int)"><CODE>glUniform3iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4f(int, float, float, float, float)"><CODE>glUniform4f</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, java.nio.FloatBuffer)"><CODE>glUniform4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, float[], int)"><CODE>glUniform4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4i(int, int, int, int, int)"><CODE>glUniform4i</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, java.nio.IntBuffer)"><CODE>glUniform4iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, int[], int)"><CODE>glUniform4iv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>glUniformMatrix2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, float[], int)"><CODE>glUniformMatrix2fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>glUniformMatrix3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, float[], int)"><CODE>glUniformMatrix3fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>glUniformMatrix4fv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, float[], int)"><CODE>glUniformMatrix4fv</CODE></A>
 to set the value of the uniform variable or to 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, java.nio.FloatBuffer)"><CODE>glGetUniformfv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, float[], int)"><CODE>glGetUniformfv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, java.nio.IntBuffer)"><CODE>glGetUniformiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>glGetUniformiv</CODE></A> in 
 order to query the current value of the uniform variable. After a program object
 has been linked successfully, the index values for uniform variables remain 
 fixed until the next link command occurs. Uniform variable locations and values 
 can only be queried after a link if the link was successful.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> has not been successfully linked.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveUniform(int, int, int[], int, int[], int)"><CODE>glGetActiveUniform</CODE></A>
  with arguments <i><code>program</code></i> and the index of an active uniform variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A>
  with arguments <i><code>program</code></i> and <code>GL_ACTIVE_UNIFORMS</code> or <code>GL_ACTIVE_UNIFORM_MAX_LENGTH</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, java.nio.FloatBuffer)"><CODE>glGetUniformfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, float[], int)"><CODE>glGetUniformfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, java.nio.IntBuffer)"><CODE>glGetUniformiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>glGetUniformiv</CODE></A>
  with arguments <i><code>program</code></i> and the name of a uniform variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the program object to be queried.<DD><CODE>name</CODE> - Specifies a <A HREF="../../../../../java/lang/String.html" title="class in java.lang"><CODE>String</CODE></A> containing the name of the uniform whose location is to be queried.
<DT><B>Returns:</B><DD>Returns the uniform location.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>name</code></i> is <code>null</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform1fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, float[], int)"><CODE>GL20.glUniform1fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1i(int, int)"><CODE>GL20.glUniform1i(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform1iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, int[], int)"><CODE>GL20.glUniform1iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2f(int, float, float)"><CODE>GL20.glUniform2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform2fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, float[], int)"><CODE>GL20.glUniform2fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2i(int, int, int)"><CODE>GL20.glUniform2i(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform2iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, int[], int)"><CODE>GL20.glUniform2iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3f(int, float, float, float)"><CODE>GL20.glUniform3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform3fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, float[], int)"><CODE>GL20.glUniform3fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3i(int, int, int, int)"><CODE>GL20.glUniform3i(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform3iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, int[], int)"><CODE>GL20.glUniform3iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4f(int, float, float, float, float)"><CODE>GL20.glUniform4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform4fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, float[], int)"><CODE>GL20.glUniform4fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4i(int, int, int, int, int)"><CODE>GL20.glUniform4i(int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform4iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, int[], int)"><CODE>GL20.glUniform4iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix2fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix2fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix3fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix3fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix4fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix4fv(int, int, boolean, float[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetVertexAttribfv(int, int, float[], int)"><!-- --></A><H3>
glGetVertexAttribfv</H3>
<PRE>
void <B>glGetVertexAttribfv</B>(int&nbsp;index,
                         int&nbsp;pname,
                         float[]&nbsp;params,
                         int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>glGetVertexAttribiv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not an 
  accepted value.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the generic vertex attribute parameter to be queried.<DD><CODE>pname</CODE> - Specifies the symbolic name of the vertex attribute parameter 
  to be queried. Accepted values are <code>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</code>, 
  <code>GL_VERTEX_ATTRIB_ARRAY_ENABLED</code>, <code>GL_VERTEX_ATTRIB_ARRAY_SIZE</code>, 
  <code>GL_VERTEX_ATTRIB_ARRAY_STRIDE</code>, <code>GL_VERTEX_ATTRIB_ARRAY_TYPE</code>, 
  <code>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</code>, or <code>GL_CURRENT_VERTEX_ATTRIB</code>.<DD><CODE>params</CODE> - Returns the requested data.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length -
             <i>offset</i></code> is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetVertexAttribfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetVertexAttribiv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>GL20.glGetVertexAttribiv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetVertexAttribfv(int, int, java.nio.FloatBuffer)"><!-- --></A><H3>
glGetVertexAttribfv</H3>
<PRE>
void <B>glGetVertexAttribfv</B>(int&nbsp;index,
                         int&nbsp;pname,
                         <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Floating-point version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><CODE>glGetVertexAttribiv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not an 
  accepted value.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the generic vertex attribute parameter to be queried.<DD><CODE>pname</CODE> - Specifies the symbolic name of the vertex attribute parameter 
  to be queried. Accepted values are <code>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</code>, 
  <code>GL_VERTEX_ATTRIB_ARRAY_ENABLED</code>, <code>GL_VERTEX_ATTRIB_ARRAY_SIZE</code>, 
  <code>GL_VERTEX_ATTRIB_ARRAY_STRIDE</code>, <code>GL_VERTEX_ATTRIB_ARRAY_TYPE</code>, 
  <code>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</code>, or <code>GL_CURRENT_VERTEX_ATTRIB</code>.<DD><CODE>params</CODE> - Returns the requested data.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> is smaller than the
             number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, float[], int)"><CODE>GL20.glGetVertexAttribfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetVertexAttribiv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>GL20.glGetVertexAttribiv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetVertexAttribiv(int, int, int[], int)"><!-- --></A><H3>
glGetVertexAttribiv</H3>
<PRE>
void <B>glGetVertexAttribiv</B>(int&nbsp;index,
                         int&nbsp;pname,
                         int[]&nbsp;params,
                         int&nbsp;offset)</PRE>
<DL>
<DD>Return a generic vertex attribute parameter.
 <p>
 <h4>Description</h4>
 <code>glGetVertexAttrib</code> returns in <i><code>params</code></i> the value of a generic 
 vertex attribute parameter. The generic vertex attribute 
 to be queried is specified by <i><code>index</code></i>, and the parameter 
 to be queried is specified by <i><code>pname</code></i>.
 <p>
 The accepted parameter names are as follows:
 <p>
 <code>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</code>
 <p>
 <i><code>params</code></i> returns a single value, the name of the buffer 
 object currently bound to the binding point corresponding 
 to generic vertex attribute array <i><code>index</code></i>. If no buffer 
 object is bound, 0 is returned. The initial value is 0.
 <p>
 <code>GL_VERTEX_ATTRIB_ARRAY_ENABLED</code>
 <p>
 <i><code>params</code></i> returns a single value that is non-zero (true) if the 
 vertex attribute array for <i><code>index</code></i> is enabled and 0 (false) 
 if it is disabled. The initial value is <code>GL_FALSE</code>.
 <p>
 <code>GL_VERTEX_ATTRIB_ARRAY_SIZE</code>
 <p>
 <i><code>params</code></i> returns a single value, the size of the vertex 
 attribute array for <i><code>index</code></i>. The size is the number of 
 values for each element of the vertex attribute array, 
 and it will be 1, 2, 3, or 4. The initial value is 4.
 <p>
 <code>GL_VERTEX_ATTRIB_ARRAY_STRIDE</code>
 <p>
 <i><code>params</code></i> returns a single value, the array stride for 
 (number of bytes between successive elements in) the 
 vertex attribute array for <i><code>index</code></i>. A value of 0 
 indicates that the array elements are stored sequentially 
 in memory. The initial value is 0.
 <p>
 <code>GL_VERTEX_ATTRIB_ARRAY_TYPE</code>
 <p>
 <i><code>params</code></i> returns a single value, a symbolic constant indicating 
 the array type for the vertex attribute array for <i><code>index</code></i>. 
 Possible values are <code>GL_BYTE</code>, <code>GL_UNSIGNED_BYTE</code>, <code>GL_SHORT</code>, 
 <code>GL_UNSIGNED_SHORT</code>, <code>GL_FIXED</code>, and <code>GL_FLOAT</code>. 
 The initial value is <code>GL_FLOAT</code>.
 <p>
 <code>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</code>
 <p>
 <i><code>params</code></i> returns a single value that is non-zero (true) 
 if fixed-point data types for the vertex attribute 
 array indicated by <i><code>index</code></i> are normalized when they 
 are converted to floating point, and 0 (false) 
 otherwise. The initial value is <code>GL_FALSE</code>.
 <p>
 <code>GL_CURRENT_VERTEX_ATTRIB</code>
 <p>
 <i><code>params</code></i> returns four values that represent the current 
 value for the generic vertex attribute specified by <i><code>index</code></i>. 
 The initial value is (0,0,0,1).
 <p>
 All of the parameters except <code>GL_CURRENT_VERTEX_ATTRIB</code> 
 represent client-side state.
 <p>
 <h4>Notes</h4>
 <p>
 If an error is generated, no change is made to the contents of <i><code>params</code></i>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not an 
  accepted value.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_MAX_VERTEX_ATTRIBS</code> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the generic vertex attribute parameter to be queried.<DD><CODE>pname</CODE> - Specifies the symbolic name of the vertex attribute parameter 
  to be queried. Accepted values are <code>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</code>, 
  <code>GL_VERTEX_ATTRIB_ARRAY_ENABLED</code>, <code>GL_VERTEX_ATTRIB_ARRAY_SIZE</code>, 
  <code>GL_VERTEX_ATTRIB_ARRAY_STRIDE</code>, <code>GL_VERTEX_ATTRIB_ARRAY_TYPE</code>, 
  <code>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</code>, or <code>GL_CURRENT_VERTEX_ATTRIB</code>.<DD><CODE>params</CODE> - Returns the requested data.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length -
             <i>offset</i></code> is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindAttribLocation(int, int, java.lang.String)"><CODE>GL20.glBindAttribLocation(int, int, String)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>GL20.glBindBuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisableVertexAttribArray(int)"><CODE>GL20.glDisableVertexAttribArray(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnableVertexAttribArray(int)"><CODE>GL20.glEnableVertexAttribArray(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetVertexAttribfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, float[], int)"><CODE>GL20.glGetVertexAttribfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetVertexAttribiv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib1fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, float[], int)"><CODE>GL20.glVertexAttrib1fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2f(int, float, float)"><CODE>GL20.glVertexAttrib2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib2fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, float[], int)"><CODE>GL20.glVertexAttrib2fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3f(int, float, float, float)"><CODE>GL20.glVertexAttrib3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib3fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, float[], int)"><CODE>GL20.glVertexAttrib3fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4f(int, float, float, float, float)"><CODE>GL20.glVertexAttrib4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib4fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, float[], int)"><CODE>GL20.glVertexAttrib4fv(int, float[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glGetVertexAttribiv</H3>
<PRE>
void <B>glGetVertexAttribiv</B>(int&nbsp;index,
                         int&nbsp;pname,
                         <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>glGetVertexAttribiv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not an 
  accepted value.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the generic vertex attribute parameter to be queried.<DD><CODE>pname</CODE> - Specifies the symbolic name of the vertex attribute parameter 
  to be queried. Accepted values are <code>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</code>, 
  <code>GL_VERTEX_ATTRIB_ARRAY_ENABLED</code>, <code>GL_VERTEX_ATTRIB_ARRAY_SIZE</code>, 
  <code>GL_VERTEX_ATTRIB_ARRAY_STRIDE</code>, <code>GL_VERTEX_ATTRIB_ARRAY_TYPE</code>, 
  <code>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</code>, or <code>GL_CURRENT_VERTEX_ATTRIB</code>.<DD><CODE>params</CODE> - Returns the requested data.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> is smaller than the
             number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetVertexAttribfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, float[], int)"><CODE>GL20.glGetVertexAttribfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>GL20.glGetVertexAttribiv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glHint(int, int)"><!-- --></A><H3>
glHint</H3>
<PRE>
void <B>glHint</B>(int&nbsp;target,
            int&nbsp;mode)</PRE>
<DL>
<DD>Specify implementation-specific hints.
 <p>
 <h4>Description</h4>
 Certain aspects of GL behavior, when there is room for interpretation, 
 can be controlled with hints. A hint is specified with two arguments. 
 <i><code>target</code></i> is a symbolic constant indicating the behavior to be controlled, 
 and <i><code>mode</code></i> is another symbolic constant indicating the desired behavior. 
 The initial value for each <i><code>target</code></i> is <code>GL_DONT_CARE</code>. 
 <i><code>mode</code></i> can be one of the following:
 <p>
 <code>GL_FASTEST</code>
 <p>
 The most efficient option should be chosen.
 <p>
 <code>GL_NICEST</code>
 <p>
 The most correct, or highest quality, option should be chosen.
 <p>
 <code>GL_DONT_CARE</code>
 <p>
 No preference.
 <p>
 Though the implementation aspects that can be hinted are well defined, 
 the interpretation of the hints depends on the implementation. 
 The hint aspects that can be specified with <i><code>target</code></i>, along with 
 suggested semantics, are as follows:
 <p>
 <code>GL_GENERATE_MIPMAP_HINT</code>
 <p>
 Indicates the quality of filtering when generating
 mipmap images with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenerateMipmap(int)"><CODE>glGenerateMipmap</CODE></A>.
 <p>
 <h4>Notes</h4>
 <p>
 The interpretation of hints depends on the implementation. 
 Some implementations ignore <code>glHint</code> settings.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if either <i><code>target</code></i> or 
  <i><code>mode</code></i> is not an accepted value.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies a symbolic constant indicating the 
  behavior to be controlled. <code>GL_GENERATE_MIPMAP_HINT</code> is accepted.<DD><CODE>mode</CODE> - Specifies a symbolic constant indicating the desired behavior. 
  <code>GL_FASTEST</code>, <code>GL_NICEST</code>, and <code>GL_DONT_CARE</code> are accepted.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenerateMipmap(int)"><CODE>GL20.glGenerateMipmap(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glIsBuffer(int)"><!-- --></A><H3>
glIsBuffer</H3>
<PRE>
boolean <B>glIsBuffer</B>(int&nbsp;buffer)</PRE>
<DL>
<DD>Determine if a name corresponds to a buffer object.
 <p>
 <h4>Description</h4>
 <code>glIsBuffer</code> returns <code>true</code> if <i><code>buffer</code></i> is currently 
 the name of a buffer object. If <i><code>buffer</code></i> is zero, or is a non-zero 
 value that is not currently the name of a buffer object, 
 or if an error occurs, <code>glIsBuffer</code> returns <code>false</code>.
 <p>
 A name returned by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, java.nio.IntBuffer)"><CODE>glGenBuffers</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, int[], int)"><CODE>glGenBuffers</CODE></A>, but not yet associated 
 with a buffer object by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>glBindBuffer</CODE></A>, 
 is not the name of a buffer object.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffer</CODE> - Specifies a value that may be the name of a buffer object.
<DT><B>Returns:</B><DD><code>true</code> if <i><code>buffer</code></i> is the name of a buffer object.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>GL20.glBindBuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteBuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteBuffers(int, int[], int)"><CODE>GL20.glDeleteBuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, java.nio.IntBuffer)"><CODE>GL20.glGenBuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenBuffers(int, int[], int)"><CODE>GL20.glGenBuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, java.nio.IntBuffer)"><CODE>GL20.glGetBooleanv(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, boolean[], int)"><CODE>GL20.glGetBooleanv(int, boolean[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>GL20.glGetIntegerv(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>GL20.glGetIntegerv(int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glIsEnabled(int)"><!-- --></A><H3>
glIsEnabled</H3>
<PRE>
boolean <B>glIsEnabled</B>(int&nbsp;cap)</PRE>
<DL>
<DD>Test whether a capability is enabled
 <p>
 <code>glIsEnabled</code> returns <code>true</code> if <i><code>cap</code></i> is an enabled capability and 
 returns <code>false</code> otherwise. Initially all capabilities 
 except <code>GL_DITHER</code> are disabled; <code>GL_DITHER</code> is initially enabled.
 <p>
 The following capabilities are accepted for <i><code>cap</code></i>:
 <p>
 <table border=1><tbody><tr>
  <td><b>Constant</b></td><td><b>See</b></td>
 </tr><tr>
  <td><code>GL_BLEND</code></td><td><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>glBlendFunc</CODE></A></td>
 </tr><tr>
  <td><code>GL_CULL_FACE</code></td><td><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCullFace(int)"><CODE>glCullFace</CODE></A></td>
 </tr><tr>
  <td><code>GL_DEPTH_TEST</code></td>
  <td><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>glDepthFunc</CODE></A>, <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthRangef(float, float)"><CODE>glDepthRangef</CODE></A></td>
 </tr><tr>
  <td><code>GL_DITHER</code></td><td><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>glEnable</CODE></A></td>
 </tr><tr>
  <td><code>GL_POLYGON_OFFSET_FILL</code></td><td><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPolygonOffset(float, float)"><CODE>glPolygonOffset</CODE></A></td>
 </tr><tr>
  <td><code>GL_SAMPLE_ALPHA_TO_COVERAGE</code></td><td><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glSampleCoverage(float, boolean)"><CODE>glSampleCoverage</CODE></A></td>
 </tr><tr>
  <td><code>GL_SAMPLE_COVERAGE</code></td><td><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glSampleCoverage(float, boolean)"><CODE>glSampleCoverage</CODE></A></td>
 </tr><tr>
  <td><code>GL_SCISSOR_TEST</code></td><td><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glScissor(int, int, int, int)"><CODE>glScissor</CODE></A></td>
 </tr><tr>
  <td><code>GL_STENCIL_TEST</code></td>
  <td><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>glStencilFunc</CODE></A>, <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>glStencilOp</CODE></A></td>
 </tr></tbody></table>
 <p>
 <h4>Notes</h4>
 <p>
 If an error is generated, <code>glIsEnabled</code> returns <code>false</code>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>cap</code></i> is not an accepted value.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cap</CODE> - Specifies a symbolic constant indicating a GL capability.
<DT><B>Returns:</B><DD><code>true</code> if the given capability is enabled.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>GL20.glEnable(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, java.nio.IntBuffer)"><CODE>GL20.glGetBooleanv(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, boolean[], int)"><CODE>GL20.glGetBooleanv(int, boolean[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>GL20.glGetIntegerv(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>GL20.glGetIntegerv(int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glIsFramebuffer(int)"><!-- --></A><H3>
glIsFramebuffer</H3>
<PRE>
boolean <B>glIsFramebuffer</B>(int&nbsp;framebuffer)</PRE>
<DL>
<DD>Determine if a name corresponds to a framebuffer object.
 <p>
 <h4>Description</h4>
 <code>glIsFramebuffer</code> returns <code>true</code> if <i><code>framebuffer</code></i> is 
 currently the name of a framebuffer object. If <i><code>framebuffer</code></i> is zero, 
 or is a non-zero value that is not currently the name of a framebuffer object, 
 or if an error occurs, <code>glIsFramebuffer</code> returns <code>false</code>.
 <p>
 A name returned by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, java.nio.IntBuffer)"><CODE>glGenFramebuffers</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, int[], int)"><CODE>glGenFramebuffers</CODE></A>, but not yet associated with a 
 framebuffer object by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindFramebuffer(int, int)"><CODE>glBindFramebuffer</CODE></A>, is not the name 
 of a framebuffer object.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>framebuffer</CODE> - Specifies a value that may be the name of a framebuffer object.
<DT><B>Returns:</B><DD><code>true</code> if <i><code>framebuffer</code></i> is the name of a framebuffer object.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindFramebuffer(int, int)"><CODE>GL20.glBindFramebuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteFramebuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteFramebuffers(int, int[], int)"><CODE>GL20.glDeleteFramebuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, java.nio.IntBuffer)"><CODE>GL20.glGenFramebuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenFramebuffers(int, int[], int)"><CODE>GL20.glGenFramebuffers(int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glIsProgram(int)"><!-- --></A><H3>
glIsProgram</H3>
<PRE>
boolean <B>glIsProgram</B>(int&nbsp;program)</PRE>
<DL>
<DD>Determine if a name corresponds to a program object.
 <p>
 <h4>Description</h4>
 <code>glIsProgram</code> returns <code>true</code> if <i><code>program</code></i> is the 
 name of a program object previously created 
 with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateProgram()"><CODE>glCreateProgram</CODE></A> and not yet deleted with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteProgram(int)"><CODE>glDeleteProgram</CODE></A>. 
 If <i><code>program</code></i> is zero or a non-zero value that is not the name 
 of a program object, or if an error occurs, 
 <code>glIsProgram</code> returns <code>false</code>.
 <p>
 <h4>Notes</h4>
 <p>
 No error is generated if <i><code>program</code></i> is not a valid program object name.
 <p>
 A program object marked for deletion with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteProgram(int)"><CODE>glDeleteProgram</CODE></A> but 
 still in use as part of current rendering state is still 
 considered a program object and <code>glIsProgram</code> will return <code>true</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies a potential program object.
<DT><B>Returns:</B><DD><code>true</code> if <i><code>program</code></i> is the name of a program object.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateProgram()"><CODE>GL20.glCreateProgram()</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteProgram(int)"><CODE>GL20.glDeleteProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>GL20.glUseProgram(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glIsRenderbuffer(int)"><!-- --></A><H3>
glIsRenderbuffer</H3>
<PRE>
boolean <B>glIsRenderbuffer</B>(int&nbsp;renderbuffer)</PRE>
<DL>
<DD>Determine if a name corresponds to a renderbuffer object.
 <p>
 <h4>Description</h4>
 <code>glIsRenderbuffer</code> returns <code>true</code> if <i><code>renderbuffer</code></i> is 
 currently the name of a renderbuffer object. If <i><code>renderbuffer</code></i> is zero, 
 or is a non-zero value that is not currently the name of a renderbuffer 
 object, or if an error occurs, <code>glIsRenderbuffer</code> returns <code>false</code>.
 <p>
 A name returned by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, java.nio.IntBuffer)"><CODE>glGenRenderbuffers</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, int[], int)"><CODE>glGenRenderbuffers</CODE></A>, but not yet associated with a 
 renderbuffer object by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindRenderbuffer(int, int)"><CODE>glBindRenderbuffer</CODE></A>, is not the name 
 of a renderbuffer object.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>renderbuffer</CODE> - Specifies a value that may be the name of a renderbuffer object.
<DT><B>Returns:</B><DD><code>true</code> if <i><code>renderbuffer</code></i> is the name of a renderbuffer object.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindRenderbuffer(int, int)"><CODE>GL20.glBindRenderbuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteRenderbuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, int[], int)"><CODE>GL20.glDeleteRenderbuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, java.nio.IntBuffer)"><CODE>GL20.glGenRenderbuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, int[], int)"><CODE>GL20.glGenRenderbuffers(int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glIsShader(int)"><!-- --></A><H3>
glIsShader</H3>
<PRE>
boolean <B>glIsShader</B>(int&nbsp;shader)</PRE>
<DL>
<DD>Determine if a name corresponds to a shader object.
 <p>
 <h4>Description</h4>
 <code>glIsShader</code> returns <code>true</code> if <i><code>shader</code></i> is the name of a 
 shader object previously created with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateShader(int)"><CODE>glCreateShader</CODE></A> and not yet 
 deleted with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteShader(int)"><CODE>glDeleteShader</CODE></A>. If <i><code>shader</code></i> is zero or a non-zero value 
 that is not the name of a shader object, or if an error occurs, 
 <code>glIsShader</code> returns <code>false</code>.
 <p>
 <h4>Notes</h4>
 <p>
 No error is generated if <i><code>shader</code></i> is not a valid shader object name.
 <p>
 A shader object marked for deletion with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteShader(int)"><CODE>glDeleteShader</CODE></A> but still 
 attached to a program object is still considered a shader object 
 and <code>glIsShader</code> will return <code>true</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shader</CODE> - Specifies a potential shader object.
<DT><B>Returns:</B><DD><code>true</code> if <i><code>shader</code></i> is the name of a shader object.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateShader(int)"><CODE>GL20.glCreateShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteShader(int)"><CODE>GL20.glDeleteShader(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glIsTexture(int)"><!-- --></A><H3>
glIsTexture</H3>
<PRE>
boolean <B>glIsTexture</B>(int&nbsp;texture)</PRE>
<DL>
<DD>Determine if a name corresponds to a texture.
 <p>
 <h4>Description</h4>
 <code>glIsTexture</code> returns <code>true</code> if <i><code>texture</code></i> is currently the name of a texture. 
 If <i><code>texture</code></i> is zero, or is a non-zero value that is not currently the 
 name of a texture, or if an error occurs, <code>glIsTexture</code> returns <code>false</code>.
 <p>
 A name returned by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, java.nio.IntBuffer)"><CODE>glGenTextures</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, int[], int)"><CODE>glGenTextures</CODE></A>,
 but not yet associated with a texture by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindTexture(int, int)"><CODE>glBindTexture</CODE></A>, is not the name of a texture.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>texture</CODE> - Specifies a value that may be the name of a texture.
<DT><B>Returns:</B><DD><code>true</code> if <i><code>texture</code></i> is the name of a texture object.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindTexture(int, int)"><CODE>GL20.glBindTexture(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteTextures(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteTextures(int, int[], int)"><CODE>GL20.glDeleteTextures(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, java.nio.IntBuffer)"><CODE>GL20.glGenTextures(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenTextures(int, int[], int)"><CODE>GL20.glGenTextures(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, java.nio.IntBuffer)"><CODE>GL20.glGetBooleanv(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetBooleanv(int, boolean[], int)"><CODE>GL20.glGetBooleanv(int, boolean[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>GL20.glGetIntegerv(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>GL20.glGetIntegerv(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glGetTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, float[], int)"><CODE>GL20.glGetTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, int[], int)"><CODE>GL20.glGetTexParameteriv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glLineWidth(float)"><!-- --></A><H3>
glLineWidth</H3>
<PRE>
void <B>glLineWidth</B>(float&nbsp;width)</PRE>
<DL>
<DD>Specify the width of rasterized lines
 <p>
 <h4>Description</h4>
 <code>glLineWidth</code> specifies the rasterized width of lines.
 <p>
 The actual width is determined by rounding the supplied 
 width to the nearest integer. (If the rounding results 
 in the value 0, it is as if the line width were 1.) 
 If <code>&#x394x >= &#x394y</code>, <i>i</i> pixels are filled in each column that is 
 rasterized, where <i>i</i> is the rounded value of <i><code>width</code></i>. 
 Otherwise, <i>i</i> pixels are filled in each row that is rasterized.
 <p>
 There is a range of supported line widths. 
 Only width 1 is guaranteed to be supported; 
 others depend on the implementation. 
 To query the range of supported widths, 
 call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
 with argument <code>GL_ALIASED_LINE_WIDTH_RANGE</code>.
 <p>
 <h4>Notes</h4>
 <p>
 The line width specified by <code>glLineWidth</code> is always 
 returned when <code>GL_LINE_WIDTH</code> is queried. 
 Clamping and rounding have no effect on the specified value.
 <p>
 Line width may be clamped to an implementation-dependent maximum. 
 Call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
 with <code>GL_ALIASED_LINE_WIDTH_RANGE</code> to determine the maximum width.
 <p>
 <h4>Errors</h4>
 <p>
 <code>GL_INVALID_VALUE</code> is generated if <i><code>width</code></i> is 
  less than or equal to 0.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_LINE_WIDTH</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_ALIASED_LINE_WIDTH_RANGE</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>width</CODE> - Specifies the width of rasterized lines. The initial value is 1.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>GL20.glEnable(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glLinkProgram(int)"><!-- --></A><H3>
glLinkProgram</H3>
<PRE>
void <B>glLinkProgram</B>(int&nbsp;program)</PRE>
<DL>
<DD>Link a program object.
 <p>
 <h4>Description</h4>
 <code>glLinkProgram</code> links the program object specified by <i><code>program</code></i>. 
 Shader objects of type <code>GL_VERTEX_SHADER</code> attached to <i><code>program</code></i> are used to 
 create an executable that will run on the programmable vertex processor. 
 Shader objects of type <code>GL_FRAGMENT_SHADER</code> attached to <i><code>program</code></i> are used 
 to create an executable that will run on the programmable fragment processor.
 <p>
 The status of the link operation will be stored as part of the 
 program object's state. This value will be set to <code>GL_TRUE</code> if the program 
 object was linked without errors and is ready for use, and <code>GL_FALSE</code> otherwise. 
 It can be queried by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A> with arguments
 <i><code>program</code></i> and <code>GL_LINK_STATUS</code>.
 <p>
 As a result of a successful link operation, all active user-defined 
 uniform variables belonging to <i><code>program</code></i> will be initialized to 0, 
 and each of the program object's active uniform variables will be 
 assigned a location that can be queried by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformLocation(int, java.lang.String)"><CODE>glGetUniformLocation</CODE></A>. 
 Also, any active user-defined attribute variables that have not been 
 bound to a generic vertex attribute index will be bound to one at this time.
 <p>
 Linking of a program object can fail for a number of reasons as specified 
 in the <i>OpenGL ES Shading Language Specification</i>. The following lists some 
 of the conditions that will cause a link error.
 <ul>
 <li><p>
 A vertex shader and a fragment shader are not both present in the program object.
 </li>
 <li><p>
 The number of active attribute variables supported by the 
 implementation has been exceeded.
 </li>
 <li><p>
 The storage limit for uniform variables has been exceeded.
 </li>
 <li><p>
 The number of active uniform variables supported by the 
 implementation has been exceeded.
 </li>
 <li><p>
 The <code>main</code> function is missing for the vertex shader or the fragment shader.
 </li>
 <li><p>
 A varying variable actually used in the fragment shader is not 
 declared in the same way (or is not declared at all) in the vertex shader.
 </li>
 <li><p>
 A reference to a function or variable name is unresolved.
 </li>
 <li><p>
 A shared global is declared with two different types or two 
 different initial values.
 </li>
 <li><p>
 One or more of the attached shader objects has not been 
 successfully compiled (via <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>glCompileShader</CODE></A>) or loaded 
 with a pre-compiled shader binary (via <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, java.nio.IntBuffer, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A>).
 </li>
 <li><p>
 Binding a generic attribute matrix caused some rows of the 
 matrix to fall outside the allowed maximum of <code>GL_MAX_VERTEX_ATTRIBS</code>.
 </li>
 <li><p>
 Not enough contiguous vertex attribute slots could be 
 found to bind attribute matrices.
 </li>
 </ul>
 <p>
 When a program object has been successfully linked, 
 the program object can be made part of current state by 
 calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>glUseProgram</CODE></A>. Whether or not the link operation 
 was successful, the program object's information log will be overwritten. 
 The information log can be retrieved by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramInfoLog(int)"><CODE>glGetProgramInfoLog</CODE></A>.
 <p>
 <code>glLinkProgram</code> will also install the generated executables as part of the 
 current rendering state if the link operation was successful and the 
 specified program object is already currently in use as a result of a 
 previous call to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>glUseProgram</CODE></A>. If the program object currently in use is 
 relinked unsuccessfully, its link status will be set to <code>GL_FALSE</code>, 
 but the executables and associated state will remain part of the 
 current state until a subsequent call to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>glUseProgram</CODE></A> removes it 
 from use. After it is removed from use, it cannot be made part of 
 current state until it has been successfully relinked.
 <p>
 The program object's information log is updated and the program is 
 generated at the time of the link operation. After the link operation, 
 applications are free to modify attached shader objects, compile 
 attached shader objects, detach shader objects, delete shader objects, 
 and attach additional shader objects. None of these operations affects 
 the information log or the program that is part of the program object.
 <p>
 <h4>Notes</h4>
 <p>
 If the link operation is unsuccessful, any information about a previous 
 link operation on <i><code>program</code></i> is lost (i.e., a failed link does not restore 
 the old state of <i><code>program</code></i>). Certain information can still be retrieved 
 from <i><code>program</code></i> even after an unsuccessful link operation. 
 See for instance <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveAttrib(int, int, int[], int, int[], int)"><CODE>glGetActiveAttrib</CODE></A>
 and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveUniform(int, int, int[], int, int[], int)"><CODE>glGetActiveUniform</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is not a 
  value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is 
  not a program object.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with the argument <code>GL_CURRENT_PROGRAM</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveAttrib(int, int, int[], int, int[], int)"><CODE>glGetActiveAttrib</CODE></A>
  with argument <i><code>program</code></i> and the index of an active attribute variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveUniform(int, int, int[], int, int[], int)"><CODE>glGetActiveUniform</CODE></A>
  with argument <i><code>program</code></i> and the index of an active uniform variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, java.nio.IntBuffer, java.nio.IntBuffer)"><CODE>glGetAttachedShaders</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, int[], int, int[], int)"><CODE>glGetAttachedShaders</CODE></A>
  with argument <i><code>program</code></i>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttribLocation(int, java.lang.String)"><CODE>glGetAttribLocation</CODE></A>
  with argument <i><code>program</code></i> and an attribute variable name
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A>
  with arguments <i><code>program</code></i> and <code>GL_LINK_STATUS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramInfoLog(int)"><CODE>glGetProgramInfoLog</CODE></A>
  with argument <i><code>program</code></i>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, java.nio.FloatBuffer)"><CODE>glGetUniformfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, float[], int)"><CODE>glGetUniformfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, java.nio.IntBuffer)"><CODE>glGetUniformiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>glGetUniformiv</CODE></A>
  with argument <i><code>program</code></i> and a uniform variable location
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformLocation(int, java.lang.String)"><CODE>glGetUniformLocation</CODE></A>
  with argument <i><code>program</code></i> and a uniform variable name
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the handle of the program object to be linked.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glAttachShader(int, int)"><CODE>GL20.glAttachShader(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindAttribLocation(int, int, java.lang.String)"><CODE>GL20.glBindAttribLocation(int, int, String)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>GL20.glCompileShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, java.nio.IntBuffer, int, java.nio.Buffer, int)"><CODE>GL20.glShaderBinary(int, IntBuffer, int, Buffer, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><CODE>GL20.glShaderBinary(int, int[], int, int, Buffer, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateProgram()"><CODE>GL20.glCreateProgram()</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteProgram(int)"><CODE>GL20.glDeleteProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDetachShader(int, int)"><CODE>GL20.glDetachShader(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform1fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, float[], int)"><CODE>GL20.glUniform1fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1i(int, int)"><CODE>GL20.glUniform1i(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform1iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, int[], int)"><CODE>GL20.glUniform1iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2f(int, float, float)"><CODE>GL20.glUniform2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform2fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, float[], int)"><CODE>GL20.glUniform2fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2i(int, int, int)"><CODE>GL20.glUniform2i(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform2iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, int[], int)"><CODE>GL20.glUniform2iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3f(int, float, float, float)"><CODE>GL20.glUniform3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform3fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, float[], int)"><CODE>GL20.glUniform3fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3i(int, int, int, int)"><CODE>GL20.glUniform3i(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform3iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, int[], int)"><CODE>GL20.glUniform3iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4f(int, float, float, float, float)"><CODE>GL20.glUniform4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform4fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, float[], int)"><CODE>GL20.glUniform4fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4i(int, int, int, int, int)"><CODE>GL20.glUniform4i(int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform4iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, int[], int)"><CODE>GL20.glUniform4iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix2fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix2fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix3fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix3fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix4fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix4fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>GL20.glUseProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glValidateProgram(int)"><CODE>GL20.glValidateProgram(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glPixelStorei(int, int)"><!-- --></A><H3>
glPixelStorei</H3>
<PRE>
void <B>glPixelStorei</B>(int&nbsp;pname,
                   int&nbsp;param)</PRE>
<DL>
<DD>Set pixel storage modes.
 <p>
 <h4>Description</h4>
 <code>glPixelStorei</code> sets pixel storage modes that affect the operation of 
 subsequent <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReadPixels(int, int, int, int, int, int, java.nio.Buffer)"><CODE>glReadPixels</CODE></A>
 as well as the unpacking of texture patterns 
 (see <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glTexImage2D</CODE></A>
 and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glTexSubImage2D</CODE></A>).
 <p>
 <i><code>pname</code></i> is a symbolic constant indicating the parameter to be set, 
 and <i><code>param</code></i> is the new value. One storage parameter affects how 
 pixel data is returned to client memory:
 <p>
 <code>GL_PACK_ALIGNMENT</code>
 <p>
 Specifies the alignment requirements for the start of each 
 pixel row in memory. The allowable values are 
 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 
 4 (word-alignment), and 8 (rows start on double-word boundaries).
 <p>
 The other storage parameter affects how pixel data is 
 read from client memory:
 <p>
 <code>GL_UNPACK_ALIGNMENT</code>
 <p>
 Specifies the alignment requirements for the start of each pixel row in memory. 
 The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 
 4 (word-alignment), and 8 (rows start on double-word boundaries).
 <p>
 The following table gives the type, initial value, and range of valid values 
 for each storage parameter that can be set with <code>glPixelStorei</code>.
 <p>
 <table border=1><tbody><tr>
  <td><i><b><code>pname</code></b></i></td><td><b>Type</b></td><td><b>Initial Value</b></td><td><b>Valid Range</b></td>
 </tr><tr>
  <td><code>GL_PACK_ALIGNMENT</code></td><td>integer</td><td>4</td><td>1, 2, 4, or 8</td>
 </tr><tr>
  <td><code>GL_UNPACK_ALIGNMENT</code></td><td>integer</td><td>4</td><td>1, 2, 4, or 8</td>
 </tr></tbody></table>
 <p>
 Boolean parameters are set to false if <i><code>param</code></i> is 0 and true otherwise.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>pname</code></i> is not an accepted value.
 <p><code>GL_INVALID_VALUE</code> is generated if alignment is specified as other than 1, 2, 4, or 8.
 <p>
 <h4>Associated Gets</h4>
 <p>
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_PACK_ALIGNMENT</code> or <code>GL_UNPACK_ALIGNMENT</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pname</CODE> - Specifies the symbolic name of the parameter to be set. 
  One value affects the packing of pixel data into memory: 
  <code>GL_PACK_ALIGNMENT</code>. The other affects the unpacking of 
  pixel data <i>from</i> memory: <code>GL_UNPACK_ALIGNMENT</code>.<DD><CODE>param</CODE> - Specifies the value that <i><code>pname</code></i> is set to.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReadPixels(int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glReadPixels(int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexSubImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glPolygonOffset(float, float)"><!-- --></A><H3>
glPolygonOffset</H3>
<PRE>
void <B>glPolygonOffset</B>(float&nbsp;factor,
                     float&nbsp;units)</PRE>
<DL>
<DD>Set the scale and units used to calculate depth values.
 <p>
 <h4>Description</h4>
 When <code>GL_POLYGON_OFFSET_FILL</code> is enabled, each fragment's 
 <i>depth</i> value will be offset after it is interpolated from 
 the <i>depth</i> values of the appropriate vertices. 
 The value of the offset is <code>factor  DZ + r  units</code>, 
 where <code>DZ</code> is a measurement of the change in depth relative 
 to the screen area of the polygon, and <code>r</code> is the 
 smallest value that is guaranteed to produce a resolvable 
 offset for a given implementation. The offset is added before 
 the depth test is performed and before the value is written 
 into the depth buffer.
 <p>
 <code>glPolygonOffset</code> is useful for rendering hidden-line images, 
 for applying decals to surfaces, and for rendering solids 
 with highlighted edges.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A> with argument <code>GL_POLYGON_OFFSET_FILL</code>.
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_POLYGON_OFFSET_FACTOR</code> or <code>GL_POLYGON_OFFSET_UNITS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>factor</CODE> - Specifies a scale factor that is used to create a 
  variable depth offset for each polygon. The initial value is 0.<DD><CODE>units</CODE> - Is multiplied by an implementation-specific value 
  to create a constant depth offset. The initial value is 0.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>GL20.glDepthFunc(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>GL20.glEnable(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>GL20.glGetIntegerv(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>GL20.glGetIntegerv(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>GL20.glIsEnabled(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glReadPixels(int, int, int, int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glReadPixels</H3>
<PRE>
void <B>glReadPixels</B>(int&nbsp;x,
                  int&nbsp;y,
                  int&nbsp;width,
                  int&nbsp;height,
                  int&nbsp;format,
                  int&nbsp;type,
                  <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;pixels)</PRE>
<DL>
<DD>Read a block of pixels from the frame buffer.
 <p>
 <h4>Description</h4>
 <code>glReadPixels</code> returns pixel data from the frame buffer, 
 starting with the pixel whose lower left corner is at 
 location (<i><code>x, y</code></i>), into client memory in the buffer <i><code>data</code></i>. 
 The <code>GL_PACK_ALIGNMENT</code> parameter, set with the <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPixelStorei(int, int)"><CODE>glPixelStorei</CODE></A> command, 
 affects the processing of the pixel data before it is placed into client memory.
 <p>
 <code>glReadPixels</code> returns values from each pixel with lower left 
 corner at <code>(x + i, y + j)</code> for <code>0 <= i < <i>width</i></code> and <code>0 <= j < <i>height</i></code>. 
 This pixel is said to be the <i>i</i>th pixel in the <i>j</i>th row. Pixels are 
 returned in row order from the lowest to the highest row, 
 left to right in each row.
 <p>
 <i><code>format</code></i> specifies the format for the returned pixel values; 
 accepted values are:
 <p>
 <code>GL_ALPHA</code><br>
 <code>GL_RGB</code><br>
 <code>GL_RGBA</code>
 <p>
 RGBA color components are read from the color buffer. 
 Each color component is converted to floating point 
 such that zero intensity maps to 0.0 and full intensity 
 maps to 1.0.
 <p>
 Unneeded data is then discarded. For example, 
 <code>GL_ALPHA</code> discards the red, green, and blue components, 
 while <code>GL_RGB</code> discards only the alpha component. 
 The final values are clamped to the range <code>[0, 1]</code>.
 <p>
 Finally, the components are converted to the proper format, 
 as specified by <i><code>type</code></i>. When <i><code>type</code></i> is <code>GL_UNSIGNED_BYTE</code>, 
 each component is multiplied by <code>2^8 - 1</code>. 
 When <i><code>type</code></i> is <code>GL_UNSIGNED_SHORT_5_6_5</code>, <code>GL_UNSIGNED_SHORT_4_4_4_4</code>, or 
 <code>GL_UNSIGNED_SHORT_5_5_5_1</code>, each component is multiplied by <code>2^<i>N</i> - 1</code>, 
 where <i><code>N</code></i> is the number of bits in the bitfield.
 <p>
 Return values are placed in memory as follows. 
 If <i><code>format</code></i> is <code>GL_ALPHA</code>, a single value is returned and the 
 data for the <i>i</i>th pixel in the <i>j</i>th row is placed in 
 location <code>j  width + i</code>. <code>GL_RGB</code> returns three values and 
 <code>GL_RGBA</code> returns four values for each pixel, with all values 
 corresponding to a single pixel occupying contiguous space in <i><code>data</code></i>. 
 Storage parameter <code>GL_PACK_ALIGNMENT</code>, set by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPixelStorei(int, int)"><CODE>glPixelStorei</CODE></A>, 
 affects the way that data is written into memory. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPixelStorei(int, int)"><CODE>glPixelStorei</CODE></A> for a description.
 <p>
 <h4>Notes</h4>
 <p>
 If the currently bound framebuffer is not the default framebuffer object, 
 color components are read from the color image attached to 
 the <code>GL_COLOR_ATTACHMENT0</code> attachment point.
 <p>
 Only two <i><code>format</code></i>/<i><code>type</code></i> parameter pairs are accepted.
 <code>GL_RGBA</code>/<code>GL_UNSIGNED_BYTE</code> 
 is always accepted, and the other acceptable pair can be discovered by 
 querying <code>GL_IMPLEMENTATION_COLOR_READ_FORMAT</code> and <code>GL_IMPLEMENTATION_COLOR_READ_TYPE</code>.
 <p>
 Values for pixels that lie outside the window connected to the 
 current GL context are undefined.
 <p>
 If an error is generated, no change is made to the contents of <i><code>data</code></i>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>format</code></i> or <i><code>type</code></i> is not an accepted value.
 <p><code>GL_INVALID_VALUE</code> is generated if either <i><code>width</code></i> or <i><code>height</code></i> is negative.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>type</code></i> is 
  <code>GL_UNSIGNED_SHORT_5_6_5</code> and <i><code>format</code></i> is not <code>GL_RGB</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>type</code></i> is 
  <code>GL_UNSIGNED_SHORT_4_4_4_4</code> or <code>GL_UNSIGNED_SHORT_5_5_5_1</code>
  and <i><code>format</code></i> is not <code>GL_RGBA</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>format</code></i> and <i><code>type</code></i> are neither 
  <code>GL_RGBA</code> and <code>GL_UNSIGNED_BYTE</code>, respectively, nor the format/type pair returned 
  by querying <code>GL_IMPLEMENTATION_COLOR_READ_FORMAT</code> and <code>GL_IMPLEMENTATION_COLOR_READ_TYPE</code>.
 <p><code>GL_INVALID_FRAMEBUFFER_OPERATION</code> is generated if the currently bound 
  framebuffer is not framebuffer complete (i.e. the return value 
  from <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)"><CODE>glCheckFramebufferStatus</CODE></A> is not <code>GL_FRAMEBUFFER_COMPLETE</code>).
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_IMPLEMENTATION_COLOR_READ_FORMAT</code> or <code>GL_IMPLEMENTATION_COLOR_READ_TYPE</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_PACK_ALIGNMENT</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Specifies the x window coordinate of the first pixel 
  that is read from the frame buffer. This location is the 
  lower left corner of a rectangular block of pixels.<DD><CODE>y</CODE> - Specifies the y window coordinate of the first pixel 
  that is read from the frame buffer. This location is the 
  lower left corner of a rectangular block of pixels.<DD><CODE>width</CODE> - Specifies the width of the pixel rectangle. 
  A <i><code>width</code></i> and <i><code>height</code></i> of one correspond to a single pixel.<DD><CODE>height</CODE> - Specifies the height dimension of the pixel rectangle. 
  A <i><code>width</code></i> and <i><code>height</code></i> of one correspond to a single pixel.<DD><CODE>format</CODE> - Specifies the format of the pixel data. 
  The following symbolic values are accepted: <code>GL_ALPHA</code>, <code>GL_RGB</code>, and <code>GL_RGBA</code>.<DD><CODE>type</CODE> - Specifies the data type of the pixel data. 
  Must be one of <code>GL_UNSIGNED_BYTE</code>, <code>GL_UNSIGNED_SHORT_5_6_5</code>, 
  <code>GL_UNSIGNED_SHORT_4_4_4_4</code>, or <code>GL_UNSIGNED_SHORT_5_5_5_1</code>.<DD><CODE>pixels</CODE> - Returns the pixel data.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>pixels</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>pixels</code></i> does not contain enough room for the pixel data.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCheckFramebufferStatus(int)"><CODE>GL20.glCheckFramebufferStatus(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPixelStorei(int, int)"><CODE>GL20.glPixelStorei(int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glReleaseShaderCompiler()"><!-- --></A><H3>
glReleaseShaderCompiler</H3>
<PRE>
void <B>glReleaseShaderCompiler</B>()</PRE>
<DL>
<DD>Release resources allocated by the shader compiler.
 <p>
 <h4>Description</h4>
 For implementations that support a shader compiler, 
 <code>glReleaseShaderCompiler</code> frees resources allocated by 
 the shader compiler. This is a hint from the application 
 that additional shader compilations are unlikely to occur, 
 at least for some period of time, and that the resources 
 consumed by the shader compiler may be released and put 
 to better use elsewhere.
 <p>
 However, if a call to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>glCompileShader</CODE></A> is made after a call 
 to <code>glReleaseShaderCompiler</code>, the shader compiler must be 
 restored to service the compilation request as 
 if <code>glReleaseShaderCompiler</code> had never been called.
 <p>
 <h4>Notes</h4>
 <p>
 Shader compiler support is optional, and thus must be queried 
 before use by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A> with argument <code>GL_SHADER_COMPILER</code>. 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>glShaderSource</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>glCompileShader</CODE></A>, 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderPrecisionFormat(int, int, int[], int, int[], int)"><CODE>glGetShaderPrecisionFormat</CODE></A>, 
 and <code>glReleaseShaderCompiler</code> will each generate <code>GL_INVALID_OPERATION</code> 
 on implementations that do not support a shader compiler. 
 Such implementations instead offer the <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, java.nio.IntBuffer, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A> 
 alternative for supplying a pre-compiled shader binary.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_OPERATION</code> is generated if a shader compiler is not supported.
 <p>
 <h4>Associated Gets</h4>
 <p>
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_SHADER_COMPILER</code> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>GL20.glCompileShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>GL20.glShaderSource(int, int, String[], int[])</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glRenderbufferStorage(int, int, int, int)"><!-- --></A><H3>
glRenderbufferStorage</H3>
<PRE>
void <B>glRenderbufferStorage</B>(int&nbsp;target,
                           int&nbsp;internalformat,
                           int&nbsp;width,
                           int&nbsp;height)</PRE>
<DL>
<DD>Create and initialize a renderbuffer object's data store.
 <p>
 <h4>Description</h4>
 <code>glRenderbufferStorage</code> establishes the data storage, format, 
 and dimensions of a renderbuffer object's image. 
 Any existing data store for the renderbuffer is 
 deleted and the contents of the new data store are undefined.
 <p>
 An implementation may vary its allocation of internal 
 component resolution based on any <code>glRenderbufferStorage</code> 
 parameter (except <i><code>target</code></i>), but the allocation and chosen 
 internal format must not be a function of any other state and 
 cannot be changed once they are established. 
 The actual resolution in bits of each component 
 of the allocated image can be queried 
 with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, java.nio.IntBuffer)"><CODE>glGetRenderbufferParameteriv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, int[], int)"><CODE>glGetRenderbufferParameteriv</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is 
  not <code>GL_RENDERBUFFER</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>internalformat</code></i> 
  is not an accepted format.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>width</code></i> or <i><code>height</code></i> 
  is less than zero or greater than <code>GL_MAX_RENDERBUFFER_SIZE</code>.
 <p><code>GL_OUT_OF_MEMORY</code> is generated if the implementation 
  is unable to create a data store with the requested <i><code>width</code></i> and <i><code>height</code></i>.
 <p><code>GL_INVALID_OPERATION</code> is generated if 
  the reserved renderbuffer object name 0 is bound.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, java.nio.IntBuffer)"><CODE>glGetRenderbufferParameteriv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, int[], int)"><CODE>glGetRenderbufferParameteriv</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the renderbuffer target. 
  The symbolic constant must be <code>GL_RENDERBUFFER</code>.<DD><CODE>internalformat</CODE> - Specifies the color-renderable, 
  depth-renderable, or stencil-renderable format of the renderbuffer. 
  Must be one of the following symbolic constants: 
  <code>GL_RGBA4</code>, <code>GL_RGB565</code>, <code>GL_RGB5_A1</code>, <code>GL_DEPTH_COMPONENT16</code>,
  or <code>GL_STENCIL_INDEX8</code>.<DD><CODE>width</CODE> - Specifies the width of the renderbuffer in pixels.<DD><CODE>height</CODE> - Specifies the height of the renderbuffer in pixels.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindRenderbuffer(int, int)"><CODE>GL20.glBindRenderbuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, java.nio.IntBuffer)"><CODE>GL20.glDeleteRenderbuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteRenderbuffers(int, int[], int)"><CODE>GL20.glDeleteRenderbuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glFramebufferRenderbuffer(int, int, int, int)"><CODE>GL20.glFramebufferRenderbuffer(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, java.nio.IntBuffer)"><CODE>GL20.glGenRenderbuffers(int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGenRenderbuffers(int, int[], int)"><CODE>GL20.glGenRenderbuffers(int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glGetRenderbufferParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetRenderbufferParameteriv(int, int, int[], int)"><CODE>GL20.glGetRenderbufferParameteriv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsRenderbuffer(int)"><CODE>GL20.glIsRenderbuffer(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glSampleCoverage(float, boolean)"><!-- --></A><H3>
glSampleCoverage</H3>
<PRE>
void <B>glSampleCoverage</B>(float&nbsp;value,
                      boolean&nbsp;invert)</PRE>
<DL>
<DD>Specify multisample coverage parameters
 <p>
 <h4>Description</h4>
 Multisampling samples a pixel multiple times at various implementation-dependent 
 subpixel locations to generate antialiasing effects. Multisampling transparently 
 antialiases points, lines, and polygons if it is enabled.
 <p>
 <i><code>value</code></i> is used in constructing a temporary mask used in determining which samples 
 will be used in resolving the final fragment color. This mask is bitwise-anded 
 with the coverage mask generated from the multisampling computation. If the <i><code>invert</code></i> 
 flag is set, the temporary mask is inverted (all bits flipped) and then 
 the bitwise-and is computed.
 <p>
 If an implementation does not have any multisample buffers available, or 
 multisampling is disabled, rasterization occurs with only a single 
 sample computing a pixel's final RGB color.
 <p>
 Provided an implementation supports multisample buffers, and 
 multisampling is enabled, then a pixel's final color is generated by 
 combining several samples per pixel. Each sample contains color, depth, 
 and stencil information, allowing those operations to be performed on each sample.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_SAMPLE_COVERAGE_VALUE</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_SAMPLE_COVERAGE_INVERT</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A> with argument <code>GL_SAMPLE_ALPHA_TO_COVERAGE</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A> with argument <code>GL_SAMPLE_COVERAGE</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>value</CODE> - Specifies a single floating-point sample coverage value. 
  The value is clamped to the range <code>[0, 1]</code>. The initial value is 1.0.<DD><CODE>invert</CODE> - Specifies a single boolean value representing if the coverage masks should be inverted.
  <code>GL_TRUE</code> and <code>GL_FALSE</code> are accepted. The initial value is <code>GL_FALSE</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>GL20.glEnable(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glScissor(int, int, int, int)"><!-- --></A><H3>
glScissor</H3>
<PRE>
void <B>glScissor</B>(int&nbsp;x,
               int&nbsp;y,
               int&nbsp;width,
               int&nbsp;height)</PRE>
<DL>
<DD>Define the scissor box.
 <p>
 <h4>Description</h4>
 <code>glScissor</code> defines a rectangle, called the scissor box, 
 in window coordinates. The first two arguments, <i><code>x</code></i> and <i><code>y</code></i>, 
 specify the lower left corner of the box. <i><code>width</code></i> and <i><code>height</code></i> 
 specify the width and height of the box.
 <p>
 To enable and disable the scissor test, call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>glEnable</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisable(int)"><CODE>glDisable</CODE></A> 
 with argument <code>GL_SCISSOR_TEST</code>. The test is initially disabled. 
 While the test is enabled, only pixels that lie within the scissor box 
 can be modified by drawing commands. Window coordinates have integer 
 values at the shared corners of frame buffer pixels. <code>glScissor(0,0,1,1)</code> 
 allows modification of only the lower left pixel in the window, and 
 <code>glScissor(0,0,0,0)</code> doesn't allow modification of any pixels 
 in the window.
 <p>
 When the scissor test is disabled, it is as though the 
 scissor box includes the entire window.
 <p>
 <h4>Errors</h4>
 <p>
 <code>GL_INVALID_VALUE</code> is generated if either <i><code>width</code></i> or <i><code>height</code></i> is negative.
 <p>
 <h4>Associated Gets</h4>
 <p>
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_SCISSOR_BOX</code>
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A> with argument <code>GL_SCISSOR_TEST</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Specifies the x coordinate of the lower left corner of the scissor box. 
  Initially 0.<DD><CODE>y</CODE> - Specifies the y coordinate of the lower left corner of the scissor box. 
  Initially 0.<DD><CODE>width</CODE> - Specifies the width of the scissor box. 
  When a GL context is first attached to a window, <i><code>width</code></i> 
  is set to the width of that window.<DD><CODE>height</CODE> - Specifies the width of the scissor box. 
  When a GL context is first attached to a window, <i><code>height</code></i> 
  is set to the height of that window.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>GL20.glEnable(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glViewport(int, int, int, int)"><CODE>GL20.glViewport(int, int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><!-- --></A><H3>
glShaderBinary</H3>
<PRE>
void <B>glShaderBinary</B>(int&nbsp;n,
                    int[]&nbsp;shaders,
                    int&nbsp;shadersOffset,
                    int&nbsp;binaryformat,
                    <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;binary,
                    int&nbsp;length)</PRE>
<DL>
<DD>Load a precompiled shader binary.
 <p>
 <h4>Description</h4>
 For implementations that support them, <code>glShaderBinary</code> loads precompiled 
 shader binaries. <i><code>shaders</code></i> contains a list of <i><code>n</code></i> shader object handles. 
 Each handle refers to a unique shader type (vertex shader or fragment shader). 
 <i><code>binary</code></i> contains precompiled binary shader code in client memory, and 
 <i><code>binaryformat</code></i> denotes the format of the pre-compiled code.
 <p>
 The binary image is decoded according to the extension specification 
 defining the specified <i><code>binaryformat</code></i>. OpenGL ES defines no specific 
 binary formats, but does provide a mechanism to obtain symbolic 
 constants for such formats provided by extensions. 
 The number of shader binary formats supported can be obtained by 
 querying the value of <code>GL_NUM_SHADER_BINARY_FORMATS</code>. The list of 
 specific binary formats supported can be obtained by querying 
 the value of <code>GL_SHADER_BINARY_FORMATS</code>.
 <p>
 Depending on the types of the shader objects in <i><code>shaders</code></i>, <code>glShaderBinary</code> 
 will individually load binary vertex or fragment shaders, or load an 
 executable binary that contains an optimized pair of vertex and fragment 
 shaders stored in the same binary.
 <p>
 If <code>glShaderBinary</code> fails, the old state of shader objects for which the 
 binary was being loaded will not be restored.
 <p>
 <h4>Notes</h4>
 <p>
 Shader binary support is optional and thus must be queried before use by calling 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
 with arguments <code>GL_NUM_SHADER_BINARY_FORMATS</code> and <code>GL_SHADER_BINARY_FORMATS</code>.  
 <code>glShaderBinary</code> generates <code>GL_INVALID_OPERATION</code> on implementations that do not 
 support any shader binary formats. Such implementations instead offer the 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderSource(int, int, java.lang.String[], int[])"><CODE>glShaderSource</CODE></A> alternative for
 supplying OpenGL ES Shading Language shader source for compilation.
 <p>
 If shader binary formats are supported, then an implementation may require 
 that an optimized pair of vertex and fragment shader binaries that were 
 compiled together to be specified to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>glLinkProgram</CODE></A>. Not specifying an 
 optimized pair my cause <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>glLinkProgram</CODE></A> to fail. Such a restriction, 
 if it exists, will be documented in the extension specification 
 defining <i><code>binaryformat</code></i>.
 <p>
 OpenGL copies the shader binary data when <code>glShaderBinary</code> 
 is called, so an application may free its copy of the data 
 immediately after the function returns.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>binaryformat</code></i> is not a 
  supported format returned in <code>GL_SHADER_BINARY_FORMATS</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if any value in 
  <i><code>shaders</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_VALUE</code> is generated if the format of the 
  data pointed to by <i><code>binary</code></i> does not match <i><code>binaryformat</code></i>.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> or <i><code>length</code></i> is negative.
 <p><code>GL_INVALID_OPERATION</code> is generated if any value in 
  <i><code>shaders</code></i> is not a shader object, or if there is more than one 
  vertex shader object handle or more than one fragment shader 
  object handle in <i><code>shaders</code></i>.
 <p>
 <h4>Associated Gets</h4>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with arguments <code>GL_NUM_SHADER_BINARY_FORMATS</code> and <code>GL_SHADER_BINARY_FORMATS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsShader(int)"><CODE>glIsShader</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of shader object handles present in <i><code>shaders</code></i>.<DD><CODE>shaders</CODE> - Specifies an array of shader object 
  handles into which the shader binary will be loaded.<DD><CODE>shadersOffset</CODE> - the starting offset within the <i><code>shaders</code></i> array.<DD><CODE>binaryformat</CODE> - Specifies the shader binary format.<DD><CODE>binary</CODE> - Specifies the shader binary data as a buffer in client memory.<DD><CODE>length</CODE> - Specifies the length of the shader binary data in bytes.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>shaders</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>shaders</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>shaders</i>.length -
             <i>shadersOffset</i></code> is smaller than the number of values required by the parameter.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>binary</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>binary</i>.remaining()</code> is smaller than <i><code>length</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateShader(int)"><CODE>GL20.glCreateShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteShader(int)"><CODE>GL20.glDeleteShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glShaderBinary(int, java.nio.IntBuffer, int, java.nio.Buffer, int)"><!-- --></A><H3>
glShaderBinary</H3>
<PRE>
void <B>glShaderBinary</B>(int&nbsp;n,
                    <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;shaders,
                    int&nbsp;binaryformat,
                    <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;binary,
                    int&nbsp;length)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>binaryformat</code></i> is not a 
  supported format returned in <code>GL_SHADER_BINARY_FORMATS</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if any value in 
  <i><code>shaders</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_VALUE</code> is generated if the format of the 
  data pointed to by <i><code>binary</code></i> does not match <i><code>binaryformat</code></i>.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>n</code></i> or <i><code>length</code></i> is negative.
 <p><code>GL_INVALID_OPERATION</code> is generated if any value in 
  <i><code>shaders</code></i> is not a shader object, or if there is more than one 
  vertex shader object handle or more than one fragment shader 
  object handle in <i><code>shaders</code></i>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - Specifies the number of shader object handles present in <i><code>shaders</code></i>.<DD><CODE>shaders</CODE> - Specifies a buffer containing shader object 
  handles into which the shader binary will be loaded.<DD><CODE>binaryformat</CODE> - Specifies the shader binary format.<DD><CODE>binary</CODE> - Specifies the shader binary data as a buffer in client memory.<DD><CODE>length</CODE> - Specifies the length of the shader binary data in bytes.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>shaders</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>shaders</i>.remaining()</code> is smaller than the n.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>binary</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>binary</i>.remaining()</code> is smaller than <i><code>length</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><CODE>GL20.glShaderBinary(int, int[], int, int, Buffer, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glShaderSource(int, int, java.lang.String[], int[])"><!-- --></A><H3>
glShaderSource</H3>
<PRE>
void <B>glShaderSource</B>(int&nbsp;shader,
                    int&nbsp;count,
                    <A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>[]&nbsp;strings,
                    int[]&nbsp;lengths)</PRE>
<DL>
<DD>Replace the source code in a shader object.
 <p>
 <h4>Description</h4>
 For implementations that support a shader compiler, <code>glShaderSource</code>  
 sets the source code in <i><code>shader</code></i> to the source code in the array of 
 strings specified by <i><code>strings</code></i>. Any source code previously stored in  
 the shader object is completely replaced. The number of strings in  
 the array is specified by <i><code>count</code></i>. If <i><code>lengths</code></i> is <code>null</code>,
 the entirety of each string in <i><code>strings</code></i> is used. 
 If <i><code>lengths</code></i> is a value other than <code>null</code>,  
 it points to an array containing a string length for each of the  
 corresponding elements of <i><code>strings</code></i>. The source code strings  
 are not scanned or parsed at this time; they are simply copied into  
 the specified shader object. 
 <p> 
 <h4>Notes</h4> 
 <p> 
 Shader compiler support is optional, and thus must be queried before  
 use by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A> with argument <code>GL_SHADER_COMPILER</code>.  
 <code>glShaderSource</code>, <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>glCompileShader</CODE></A>, 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderPrecisionFormat(int, int, int[], int, int[], int)"><CODE>glGetShaderPrecisionFormat</CODE></A>,  
 and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReleaseShaderCompiler()"><CODE>glReleaseShaderCompiler</CODE></A> will each generate <code>GL_INVALID_OPERATION</code>  
 on implementations that do not support a shader compiler.  
 Such implementations instead offer the <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, java.nio.IntBuffer, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A> alternative  
 for supplying a pre-compiled shader binary. 
 <p> 
 OpenGL copies the shader source code strings when <code>glShaderSource</code>  
 is called, so an application may free its copy of the source code  
 strings immediately after the function returns. 
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if a shader compiler is not supported. 
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>shader</code></i> is not a value generated by OpenGL. 
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>shader</code></i> is not a shader object. 
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0. 
 <p> 
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_SHADER_COMPILER</code> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>glGetShaderiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A>
  with arguments <i><code>shader</code></i> and <code>GL_SHADER_SOURCE_LENGTH</code> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderSource(int, int, int[], byte[])"><CODE>glGetShaderSource</CODE></A> with argument <i><code>shader</code></i> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsShader(int)"><CODE>glIsShader</CODE></A> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shader</CODE> - Specifies the handle of the shader object whose source code is to be replaced.<DD><CODE>count</CODE> - Specifies the number of elements in the <i><code>strings</code></i>
  and <i><code>lengths</code></i> arrays.<DD><CODE>strings</CODE> - Specifies an array of strings containing  
  the source code to be loaded into the shader.<DD><CODE>lengths</CODE> - Specifies an array of string lengths. May be <code>null</code>.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>strings</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>strings</i>.length()</code> or 
  <code><i>lengths</i>.length()</code> is smaller than <i><code>count</code></i>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If any element in <i><code>strings</code></i> 
  in the range <code>[0, <i>count</i> - 1]</code> is <code>null</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>GL20.glCompileShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderPrecisionFormat(int, int, int[], int, int[], int)"><CODE>GL20.glGetShaderPrecisionFormat(int, int, int[], int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateShader(int)"><CODE>GL20.glCreateShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteShader(int)"><CODE>GL20.glDeleteShader(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glShaderSource(int, java.lang.String)"><!-- --></A><H3>
glShaderSource</H3>
<PRE>
void <B>glShaderSource</B>(int&nbsp;shader,
                    <A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;source)</PRE>
<DL>
<DD>Replace the source code in a shader object.
 <p>
 <h4>Description</h4>
 For implementations that support a shader compiler, <code>glShaderSource</code>  
 sets the source code in <i><code>shader</code></i> to the source code in <i><code>source</code></i>.
 Any source code previously stored in the shader object is completely replaced.
 The source code strings are not scanned or parsed at this time; they are simply copied into 
 the specified shader object. 
 <p> 
 <h4>Notes</h4> 
 <p> 
 Shader compiler support is optional, and thus must be queried before  
 use by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A> with argument <code>GL_SHADER_COMPILER</code>.  
 <code>glShaderSource</code>, <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>glCompileShader</CODE></A>, 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderPrecisionFormat(int, int, int[], int, int[], int)"><CODE>glGetShaderPrecisionFormat</CODE></A>,  
 and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glReleaseShaderCompiler()"><CODE>glReleaseShaderCompiler</CODE></A> will each generate <code>GL_INVALID_OPERATION</code>  
 on implementations that do not support a shader compiler.  
 Such implementations instead offer the <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, java.nio.IntBuffer, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glShaderBinary(int, int[], int, int, java.nio.Buffer, int)"><CODE>glShaderBinary</CODE></A> alternative  
 for supplying a pre-compiled shader binary. 
 <p> 
 OpenGL copies the shader source code strings when <code>glShaderSource</code>  
 is called, so an application may free its copy of the source code  
 strings immediately after the function returns. 
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if a shader compiler is not supported. 
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>shader</code></i> is not a value generated by OpenGL. 
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>shader</code></i> is not a shader object. 
 <p> 
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_SHADER_COMPILER</code> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, java.nio.IntBuffer)"><CODE>glGetShaderiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderiv(int, int, int[], int)"><CODE>glGetShaderiv</CODE></A>
  with arguments <i><code>shader</code></i> and <code>GL_SHADER_SOURCE_LENGTH</code> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderSource(int, int, int[], byte[])"><CODE>glGetShaderSource</CODE></A> with argument <i><code>shader</code></i> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsShader(int)"><CODE>glIsShader</CODE></A> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>shader</CODE> - Specifies the handle of the shader object whose source code is to be replaced.<DD><CODE>source</CODE> - The source code to be loaded into the shader.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>source</code></i> is <code>null</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>GL20.glCompileShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetShaderPrecisionFormat(int, int, int[], int, int[], int)"><CODE>GL20.glGetShaderPrecisionFormat(int, int, int[], int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateShader(int)"><CODE>GL20.glCreateShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteShader(int)"><CODE>GL20.glDeleteShader(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glStencilFunc(int, int, int)"><!-- --></A><H3>
glStencilFunc</H3>
<PRE>
void <B>glStencilFunc</B>(int&nbsp;func,
                   int&nbsp;ref,
                   int&nbsp;mask)</PRE>
<DL>
<DD>Set front and back function and reference value for stencil testing.
 <p>
 <h4>Description</h4>
 Stenciling, like depth-buffering, enables and disables drawing on 
 a per-pixel basis. Stencil planes are first drawn into using GL 
 drawing primitives, then geometry and images are rendered using 
 the stencil planes to mask out portions of the screen. Stenciling 
 is typically used in multipass rendering algorithms to achieve 
 special effects, such as decals, outlining, and constructive 
 solid geometry rendering.
 <p> 
 The stencil test conditionally eliminates a pixel based on the 
 outcome of a comparison between the reference value and the 
 value in the stencil buffer. To enable and disable the test, 
 call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>glEnable</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisable(int)"><CODE>glDisable</CODE></A> with argument <code>GL_STENCIL_TEST</code>. 
 To specify actions based on the outcome of the stencil test, 
 call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>glStencilOp</CODE></A> or
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>glStencilOpSeparate</CODE></A>.
 <p> 
 There can be two separate sets of <i><code>func</code></i>,
 <i><code>ref</code></i>, and <i><code>mask</code></i> parameters; 
 one affects back-facing polygons, and the other affects 
 front-facing polygons as well as other non-polygon primitives. 
 <code>glStencilFunc</code> sets both front and back stencil state to the 
 same values. Use <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>glStencilFuncSeparate</CODE></A> to set front and 
 back stencil state to different values.
 <p> 
 <i><code>func</code></i> is a symbolic constant that determines the stencil 
 comparison function. It accepts one of eight values, 
 shown in the following list. <i><code>ref</code></i> is an integer reference 
 value that is used in the stencil comparison. It is clamped 
 to the range <code>[0, 2^n - 1]</code>, where <code>n</code> is the number of bitplanes 
 in the stencil buffer. <i><code>mask</code></i> is bitwise <code>AND</code>ed with both the 
 reference value and the stored stencil value, with 
 the <code>AND</code>ed values participating in the comparison.
 <p> 
 If <i>stencil</i> represents the value stored in the corresponding 
 stencil buffer location, the following list shows the effect 
 of each comparison function that can be specified by <i><code>func</code></i>. 
 Only if the comparison succeeds is the pixel passed through 
 to the next stage in the rasterization process (see <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>glStencilOp</CODE></A>). 
 All tests treat <i>stencil</i> values as unsigned integers in 
 the range <code>[0, 2^n - 1]</code>, where <code>n</code> is the number of bitplanes 
 in the stencil buffer.
 <p> 
 The following values are accepted by <i><code>func</code></i>:
 <p> 
 <code>GL_NEVER</code>
 <p> 
 Always fails.
 <p> 
 <code>GL_LESS</code>
 <p> 
 Passes if ( <code><i>ref</i> & <i>mask</i></code> ) < ( <i>stencil</i> <code>& <i>mask</i></code> ).
 <p> 
 <code>GL_LEQUAL</code>
 <p> 
 Passes if ( <code><i>ref</i> & <i>mask</i></code> ) <= ( <i>stencil</i> <code>& <i>mask</i></code> ).
 <p> 
 <code>GL_GREATER</code>
 <p> 
 Passes if ( <code><i>ref</i> & <i>mask</i></code> ) > ( <i>stencil</i> <code>& <i>mask</i></code> ).
 <p> 
 <code>GL_GEQUAL</code>
 <p> 
 Passes if ( <code><i>ref</i> & <i>mask</i></code> ) >= ( <i>stencil</i> <code>& <i>mask</i></code> ).
 <p> 
 <code>GL_EQUAL</code>
 <p> 
 Passes if ( <code><i>ref</i> & <i>mask</i></code> ) = ( <i>stencil</i> <code>& <i>mask</i></code> ).
 <p> 
 <code>GL_NOTEQUAL</code>
 <p> 
 Passes if ( <code><i>ref</i> & <i>mask</i></code> ) != ( <i>stencil</i> <code>& <i>mask</i></code> ).
 <p> 
 <code>GL_ALWAYS</code>
 <p> 
 Always passes. 
 <p> 
 <h4>Notes</h4> 
 <p> 
 Initially, the stencil test is disabled. If there is no stencil buffer, 
 no stencil modification can occur and it is as if the stencil test always passes.
 <p> 
 <code>glStencilFunc</code> is the same as calling 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>glStencilFuncSeparate</CODE></A> with 
 <i><code>face</code></i> set to <code>GL_FRONT_AND_BACK</code>.  
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>func</code></i> is not one 
  of the eight accepted values.
 <p> 
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_STENCIL_FUNC</code>, <code>GL_STENCIL_VALUE_MASK</code>, <code>GL_STENCIL_REF</code>, 
  <code>GL_STENCIL_BACK_FUNC</code>, <code>GL_STENCIL_BACK_VALUE_MASK</code>, <code>GL_STENCIL_BACK_REF</code>,
  or <code>GL_STENCIL_BITS</code> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A> with argument <code>GL_STENCIL_TEST</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>func</CODE> - Specifies the test function. Eight symbolic constants are valid: 
  <code>GL_NEVER</code>, <code>GL_LESS</code>, <code>GL_LEQUAL</code>, <code>GL_GREATER</code>, <code>GL_GEQUAL</code>, 
  <code>GL_EQUAL</code>, <code>GL_NOTEQUAL</code>, and <code>GL_ALWAYS</code>. 
  The initial value is <code>GL_ALWAYS</code>.<DD><CODE>ref</CODE> - Specifies the reference value for the 
  stencil test. <i><code>ref</code></i> is clamped to the range <code>[0, 2^n - 1]</code>, 
  where <code>n</code> is the number of bitplanes in the stencil buffer. 
  The initial value is 0.<DD><CODE>mask</CODE> - Specifies a mask that is <code>AND</code>ed with both 
  the reference value and the stored stencil value when 
  the test is done. The initial value is all 1's.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>GL20.glBlendFunc(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>GL20.glDepthFunc(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>GL20.glEnable(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>GL20.glStencilFuncSeparate(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMask(int)"><CODE>GL20.glStencilMask(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMaskSeparate(int, int)"><CODE>GL20.glStencilMaskSeparate(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>GL20.glStencilOp(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>GL20.glStencilOpSeparate(int, int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glStencilFuncSeparate(int, int, int, int)"><!-- --></A><H3>
glStencilFuncSeparate</H3>
<PRE>
void <B>glStencilFuncSeparate</B>(int&nbsp;face,
                           int&nbsp;func,
                           int&nbsp;ref,
                           int&nbsp;mask)</PRE>
<DL>
<DD>Set front and/or back function and reference value for stencil testing.
 <p> 
 <h4>Description</h4>
 Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis.
 You draw into the stencil planes using GL drawing primitives, then render geometry and images,
 using the stencil planes to mask out portions of the screen. Stenciling is typically used
 in multipass rendering algorithms to achieve special effects, such as decals, outlining, 
 and constructive solid geometry rendering.
 <p> 
 The stencil test conditionally eliminates a pixel based on the outcome of a comparison 
 between the reference value and the value in the stencil buffer. To enable and disable
 the test, call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>glEnable</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisable(int)"><CODE>glDisable</CODE></A> 
 with argument <code>GL_STENCIL_TEST</code>. To specify actions based on the outcome
 of the stencil test, call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>glStencilOp</CODE></A> or 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>glStencilOpSeparate</CODE></A>.
 <p> 
 There can be two separate sets of <i><code>func</code></i>, <i><code>ref</code></i>, and
 <i><code>mask</code></i> parameters; one affects back-facing polygons, and the other
 affects front-facing polygons as well as other non-polygon primitives. 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>glStencilFunc</CODE></A> sets both front and back stencil
 state to the same values, as if <code>glStencilFuncSeparate</code> were called with
 <i><code>face</code></i> set to <code>GL_FRONT_AND_BACK</code>.
 <p> 
 <i><code>func</code></i> is a symbolic constant that determines the stencil comparison
 function. It accepts one of eight values, shown in the following list. <i><code>ref</code></i>
 is an integer reference value that is used in the stencil comparison. It is clamped to the range <code>[0, 2^n - 1]</code>, 
 where <code>n</code> is the number of bitplanes in the stencil buffer. <i><code>mask</code></i> is bitwise 
 <code>AND</code>ed with both the reference value and the stored stencil value, 
 with the <code>AND</code>ed values participating in the comparison.
 <p> 
 If <i>stencil</i> represents the value stored in the corresponding stencil buffer location, 
 the following list shows the effect of each comparison function that can be specified by 
 <i><code>func</code></i>. Only if the comparison succeeds is the pixel passed through to 
 the next stage in the rasterization process (see <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>glStencilOp</CODE></A>).
 All tests treat <i>stencil</i> values as unsigned integers in the range <code>[0, 2^n - 1]</code>, 
 where <code>n</code> is the number of bitplanes in the stencil buffer.
 <p> 
 The following values are accepted by <i><code>func</code></i>:
 <p> 
 <code>GL_NEVER</code>
 <p> 
 Always fails.
 <p> 
 <code>GL_LESS</code>
 <p> 
 Passes if ( <code><i>ref</i> & <i>mask</i></code> ) < ( <i>stencil</i> <code>& <i>mask</i></code> ).
 <p> 
 <code>GL_LEQUAL</code>
 <p> 
 Passes if ( <code><i>ref</i> & <i>mask</i></code> ) <= ( <i>stencil</i> <code>& <i>mask</i></code> ).
 <p> 
 <code>GL_GREATER</code>
 <p> 
 Passes if ( <code><i>ref</i> & <i>mask</i></code> ) > ( <i>stencil</i> <code>& <i>mask</i></code> ).
 <p> 
 <code>GL_GEQUAL</code>
 <p> 
 Passes if ( <code><i>ref</i> & <i>mask</i></code> ) >= ( <i>stencil</i> <code>& <i>mask</i></code> ).
 <p> 
 <code>GL_EQUAL</code>
 <p> 
 Passes if ( <code><i>ref</i> & <i>mask</i></code> ) = ( <i>stencil</i> <code>& <i>mask</i></code> ).
 <p> 
 <code>GL_NOTEQUAL</code>
 <p> 
 Passes if ( <code><i>ref</i> & <i>mask</i></code> ) != ( <i>stencil</i> <code>& <i>mask</i></code> ).
 <p> 
 <code>GL_ALWAYS</code>
 <p> 
 Always passes. 
 <p>
 <h4>Notes</h4> 
 <p> 
 Initially, the stencil test is disabled. If there is no stencil buffer, 
 no stencil modification can occur and it is as if the stencil 
 test always passes. 
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>face</code></i> is 
  not <code>GL_FRONT</code>, <code>GL_BACK</code>, or <code>GL_FRONT_AND_BACK</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>func</code></i> is 
  not one of the eight accepted values.
 <p> 
 <h4>Associated Gets</h4> 
 <p> <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_STENCIL_FUNC</code>, <code>GL_STENCIL_VALUE_MASK</code>, 
  <code>GL_STENCIL_REF</code>, <code>GL_STENCIL_BACK_FUNC</code>, <code>GL_STENCIL_BACK_VALUE_MASK</code>, 
  <code>GL_STENCIL_BACK_REF</code>, or <code>GL_STENCIL_BITS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A> with argument <code>GL_STENCIL_TEST</code> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>face</CODE> - Specifies whether front and/or back stencil state is updated. 
  Three symbolic constants are valid: <code>GL_FRONT</code>, <code>GL_BACK</code>,
  and <code>GL_FRONT_AND_BACK</code>.<DD><CODE>func</CODE> - Specifies the test function. Eight symbolic constants are valid: 
  <code>GL_NEVER</code>, <code>GL_LESS</code>, <code>GL_LEQUAL</code>, 
  <code>GL_GREATER</code>, <code>GL_GEQUAL</code>, <code>GL_EQUAL</code>, 
  <code>GL_NOTEQUAL</code>, and <code>GL_ALWAYS</code>. The initial value is <code>GL_ALWAYS</code>.<DD><CODE>ref</CODE> - Specifies the reference value for the stencil test. 
  <i><code>ref</code></i> is clamped to the range <code>[0, 2^n - 1]</code>, 
  where <code>n</code> is the number of bitplanes in the stencil buffer. The initial value is 0.<DD><CODE>mask</CODE> - Specifies a mask that is <code>AND</code>ed with both the reference 
  value and the stored stencil value when the test is done. 
  The initial value is all 1's.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>GL20.glBlendFunc(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>GL20.glDepthFunc(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>GL20.glEnable(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>GL20.glStencilFunc(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMask(int)"><CODE>GL20.glStencilMask(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMaskSeparate(int, int)"><CODE>GL20.glStencilMaskSeparate(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>GL20.glStencilOp(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>GL20.glStencilOpSeparate(int, int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glStencilMask(int)"><!-- --></A><H3>
glStencilMask</H3>
<PRE>
void <B>glStencilMask</B>(int&nbsp;mask)</PRE>
<DL>
<DD>Control the front and back writing of individual bits in the stencil planes. 
 <p>
 <h4>Description</h4>
 <code>glStencilMask</code> controls the writing of individual bits in the stencil planes. 
 The least significant <code>n</code> bits of <i><code>mask</code></i>, where <code>n</code> is the number of bits in the 
 stencil buffer, specify a mask. Where a 1 appears in the mask, 
 it's possible to write to the corresponding bit in the stencil buffer. 
 Where a 0 appears, the corresponding bit is write-protected. 
 Initially, all bits are enabled for writing.
 <p> 
 There can be two separate <i><code>mask</code></i> writemasks; one affects back-facing polygons, 
 and the other affects front-facing polygons as well as other 
 non-polygon primitives. <code>glStencilMask</code> sets both front and back stencil 
 writemasks to the same values. Use <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMaskSeparate(int, int)"><CODE>glStencilMaskSeparate</CODE></A> to set 
 front and back stencil writemasks to different values. 
 <p> 
 <h4>Notes</h4> 
 <p> 
 <code>glStencilMask</code> is the same as calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMaskSeparate(int, int)"><CODE>glStencilMaskSeparate</CODE></A> with 
 <i><code>face</code></i> set to <code>GL_FRONT_AND_BACK</code>. 
 <p> 
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
 with argument <code>GL_STENCIL_WRITEMASK</code>, <code>GL_STENCIL_BACK_WRITEMASK</code>, or <code>GL_STENCIL_BITS</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mask</CODE> - Specifies a bit mask to enable and disable writing of 
  individual bits in the stencil planes. Initially, the mask is all 1's.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glColorMask(boolean, boolean, boolean, boolean)"><CODE>GL20.glColorMask(boolean, boolean, boolean, boolean)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthMask(boolean)"><CODE>GL20.glDepthMask(boolean)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>GL20.glStencilFunc(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>GL20.glStencilFuncSeparate(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMaskSeparate(int, int)"><CODE>GL20.glStencilMaskSeparate(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>GL20.glStencilOp(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>GL20.glStencilOpSeparate(int, int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glStencilMaskSeparate(int, int)"><!-- --></A><H3>
glStencilMaskSeparate</H3>
<PRE>
void <B>glStencilMaskSeparate</B>(int&nbsp;face,
                           int&nbsp;mask)</PRE>
<DL>
<DD>Control the front and/or back writing of individual bits in the stencil planes.
 <p> 
 <h4>Description</h4>
 <code>glStencilMaskSeparate</code> controls the writing of individual bits in the 
 stencil planes. The least significant <code>n</code> bits of <i><code>mask</code></i>, where <code>n</code> is the 
 number of bits in the stencil buffer, specify a mask. Where a 1 
 appears in the mask, it's possible to write to the corresponding 
 bit in the stencil buffer. Where a 0 appears, the corresponding 
 bit is write-protected. Initially, all bits are enabled for writing.
 <p>
 There can be two separate <i><code>mask</code></i> writemasks; one affects back-facing polygons, 
 and the other affects front-facing polygons as well as other non-polygon primitives. 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMask(int)"><CODE>glStencilMask</CODE></A> sets both front and back stencil writemasks to the same values, 
 as if <code>glStencilMaskSeparate</code> were called with <i><code>face</code></i> set to <code>GL_FRONT_AND_BACK</code>. 
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>face</code></i> is not 
  <code>GL_FRONT</code>, <code>GL_BACK</code>, or <code>GL_FRONT_AND_BACK</code>.
 <p> 
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_STENCIL_WRITEMASK</code>, <code>GL_STENCIL_BACK_WRITEMASK</code>, or <code>GL_STENCIL_BITS</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>face</CODE> - Specifies whether the front and/or back stencil writemask is updated. 
  Three symbolic constants are valid: <code>GL_FRONT</code>, <code>GL_BACK</code>, and <code>GL_FRONT_AND_BACK</code>.<DD><CODE>mask</CODE> - Specifies a bit mask to enable and disable writing of individual
  bits in the stencil planes. Initially, the mask is all 1's.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glColorMask(boolean, boolean, boolean, boolean)"><CODE>GL20.glColorMask(boolean, boolean, boolean, boolean)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthMask(boolean)"><CODE>GL20.glDepthMask(boolean)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>GL20.glStencilFunc(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>GL20.glStencilFuncSeparate(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMask(int)"><CODE>GL20.glStencilMask(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMaskSeparate(int, int)"><CODE>GL20.glStencilMaskSeparate(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>GL20.glStencilOp(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>GL20.glStencilOpSeparate(int, int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glStencilOp(int, int, int)"><!-- --></A><H3>
glStencilOp</H3>
<PRE>
void <B>glStencilOp</B>(int&nbsp;fail,
                 int&nbsp;zfail,
                 int&nbsp;zpass)</PRE>
<DL>
<DD>Set front and back stencil test actions.
 <p> 
 <h4>Description</h4>
 Stenciling, like depth-buffering, enables and disables 
 drawing on a per-pixel basis. You draw into the stencil 
 planes using GL drawing primitives, then render geometry and 
 images, using the stencil planes to mask out portions of the 
 screen. Stenciling is typically used in multipass rendering 
 algorithms to achieve special effects, such as decals, 
 outlining, and constructive solid geometry rendering.
 <p> 
 The stencil test conditionally eliminates a pixel based on the 
 outcome of a comparison between the value in the stencil buffer 
 and a reference value. To enable and disable the test, 
 call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>glEnable</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisable(int)"><CODE>glDisable</CODE></A> with argument <code>GL_STENCIL_TEST</code>; 
 to control it, call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>glStencilFunc</CODE></A> or
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>glStencilFuncSeparate</CODE></A>.
 <p> 
 There can be two separate sets of <i><code>fail</code></i>, <i><code>zfail</code></i>, and <i><code>zpass</code></i> parameters; 
 one affects back-facing polygons, and the other affects front-facing polygons 
 as well as other non-polygon primitives. <code>glStencilOp</code> sets both front and 
 back stencil state to the same values. Use <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>glStencilOpSeparate</CODE></A> 
 to set front and back stencil state to different values.
 <p> 
 <code>glStencilOp</code> takes three arguments that indicate what happens to the 
 stored stencil value while stenciling is enabled. If the stencil test fails, 
 no change is made to the pixel's color or depth buffers, and <i><code>fail</code></i> 
 specifies what happens to the stencil buffer contents. 
 The following eight actions are possible.
 <p> 
 <code>GL_KEEP</code>
 <p> 
 Keeps the current value.
 <p> 
 <code>GL_ZERO</code>
 <p> 
 Sets the stencil buffer value to 0.
 <p> 
 <code>GL_REPLACE</code>
 <p> 
 Sets the stencil buffer value to <i><code>ref</code></i>, as specified 
 by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>glStencilFunc</CODE></A>.
 <p> 
 <code>GL_INCR</code>
 <p> 
 Increments the current stencil buffer value. 
 Clamps to the maximum representable unsigned value.
 <p> 
 <code>GL_INCR_WRAP</code>
 <p> 
 Increments the current stencil buffer value. 
 Wraps stencil buffer value to zero when incrementing the
 maximum representable unsigned value.
 <p> 
 <code>GL_DECR</code>
 <p> 
 Decrements the current stencil buffer value. Clamps to 0.
 <p> 
 <code>GL_DECR_WRAP</code>
 <p> 
 Decrements the current stencil buffer value. 
 Wraps stencil buffer value to the maximum representable 
 unsigned value when decrementing a stencil buffer value of zero.
 <p> 
 <code>GL_INVERT</code>
 <p> 
 Bitwise inverts the current stencil buffer value.
 <p> 
 Stencil buffer values are treated as unsigned integers. 
 When incremented and decremented, values are clamped 
 to the range <code>[0, 2^n - 1]</code>, 
 where <code>n</code> is the value returned by 
 querying <code>GL_STENCIL_BITS</code>.
 <p> 
 The other two arguments to <code>glStencilOp</code> specify stencil 
 buffer actions that depend on whether subsequent depth 
 buffer tests succeed (<i><code>zpass</code></i>) or fail (<i><code>zfail</code></i>)
 (see <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>glDepthFunc</CODE></A>).
 The actions are specified using the same eight symbolic constants 
 as <i><code>fail</code></i>. Note that <i><code>zfail</code></i> is ignored when there is 
 no depth buffer, or when the depth buffer is not enabled. 
 In these cases, <i><code>fail</code></i> and <i><code>zpass</code></i> specify stencil action when 
 the stencil test fails and passes, respectively. 
 <p> 
 <h4>Notes</h4> 
 <p> 
 Initially the stencil test is disabled. If there is no stencil buffer, 
 no stencil modification can occur and it is as if the stencil tests 
 always pass, regardless of any call to <code>glStencilOp</code>.
 <p> 
 <code>glStencilOp</code> is the same as calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>glStencilOpSeparate</CODE></A> with 
 <i><code>face</code></i> set to <code>GL_FRONT_AND_BACK</code>. 
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>fail</code></i>,
  <i><code>zfail</code></i>, or <i><code>zpass</code></i> 
  is any value other than the eight defined symbolic constant values. 
 <p> 
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_STENCIL_FAIL</code>, <code>GL_STENCIL_PASS_DEPTH_PASS</code>, 
  <code>GL_STENCIL_PASS_DEPTH_FAIL</code>, <code>GL_STENCIL_BACK_FAIL</code>, <code>GL_STENCIL_BACK_PASS_DEPTH_PASS</code>, 
  <code>GL_STENCIL_BACK_PASS_DEPTH_FAIL</code>, or <code>GL_STENCIL_BITS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A> with argument <code>GL_STENCIL_TEST</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fail</CODE> - Specifies the action to take when the stencil test fails. 
  Eight symbolic constants are accepted: 
  <code>GL_KEEP</code>, <code>GL_ZERO</code>, <code>GL_REPLACE</code>, <code>GL_INCR</code>, <code>GL_INCR_WRAP</code>, 
  <code>GL_DECR</code>, <code>GL_DECR_WRAP</code>, and <code>GL_INVERT</code>. 
  The initial value is <code>GL_KEEP</code>.<DD><CODE>zfail</CODE> - Specifies the stencil action when the stencil test passes, 
  but the depth test fails. <i><code>zfail</code></i> accepts the same symbolic constants as <i><code>fail</code></i>. 
  The initial value is <code>GL_KEEP</code>.<DD><CODE>zpass</CODE> - Specifies the stencil action when both the stencil 
  test and the depth test pass, or when the stencil test passes and 
  either there is no depth buffer or depth testing is not enabled. 
  <i><code>zpass</code></i> accepts the same symbolic constants as <i><code>fail</code></i>. The initial value is <code>GL_KEEP</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>GL20.glBlendFunc(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>GL20.glDepthFunc(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>GL20.glEnable(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>GL20.glStencilFunc(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>GL20.glStencilFuncSeparate(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMask(int)"><CODE>GL20.glStencilMask(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMaskSeparate(int, int)"><CODE>GL20.glStencilMaskSeparate(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOpSeparate(int, int, int, int)"><CODE>GL20.glStencilOpSeparate(int, int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glStencilOpSeparate(int, int, int, int)"><!-- --></A><H3>
glStencilOpSeparate</H3>
<PRE>
void <B>glStencilOpSeparate</B>(int&nbsp;face,
                         int&nbsp;fail,
                         int&nbsp;zfail,
                         int&nbsp;zpass)</PRE>
<DL>
<DD>Set front and/or back stencil test actions.
 <p>
 <h4>Description</h4>
 Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. 
 You draw into the stencil planes using GL drawing primitives, then render geometry 
 and images, using the stencil planes to mask out portions of the screen. Stenciling 
 is typically used in multipass rendering algorithms to achieve special effects, 
 such as decals, outlining, and constructive solid geometry rendering.
 <p>
 The stencil test conditionally eliminates a pixel based on the outcome of a 
 comparison between the value in the stencil buffer and a reference value. 
 To enable and disable the test, call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>glEnable</CODE></A> and <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisable(int)"><CODE>glDisable</CODE></A> with argument 
 <code>GL_STENCIL_TEST</code>; to control it, call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>glStencilFunc</CODE></A>
 or <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>glStencilFuncSeparate</CODE></A>.
 <p>
 There can be two separate sets of <i><code>fail</code></i>, <i><code>zfail</code></i>, and <i><code>zpass</code></i> parameters; 
 one affects back-facing polygons, and the other affects front-facing polygons 
 as well as other non-polygon primitives. <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>glStencilOp</CODE></A> sets both front and back 
 stencil state to the same values, as if <code>glStencilOpSeparate</code> were called 
 with face set to <code>GL_FRONT_AND_BACK</code>.
 <p>
 <code>glStencilOpSeparate</code> takes three arguments that indicate what happens to the 
 stored stencil value while stenciling is enabled. If the stencil test fails, 
 no change is made to the pixel's color or depth buffers, and <i><code>fail</code></i> specifies 
 what happens to the stencil buffer contents. The following eight actions 
 are possible. 
 <p> 
 <code>GL_KEEP</code>
 <p> 
 Keeps the current value.
 <p> 
 <code>GL_ZERO</code>
 <p> 
 Sets the stencil buffer value to 0.
 <p> 
 <code>GL_REPLACE</code>
 <p> 
 Sets the stencil buffer value to <i><code>ref</code></i>, as specified 
 by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>glStencilFunc</CODE></A>.
 <p> 
 <code>GL_INCR</code>
 <p> 
 Increments the current stencil buffer value. 
 Clamps to the maximum representable unsigned value.
 <p> 
 <code>GL_INCR_WRAP</code>
 <p> 
 Increments the current stencil buffer value. 
 Wraps stencil buffer value to zero when incrementing the
 maximum representable unsigned value.
 <p> 
 <code>GL_DECR</code>
 <p> 
 Decrements the current stencil buffer value. Clamps to 0.
 <p> 
 <code>GL_DECR_WRAP</code>
 <p> 
 Decrements the current stencil buffer value. 
 Wraps stencil buffer value to the maximum representable 
 unsigned value when decrementing a stencil buffer value of zero.
 <p> 
 <code>GL_INVERT</code>
 <p> 
 Bitwise inverts the current stencil buffer value.
 <p>
 Stencil buffer values are treated as unsigned integers. 
 When incremented and decremented, values are clamped to the range
 <code>[0, 2^n - 1]</code>, 
 where <code>n</code> is the value returned by querying <code>GL_STENCIL_BITS</code>.
 <p>
 The other two arguments to <code>glStencilOpSeparate</code> specify stencil buffer 
 actions that depend on whether subsequent depth buffer tests 
 succeed (<i><code>zpass</code></i>) or fail (<i><code>zfail</code></i>)
 (see <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>glDepthFunc</CODE></A>). The actions 
 are specified using the same eight symbolic constants as <i><code>fail</code></i>. 
 Note that <i><code>zfail</code></i> is ignored when there is no depth buffer, or when 
 the depth buffer is not enabled. In these cases, <i><code>fail</code></i> and <i><code>zpass</code></i> 
 specify stencil action when the stencil test fails and passes, respectively.
 <p> 
 <h4>Notes</h4> 
 <p> 
 Initially the stencil test is disabled. If there is no stencil buffer, 
 no stencil modification can occur and it is as if the stencil 
 test always passes. 
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>face</code></i> is any value other 
  than <code>GL_FRONT</code>, <code>GL_BACK</code>, or <code>GL_FRONT_AND_BACK</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>fail</code></i>,
  <i><code>zfail</code></i>, or <i><code>zpass</code></i> 
  is any value other than the eight defined symbolic constant values.
 <p> 
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_STENCIL_FAIL</code>, <code>GL_STENCIL_PASS_DEPTH_PASS</code>, 
  <code>GL_STENCIL_PASS_DEPTH_FAIL</code>, <code>GL_STENCIL_BACK_FAIL</code>, 
  <code>GL_STENCIL_BACK_PASS_DEPTH_PASS</code>, <code>GL_STENCIL_BACK_PASS_DEPTH_FAIL</code>, 
  or <code>GL_STENCIL_BITS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsEnabled(int)"><CODE>glIsEnabled</CODE></A> with argument <code>GL_STENCIL_TEST</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>face</CODE> - Specifies whether front and/or back stencil state is updated. 
  Three symbolic constants are valid: <code>GL_FRONT</code>, <code>GL_BACK</code>, and <code>GL_FRONT_AND_BACK</code>.<DD><CODE>fail</CODE> - Specifies the action to take when the stencil test fails. 
  Eight symbolic constants are accepted: <code>GL_KEEP</code>, <code>GL_ZERO</code>, 
  <code>GL_REPLACE</code>, <code>GL_INCR</code>, <code>GL_INCR_WRAP</code>, <code>GL_DECR</code>, 
  <code>GL_DECR_WRAP</code>, and <code>GL_INVERT</code>. 
  The initial value is <code>GL_KEEP</code>.<DD><CODE>zfail</CODE> - Specifies the stencil action when the stencil test passes, 
  but the depth test fails. <i><code>zfail</code></i> accepts the same 
  symbolic constants as <i><code>fail</code></i>. 
  The initial value is <code>GL_KEEP</code>.<DD><CODE>zpass</CODE> - Specifies the stencil action when both the stencil test 
  and the depth test pass, or when the stencil test passes and either 
  there is no depth buffer or depth testing is not enabled. <i><code>zpass</code></i> 
  accepts the same symbolic constants as <i><code>fail</code></i>. 
  The initial value is <code>GL_KEEP</code>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBlendFunc(int, int)"><CODE>GL20.glBlendFunc(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthFunc(int)"><CODE>GL20.glDepthFunc(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnable(int)"><CODE>GL20.glEnable(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFunc(int, int, int)"><CODE>GL20.glStencilFunc(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilFuncSeparate(int, int, int, int)"><CODE>GL20.glStencilFuncSeparate(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMask(int)"><CODE>GL20.glStencilMask(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilMaskSeparate(int, int)"><CODE>GL20.glStencilMaskSeparate(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glStencilOp(int, int, int)"><CODE>GL20.glStencilOp(int, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glTexImage2D</H3>
<PRE>
void <B>glTexImage2D</B>(int&nbsp;target,
                  int&nbsp;level,
                  int&nbsp;internalformat,
                  int&nbsp;width,
                  int&nbsp;height,
                  int&nbsp;border,
                  int&nbsp;format,
                  int&nbsp;type,
                  <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</PRE>
<DL>
<DD>Specify a two-dimensional texture image.
 <p>
 <h4>Description</h4>
 Texturing maps a portion of a specified texture image onto each 
 graphical primitive for which texturing is active. Texturing is 
 active when the current fragment shader or vertex shader makes 
 use of built-in texture lookup functions.
 <p>
 To define texture images, call <code>glTexImage2D</code>. The arguments 
 describe the parameters of the texture image, such as height, 
 width, level-of-detail number (see <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>glTexParameterf</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>glTexParameterfv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>glTexParameterfv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>glTexParameteri</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>glTexParameteriv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>glTexParameteriv</CODE></A>), and format. 
 The last three arguments describe how the image is represented in memory.
 <p>
 Data is read from <i><code>data</code></i> as a sequence of unsigned bytes or shorts, 
 depending on <i><code>type</code></i>. When <i><code>type</code></i> is <code>GL_UNSIGNED_BYTE</code>, each of the bytes 
 is interpreted as one color component. When <i><code>type</code></i> is one of 
 <code>GL_UNSIGNED_SHORT_5_6_5</code>, <code>GL_UNSIGNED_SHORT_4_4_4_4</code>, or 
 <code>GL_UNSIGNED_SHORT_5_5_5_1</code>, each unsigned short value is 
 interpreted as containing all the components for a single texel, 
 with the color components arranged according to <i><code>format</code></i>. Color components 
 are treated as groups of one, two, three, or four values, again based on 
 <i><code>format</code></i>. Groups of components are referred to as texels.
 <p>
 <code><i>width</i>  <i>height</i></code> texels are read from <i><code>data</code></i>. 
 By default, these texels are taken from adjacent memory locations, 
 except that after all <i><code>width</code></i> texels are read, the read pointer is 
 advanced to the next four-byte boundary. The four-byte row alignment 
 is specified by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPixelStorei(int, int)"><CODE>glPixelStorei</CODE></A> with argument <code>GL_UNPACK_ALIGNMENT</code>, 
 and it can be set to one, two, four, or eight bytes.
 <p>
 The first element corresponds to the lower left corner of the texture image.
  Subsequent elements progress left-to-right through the remaining texels 
  in the lowest row of the texture image, and then in successively higher 
  rows of the texture image. The final element corresponds to the 
  upper right corner of the texture image.
 <p>
 <i><code>format</code></i> determines the composition of each element in <i><code>data</code></i>. 
 It can assume one of these symbolic values:
 <p>
 <code>GL_ALPHA</code>
 <p>
 Each element is a single alpha component. The GL converts it to 
 floating point and assembles it into an RGBA element by 
 attaching 0 for red, green, and blue. Each component is 
 then clamped to the range <code>[0, 1]</code>.
 <p>
 <code>GL_RGB</code>
 <p>
 Each element is an RGB triple. The GL converts it to floating point 
 and assembles it into an RGBA element by attaching 1 for alpha. 
 Each component is then clamped to the range <code>[0, 1]</code>.
 <p>
 <code>GL_RGBA</code>
 <p>
 Each element contains all four components. The GL converts 
 it to floating point, then each component is clamped to 
 the range <code>[0, 1]</code>.
 <p>
 <code>GL_LUMINANCE</code>
 <p>
 Each element is a single luminance value. The GL converts it to 
 floating point, then assembles it into an RGBA element by 
 replicating the luminance value three times for red, green, 
 and blue and attaching 1 for alpha. Each component is then clamped 
 to the range <code>[0, 1]</code>.
 <p>
 <code>GL_LUMINANCE_ALPHA</code>
 <p>
 Each element is a luminance/alpha pair. The GL converts it to 
 floating point, then assembles it into an RGBA element by 
 replicating the luminance value three times for red, green, and blue. 
 Each component is then clamped to the range <code>[0, 1]</code>.
 <p>
 Color components are converted to floating point based on the <i><code>type</code></i>. 
 When <i><code>type</code></i> is <code>GL_UNSIGNED_BYTE</code>, each component is divided by <code>2^8 - 1</code>. 
 When <i><code>type</code></i> is <code>GL_UNSIGNED_SHORT_5_6_5</code>, <code>GL_UNSIGNED_SHORT_4_4_4_4</code>, 
 or <code>GL_UNSIGNED_SHORT_5_5_5_1</code>, each component is divided by <code>2^<i>N</i> - 1</code>, 
 where <i><code>N</code></i> is the number of bits in the bitfield. 
 <p> 
 <h4>Notes</h4> 
 <p> 
 <i><code>internalformat</code></i> must match <i><code>format</code></i>. No conversion between formats is 
 supported during texture image processing. <i><code>type</code></i> may be used as a 
 hint to specify how much precision is desired, but a GL implementation 
 may choose to store the texture array at any internal resolution it chooses.
 <p>
 <i><code>data</code></i> may be <code>null</code>. In this case, texture memory is allocated 
 to accommodate a texture of width <i><code>width</code></i> and height <i><code>height</code></i>. You can 
 then download subtextures to initialize this texture memory. 
 The image is undefined if the user tries to apply an uninitialized 
 portion of the texture image to a primitive.
 <p>
 <code>glTexImage2D</code> specifies a two-dimensional or cube-map texture 
 for the current texture unit, specified with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>glActiveTexture</CODE></A>. 
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not 
  <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>format</code></i> or 
  <i><code>type</code></i> is not an accepted value.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>target</code></i> is one of 
  the six cube map 2D image targets and the width and height 
  parameters are not equal.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>level</code></i> is less than 0.
 <p><code>GL_INVALID_VALUE</code> may be generated if <i><code>level</code></i> is greater 
  than <code>log_2(<i>max</i>)</code>, where <i><code>max</code></i> is the returned value of 
  <code>GL_MAX_TEXTURE_SIZE</code> when <i><code>target</code></i> is <code>GL_TEXTURE_2D</code> or 
  <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code> when <i><code>target</code></i> is not <code>GL_TEXTURE_2D</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>internalformat</code></i> 
  is not an accepted format.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>width</code></i> or <i><code>height</code></i> 
  is less than 0 or greater than <code>GL_MAX_TEXTURE_SIZE</code> when 
  <i><code>target</code></i> is <code>GL_TEXTURE_2D</code> or <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code> 
  when <i><code>target</code></i> is not <code>GL_TEXTURE_2D</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if 
  <i><code>border</code></i> is not 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if 
  <i><code>format</code></i> does not match <i><code>internalformat</code></i>.
 <p><code>GL_INVALID_OPERATION</code> is generated if 
  <i><code>type</code></i> is <code>GL_UNSIGNED_SHORT_5_6_5</code> and <i><code>format</code></i> is not <code>GL_RGB</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if 
  <i><code>type</code></i> is <code>GL_UNSIGNED_SHORT_4_4_4_4</code> or 
  <code>GL_UNSIGNED_SHORT_5_5_5_1</code> and <i><code>format</code></i> is not <code>GL_RGBA</code>.
 <p> 
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_MAX_TEXTURE_SIZE</code> or <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture. Must be 
  <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.<DD><CODE>level</CODE> - Specifies the level-of-detail number. 
  Level 0 is the base image level. Level <i>n</i> is the <i>n</i>th mipmap 
  reduction image.<DD><CODE>internalformat</CODE> - Specifies the internal format of the 
  texture. Must be one of the following symbolic constants: 
  <code>GL_ALPHA</code>, <code>GL_LUMINANCE</code>, <code>GL_LUMINANCE_ALPHA</code>, <code>GL_RGB</code>, <code>GL_RGBA</code>.<DD><CODE>width</CODE> - Specifies the width of the texture image. 
  All implementations support 2D texture images that are at 
  least 64 texels wide and cube-mapped texture images that 
  are at least 16 texels wide.<DD><CODE>height</CODE> - Specifies the height of the texture image 
  All implementations support 2D texture images that are 
  at least 64 texels high and cube-mapped texture images 
  that are at least 16 texels high.<DD><CODE>border</CODE> - Specifies the width of the border. Must be 0.<DD><CODE>format</CODE> - Specifies the format of the texel data. 
  Must match <i><code>internalformat</code></i>. The following symbolic values 
  are accepted: <code>GL_ALPHA</code>, <code>GL_RGB</code>, <code>GL_RGBA</code>, <code>GL_LUMINANCE</code>, 
  and <code>GL_LUMINANCE_ALPHA</code>.<DD><CODE>type</CODE> - Specifies the data type of the texel data. 
  The following symbolic values are accepted: <code>GL_UNSIGNED_BYTE</code>, 
  <code>GL_UNSIGNED_SHORT_5_6_5</code>, <code>GL_UNSIGNED_SHORT_4_4_4_4</code>, and <code>GL_UNSIGNED_SHORT_5_5_5_1</code>.<DD><CODE>data</CODE> - Specifies the image data as a buffer in memory.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>data</code></i> is non-<code>null</code> and does not contain
  the desired number of pixels.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>GL20.glActiveTexture(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexImage2D(int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glCompressedTexImage2D(int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glCompressedTexSubImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexSubImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexSubImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPixelStorei(int, int)"><CODE>GL20.glPixelStorei(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexSubImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glTexParameterf(int, int, float)"><!-- --></A><H3>
glTexParameterf</H3>
<PRE>
void <B>glTexParameterf</B>(int&nbsp;target,
                     int&nbsp;pname,
                     float&nbsp;param)</PRE>
<DL>
<DD>Set texture parameters.
 <p>
 <h4>Description</h4>
 Texture mapping is a technique that applies an image onto an object's 
 surface as if the image were a decal or cellophane shrink-wrap. 
 The image is created in texture space, with an (s, t) coordinate system. 
 A texture is a two-dimensional or cube-mapped image and a set of parameters 
 that determine how samples are derived from the image.
 <p>
 <code>glTexParameterf</code> assigns the value or values in <i><code>params</code></i> to the 
 texture parameter specified as <i><code>pname</code></i>. <i><code>target</code></i> defines
 the target texture of the active texture, 
 either <code>GL_TEXTURE_2D</code> or <code>GL_TEXTURE_CUBE_MAP</code>. 
 The following symbols are accepted in <i><code>pname</code></i>:
 <p>
 <code>GL_TEXTURE_MIN_FILTER</code>
 <p>
 The texture minifying function is used whenever the pixel being textured maps 
 to an area greater than one texture element. There are six defined minifying functions. 
 Two of them use the nearest one or nearest four texture elements to compute the texture
 value. The other four use mipmaps.
 <p>
 A mipmap is an ordered set of arrays representing the same image at 
 progressively lower resolutions. If the texture has dimensions <code>w  h</code>, 
 there are <code>floor(log_2(<i>max</i>(w, h))) + 1</code> mipmap levels. The first mipmap 
 level is the original texture, with dimensions <code>w  h</code>. Each subsequent 
 mipmap level has dimensions <code>max(1, floor(w/2^i))  max(1, floor(h/2^i))</code>, 
 where <i>i</i> is the mipmap level, until the final mipmap is reached, 
 which has dimension <code>1  1</code>.
 <p>
 To define the mipmap levels, call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glTexImage2D</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexImage2D(int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glCompressedTexImage2D</CODE></A>, or 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)"><CODE>glCopyTexImage2D</CODE></A>
 with the <i>level</i> argument indicating the order of the mipmaps. 
 Level 0 is the original texture; level <code>floor(log_2(max(w, h)))</code> is 
 the final <code>1  1</code> mipmap.
 <p>
 <i><code>params</code></i> supplies a function for minifying the texture as one of the following:
 <p>
 <code>GL_NEAREST</code>
 <p>
 Returns the value of the texture element that is nearest (in Manhattan distance) 
 to the center of the pixel being textured.
 <p>
 <code>GL_LINEAR</code>
 <p>
 Returns the weighted average of the four texture elements that are 
 closest to the center of the pixel being textured.
 <p>
 <code>GL_NEAREST_MIPMAP_NEAREST</code>
 <p>
 Chooses the mipmap that most closely matches the size of the pixel 
 being textured and uses the <code>GL_NEAREST</code> criterion (the texture 
 element nearest to the center of the pixel) to produce a texture value.
 <p>
 <code>GL_LINEAR_MIPMAP_NEAREST</code>
 <p>
 Chooses the mipmap that most closely matches the size of the pixel being 
 textured and uses the <code>GL_LINEAR</code> criterion (a weighted average of the 
 four texture elements that are closest to the center of the pixel) 
 to produce a texture value.
 <p>
 <code>GL_NEAREST_MIPMAP_LINEAR</code>
 <p>
 Chooses the two mipmaps that most closely match the size of the pixel being 
 textured and uses the <code>GL_NEAREST</code> criterion (the texture element nearest 
 to the center of the pixel) to produce a texture value from each mipmap. 
 The final texture value is a weighted average of those two values.
 <p>
 <code>GL_LINEAR_MIPMAP_LINEAR</code>
 <p>
 Chooses the two mipmaps that most closely match the size of the pixel 
 being textured and uses the <code>GL_LINEAR</code> criterion (a weighted average 
 of the four texture elements that are closest to the center of the pixel) 
 to produce a texture value from each mipmap. The final texture value 
 is a weighted average of those two values.
 <p>
 As more texture elements are sampled in the minification process, 
 fewer aliasing artifacts will be apparent. While the <code>GL_NEAREST</code> and 
 <code>GL_LINEAR</code> minification functions can be faster than the other four, 
 they sample only one or four texture elements to determine the texture value 
 of the pixel being rendered and can produce moire patterns or ragged transitions. 
 The initial value of <code>GL_TEXTURE_MIN_FILTER</code> is <code>GL_NEAREST_MIPMAP_LINEAR</code>.
 <p>
 <code>GL_TEXTURE_MAG_FILTER</code>
 <p>
 The texture magnification function is used when the pixel being textured 
 maps to an area less than or equal to one texture element. It sets the 
 texture magnification function to either <code>GL_NEAREST</code> or <code>GL_LINEAR</code> (see below). 
 <code>GL_NEAREST</code> is generally faster than <code>GL_LINEAR</code>, but it can produce textured images with
 sharper edges because the transition between texture elements is not as smooth. 
 The initial value of <code>GL_TEXTURE_MAG_FILTER</code> is <code>GL_LINEAR</code>.
 <p>
 <code>GL_NEAREST</code>
 <p>
 Returns the value of the texture element that is nearest (in Manhattan distance) 
 to the center of the pixel being textured.
 <p>
 <code>GL_LINEAR</code>
 <p>
 Returns the weighted average of the four texture elements that are 
 closest to the center of the pixel being textured.
 <p>
 <code>GL_TEXTURE_WRAP_S</code>
 <p>
 Sets the wrap parameter for texture coordinate <i>s</i> to either <code>GL_CLAMP_TO_EDGE</code>, 
 <code>GL_MIRRORED_REPEAT</code>, or <code>GL_REPEAT</code>. <code>GL_CLAMP_TO_EDGE</code> causes <i>s</i> coordinates to be 
 clamped to the range <code>[1/2<i>N</i>, 1 - 1/2<i>N</i>]</code>, where <i><code>N</code></i> is the size of the texture in the 
 direction of clamping. <code>GL_REPEAT</code> causes the integer part of the <i>s</i> coordinate 
 to be ignored; the GL uses only the fractional part, thereby creating a 
 repeating pattern. <code>GL_MIRRORED_REPEAT</code> causes the <i>s</i> coordinate to be set 
 to the fractional part of the texture coordinate if the integer 
 part of <i>s</i> is even; if the integer part of <i>s</i> is odd, then the <i>s</i> texture 
 coordinate is set to <code>1 - frac(<i>s</i>)</code>, where <code>frac(<i>s</i>)</code> represents the 
 fractional part of <code>s</code>. Initially, <code>GL_TEXTURE_WRAP_S</code> is set 
 to <code>GL_REPEAT</code>.
 <p>
 <code>GL_TEXTURE_WRAP_T</code>
 <p>
 Sets the wrap parameter for texture coordinate <i>t</i> to either 
 <code>GL_CLAMP_TO_EDGE</code>, <code>GL_MIRRORED_REPEAT</code>, or <code>GL_REPEAT</code>. See the 
 discussion under <code>GL_TEXTURE_WRAP_S</code>. Initially, <code>GL_TEXTURE_WRAP_T</code> 
 is set to <code>GL_REPEAT</code>. 
 <p> 
 <h4>Notes</h4> 
 <p>
 Suppose that a texture is accessed from a fragment shader or vertex shader 
 and has set <code>GL_TEXTURE_MIN_FILTER</code> to one of the functions that requires mipmaps. 
 If either the dimensions of the texture images currently defined (with previous 
 calls to <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glTexImage2D</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexImage2D(int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glCompressedTexImage2D</CODE></A>,
 or <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)"><CODE>glCopyTexImage2D</CODE></A>) do not 
 follow the proper sequence for mipmaps (described above), or there are fewer 
 texture images defined than are needed, or the set of texture images were 
 defined with different formats or types, then the texture image unit will 
 return <code>(R, G, B, A) = (0, 0, 0, 1)</code>.
 <p>
 Similarly, if the width or height of a texture image are not powers of 
 two and either the <code>GL_TEXTURE_MIN_FILTER</code> is set to one of the functions 
 that requires mipmaps or the <code>GL_TEXTURE_WRAP_S</code> or <code>GL_TEXTURE_WRAP_T</code> 
 is not set to <code>GL_CLAMP_TO_EDGE</code>, then the texture image unit 
 will return <code>(R, G, B, A) = (0, 0, 0, 1)</code>.
 <p>
 <code>glTexParameterf</code> specifies the texture parameters for the 
 active texture unit, specified by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>glActiveTexture</CODE></A>. 
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> or <i><code>pname</code></i> is 
  not one of the accepted defined values.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>params</code></i> should 
  have a defined symbolic constant value (based on the value of <i><code>pname</code></i>) 
  and does not.
 <p> 
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>glGetTexParameterfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameterfv(int, int, float[], int)"><CODE>glGetTexParameterfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>glGetTexParameteriv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetTexParameteriv(int, int, int[], int)"><CODE>glGetTexParameteriv</CODE></A> 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture, which must be either 
  <code>GL_TEXTURE_2D</code> or <code>GL_TEXTURE_CUBE_MAP</code>.<DD><CODE>pname</CODE> - Specifies the symbolic name of a single-valued 
  texture parameter. <i><code>pname</code></i> can be one of the following: 
  <code>GL_TEXTURE_MIN_FILTER</code>, <code>GL_TEXTURE_MAG_FILTER</code>, 
  <code>GL_TEXTURE_WRAP_S</code>, or <code>GL_TEXTURE_WRAP_T</code>.<DD><CODE>param</CODE> - Specifies the value of <i><code>pname</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>GL20.glActiveTexture(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindTexture(int, int)"><CODE>GL20.glBindTexture(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexSubImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexSubImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPixelStorei(int, int)"><CODE>GL20.glPixelStorei(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexSubImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glTexParameterfv(int, int, float[], int)"><!-- --></A><H3>
glTexParameterfv</H3>
<PRE>
void <B>glTexParameterfv</B>(int&nbsp;target,
                      int&nbsp;pname,
                      float[]&nbsp;params,
                      int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>glTexParameterf</CODE></A>.
 <p>
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> or <i><code>pname</code></i> is 
  not one of the accepted defined values.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>params</code></i> should 
  have a defined symbolic constant value (based on the value of <i><code>pname</code></i>) 
  and does not.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture, which must be either 
  <code>GL_TEXTURE_2D</code> or <code>GL_TEXTURE_CUBE_MAP</code>.<DD><CODE>pname</CODE> - Specifies the symbolic name of a single-valued 
  texture parameter. <i><code>pname</code></i> can be one of the following: 
  <code>GL_TEXTURE_MIN_FILTER</code>, <code>GL_TEXTURE_MAG_FILTER</code>, 
  <code>GL_TEXTURE_WRAP_S</code>, or <code>GL_TEXTURE_WRAP_T</code>.<DD><CODE>params</CODE> - Specifies an array where the value of <i><code>pname</code></i> is stored.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length - 
             <i>offset</i></code> is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glTexParameterfv(int, int, java.nio.FloatBuffer)"><!-- --></A><H3>
glTexParameterfv</H3>
<PRE>
void <B>glTexParameterfv</B>(int&nbsp;target,
                      int&nbsp;pname,
                      <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Floating-point <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>glTexParameterfv</CODE></A>.
 <p> 
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> or <i><code>pname</code></i> is 
  not one of the accepted defined values.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>params</code></i> should 
  have a defined symbolic constant value (based on the value of <i><code>pname</code></i>) 
  and does not.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture, which must be either 
  <code>GL_TEXTURE_2D</code> or <code>GL_TEXTURE_CUBE_MAP</code>.<DD><CODE>pname</CODE> - Specifies the symbolic name of a single-valued 
  texture parameter. <i><code>pname</code></i> can be one of the following: 
  <code>GL_TEXTURE_MIN_FILTER</code>, <code>GL_TEXTURE_MAG_FILTER</code>, 
  <code>GL_TEXTURE_WRAP_S</code>, or <code>GL_TEXTURE_WRAP_T</code>.<DD><CODE>params</CODE> - Specifies a buffer where the value of <i><code>pname</code></i> is stored.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> is smaller than the 
             number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glTexParameteri(int, int, int)"><!-- --></A><H3>
glTexParameteri</H3>
<PRE>
void <B>glTexParameteri</B>(int&nbsp;target,
                     int&nbsp;pname,
                     int&nbsp;param)</PRE>
<DL>
<DD>Integer version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>glTexParameterf</CODE></A>.
 <p> 
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> or <i><code>pname</code></i> is 
  not one of the accepted defined values.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>params</code></i> should 
  have a defined symbolic constant value (based on the value of <i><code>pname</code></i>) 
  and does not.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture, which must be either 
  <code>GL_TEXTURE_2D</code> or <code>GL_TEXTURE_CUBE_MAP</code>.<DD><CODE>pname</CODE> - Specifies the symbolic name of a single-valued 
  texture parameter. <i><code>pname</code></i> can be one of the following: 
  <code>GL_TEXTURE_MIN_FILTER</code>, <code>GL_TEXTURE_MAG_FILTER</code>, 
  <code>GL_TEXTURE_WRAP_S</code>, or <code>GL_TEXTURE_WRAP_T</code>.<DD><CODE>param</CODE> - Specifies the value of <i><code>pname</code></i>.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glTexParameteriv(int, int, int[], int)"><!-- --></A><H3>
glTexParameteriv</H3>
<PRE>
void <B>glTexParameteriv</B>(int&nbsp;target,
                      int&nbsp;pname,
                      int[]&nbsp;params,
                      int&nbsp;offset)</PRE>
<DL>
<DD>Integer array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>glTexParameteri</CODE></A>.
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> or <i><code>pname</code></i> is 
  not one of the accepted defined values.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>params</code></i> should 
  have a defined symbolic constant value (based on the value of <i><code>pname</code></i>) 
  and does not.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture, which must be either 
  <code>GL_TEXTURE_2D</code> or <code>GL_TEXTURE_CUBE_MAP</code>.<DD><CODE>pname</CODE> - Specifies the symbolic name of a single-valued 
  texture parameter. <i><code>pname</code></i> can be one of the following: 
  <code>GL_TEXTURE_MIN_FILTER</code>, <code>GL_TEXTURE_MAG_FILTER</code>, 
  <code>GL_TEXTURE_WRAP_S</code>, or <code>GL_TEXTURE_WRAP_T</code>.<DD><CODE>params</CODE> - Specifies an array where the value of <i><code>pname</code></i> is stored.<DD><CODE>offset</CODE> - The starting offset within the <i><code>params</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.length - 
             <i>offset</i></code> is smaller than the number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glTexParameteriv(int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glTexParameteriv</H3>
<PRE>
void <B>glTexParameteriv</B>(int&nbsp;target,
                      int&nbsp;pname,
                      <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;params)</PRE>
<DL>
<DD>Integer <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>glTexParameteriv</CODE></A>.
 <p> 
 <h4>Errors</h4>
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> or <i><code>pname</code></i> is 
  not one of the accepted defined values.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>params</code></i> should 
  have a defined symbolic constant value (based on the value of <i><code>pname</code></i>) 
  and does not.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture, which must be either 
  <code>GL_TEXTURE_2D</code> or <code>GL_TEXTURE_CUBE_MAP</code>.<DD><CODE>pname</CODE> - Specifies the symbolic name of a single-valued 
  texture parameter. <i><code>pname</code></i> can be one of the following: 
  <code>GL_TEXTURE_MIN_FILTER</code>, <code>GL_TEXTURE_MAG_FILTER</code>, 
  <code>GL_TEXTURE_WRAP_S</code>, or <code>GL_TEXTURE_WRAP_T</code>.<DD><CODE>params</CODE> - Specifies a buffer where the value of <i><code>pname</code></i> is stored.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>params</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>params</i>.remaining()</code> is smaller than the 
             number of values required by the parameter.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><!-- --></A><H3>
glTexSubImage2D</H3>
<PRE>
void <B>glTexSubImage2D</B>(int&nbsp;target,
                     int&nbsp;level,
                     int&nbsp;xoffset,
                     int&nbsp;yoffset,
                     int&nbsp;width,
                     int&nbsp;height,
                     int&nbsp;format,
                     int&nbsp;type,
                     <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</PRE>
<DL>
<DD>Specify a two-dimensional texture subimage.
 <p>
 <h4>Description</h4>
 Texturing maps a portion of a specified texture image onto each 
 graphical primitive for which texturing is active. 
 Texturing is active when the current fragment shader or 
 vertex shader makes use of built-in texture lookup functions.
 <p>
 <code>glTexSubImage2D</code> redefines a contiguous subregion of an 
 existing two-dimensional texture image. The texels referenced by <i><code>data</code></i> 
 replace the portion of the existing texture array 
 with x indices <i><code>xoffset</code></i> and <code><i>xoffset</i> + <i>width</i> - 1</code>, inclusive, 
 and y indices <i><code>yoffset</code></i> and <code><i>yoffset</i> + <i>height</i> - 1</code>, inclusive. 
 This region may not include any texels outside the range of the 
 texture array as it was originally specified. It is not an 
 error to specify a subtexture with zero width or height, 
 but such a specification has no effect.
 <p> 
 <h4>Notes</h4> 
 <p>
 Storage parameter <code>GL_UNPACK_ALIGNMENT</code>, set by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPixelStorei(int, int)"><CODE>glPixelStorei</CODE></A>, 
 affects the way that data is read out of client memory. 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPixelStorei(int, int)"><CODE>glPixelStorei</CODE></A> for a description.
 <p>
 <code>glTexSubImage2D</code> specifies a two-dimensional or cube-map 
 subtexture for the current texture unit, 
 specified with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>glActiveTexture</CODE></A>. 
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>target</code></i> is not 
  <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>format</code></i> or <i><code>type</code></i> is 
  not an accepted value.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>level</code></i> is less than 0.
 <p><code>GL_INVALID_VALUE</code> may be generated if <i><code>level</code></i> is greater 
  than <code>log_2(<i>max</i>)</code>, where <i><code>max</code></i> is the returned value of 
  <code>GL_MAX_TEXTURE_SIZE</code> when <i><code>target</code></i> is <code>GL_TEXTURE_2D</code> or 
  <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code> when <i><code>target</code></i> is not <code>GL_TEXTURE_2D</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if <code><i>xoffset</i> < 0</code>, <code><i>xoffset</i> + <i>width</i> > w</code>, 
  <code><i>yoffset</i> < 0</code>, or <code><i>yoffset</i> + <i>height</i> > h</code>,
  where <code>w</code> is the width and <code>h</code> is the 
  height of the texture image being modified.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>width</code></i> or <i><code>height</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if the texture array has not 
  been defined by a previous <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glTexImage2D</CODE></A>
  or <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)"><CODE>glCopyTexImage2D</CODE></A> operation 
  whose <i><code>internalformat</code></i> matches the <i><code>format</code></i> of
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>glTexSubImage2D</CODE></A>.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>type</code></i> is 
  <code>GL_UNSIGNED_SHORT_5_6_5</code> and <i><code>format</code></i> is not <code>GL_RGB</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>type</code></i> is <code>GL_UNSIGNED_SHORT_4_4_4_4</code> or 
  <code>GL_UNSIGNED_SHORT_5_5_5_1</code> and <i><code>format</code></i> is not <code>GL_RGBA</code>.
 <p> 
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_MAX_TEXTURE_SIZE</code> or <code>GL_MAX_CUBE_MAP_TEXTURE_SIZE</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - Specifies the target texture of the active texture. Must be 
  <code>GL_TEXTURE_2D</code>, <code>GL_TEXTURE_CUBE_MAP_POSITIVE_X</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</code>, <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</code>, 
  <code>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</code>, or <code>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</code>.<DD><CODE>level</CODE> - Specifies the level-of-detail number. Level 0 is the 
  base image level. Level <i>n</i> is the <i>n</i>th mipmap reduction image.<DD><CODE>xoffset</CODE> - Specifies a texel offset in the x direction 
  within the texture array.<DD><CODE>yoffset</CODE> - Specifies a texel offset in the y direction 
  within the texture array.<DD><CODE>width</CODE> - Specifies the width of the texture subimage.<DD><CODE>height</CODE> - Specifies the height of the texture subimage.<DD><CODE>format</CODE> - Specifies the format of the pixel data. 
  The following symbolic values are accepted: 
  <code>GL_ALPHA</code>, <code>GL_RGB</code>, <code>GL_RGBA</code>, <code>GL_LUMINANCE</code>, and <code>GL_LUMINANCE_ALPHA</code>.<DD><CODE>type</CODE> - Specifies the data type of the pixel data. 
  The following symbolic values are accepted: 
  <code>GL_UNSIGNED_BYTE</code>, <code>GL_UNSIGNED_SHORT_5_6_5</code>, 
  <code>GL_UNSIGNED_SHORT_4_4_4_4</code>, and <code>GL_UNSIGNED_SHORT_5_5_5_1</code>.<DD><CODE>data</CODE> - Specifies the image data as a buffer in memory.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>data</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>data</code></i> does not contain
  the desired number of pixels.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glActiveTexture(int)"><CODE>GL20.glActiveTexture(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexImage2D(int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glCompressedTexImage2D(int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompressedTexSubImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glCompressedTexSubImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCopyTexSubImage2D(int, int, int, int, int, int, int, int)"><CODE>GL20.glCopyTexSubImage2D(int, int, int, int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glPixelStorei(int, int)"><CODE>GL20.glPixelStorei(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexImage2D(int, int, int, int, int, int, int, int, java.nio.Buffer)"><CODE>GL20.glTexImage2D(int, int, int, int, int, int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterf(int, int, float)"><CODE>GL20.glTexParameterf(int, int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glTexParameterfv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameterfv(int, int, float[], int)"><CODE>GL20.glTexParameterfv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteri(int, int, int)"><CODE>GL20.glTexParameteri(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, java.nio.IntBuffer)"><CODE>GL20.glTexParameteriv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glTexParameteriv(int, int, int[], int)"><CODE>GL20.glTexParameteriv(int, int, int[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform1f(int, float)"><!-- --></A><H3>
glUniform1f</H3>
<PRE>
void <B>glUniform1f</B>(int&nbsp;location,
                 float&nbsp;x)</PRE>
<DL>
<DD>Specify the value of a uniform variable for the current program object.
 <p>
 <h4>Description</h4>
 <code>glUniform</code> modifies the value of a uniform variable or a 
 uniform variable array. The location of the uniform variable to be modified 
 is specified by <i><code>location</code></i>, which should be a value returned 
 by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformLocation(int, java.lang.String)"><CODE>glGetUniformLocation</CODE></A>. 
 <code>glUniform</code> operates on the program object 
 that was made part of current state by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>glUseProgram</CODE></A>.
 <p> 
 The commands <code>glUniform{1|2|3|4}{f|i}</code> is used to change the 
 value of the uniform variable specified by <i><code>location</code></i> using the 
 values passed as arguments. The number specified in the command 
 should match the number of components in the data type of the specified
 uniform variable (e.g., <code>1</code> for float, int, bool; <code>2</code> for vec2, ivec2, bvec2, etc.). 
 The suffix <code>f</code> indicates that floating-point values are being passed; 
 the suffix <code>i</code> indicates that integer values are being passed, 
 and this type should also match the data type of the 
 specified uniform variable. The <code>i</code> variants of this function should be used to 
 provide values for uniform variables defined as int, ivec2, ivec3, ivec4, or 
 arrays of these. The <code>f</code> variants should be used to provide values for 
 uniform variables of type float, vec2, vec3, vec4, or arrays of these. 
 Either the <code>i</code> or the <code>f</code> variants may be used to provide values for 
 uniform variables of type bool, bvec2, bvec3, bvec4, or arrays of these. 
 The uniform variable will be set to false if the input value is 0 or 0.0f, 
 and it will be set to true otherwise.
 <p> 
 All active uniform variables defined in a program object are initialized 
 to 0 when the program object is linked successfully. They retain the 
 values assigned to them by a call to <code>glUniform</code> until the next successful 
 link operation occurs on the program object, when they are once again 
 initialized to 0.
 <p> 
 The commands <code>glUniform{1|2|3|4}{f|i}v</code> can be used to modify a 
 single uniform variable or a uniform variable array. 
 These commands pass a count and the values to be 
 loaded into a uniform variable or a uniform variable array. 
 A count of 1 should be used if modifying the value of a single 
 uniform variable, and a count of 1 or greater can be used to 
 modify an entire array or part of an array. When loading <i>n</i> 
 elements starting at an arbitrary position <i>m</i> in a uniform 
 variable array, elements <i>m</i> + <i>n</i> - 1 in the array will be replaced 
 with the new values. If <i>m</i> + <i>n</i> - 1 is larger than the size of the 
 uniform variable array, values for all array elements beyond 
 the end of the array will be ignored. The number specified in 
 the name of the command indicates the number of components for 
 each element in <i><code>value</code></i>, and it should match the number of 
 components in the data type of the specified uniform variable 
 (e.g., <code>1</code> for float, int, bool; <code>2</code> for vec2, ivec2, bvec2, etc.). 
 The data type specified in the name of the command must match 
 the data type for the specified uniform variable as described 
 previously for <code>glUniform{1|2|3|4}{f|i}</code>.
 <p> 
 For uniform variable arrays, each element of the array is 
 considered to be of the type indicated in the name of the command 
 (e.g., <code>glUniform3f</code> or <code>glUniform3fv</code> can be used to load a uniform 
 variable array of type vec3). The number of elements of the uniform 
 variable array to be modified is specified by <i><code>count</code></i>.
 <p> 
 The commands <code>glUniformMatrix{2|3|4}fv</code> are used to modify a 
 matrix or an array of matrices. The numbers in the command name 
 are interpreted as the dimensionality of the matrix. 
 The number <code>2</code> indicates a 2  2 matrix (i.e., 4 values), 
 the number <code>3</code> indicates a 3  3 matrix (i.e., 9 values), 
 and the number <code>4</code> indicates a 4  4 matrix (i.e., 16 values). 
 Each matrix is assumed to be supplied in column major order. 
 The <i><code>count</code></i> argument indicates the number of matrices to be passed. 
 A count of 1 should be used if modifying the value of a single matrix, 
 and a count greater than 1 can be used to modify an array of matrices. 
 <p> 
 <h4>Notes</h4> 
 <p> 
 <code>glUniform1i</code> and <code>glUniform1iv</code> are the only two functions that may be 
 used to load uniform variables defined as sampler types. 
 Loading samplers with any other function will result in a 
 <code>GL_INVALID_OPERATION</code> error.
 <p> 
 If <i><code>count</code></i> is greater than 1 and the indicated uniform variable 
 is not an array, a <code>GL_INVALID_OPERATION</code> error is generated and the 
 specified uniform variable will remain unchanged.
 <p> 
 Other than the preceding exceptions, if the type and size of the 
 uniform variable as defined in the shader do not match the type and 
 size specified in the name of the command used to load its value, a 
 <code>GL_INVALID_OPERATION</code> error will be generated and the specified uniform 
 variable will remain unchanged.
 <p> 
 If <i><code>location</code></i> is a value other than -1 and it does not represent a 
 valid uniform variable location in the current program object, 
 an error will be generated, and no changes will be made to the 
 uniform variable storage of the current program object. 
 If <i><code>location</code></i> is equal to -1, the data passed in will be silently 
 ignored and the specified uniform variable will not be changed. 
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p> 
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with the argument <code>GL_CURRENT_PROGRAM</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveUniform(int, int, int[], int, int[], int)"><CODE>glGetActiveUniform</CODE></A>
  with the handle of a program object and the index of an active uniform variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, java.nio.FloatBuffer)"><CODE>glGetUniformfv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, float[], int)"><CODE>glGetUniformfv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, java.nio.IntBuffer)"><CODE>glGetUniformiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>glGetUniformiv</CODE></A> 
  with the handle of a program object and the location of a uniform variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformLocation(int, java.lang.String)"><CODE>glGetUniformLocation</CODE></A> 
  with the handle of a program object and the name of a uniform variable 
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform variable to be modified.<DD><CODE>x</CODE> - Specifies the new value to be used for the specified uniform variable.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>GL20.glUseProgram(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform1fv(int, int, float[], int)"><!-- --></A><H3>
glUniform1fv</H3>
<PRE>
void <B>glUniform1fv</B>(int&nbsp;location,
                  int&nbsp;count,
                  float[]&nbsp;v,
                  int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point 1 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 1-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies an array of <i><code>count</code></i> values that will be used to update the specified uniform variable.<DD><CODE>offset</CODE> - The starting offset within the <i><code>v</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.length - <i>offset</i></code> is smaller than 1.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform1fv(int, int, java.nio.FloatBuffer)"><!-- --></A><H3>
glUniform1fv</H3>
<PRE>
void <B>glUniform1fv</B>(int&nbsp;location,
                  int&nbsp;count,
                  <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;v)</PRE>
<DL>
<DD>Floating-point 1 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 1-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies a buffer that will be used to update the specified uniform variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.remaining()</code> is smaller than 1.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform1i(int, int)"><!-- --></A><H3>
glUniform1i</H3>
<PRE>
void <B>glUniform1i</B>(int&nbsp;location,
                 int&nbsp;x)</PRE>
<DL>
<DD>Integer 1 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform variable to be modified.<DD><CODE>x</CODE> - Specifies the new value to be used for the specified uniform variable.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform1iv(int, int, int[], int)"><!-- --></A><H3>
glUniform1iv</H3>
<PRE>
void <B>glUniform1iv</B>(int&nbsp;location,
                  int&nbsp;count,
                  int[]&nbsp;v,
                  int&nbsp;offset)</PRE>
<DL>
<DD>Ingteger 1 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 1-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies an array of <i><code>count</code></i> values that will be used to update the specified uniform variable.<DD><CODE>offset</CODE> - The starting offset within the <i><code>v</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.length - <i>offset</i></code> is smaller than 1.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform1iv(int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glUniform1iv</H3>
<PRE>
void <B>glUniform1iv</B>(int&nbsp;location,
                  int&nbsp;count,
                  <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;v)</PRE>
<DL>
<DD>Integer 1 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 1-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies a buffer that will be used to update the specified uniform variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.remaining()</code> is smaller than 1.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform2f(int, float, float)"><!-- --></A><H3>
glUniform2f</H3>
<PRE>
void <B>glUniform2f</B>(int&nbsp;location,
                 float&nbsp;x,
                 float&nbsp;y)</PRE>
<DL>
<DD>Floating-point 2 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform variable to be modified.<DD><CODE>x</CODE> - Specifies the new value to be used for the specified uniform variable.<DD><CODE>y</CODE> - Specifies the new value to be used for the specified uniform variable.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform2fv(int, int, float[], int)"><!-- --></A><H3>
glUniform2fv</H3>
<PRE>
void <B>glUniform2fv</B>(int&nbsp;location,
                  int&nbsp;count,
                  float[]&nbsp;v,
                  int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point 2 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 2-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies an array of <i><code>count</code></i> values that will be used to update the specified uniform variable.<DD><CODE>offset</CODE> - The starting offset within the <i><code>v</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.length - <i>offset</i></code> is smaller than 2.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform2fv(int, int, java.nio.FloatBuffer)"><!-- --></A><H3>
glUniform2fv</H3>
<PRE>
void <B>glUniform2fv</B>(int&nbsp;location,
                  int&nbsp;count,
                  <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;v)</PRE>
<DL>
<DD>Floating-point 2 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 2-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies a buffer that will be used to update the specified uniform variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.remaining()</code> is smaller than 2.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform2i(int, int, int)"><!-- --></A><H3>
glUniform2i</H3>
<PRE>
void <B>glUniform2i</B>(int&nbsp;location,
                 int&nbsp;x,
                 int&nbsp;y)</PRE>
<DL>
<DD>Integer 2 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform variable to be modified.<DD><CODE>x</CODE> - Specifies the new value to be used for the specified uniform variable.<DD><CODE>y</CODE> - Specifies the new value to be used for the specified uniform variable.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform2iv(int, int, int[], int)"><!-- --></A><H3>
glUniform2iv</H3>
<PRE>
void <B>glUniform2iv</B>(int&nbsp;location,
                  int&nbsp;count,
                  int[]&nbsp;v,
                  int&nbsp;offset)</PRE>
<DL>
<DD>Ingteger 2 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 2-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies an array of <i><code>count</code></i> values that will be used to update the specified uniform variable.<DD><CODE>offset</CODE> - The starting offset within the <i><code>v</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.length - <i>offset</i></code> is smaller than 2.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform2iv(int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glUniform2iv</H3>
<PRE>
void <B>glUniform2iv</B>(int&nbsp;location,
                  int&nbsp;count,
                  <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;v)</PRE>
<DL>
<DD>Integer 2 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.  
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 2-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies a buffer that will be used to update the specified uniform variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.remaining()</code> is smaller than 2.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform3f(int, float, float, float)"><!-- --></A><H3>
glUniform3f</H3>
<PRE>
void <B>glUniform3f</B>(int&nbsp;location,
                 float&nbsp;x,
                 float&nbsp;y,
                 float&nbsp;z)</PRE>
<DL>
<DD>Floating-point 3 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform variable to be modified.<DD><CODE>x</CODE> - Specifies the new value to be used for the specified uniform variable.<DD><CODE>y</CODE> - Specifies the new value to be used for the specified uniform variable.<DD><CODE>z</CODE> - Specifies the new value to be used for the specified uniform variable.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform3fv(int, int, float[], int)"><!-- --></A><H3>
glUniform3fv</H3>
<PRE>
void <B>glUniform3fv</B>(int&nbsp;location,
                  int&nbsp;count,
                  float[]&nbsp;v,
                  int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point 3 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 3-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies an array of <i><code>count</code></i> values that will be used to update the specified uniform variable.<DD><CODE>offset</CODE> - The starting offset within the <i><code>v</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.length - <i>offset</i></code> is smaller than 3.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform3fv(int, int, java.nio.FloatBuffer)"><!-- --></A><H3>
glUniform3fv</H3>
<PRE>
void <B>glUniform3fv</B>(int&nbsp;location,
                  int&nbsp;count,
                  <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;v)</PRE>
<DL>
<DD>Floating-point 3 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 3-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies a buffer that will be used to update the specified uniform variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.remaining()</code> is smaller than 3.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform3i(int, int, int, int)"><!-- --></A><H3>
glUniform3i</H3>
<PRE>
void <B>glUniform3i</B>(int&nbsp;location,
                 int&nbsp;x,
                 int&nbsp;y,
                 int&nbsp;z)</PRE>
<DL>
<DD>Integer 3 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform variable to be modified.<DD><CODE>x</CODE> - Specifies the new value to be used for the specified uniform variable.<DD><CODE>y</CODE> - Specifies the new value to be used for the specified uniform variable.<DD><CODE>z</CODE> - Specifies the new value to be used for the specified uniform variable.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform3iv(int, int, int[], int)"><!-- --></A><H3>
glUniform3iv</H3>
<PRE>
void <B>glUniform3iv</B>(int&nbsp;location,
                  int&nbsp;count,
                  int[]&nbsp;v,
                  int&nbsp;offset)</PRE>
<DL>
<DD>Ingteger 3 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 3-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies an array of <i><code>count</code></i> values that will be used to update the specified uniform variable.<DD><CODE>offset</CODE> - The starting offset within the <i><code>v</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.length - <i>offset</i></code> is smaller than 3.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform3iv(int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glUniform3iv</H3>
<PRE>
void <B>glUniform3iv</B>(int&nbsp;location,
                  int&nbsp;count,
                  <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;v)</PRE>
<DL>
<DD>Integer 3 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 3-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies a buffer that will be used to update the specified uniform variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.remaining()</code> is smaller than 3.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform4f(int, float, float, float, float)"><!-- --></A><H3>
glUniform4f</H3>
<PRE>
void <B>glUniform4f</B>(int&nbsp;location,
                 float&nbsp;x,
                 float&nbsp;y,
                 float&nbsp;z,
                 float&nbsp;w)</PRE>
<DL>
<DD>Floating-point 4 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform variable to be modified.<DD><CODE>x</CODE> - Specifies the new value to be used for the specified uniform variable.<DD><CODE>y</CODE> - Specifies the new value to be used for the specified uniform variable.<DD><CODE>z</CODE> - Specifies the new value to be used for the specified uniform variable.<DD><CODE>w</CODE> - Specifies the new value to be used for the specified uniform variable.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform4fv(int, int, float[], int)"><!-- --></A><H3>
glUniform4fv</H3>
<PRE>
void <B>glUniform4fv</B>(int&nbsp;location,
                  int&nbsp;count,
                  float[]&nbsp;v,
                  int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point 4 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 4-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies an array of <i><code>count</code></i> values that will be used to update the specified uniform variable.<DD><CODE>offset</CODE> - The starting offset within the <i><code>v</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.length - <i>offset</i></code> is smaller than 4.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform4fv(int, int, java.nio.FloatBuffer)"><!-- --></A><H3>
glUniform4fv</H3>
<PRE>
void <B>glUniform4fv</B>(int&nbsp;location,
                  int&nbsp;count,
                  <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;v)</PRE>
<DL>
<DD>Floating-point 4 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 4-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies a buffer that will be used to update the specified uniform variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.remaining()</code> is smaller than 4.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform4i(int, int, int, int, int)"><!-- --></A><H3>
glUniform4i</H3>
<PRE>
void <B>glUniform4i</B>(int&nbsp;location,
                 int&nbsp;x,
                 int&nbsp;y,
                 int&nbsp;z,
                 int&nbsp;w)</PRE>
<DL>
<DD>Integer 4 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform variable to be modified.<DD><CODE>x</CODE> - Specifies the new value to be used for the specified uniform variable.<DD><CODE>y</CODE> - Specifies the new value to be used for the specified uniform variable.<DD><CODE>z</CODE> - Specifies the new value to be used for the specified uniform variable.<DD><CODE>w</CODE> - Specifies the new value to be used for the specified uniform variable.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform4iv(int, int, int[], int)"><!-- --></A><H3>
glUniform4iv</H3>
<PRE>
void <B>glUniform4iv</B>(int&nbsp;location,
                  int&nbsp;count,
                  int[]&nbsp;v,
                  int&nbsp;offset)</PRE>
<DL>
<DD>Integer 4 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 4-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies an array of <i><code>count</code></i> values that will be used to update the specified uniform variable.<DD><CODE>offset</CODE> - The starting offset within the <i><code>v</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.length - <i>offset</i></code> is smaller than 4.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniform4iv(int, int, java.nio.IntBuffer)"><!-- --></A><H3>
glUniform4iv</H3>
<PRE>
void <B>glUniform4iv</B>(int&nbsp;location,
                  int&nbsp;count,
                  <A HREF="../../../../../java/nio/IntBuffer.html" title="class in java.nio">IntBuffer</A>&nbsp;v)</PRE>
<DL>
<DD>Integer 4 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of sets of 4-element arrays that are to be modified.<DD><CODE>v</CODE> - Specifies a buffer that will be used to update the specified uniform variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>v</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>v</i>.remaining()</code> is smaller than 4.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniformMatrix2fv(int, int, boolean, float[], int)"><!-- --></A><H3>
glUniformMatrix2fv</H3>
<PRE>
void <B>glUniformMatrix2fv</B>(int&nbsp;location,
                        int&nbsp;count,
                        boolean&nbsp;transpose,
                        float[]&nbsp;value,
                        int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point 2x2 matrix array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>transpose</code></i> is not <code>GL_FALSE</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified<DD><CODE>count</CODE> - Specifies the number of matrices that are to be modified.<DD><CODE>transpose</CODE> - Specifies whether to transpose the matrix as the values are 
  loaded into the uniform variable. Must be <code>GL_FALSE</code>.<DD><CODE>value</CODE> - Specifies an array of <i><code>count</code></i> values that will be used to update 
  the specified uniform variable.<DD><CODE>offset</CODE> - The starting offset within the <i><code>value</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>value</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>value</i>.length - <i>offset</i></code> is smaller than 4.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniformMatrix2fv(int, int, boolean, java.nio.FloatBuffer)"><!-- --></A><H3>
glUniformMatrix2fv</H3>
<PRE>
void <B>glUniformMatrix2fv</B>(int&nbsp;location,
                        int&nbsp;count,
                        boolean&nbsp;transpose,
                        <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;value)</PRE>
<DL>
<DD>Floating-point 2x2 matrix <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>transpose</code></i> is not <code>GL_FALSE</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of matrices that are to be modified.<DD><CODE>transpose</CODE> - Specifies whether to transpose the matrix as the values are 
  loaded into the uniform variable. Must be <code>GL_FALSE</code>.<DD><CODE>value</CODE> - Specifies a buffer that will be used to update the specified uniform variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>value</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>value</i>.remaining()</code> is smaller than 4.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniformMatrix3fv(int, int, boolean, float[], int)"><!-- --></A><H3>
glUniformMatrix3fv</H3>
<PRE>
void <B>glUniformMatrix3fv</B>(int&nbsp;location,
                        int&nbsp;count,
                        boolean&nbsp;transpose,
                        float[]&nbsp;value,
                        int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point 3x3 matrix array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>transpose</code></i> is not <code>GL_FALSE</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified<DD><CODE>count</CODE> - Specifies the number of matrices that are to be modified.<DD><CODE>transpose</CODE> - Specifies whether to transpose the matrix as the values are 
  loaded into the uniform variable. Must be <code>GL_FALSE</code>.<DD><CODE>value</CODE> - Specifies an array of <i><code>count</code></i> values that will be used to update 
  the specified uniform variable.<DD><CODE>offset</CODE> - The starting offset within the <i><code>value</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>value</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>value</i>.length - <i>offset</i></code> is smaller than 9.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniformMatrix3fv(int, int, boolean, java.nio.FloatBuffer)"><!-- --></A><H3>
glUniformMatrix3fv</H3>
<PRE>
void <B>glUniformMatrix3fv</B>(int&nbsp;location,
                        int&nbsp;count,
                        boolean&nbsp;transpose,
                        <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;value)</PRE>
<DL>
<DD>Floating-point 3x3 matrix <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>transpose</code></i> is not <code>GL_FALSE</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of matrices that are to be modified.<DD><CODE>transpose</CODE> - Specifies whether to transpose the matrix as the values are 
  loaded into the uniform variable. Must be <code>GL_FALSE</code>.<DD><CODE>value</CODE> - Specifies a buffer that will be used to update the specified uniform variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>value</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>value</i>.remaining()</code> is smaller than 9.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniformMatrix4fv(int, int, boolean, float[], int)"><!-- --></A><H3>
glUniformMatrix4fv</H3>
<PRE>
void <B>glUniformMatrix4fv</B>(int&nbsp;location,
                        int&nbsp;count,
                        boolean&nbsp;transpose,
                        float[]&nbsp;value,
                        int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point 4x4 matrix array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>transpose</code></i> is not <code>GL_FALSE</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified<DD><CODE>count</CODE> - Specifies the number of matrices that are to be modified.<DD><CODE>transpose</CODE> - Specifies whether to transpose the matrix as the values are 
  loaded into the uniform variable. Must be <code>GL_FALSE</code>.<DD><CODE>value</CODE> - Specifies an array of <i><code>count</code></i> values that will be used to update 
  the specified uniform variable.<DD><CODE>offset</CODE> - The starting offset within the <i><code>value</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>value</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>value</i>.length - <i>offset</i></code> is smaller than 16.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUniformMatrix4fv(int, int, boolean, java.nio.FloatBuffer)"><!-- --></A><H3>
glUniformMatrix4fv</H3>
<PRE>
void <B>glUniformMatrix4fv</B>(int&nbsp;location,
                        int&nbsp;count,
                        boolean&nbsp;transpose,
                        <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;value)</PRE>
<DL>
<DD>Floating-point 4x4 matrix <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>glUniform1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_OPERATION</code> is generated if there is no current program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if the size of the uniform variable 
  declared in the shader does not match the size indicated by the <code>glUniform</code> command.
 <p><code>GL_INVALID_OPERATION</code> is generated if one of the integer variants of this 
  function is used to load a uniform variable of type float, vec2, vec3, vec4, or 
  an array of these, or if one of the floating-point variants of this function is 
  used to load a uniform variable of type int, ivec2, ivec3, or ivec4, or an array of these.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>location</code></i> is an invalid uniform location 
  for the current program object and <i><code>location</code></i> is not equal to -1.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>count</code></i> is less than 0.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>transpose</code></i> is not <code>GL_FALSE</code>.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>count</code></i> is greater than 1 
  and the indicated uniform variable is not an array variable.
 <p><code>GL_INVALID_OPERATION</code> is generated if a sampler is loaded using 
  a command other than <code>glUniform1i</code> and <code>glUniform1iv</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>location</CODE> - Specifies the location of the uniform value to be modified.<DD><CODE>count</CODE> - Specifies the number of matrices that are to be modified.<DD><CODE>transpose</CODE> - Specifies whether to transpose the matrix as the values are 
  loaded into the uniform variable. Must be <code>GL_FALSE</code>.<DD><CODE>value</CODE> - Specifies a buffer that will be used to update the specified uniform variable.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>value</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>value</i>.remaining()</code> is smaller than 16.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glUseProgram(int)"><!-- --></A><H3>
glUseProgram</H3>
<PRE>
void <B>glUseProgram</B>(int&nbsp;program)</PRE>
<DL>
<DD>Install a program object as part of current rendering state.
 <p> 
 <h4>Description</h4>
 <code>glUseProgram</code> installs the program object specified by 
 <i><code>program</code></i> as part of current rendering state. One or more 
 executables are created in a program object by successfully 
 attaching shader objects to it with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glAttachShader(int, int)"><CODE>glAttachShader</CODE></A>, 
 successfully compiling the shader objects with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>glCompileShader</CODE></A>, 
 and successfully linking the program object with <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>glLinkProgram</CODE></A>.
 <p>
 A program object will contain executables that will run on the 
 vertex and fragment processors if it contains one or more 
 shader objects of type <code>GL_VERTEX_SHADER</code> and one or more 
 shader objects of type <code>GL_FRAGMENT_SHADER</code> that have all been 
 successfully compiled and linked.
 <p>
 While a program object is in use, applications are free to modify 
 attached shader objects, compile attached shader objects, 
 attach additional shader objects, and detach or delete shader objects. 
 None of these operations will affect the executables that are 
 part of the current state. However, relinking the program object 
 that is currently in use will install the program object as part 
 of the current rendering state if the link operation was successful 
 (see <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>glLinkProgram</CODE></A>). If the program object currently in use is 
 relinked unsuccessfully, its link status will be set to <code>GL_FALSE</code>, 
 but the executables and associated state will remain part of the 
 current state until a subsequent call to <code>glUseProgram</code> removes 
 it from use. After it is removed from use, it cannot be made part 
 of current state until it has been successfully relinked.
 <p>
 If <i><code>program</code></i> is 0, then the current rendering state refers to an 
 invalid program object, and the results of vertex and fragment shader 
 execution due to any <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawArrays(int, int, int)"><CODE>glDrawArrays</CODE></A>
 or <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>glDrawElements</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)"><CODE>glDrawElements</CODE></A> commands are undefined. 
 <p> 
 <h4>Notes</h4> 
 <p> 
 Like texture objects and buffer objects, the name space for program 
 objects may be shared across a set of contexts, as long as the 
 server sides of the contexts share the same address space. 
 If the name space is shared across contexts, any attached objects 
 and the data associated with those attached objects are shared as well.
 <p>
 Applications are responsible for providing the synchronization 
 across API calls when objects are accessed from different execution threads. 
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is neither 0 nor a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> could not be made part of current state.
 <p> 
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with the argument <code>GL_CURRENT_PROGRAM</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveAttrib(int, int, int[], int, int[], int)"><CODE>glGetActiveAttrib</CODE></A>
  with a valid program object and the index of an active attribute variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveUniform(int, int, int[], int, int[], int)"><CODE>glGetActiveUniform</CODE></A>
  with a valid program object and the index of an active uniform variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, java.nio.IntBuffer, java.nio.IntBuffer)"><CODE>glGetAttachedShaders</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttachedShaders(int, int, int[], int, int[], int)"><CODE>glGetAttachedShaders</CODE></A> with a valid program object
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttribLocation(int, java.lang.String)"><CODE>glGetAttribLocation</CODE></A> with a valid program object and the name of an attribute variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A>
  with a valid program object and the parameter to be queried
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramInfoLog(int)"><CODE>glGetProgramInfoLog</CODE></A> with a valid program object
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, java.nio.FloatBuffer)"><CODE>glGetUniformfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformfv(int, int, int, float[], int)"><CODE>glGetUniformfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, java.nio.IntBuffer)"><CODE>glGetUniformiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformiv(int, int, int, int[], int)"><CODE>glGetUniformiv</CODE></A>
  with a valid program object and the location of a uniform variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetUniformLocation(int, java.lang.String)"><CODE>glGetUniformLocation</CODE></A>
  with a valid program object and the name of a uniform variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the handle of the program object whose 
  executables are to be used as part of current rendering state.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glAttachShader(int, int)"><CODE>GL20.glAttachShader(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindAttribLocation(int, int, java.lang.String)"><CODE>GL20.glBindAttribLocation(int, int, String)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCompileShader(int)"><CODE>GL20.glCompileShader(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glCreateProgram()"><CODE>GL20.glCreateProgram()</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDeleteProgram(int)"><CODE>GL20.glDeleteProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDetachShader(int, int)"><CODE>GL20.glDetachShader(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1f(int, float)"><CODE>GL20.glUniform1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform1fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1fv(int, int, float[], int)"><CODE>GL20.glUniform1fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1i(int, int)"><CODE>GL20.glUniform1i(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform1iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform1iv(int, int, int[], int)"><CODE>GL20.glUniform1iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2f(int, float, float)"><CODE>GL20.glUniform2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform2fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2fv(int, int, float[], int)"><CODE>GL20.glUniform2fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2i(int, int, int)"><CODE>GL20.glUniform2i(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform2iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform2iv(int, int, int[], int)"><CODE>GL20.glUniform2iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3f(int, float, float, float)"><CODE>GL20.glUniform3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform3fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3fv(int, int, float[], int)"><CODE>GL20.glUniform3fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3i(int, int, int, int)"><CODE>GL20.glUniform3i(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform3iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform3iv(int, int, int[], int)"><CODE>GL20.glUniform3iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4f(int, float, float, float, float)"><CODE>GL20.glUniform4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, java.nio.FloatBuffer)"><CODE>GL20.glUniform4fv(int, int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4fv(int, int, float[], int)"><CODE>GL20.glUniform4fv(int, int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4i(int, int, int, int, int)"><CODE>GL20.glUniform4i(int, int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, java.nio.IntBuffer)"><CODE>GL20.glUniform4iv(int, int, IntBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniform4iv(int, int, int[], int)"><CODE>GL20.glUniform4iv(int, int, int[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix2fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix2fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix2fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix3fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix3fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix3fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, java.nio.FloatBuffer)"><CODE>GL20.glUniformMatrix4fv(int, int, boolean, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUniformMatrix4fv(int, int, boolean, float[], int)"><CODE>GL20.glUniformMatrix4fv(int, int, boolean, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glValidateProgram(int)"><CODE>GL20.glValidateProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib1fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, float[], int)"><CODE>GL20.glVertexAttrib1fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2f(int, float, float)"><CODE>GL20.glVertexAttrib2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib2fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, float[], int)"><CODE>GL20.glVertexAttrib2fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3f(int, float, float, float)"><CODE>GL20.glVertexAttrib3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib3fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, float[], int)"><CODE>GL20.glVertexAttrib3fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4f(int, float, float, float, float)"><CODE>GL20.glVertexAttrib4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib4fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, float[], int)"><CODE>GL20.glVertexAttrib4fv(int, float[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glValidateProgram(int)"><!-- --></A><H3>
glValidateProgram</H3>
<PRE>
void <B>glValidateProgram</B>(int&nbsp;program)</PRE>
<DL>
<DD>Validate a program object.
 <p>
 <h4>Description</h4>
 <code>glValidateProgram</code> checks to see whether the executables 
 contained in <i><code>program</code></i> can execute given the current OpenGL state. 
 The information generated by the validation process will be stored 
 in <i><code>program</code></i>'s information log. The validation information may consist 
 of an empty string, or it may be a string containing information 
 about how the current program object interacts with the rest of current 
 OpenGL state. This provides a way for OpenGL implementers to convey more 
 information about why the current program is inefficient, suboptimal, 
 failing to execute, and so on.
 <p>
 The status of the validation operation will be stored as part of the 
 program object's state. This value will be set to <code>GL_TRUE</code> if the 
 validation succeeded, and <code>GL_FALSE</code> otherwise. It can be queried 
 by calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A> with arguments
 <i><code>program</code></i> and <code>GL_VALIDATE_STATUS</code>. 
 If validation is successful, <i><code>program</code></i> is guaranteed to execute 
 given the current state. Otherwise, <i><code>program</code></i> is guaranteed to not execute.
 <p>
 This function is typically useful only during application development. 
 The informational string stored in the information log is completely 
 implementation dependent; therefore, an application should not expect 
 different OpenGL implementations to produce identical information strings. 
 <p> 
 <h4>Notes</h4> 
 <p> 
 This function mimics the validation operation that OpenGL implementations 
 must perform when rendering commands are issued while programmable shaders 
 are part of current state. The error <code>GL_INVALID_OPERATION</code> will be generated 
 by <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawArrays(int, int, int)"><CODE>glDrawArrays</CODE></A> or 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>glDrawElements</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)"><CODE>glDrawElements</CODE></A> if:
 <ul><li><p>
 any two active samplers in the current program object are of different types, 
 but refer to the same texture image unit,
 </li><li><p>
 any active sampler in the current program object refers to a texture image 
 unit where fixed-function fragment processing accesses a texture target 
 that does not match the sampler type, or
 </li><li><p>
 the sum of the number of active samplers in the program and the number of 
 texture image units enabled for fixed-function fragment processing exceeds 
 the combined limit on the total number of texture image units allowed.
 </li></ul>
 <p>
 It may be difficult or cause a performance degradation for applications to 
 catch these errors when rendering commands are issued. 
 Therefore, applications are advised to make calls to <code>glValidateProgram</code> 
 to detect these issues during application development. 
 <p>
 <h4>Errors</h4> 
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>program</code></i> is not a value generated by OpenGL.
 <p><code>GL_INVALID_OPERATION</code> is generated if <i><code>program</code></i> is not a program object.
 <p> 
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, java.nio.IntBuffer)"><CODE>glGetProgramiv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramiv(int, int, int[], int)"><CODE>glGetProgramiv</CODE></A>
  with arguments <i><code>program</code></i> and <code>GL_VALIDATE_STATUS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetProgramInfoLog(int)"><CODE>glGetProgramInfoLog</CODE></A> with argument <i><code>program</code></i>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glIsProgram(int)"><CODE>glIsProgram</CODE></A>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>program</CODE> - Specifies the handle of the program object to be validated.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glLinkProgram(int)"><CODE>GL20.glLinkProgram(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glUseProgram(int)"><CODE>GL20.glUseProgram(int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glVertexAttrib1f(int, float)"><!-- --></A><H3>
glVertexAttrib1f</H3>
<PRE>
void <B>glVertexAttrib1f</B>(int&nbsp;index,
                      float&nbsp;x)</PRE>
<DL>
<DD>Specify the value of a generic vertex attribute.
 <p>
 <h4>Description</h4>
 The <code>glVertexAttrib</code> family of entry points allows an application 
 to pass generic vertex attributes in numbered locations.
 <p>
 Generic attributes are defined as four-component values that are
 organized into an array. The first entry of this array is 
 numbered 0, and the size of the array is specified by the 
 implementation-dependent symbolic constant <code>GL_MAX_VERTEX_ATTRIBS</code>. 
 Individual elements of this array can be modified with 
 a <code>glVertexAttrib</code> call that specifies the index of the 
 element to be modified and a value for that element.
 <p>
 These commands can be used to specify one, two, three, 
 or all four components of the generic vertex attribute 
 specified by <i><code>index</code></i>. A <code>1</code> in the name of the command indicates 
 that only one value is passed, and it will be used to modify 
 the first component of the generic vertex attribute. 
 The second and third components will be set to 0, and 
 the fourth component will be set to 1. Similarly, a <code>2</code> 
 in the name of the command indicates that values are 
 provided for the first two components, the third component 
 will be set to 0, and the fourth component will be set to 1. 
 A <code>3</code> in the name of the command indicates that values are 
 provided for the first three components and the fourth 
 component will be set to 1, whereas a <code>4</code> in the name 
 indicates that values are provided for all four components.
 <p>
 The letter <code>f</code> indicates that the arguments are of type float. 
 When <code>v</code> is appended to the name, the commands can take an array of floats.
 <p>
 OpenGL ES Shading Language attribute variables are allowed 
 to be of type mat2, mat3, or mat4. Attributes of these types 
 may be loaded using the <code>glVertexAttrib</code> entry points. 
 Matrices must be loaded into successive generic attribute 
 slots in column major order, with one column of the matrix 
 in each generic attribute slot.
 <p>
 A user-defined attribute variable declared in a vertex shader 
 can be bound to a generic attribute index by 
 calling <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindAttribLocation(int, int, java.lang.String)"><CODE>glBindAttribLocation</CODE></A>. This allows an application to 
 use descriptive variable names in a vertex shader. 
 A subsequent change to the specified generic vertex attribute 
 will be immediately reflected as a change to the corresponding 
 attribute variable in the vertex shader.
 <p>
 The binding between a generic vertex attribute index and a 
 user-defined attribute variable in a vertex shader is part of 
 the state of a program object, but the current value of the 
 generic vertex attribute is not. The value of each generic 
 vertex attribute is part of current state and it is 
 maintained even if a different program object is used.
 <p>
 An application may freely modify generic vertex attributes 
 that are not bound to a named vertex shader attribute variable. 
 These values are simply maintained as part of current state and 
 will not be accessed by the vertex shader. If a generic vertex 
 attribute bound to an attribute variable in a vertex shader is 
 not updated while the vertex shader is executing, the vertex shader 
 will repeatedly use the current value for the generic vertex attribute. 
 <p> 
 <h4>Notes</h4> 
 <p> 
 It is possible for an application to bind more than one attribute 
 name to the same generic vertex attribute index. This is referred 
 to as aliasing, and it is allowed only if just one of the aliased
 attribute variables is active in the vertex shader, or if no path 
 through the vertex shader consumes more than one of the attributes 
 aliased to the same location. OpenGL implementations are not 
 required to do error checking to detect aliasing, they are allowed 
 to assume that aliasing will not occur, and they are allowed to 
 employ optimizations that work only in the absence of aliasing. 
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p> 
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with the argument <code>GL_CURRENT_PROGRAM</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetActiveAttrib(int, int, int[], int, int[], int)"><CODE>glGetActiveAttrib</CODE></A>
  with argument <i><code>program</code></i> and the index of an active attribute variable
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetAttribLocation(int, java.lang.String)"><CODE>glGetAttribLocation</CODE></A>
  with argument <i><code>program</code></i> and an attribute variable name
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, java.nio.FloatBuffer)"><CODE>glGetVertexAttribfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, float[], int)"><CODE>glGetVertexAttribfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><CODE>glGetVertexAttribiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>glGetVertexAttribiv</CODE></A>
  with arguments <code>GL_CURRENT_VERTEX_ATTRIB</code> and <i><code>index</code></i>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be modified.<DD><CODE>x</CODE> - Specifies the new value to be used for the specified vertex attribute.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindAttribLocation(int, int, java.lang.String)"><CODE>GL20.glBindAttribLocation(int, int, String)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, int)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glVertexAttrib1fv(int, float[], int)"><!-- --></A><H3>
glVertexAttrib1fv</H3>
<PRE>
void <B>glVertexAttrib1fv</B>(int&nbsp;index,
                       float[]&nbsp;values,
                       int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point 1 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be modified.<DD><CODE>values</CODE> - Specifies an array of values to be used for the generic vertex attribute.<DD><CODE>offset</CODE> - The starting offset within the <i><code>values</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>values</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>values</i>.length - <i>offset</i></code> is smaller than 1.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glVertexAttrib1fv(int, java.nio.FloatBuffer)"><!-- --></A><H3>
glVertexAttrib1fv</H3>
<PRE>
void <B>glVertexAttrib1fv</B>(int&nbsp;index,
                       <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;values)</PRE>
<DL>
<DD>Floating-point 1 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p> 
 <code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be modified.<DD><CODE>values</CODE> - Specifies an array of values to be used for the generic vertex attribute.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>values</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>values</i>.remaining()</code> is smaller than 1.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glVertexAttrib2f(int, float, float)"><!-- --></A><H3>
glVertexAttrib2f</H3>
<PRE>
void <B>glVertexAttrib2f</B>(int&nbsp;index,
                      float&nbsp;x,
                      float&nbsp;y)</PRE>
<DL>
<DD>Floating-point 2 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be modified.<DD><CODE>x</CODE> - Specifies the new value to be used for the specified vertex attribute.<DD><CODE>y</CODE> - Specifies the new value to be used for the specified vertex attribute.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glVertexAttrib2fv(int, float[], int)"><!-- --></A><H3>
glVertexAttrib2fv</H3>
<PRE>
void <B>glVertexAttrib2fv</B>(int&nbsp;index,
                       float[]&nbsp;values,
                       int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point 2 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be modified.<DD><CODE>values</CODE> - Specifies an array of values to be used for the generic vertex attribute.<DD><CODE>offset</CODE> - The starting offset within the <i><code>values</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>values</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>values</i>.length - <i>offset</i></code> is smaller than 2.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glVertexAttrib2fv(int, java.nio.FloatBuffer)"><!-- --></A><H3>
glVertexAttrib2fv</H3>
<PRE>
void <B>glVertexAttrib2fv</B>(int&nbsp;index,
                       <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;values)</PRE>
<DL>
<DD>Floating-point 2 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p> 
 <code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be modified.<DD><CODE>values</CODE> - Specifies an array of values to be used for the generic vertex attribute.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>values</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>values</i>.remaining()</code> is smaller than 2.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glVertexAttrib3f(int, float, float, float)"><!-- --></A><H3>
glVertexAttrib3f</H3>
<PRE>
void <B>glVertexAttrib3f</B>(int&nbsp;index,
                      float&nbsp;x,
                      float&nbsp;y,
                      float&nbsp;z)</PRE>
<DL>
<DD>Floating-point 3 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be modified.<DD><CODE>x</CODE> - Specifies the new value to be used for the specified vertex attribute.<DD><CODE>y</CODE> - Specifies the new value to be used for the specified vertex attribute.<DD><CODE>z</CODE> - Specifies the new value to be used for the specified vertex attribute.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glVertexAttrib3fv(int, float[], int)"><!-- --></A><H3>
glVertexAttrib3fv</H3>
<PRE>
void <B>glVertexAttrib3fv</B>(int&nbsp;index,
                       float[]&nbsp;values,
                       int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point 3 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be modified.<DD><CODE>values</CODE> - Specifies an array of values to be used for the generic vertex attribute.<DD><CODE>offset</CODE> - The starting offset within the <i><code>values</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>values</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>values</i>.length - <i>offset</i></code> is smaller than 3.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glVertexAttrib3fv(int, java.nio.FloatBuffer)"><!-- --></A><H3>
glVertexAttrib3fv</H3>
<PRE>
void <B>glVertexAttrib3fv</B>(int&nbsp;index,
                       <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;values)</PRE>
<DL>
<DD>Floating-point 3 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p> 
 <code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be modified.<DD><CODE>values</CODE> - Specifies an array of values to be used for the generic vertex attribute.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>values</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>values</i>.remaining()</code> is smaller than 3.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glVertexAttrib4f(int, float, float, float, float)"><!-- --></A><H3>
glVertexAttrib4f</H3>
<PRE>
void <B>glVertexAttrib4f</B>(int&nbsp;index,
                      float&nbsp;x,
                      float&nbsp;y,
                      float&nbsp;z,
                      float&nbsp;w)</PRE>
<DL>
<DD>Floating-point 4 value version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be modified.<DD><CODE>x</CODE> - Specifies the new value to be used for the specified vertex attribute.<DD><CODE>y</CODE> - Specifies the new value to be used for the specified vertex attribute.<DD><CODE>z</CODE> - Specifies the new value to be used for the specified vertex attribute.<DD><CODE>w</CODE> - Specifies the new value to be used for the specified vertex attribute.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glVertexAttrib4fv(int, float[], int)"><!-- --></A><H3>
glVertexAttrib4fv</H3>
<PRE>
void <B>glVertexAttrib4fv</B>(int&nbsp;index,
                       float[]&nbsp;values,
                       int&nbsp;offset)</PRE>
<DL>
<DD>Floating-point 4 value array version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be modified.<DD><CODE>values</CODE> - Specifies an array of values to be used for the generic vertex attribute.<DD><CODE>offset</CODE> - The starting offset within the <i><code>values</code></i> array.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>values</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>offset</code></i> is less than 0.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>values</i>.length - <i>offset</i></code> is smaller than 4.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glVertexAttrib4fv(int, java.nio.FloatBuffer)"><!-- --></A><H3>
glVertexAttrib4fv</H3>
<PRE>
void <B>glVertexAttrib4fv</B>(int&nbsp;index,
                       <A HREF="../../../../../java/nio/FloatBuffer.html" title="class in java.nio">FloatBuffer</A>&nbsp;values)</PRE>
<DL>
<DD>Floating-point 4 value <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio"><CODE>Buffer</CODE></A> version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A>. 
 <p> 
 See <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>glVertexAttrib1f</CODE></A> for documentation.
 <p> 
 <h4>Errors</h4> 
 <p> 
 <code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is 
  greater than or equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be modified.<DD><CODE>values</CODE> - Specifies an array of values to be used for the generic vertex attribute.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <i><code>values</code></i> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If <code><i>values</i>.remaining()</code> is smaller than 4.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><!-- --></A><H3>
glVertexAttribPointer</H3>
<PRE>
void <B>glVertexAttribPointer</B>(int&nbsp;index,
                           int&nbsp;size,
                           int&nbsp;type,
                           boolean&nbsp;normalized,
                           int&nbsp;stride,
                           <A HREF="../../../../../java/nio/Buffer.html" title="class in java.nio">Buffer</A>&nbsp;data)</PRE>
<DL>
<DD>Define an array of generic vertex attribute data.
 <p>
 <h4>Description</h4>
 <code>glVertexAttribPointer</code> specifies the location and data format of the 
 array of generic vertex attributes at index <i><code>index</code></i> to use when rendering. 
 <i><code>size</code></i> specifies the number of components per attribute and must 
 be 1, 2, 3, or 4. <i><code>type</code></i> specifies the data type of each component, 
 and <i><code>stride</code></i> specifies the byte stride from one attribute to the next, 
 allowing vertices and attributes to be packed into a single array or 
 stored in separate arrays. If set to <code>true</code>, <i><code>normalized</code></i> indicates 
 that values stored in an integer format are to be mapped to the 
 range <code>[-1, 1]</code> (for signed values) or <code>[0, 1]</code> (for unsigned values) 
 when they are accessed and converted to floating point. Otherwise, 
 values will be converted to floats directly without normalization.
 <p>
 When a generic vertex attribute array is specified, <i><code>size</code></i>, 
 <i><code>type</code></i>, <i><code>normalized</code></i>, <i><code>stride</code></i>, and 
 <i><code>data</code></i> are saved as client-side 
 state, in addition to the current vertex array buffer object binding.
 <p>
 To enable and disable a generic vertex attribute array, 
 call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnableVertexAttribArray(int)"><CODE>glEnableVertexAttribArray</CODE></A> and
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisableVertexAttribArray(int)"><CODE>glDisableVertexAttribArray</CODE></A> 
 with <i><code>index</code></i>. If enabled, the generic vertex attribute array is 
 used when <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawArrays(int, int, int)"><CODE>glDrawArrays</CODE></A> or 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>glDrawElements</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)"><CODE>glDrawElements</CODE></A> is called. 
 <p> 
 <h4>Notes</h4> 
 <p> 
 Each generic vertex attribute array is initially disabled and 
 isn't accessed when <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>glDrawElements</CODE></A>/
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)"><CODE>glDrawElements</CODE></A> or 
 <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawArrays(int, int, int)"><CODE>glDrawArrays</CODE></A> is called.
 <p> 
 <code>glVertexAttribPointer</code> is typically implemented on the client side. 
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>type</code></i> is not an accepted value.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is greater than or 
  equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>size</code></i> is not 1, 2, 3, or 4.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>stride</code></i> is negative.
 <p>
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_MAX_VERTEX_ATTRIBS</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, java.nio.FloatBuffer)"><CODE>glGetVertexAttribfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, float[], int)"><CODE>glGetVertexAttribfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><CODE>glGetVertexAttribiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>glGetVertexAttribiv</CODE></A>
  with arguments <i><code>index</code></i> and <code>GL_VERTEX_ATTRIB_ARRAY_ENABLED</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, java.nio.FloatBuffer)"><CODE>glGetVertexAttribfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, float[], int)"><CODE>glGetVertexAttribfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><CODE>glGetVertexAttribiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>glGetVertexAttribiv</CODE></A>
  with arguments <i><code>index</code></i> and <code>GL_VERTEX_ATTRIB_ARRAY_SIZE</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, java.nio.FloatBuffer)"><CODE>glGetVertexAttribfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, float[], int)"><CODE>glGetVertexAttribfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><CODE>glGetVertexAttribiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>glGetVertexAttribiv</CODE></A>
  with arguments <i><code>index</code></i> and <code>GL_VERTEX_ATTRIB_ARRAY_TYPE</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, java.nio.FloatBuffer)"><CODE>glGetVertexAttribfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, float[], int)"><CODE>glGetVertexAttribfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><CODE>glGetVertexAttribiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>glGetVertexAttribiv</CODE></A>
  with arguments <i><code>index</code></i> and <code>GL_VERTEX_ATTRIB_ARRAY_NORMALIZED</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, java.nio.FloatBuffer)"><CODE>glGetVertexAttribfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, float[], int)"><CODE>glGetVertexAttribfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><CODE>glGetVertexAttribiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>glGetVertexAttribiv</CODE></A>
  with arguments <i><code>index</code></i> and <code>GL_VERTEX_ATTRIB_ARRAY_STRIDE</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, java.nio.FloatBuffer)"><CODE>glGetVertexAttribfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribfv(int, int, float[], int)"><CODE>glGetVertexAttribfv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, java.nio.IntBuffer)"><CODE>glGetVertexAttribiv</CODE></A>/
  <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetVertexAttribiv(int, int, int[], int)"><CODE>glGetVertexAttribiv</CODE></A>
  with arguments <i><code>index</code></i> and <code>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_ARRAY_BUFFER_BINDING</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be modified.<DD><CODE>size</CODE> - Specifies the number of components per generic vertex attribute. 
  Must be 1, 2, 3, or 4. The initial value is 4.<DD><CODE>type</CODE> - Specifies the data type of each component in the array. 
  Symbolic constants <code>GL_BYTE</code>, <code>GL_UNSIGNED_BYTE</code>, <code>GL_SHORT</code>, <code>GL_UNSIGNED_SHORT</code>, 
  <code>GL_FIXED</code>, or <code>GL_FLOAT</code> are accepted. The initial value is <code>GL_FLOAT</code>.<DD><CODE>normalized</CODE> - Specifies whether fixed-point data values should be 
  normalized (<code>GL_TRUE</code>) or converted directly as fixed-point values (<code>GL_FALSE</code>) 
  when they are accessed.<DD><CODE>stride</CODE> - Specifies the byte offset between consecutive generic vertex 
  attributes. If <i><code>stride</code></i> is 0, the generic vertex attributes are understood 
  to be tightly packed in the array. The initial value is 0.<DD><CODE>data</CODE> - Specifies the generic vertex attribute data as a buffer.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - if <code>data</code> is <code>null</code>.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - if <code>data</code> is not a direct buffer.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindAttribLocation(int, int, java.lang.String)"><CODE>GL20.glBindAttribLocation(int, int, String)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>GL20.glBindBuffer(int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDisableVertexAttribArray(int)"><CODE>GL20.glDisableVertexAttribArray(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawArrays(int, int, int)"><CODE>GL20.glDrawArrays(int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, java.nio.Buffer)"><CODE>GL20.glDrawElements(int, int, int, Buffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDrawElements(int, int, int, int)"><CODE>GL20.glDrawElements(int, int, int, int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glEnableVertexAttribArray(int)"><CODE>GL20.glEnableVertexAttribArray(int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1f(int, float)"><CODE>GL20.glVertexAttrib1f(int, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib1fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib1fv(int, float[], int)"><CODE>GL20.glVertexAttrib1fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2f(int, float, float)"><CODE>GL20.glVertexAttrib2f(int, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib2fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib2fv(int, float[], int)"><CODE>GL20.glVertexAttrib2fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3f(int, float, float, float)"><CODE>GL20.glVertexAttrib3f(int, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib3fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib3fv(int, float[], int)"><CODE>GL20.glVertexAttrib3fv(int, float[], int)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4f(int, float, float, float, float)"><CODE>GL20.glVertexAttrib4f(int, float, float, float, float)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, java.nio.FloatBuffer)"><CODE>GL20.glVertexAttrib4fv(int, FloatBuffer)</CODE></A>, 
<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttrib4fv(int, float[], int)"><CODE>GL20.glVertexAttrib4fv(int, float[], int)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glVertexAttribPointer(int, int, int, boolean, int, int)"><!-- --></A><H3>
glVertexAttribPointer</H3>
<PRE>
void <B>glVertexAttribPointer</B>(int&nbsp;index,
                           int&nbsp;size,
                           int&nbsp;type,
                           boolean&nbsp;normalized,
                           int&nbsp;stride,
                           int&nbsp;offset)</PRE>
<DL>
<DD>VBO version of <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><CODE>glVertexAttribPointer</CODE></A>.
 <p>
 <b>Note:</b> <i><code>offset</code></i> specifies a byte offset into the currently bound buffer object's data
 store where the generic vertex attributes are stored (a non-zero named buffer object must be bound to
 the <code>GL_ARRAY_BUFFER</code> target (see <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glBindBuffer(int, int)"><CODE>glBindBuffer</CODE></A>)).
 Also, the buffer object binding (<code>GL_ARRAY_BUFFER_BINDING</code>) is saved as generic vertex attribute 
 array client-side state (<code>GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING</code>) 
 for index <i><code>index</code></i>.
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_ENUM</code> is generated if <i><code>type</code></i> is not an accepted value.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>index</code></i> is greater than or 
  equal to <code>GL_MAX_VERTEX_ATTRIBS</code>.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>size</code></i> is not 1, 2, 3, or 4.
 <p><code>GL_INVALID_VALUE</code> is generated if <i><code>stride</code></i> is negative.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Specifies the index of the generic vertex attribute to be modified.<DD><CODE>size</CODE> - Specifies the number of components per generic vertex attribute. 
  Must be 1, 2, 3, or 4. The initial value is 4.<DD><CODE>type</CODE> - Specifies the data type of each component in the array. 
  Symbolic constants <code>GL_BYTE</code>, <code>GL_UNSIGNED_BYTE</code>, <code>GL_SHORT</code>, <code>GL_UNSIGNED_SHORT</code>, 
  <code>GL_FIXED</code>, or <code>GL_FLOAT</code> are accepted. The initial value is <code>GL_FLOAT</code>.<DD><CODE>normalized</CODE> - Specifies whether fixed-point data values should be 
  normalized (<code>GL_TRUE</code>) or converted directly as fixed-point values (<code>GL_FALSE</code>) 
  when they are accessed.<DD><CODE>stride</CODE> - Specifies the byte offset between consecutive generic vertex 
  attributes. If <i><code>stride</code></i> is 0, the generic vertex attributes are understood 
  to be tightly packed in the array. The initial value is 0.<DD><CODE>offset</CODE> - Specifies the byte offset into the currently bound buffer object's data store.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</A></CODE> - If VBOs are not enabled.
<DD><CODE><A HREF="../../../../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</A></CODE> - If
             <i><code>offset</code></i> is less than 0 or greater than
             or equal to the length of the currently bound buffer.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glVertexAttribPointer(int, int, int, boolean, int, java.nio.Buffer)"><CODE>GL20.glVertexAttribPointer(int, int, int, boolean, int, Buffer)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="glViewport(int, int, int, int)"><!-- --></A><H3>
glViewport</H3>
<PRE>
void <B>glViewport</B>(int&nbsp;x,
                int&nbsp;y,
                int&nbsp;width,
                int&nbsp;height)</PRE>
<DL>
<DD>Set the viewport.
 <p>
 <h4>Description</h4>
 <code>glViewport</code> specifies the affine transformation of x and y from normalized device 
 coordinates to window coordinates. Let <code>(x_nd, y_nd)</code> be normalized device coordinates. 
 Then the window coordinates <code>(x_w, y_w)</code> are computed as follows:
 <p>
 <code>x_w = (x_nd + 1)(width/2) + x</code>
 <p>
 <code>y_w = (y_nd + 1)(height/2) + y</code>
 <p>
 Viewport width and height are silently clamped to a range that 
 depends on the implementation. To query this range, 
 call <A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
 with argument <code>GL_MAX_VIEWPORT_DIMS</code>. 
 <p> 
 <h4>Errors</h4> 
 <p><code>GL_INVALID_VALUE</code> is generated if either <i><code>width</code></i> or <i><code>height</code></i> is negative.
 <p> 
 <h4>Associated Gets</h4> 
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_VIEWPORT</code>
 <p><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, java.nio.IntBuffer)"><CODE>glGetIntegerv</CODE></A>/<A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glGetIntegerv(int, int[], int)"><CODE>glGetIntegerv</CODE></A>
  with argument <code>GL_MAX_VIEWPORT_DIMS</code>
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Specifies the x coordinate of the lower left corner of the viewport rectangle, in pixels. 
  The initial value is 0.<DD><CODE>y</CODE> - Specifies the y coordinate of the lower left corner of the viewport rectangle, in pixels. 
  The initial value is 0.<DD><CODE>width</CODE> - Specifies the width of the viewport. 
  When a GL context is first attached to a window, <i><code>width</code></i> is set to the width of that window.<DD><CODE>height</CODE> - Specifies the height of the viewport. 
  When a GL context is first attached to a window, <i><code>height</code></i> is set to the height of that window.<DT><B>See Also:</B><DD><A HREF="../../../../../net/rim/device/api/opengles/GL20.html#glDepthRangef(float, float)"><CODE>GL20.glDepthRangef(float, float)</CODE></A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>

<BR>

<BR>
<FORM action="https://www.blackberry.com/DocsFeedback/" method="GET" target="_new">
<INPUT type="hidden" name="title" value="API Reference">
<INPUT type="hidden" name="source" value="External">
<INPUT type="hidden" name="version" value="7.1.0">
<INPUT type="hidden" name="classname" value="net.rim.device.api.opengles.GL20">
<INPUT type="submit" value="Submit Feedback" /></FORM>

<BR>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../../../net/rim/device/api/opengles/GLField.html" title="class in net.rim.device.api.opengles"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?net/rim/device/api/opengles/GL20.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GL20.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size=-1><p>Copyright 1999-2011 Research In Motion Limited.  295 Phillip Street, Waterloo, Ontario, Canada, N2L 3W8.  All Rights Reserved.<br>Java is a trademark of Oracle America Inc. in the US and other countries.<br><a target='_blank' href='http://www.blackberry.com/legal'>Legal</a></p></font>
</BODY>
</HTML>
