<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_04) on Thu Nov 24 17:43:27 EST 2011 -->
<TITLE>
Graphics (BlackBerry JDE 7.1.0 API Reference)
</TITLE>

<META NAME="keywords" CONTENT="net.rim.device.api.ui.Graphics class">
<META NAME="keywords" CONTENT="BLACK">
<META NAME="keywords" CONTENT="WHITE">
<META NAME="keywords" CONTENT="FULL_BLACK">
<META NAME="keywords" CONTENT="FULL_WHITE">
<META NAME="keywords" CONTENT="ROP_SRC_COPY">
<META NAME="keywords" CONTENT="ROP_SRCMONOEXPAND_COPY">
<META NAME="keywords" CONTENT="ROP_SRC_ALPHA">
<META NAME="keywords" CONTENT="ROP_SRCMONOEXPAND_ALPHA">
<META NAME="keywords" CONTENT="ROP_CONST_GLOBALALPHA">
<META NAME="keywords" CONTENT="ROP_SRC_GLOBALALPHA">
<META NAME="keywords" CONTENT="ROP_SRC_ALPHA_GLOBALALPHA">
<META NAME="keywords" CONTENT="ROP2_0">
<META NAME="keywords" CONTENT="ROP2_DSon">
<META NAME="keywords" CONTENT="ROP2_DSna">
<META NAME="keywords" CONTENT="ROP2_Sn">
<META NAME="keywords" CONTENT="ROP2_SDna">
<META NAME="keywords" CONTENT="ROP2_Dn">
<META NAME="keywords" CONTENT="ROP2_DSx">
<META NAME="keywords" CONTENT="ROP2_DSan">
<META NAME="keywords" CONTENT="ROP2_DSa">
<META NAME="keywords" CONTENT="ROP2_DSxn">
<META NAME="keywords" CONTENT="ROP2_D">
<META NAME="keywords" CONTENT="ROP2_DSno">
<META NAME="keywords" CONTENT="ROP2_S">
<META NAME="keywords" CONTENT="ROP2_SDno">
<META NAME="keywords" CONTENT="ROP2_DSo">
<META NAME="keywords" CONTENT="ROP2_1">
<META NAME="keywords" CONTENT="DRAWSTYLE_AALINES">
<META NAME="keywords" CONTENT="DRAWSTYLE_AAPOLYGONS">
<META NAME="keywords" CONTENT="DRAWSTYLE_ANTIALIASED">
<META NAME="keywords" CONTENT="DRAWSTYLE_FOCUS">
<META NAME="keywords" CONTENT="DRAWSTYLE_SELECT">
<META NAME="keywords" CONTENT="CURVEDPATH_END_POINT">
<META NAME="keywords" CONTENT="CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT">
<META NAME="keywords" CONTENT="CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT">
<META NAME="keywords" CONTENT="NO_ROUNDED_RECT_CORNERS">
<META NAME="keywords" CONTENT="TOP_LEFT_ROUNDED_RECT_CORNER">
<META NAME="keywords" CONTENT="TOP_RIGHT_ROUNDED_RECT_CORNER">
<META NAME="keywords" CONTENT="BOTTOM_LEFT_ROUNDED_RECT_CORNER">
<META NAME="keywords" CONTENT="BOTTOM_RIGHT_ROUNDED_RECT_CORNER">
<META NAME="keywords" CONTENT="TOP_ROUNDED_RECT_CORNERS">
<META NAME="keywords" CONTENT="BOTTOM_ROUNDED_RECT_CORNERS">
<META NAME="keywords" CONTENT="LEFT_ROUNDED_RECT_CORNERS">
<META NAME="keywords" CONTENT="RIGHT_ROUNDED_RECT_CORNERS">
<META NAME="keywords" CONTENT="ALL_ROUNDED_RECT_CORNERS">
<META NAME="keywords" CONTENT="SCREEN_HAS_BORDER">
<META NAME="keywords" CONTENT="create()">
<META NAME="keywords" CONTENT="clear()">
<META NAME="keywords" CONTENT="copyArea()">
<META NAME="keywords" CONTENT="drawARGB()">
<META NAME="keywords" CONTENT="drawArc()">
<META NAME="keywords" CONTENT="drawEllipse()">
<META NAME="keywords" CONTENT="isRopSupported()">
<META NAME="keywords" CONTENT="rop()">
<META NAME="keywords" CONTENT="tileRop()">
<META NAME="keywords" CONTENT="drawBitmap()">
<META NAME="keywords" CONTENT="drawImage()">
<META NAME="keywords" CONTENT="drawFilledPath()">
<META NAME="keywords" CONTENT="drawShadedFilledPath()">
<META NAME="keywords" CONTENT="drawPathOutline()">
<META NAME="keywords" CONTENT="drawOutlinedPath()">
<META NAME="keywords" CONTENT="drawTexturedPath()">
<META NAME="keywords" CONTENT="drawTextOnPath()">
<META NAME="keywords" CONTENT="drawLine()">
<META NAME="keywords" CONTENT="drawPoint()">
<META NAME="keywords" CONTENT="drawRect()">
<META NAME="keywords" CONTENT="drawRoundRect()">
<META NAME="keywords" CONTENT="drawRGB()">
<META NAME="keywords" CONTENT="drawText()">
<META NAME="keywords" CONTENT="fillArc()">
<META NAME="keywords" CONTENT="fillEllipse()">
<META NAME="keywords" CONTENT="fillRect()">
<META NAME="keywords" CONTENT="fillRoundRect()">
<META NAME="keywords" CONTENT="getAbsoluteClippingRect()">
<META NAME="keywords" CONTENT="getBackgroundColor()">
<META NAME="keywords" CONTENT="getClippingRect()">
<META NAME="keywords" CONTENT="getContextStackSize()">
<META NAME="keywords" CONTENT="getColor()">
<META NAME="keywords" CONTENT="getDrawingOffset()">
<META NAME="keywords" CONTENT="getGlobalAlpha()">
<META NAME="keywords" CONTENT="getNearestColor()">
<META NAME="keywords" CONTENT="getNumColors()">
<META NAME="keywords" CONTENT="getStipple()">
<META NAME="keywords" CONTENT="getFont()">
<META NAME="keywords" CONTENT="getScreenHeight()">
<META NAME="keywords" CONTENT="getScreenHorizontalResolution()">
<META NAME="keywords" CONTENT="getScreenVerticalResolution()">
<META NAME="keywords" CONTENT="getScreenWidth()">
<META NAME="keywords" CONTENT="invert()">
<META NAME="keywords" CONTENT="popContext()">
<META NAME="keywords" CONTENT="pushRegion()">
<META NAME="keywords" CONTENT="pushContext()">
<META NAME="keywords" CONTENT="translate()">
<META NAME="keywords" CONTENT="getTranslateX()">
<META NAME="keywords" CONTENT="getTranslateY()">
<META NAME="keywords" CONTENT="isDrawingStyleSet()">
<META NAME="keywords" CONTENT="setDrawingStyle()">
<META NAME="keywords" CONTENT="setColor()">
<META NAME="keywords" CONTENT="setGlobalAlpha()">
<META NAME="keywords" CONTENT="setStipple()">
<META NAME="keywords" CONTENT="setBackgroundColor()">
<META NAME="keywords" CONTENT="setFont()">
<META NAME="keywords" CONTENT="isColor()">
<META NAME="keywords" CONTENT="drawGradientFilledRect()">
<META NAME="keywords" CONTENT="drawGradientFilledRoundedRect()">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Graphics (BlackBerry JDE 7.1.0 API Reference)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<SCRIPT SRC="../../../../../script.js" TYPE="text/javascript"></SCRIPT>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../net/rim/device/api/ui/FontSpec.html" title="class in net.rim.device.api.ui"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../net/rim/device/api/ui/Keypad.html" title="class in net.rim.device.api.ui"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?net/rim/device/api/ui/Graphics.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Graphics.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<FORM action="https://www.blackberry.com/DocsFeedback/" method="GET" target="_new">
<INPUT type="hidden" name="title" value="API Reference">
<INPUT type="hidden" name="source" value="External">
<INPUT type="hidden" name="version" value="7.1.0">
<INPUT type="hidden" name="classname" value="net.rim.device.api.ui.Graphics">
<INPUT type="submit" value="Submit Feedback" /></FORM>

<BR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
net.rim.device.api.ui</FONT>
<BR>
Class Graphics</H2>
<PRE>
<A HREF="../../../../../java/lang/Object.html" title="class in java.lang">java.lang.Object</A>
  <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><B>net.rim.device.api.ui.Graphics</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html" title="interface in net.rim.device.api.ui">DrawStyle</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Graphics</B><DT>extends <A HREF="../../../../../java/lang/Object.html" title="class in java.lang">Object</A><DT>implements <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html" title="interface in net.rim.device.api.ui">DrawStyle</A></DL>
</PRE>

<P>
Provides a surface on which applications can draw.

 <p> A graphics object encapsulates the state information needed for basic
 rendering operations, making it accessible to applications (for example, the
 current font, and drawing color).

 <p> <em>Example</em>
 <pre>
 g = getGraphics();
 // draw here
 pushContext(...);
 draw(g);
 popContext();

 draw(Graphics g) {
 // draw or fill various objects
 // might {push, recurse paint(), pop}
 }
 </pre>

 <p><strong>The context stack</strong><br/>
 Typically your application maintains one graphics object for each screen it
 must present to the user. Each manager controlled by the screen uses that
 graphics object to handle the layout and painting of each field the manager
 contains.

 <p> To accomodate this model, the graphics object maintains an internal
 <em>context stack</em>. Each stack element contains the following information
 about the current drawing context:

 <ul>
     <li>Clipping region</li>
     <li>Offset position</li>
     <li>Foreground color</li>
     <li>Global alpha</li>
     <li>Background color</li>
     <li>Stippling pattern</li>
     <li>Draw style flags</li>
     <li>Stroke width</li>
     <li>Stroke style</li>
 </ul>

 <p> Typically, a field's manager pushes a transform on the stack that
 describes the field's extent as the clipping region, and a drawing offset to
 position drawing. Then it hands the graphics object to the field
 when it requests the field to update itself.

 <p> Each transform pushed onto the stack describes the transform in terms of
 the parent coordinates, so that each draw operation can be done using local
 coordinates and translated back through the stack to finally appear on the
 appropriate location of the screen.

 <p><strong>The drawing anchor</strong><br/>
 When you use one of this class's methods to draw an object, or text, you must
 set the <em>drawing anchor</em>. This anchor describes the pixel in the
 drawing region where the invoked method begins to draw. The coordinate system
 for the drawing anchor assumes that the top left pixel in the region is
 coordinate <code>0,0</code>.

 <p> The drawing anchor is not persistent. Each time you call one of these
 methods, you must provide a position for the anchor, and if maintaining
 information about relative positions of the anchor is important, then your
 code must do that.

 <p><strong>What happens to clipped objects</strong><br/>
 When you draw an object and the size of that object would have a portion of
 it fall outside the clipping region, then those portions are clipped off
 (i.e. the object or text is cropped to fit the clipping region).

 <p><b>Drawing rectangles with rounded corners</b><br>
 You have a variety of methods for drawing rects with rounded corners. This
 class identifies each logical corner with an associated static bitmask
 constant with a name ending in _ROUNDED_RECT_CORNER, and this class also
 provides pre-combined mask constants representing groups of corners (with
 names ending in _ROUNDED_RECT_CORNERS). Combine these constants together to
 pass to one of the appropriate draw methods
 (such as <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRoundedRect(net.rim.device.api.ui.XYRect, int, int, int, int)"><CODE>Graphics.drawGradientFilledRoundedRect(net.rim.device.api.ui.XYRect, int, int, int, int)</CODE></A>), identifying which of
 the rect's corners should render as rounded, and which should render as
 squared off.

 <p><strong>Drawing text</strong><br/>
 The Graphics class provides a variety of <code>drawText</code> methods to
 render text on the drawing surface. There are several versions of
 drawText, taking single characters and various text classes. The most general
 take a drawing anchor (x and y coordinates of the start of the text),
 drawing position flags made up from bit flags specified as constants in
 the <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html" title="interface in net.rim.device.api.ui"><CODE>DrawStyle</CODE></A> interface, and a width into which the text is drawn.

 <p>The drawing position flags specify both the baseline and the horizontal
 alignment. You combine them using the OR operator: e.g., BASELINE | HCENTER.

 <p>Baseline values:

 <p>The TOP baseline value draws the text below the drawing anchor.

 <p>The BOTTOM baseline value draws the text above the drawing anchor.

 <p>The BASELINE baseline value draws the text with its alphabetic baseline on the drawing anchor.

 <p>The VCENTER baseline value centers the text vertically on the drawing anchor.

 <p>Horizontal alignment values, used if a width greater than 0 is specified
 (a width of -1 forces left alignment; other values less than or equal to
 zero cause no text to be drawn):

 <p>The LEFT alignment value draws the text left-aligned to the paintable region. The
 paintable region is the area of the screen on which text can be drawn.

 <p>The HCENTER alignment value centers the text horizontally in the supplied width.

 <p>The RIGHT alignment value draws the text right-aligned to the paintable region. The
 paintable region is the area of the screen on which text can be drawn.

 <p>The HFULL (full justification) alignment value is not implemented by this
 interface, and is treated as identical to HCENTER.

 <p>By default, the <code>drawText</code> methods assume the drawing position
 flags <code>(TOP | LEFT)</code>. You can request another method of drawing
 the glyphs by passing other combinations of this class's constant drawing
 position values.

 <p><strong>Using DrawTextParam and TextMetrics</strong><br/>
 Some versions of <code>drawText</code> allow more detailed control over the
 way the text is drawn, and can return full text metrics. See the
 <A HREF="../../../../../net/rim/device/api/ui/DrawTextParam.html" title="class in net.rim.device.api.ui"><CODE>DrawTextParam</CODE></A> and <A HREF="../../../../../net/rim/device/api/ui/Graphics.WrappedTextMetrics.html" title="class in net.rim.device.api.ui"><CODE>Graphics.WrappedTextMetrics</CODE></A> classes for details.

 <p><strong>What happens to clipped text</strong><br/>
 The mechanism for handling clipping with <code>drawText</code> operations is
 slightly more complex.

 <p> The text drawing methods clip in two ways: pixels that fall outside the
 general clipping region, and pixels that fall outside a text <em>width</em>
 parameter specified to the appropriate <code>drawText</code> method. Text
 drawing methods that don't support a text width parameter use the width
 of the whole text to be drawn.

 <p> If you pass the <code>ELLIPSIS</code> constant to a <code>drawText</code>
 method, in combination with the drawing position constants, then clipping by
 the text width parameter is handled specially. The method replaces the last
 fully rendered glyph, and any pixels of a partially rendered glyph, with the
 ellipsis glyph (usually three dots, like this: ...).
 If the ellipsis glyph itself would be clipped by the text width
 parameter, then no ellipsis character is drawn.

 <p>You can use the <code>TRUNCATE_BEGINNING</code> constant to truncate the
 text at the start, not at the end, if it is wider than the supplied width. It
 can be combined with <code>ELLIPSIS</code> to put an ellipsis at the start
 if truncation occurs.

 <p><strong>Width of text rendered</strong><br/>
 All of the <code>drawText</code> methods return the linear advance, in pixels, of
 the text drawn. That is the amount by which the drawing position
 is moved along the baseline by drawing the text. If you want to draw some more
 text so that it joins with the text you have just drawn, the correct new
 x anchor position is the old x anchor position plus this advance value
 (assuming that you are drawing on a left-to-right baseline)
 but see also <CODE>AdvancedDrawTextParam.iAllowStartOverlap</CODE>.

 <p> You should also note that the advance width of drawn text returned by the
 <code>drawText</code> methods <em>includes</em> any pixels that are clipped
 by the clipping region. However, if you pass a width parameter into the
 <code>drawText</code> method to constrain the region available for drawing,
 and this width parameter clips the drawn text, the clipped pixels <em>do
 not</em> count in the width of text rendered returned by the method. 
 
 <p> You may further notice that since advance width can be less than the inked
 pixels width (e.g. 'K' in BBAlphaSans or Georgia), if we pass width returned by 
 <CODE>Font.measureText()</CODE> (x advance) into the <code>drawText</code>
 method, the text drawn might get truncated. The <code>drawText</code> tries to align 
 width of the inked pixels within the supplied width. For most of the cases, you may use
 <CODE>Font.getBounds()</CODE> which returns maximum of these widths.

 <p><strong>Italics and kerning</strong><br/>
 Parts of italic characters often protrude beyond - before or after - the
 horizontal bounds defined by the anchor position and the advance width. This
 can also happen when two adjacent characters, like 'T' and 'o', are
 automatically moved closer together, which is called kerning. If you need
 to take account of kerning outside the advance width, you should either
 use the ARTIC text layout system (see the <A HREF="../../../../../net/rim/device/internal/ui/ArticInterface.html" title="class in net.rim.device.internal.ui"><CODE>ArticInterface</CODE></A> class),
 or use <CODE>Font.measureText</CODE> to obtain the full metrics.
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="" CLASS="SummaryTable">
<TR BGCOLOR="#CCCCFF">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+0">
Field Summary</FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ALL_ROUNDED_RECT_CORNERS">ALL_ROUNDED_RECT_CORNERS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All four corners of a drawn rectangle should be rounded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#BLACK">BLACK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Black (0x00101010).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#BOTTOM_LEFT_ROUNDED_RECT_CORNER">BOTTOM_LEFT_ROUNDED_RECT_CORNER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bottom-left corner of a drawn rectangle should be rounded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#BOTTOM_RIGHT_ROUNDED_RECT_CORNER">BOTTOM_RIGHT_ROUNDED_RECT_CORNER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bottom-right corner of a drawn rectangle should be rounded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#BOTTOM_ROUNDED_RECT_CORNERS">BOTTOM_ROUNDED_RECT_CORNERS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Both bottom corners of a drawn rectangle should be rounded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT">CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cubic bezier control-point type for drawing paths.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT">CURVEDPATH_END_POINT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;End-point type for drawing paths.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT">CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Quadratic bezier control-point type for drawing paths.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#DRAWSTYLE_AALINES">DRAWSTYLE_AALINES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>use DRAWSTYLE_ANTIALIASED instead</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#DRAWSTYLE_AAPOLYGONS">DRAWSTYLE_AAPOLYGONS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>use DRAWSTYLE_ANTIALIASED instead</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#DRAWSTYLE_ANTIALIASED">DRAWSTYLE_ANTIALIASED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Drawing style for anti-aliased rendering of lines and polygons, used by
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setDrawingStyle(int, boolean)"><CODE>Graphics.setDrawingStyle(int, boolean)</CODE></A> and <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#isDrawingStyleSet(int)"><CODE>Graphics.isDrawingStyleSet(int)</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#DRAWSTYLE_FOCUS">DRAWSTYLE_FOCUS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This style is set by the framework when painting is being done for focus
 drawing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#DRAWSTYLE_SELECT">DRAWSTYLE_SELECT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This style is set by the framework when painting is being done for
 selection drawing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#FULL_BLACK">FULL_BLACK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Full black (0x00000000).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#FULL_WHITE">FULL_WHITE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Full white (0x00ffffff).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#LEFT_ROUNDED_RECT_CORNERS">LEFT_ROUNDED_RECT_CORNERS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Both left-side corners of a drawn rectangle should be rounded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#NO_ROUNDED_RECT_CORNERS">NO_ROUNDED_RECT_CORNERS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;No corners of a drawn rectangle should be rounded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#RIGHT_ROUNDED_RECT_CORNERS">RIGHT_ROUNDED_RECT_CORNERS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Both right-side corners of a drawn rectangle should be rounded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_0">ROP2_0</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for zeroing out the destination.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_1">ROP2_1</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for filling dest with 1 values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_D">ROP2_D</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for nop.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_DSa">ROP2_DSa</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for masking ( source and dest ).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_DSan">ROP2_DSan</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for ( not ( source and dest ) ).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_DSna">ROP2_DSna</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for ( ( not source ) and dest ).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_DSno">ROP2_DSno</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for ( ( not source ) or dest ).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_DSo">ROP2_DSo</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for ( source or dest ).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_DSon">ROP2_DSon</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for ( not ( source or dest ) ).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_DSx">ROP2_DSx</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for selective invert ( source xor dest ).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_DSxn">ROP2_DSxn</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for ( not ( source xor dest ) ).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_Dn">ROP2_Dn</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for invert destination.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_S">ROP2_S</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for normal source copy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_SDna">ROP2_SDna</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for ( ( not dest ) and source ).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_SDno">ROP2_SDno</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for ( source or ( not dest ) ).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP2_Sn">ROP2_Sn</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Binary raster op constant for ( not source ).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP_CONST_GLOBALALPHA">ROP_CONST_GLOBALALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use fillRect instead.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP_SRCMONOEXPAND_ALPHA">ROP_SRCMONOEXPAND_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Raster operation constant for expanding a monochrome source bitmap
 with current foreground and background drawing colors, respecting
 the alpha channel.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP_SRCMONOEXPAND_COPY">ROP_SRCMONOEXPAND_COPY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Raster operation constant for expanding a monochrome source bitmap with
 the current foreground and background drawing colors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP_SRC_ALPHA">ROP_SRC_ALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Raster operation constant for normal bitmap copy with an alpha channel.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP_SRC_ALPHA_GLOBALALPHA">ROP_SRC_ALPHA_GLOBALALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Raster operation constant for blending a source bitmap with an
 alpha channel and a constant global alpha value with destination
 pixels.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP_SRC_COPY">ROP_SRC_COPY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Raster operation constant for normal bitmap copy.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP_SRC_GLOBALALPHA">ROP_SRC_GLOBALALPHA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Raster operation constant for blending a source bitmap using a
 constant global alpha value with destination pixels.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#SCREEN_HAS_BORDER">SCREEN_HAS_BORDER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does the screen have a lit border around the drawable area of the screen?</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#TOP_LEFT_ROUNDED_RECT_CORNER">TOP_LEFT_ROUNDED_RECT_CORNER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Top-left corner of a drawn rectangle should be rounded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#TOP_RIGHT_ROUNDED_RECT_CORNER">TOP_RIGHT_ROUNDED_RECT_CORNER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Top-right corner of a drawn rectangle should be rounded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#TOP_ROUNDED_RECT_CORNERS">TOP_ROUNDED_RECT_CORNERS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Both top corners of a drawn rectangle should be rounded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#WHITE">WHITE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;White (0x00EBEBEB).</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_net.rim.device.api.ui.DrawStyle"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Fields inherited from interface net.rim.device.api.ui.<A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html" title="interface in net.rim.device.api.ui">DrawStyle</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#BASELINE">BASELINE</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#BOTTOM">BOTTOM</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#ELLIPSIS">ELLIPSIS</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#HALIGN_MASK">HALIGN_MASK</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#HCENTER">HCENTER</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#HDEFAULT">HDEFAULT</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#HFULL">HFULL</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#LEADING">LEADING</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#LEFT">LEFT</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#RIGHT">RIGHT</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#TOP">TOP</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#TRAILING">TRAILING</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#TRUNCATE_BEGINNING">TRUNCATE_BEGINNING</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#VALIGN_MASK">VALIGN_MASK</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#VCENTER">VCENTER</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#VDEFAULT">VDEFAULT</A>, <A HREF="../../../../../net/rim/device/api/ui/DrawStyle.html#VFULL">VFULL</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="" CLASS="SummaryTable">
<TR BGCOLOR="#CCCCFF">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+0">
Constructor Summary</FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#Graphics(net.rim.device.api.system.Bitmap)">Graphics</A></B>(<A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system">Bitmap</A>&nbsp;bitmap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use the static factory method, <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#create(net.rim.device.api.system.Bitmap)"><CODE>Graphics.create(Bitmap)</CODE></A>, instead.</I></TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="" CLASS="SummaryTable">
<TR BGCOLOR="#CCCCFF">
<TH ALIGN="left" COLSPAN="3"><FONT SIZE="+0">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#clear()">clear</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the entire graphics area to the current background color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#clear(int, int, int, int)">clear</A></B>(int&nbsp;x,
      int&nbsp;y,
      int&nbsp;width,
      int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears a region to the current background color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#clear(net.rim.device.api.ui.XYRect)">clear</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;region)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears a region specified by an XYRect object to the current background color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#copyArea(int, int, int, int, int, int)">copyArea</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height,
         int&nbsp;dx,
         int&nbsp;dy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies a region of this graphics canvas.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#copyArea(net.rim.device.api.ui.XYRect, int, int)">copyArea</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;region,
         int&nbsp;dx,
         int&nbsp;dy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies a region of this graphics canvas, specified by an <A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui"><CODE>XYRect</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../../../net/rim/device/api/ui/Graphics.html" title="class in net.rim.device.api.ui">Graphics</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#create(net.rim.device.api.system.Bitmap)">create</A></B>(<A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system">Bitmap</A>&nbsp;bitmap)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a Graphics object for drawing to a bitmap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawARGB(int[], int, int, int, int, int, int)">drawARGB</A></B>(int[]&nbsp;data,
         int&nbsp;offset,
         int&nbsp;scanLength,
         int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Similar to drawRGB, but source data also contains alpha.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawArc(int, int, int, int, int, int)">drawArc</A></B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height,
        int&nbsp;startAngle,
        int&nbsp;arcAngle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws an arc through a specified rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawBitmap(int, int, int, int, net.rim.device.api.system.Bitmap, int, int)">drawBitmap</A></B>(int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height,
           <A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system">Bitmap</A>&nbsp;bitmap,
           int&nbsp;left,
           int&nbsp;top)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a bitmap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawBitmap(net.rim.device.api.ui.XYRect, net.rim.device.api.system.Bitmap, int, int)">drawBitmap</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;dest,
           <A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system">Bitmap</A>&nbsp;bitmap,
           int&nbsp;left,
           int&nbsp;top)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a bitmap on a region specified by an <A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui"><CODE>XYRect</CODE></A> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawEllipse(int, int, int, int, int, int, int, int)">drawEllipse</A></B>(int&nbsp;cx,
            int&nbsp;cy,
            int&nbsp;px,
            int&nbsp;py,
            int&nbsp;qx,
            int&nbsp;qy,
            int&nbsp;startAngle,
            int&nbsp;arcAngle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws an ellipse.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawFilledPath(int[], int[], byte[], int[])">drawFilledPath</A></B>(int[]&nbsp;xPts,
               int[]&nbsp;yPts,
               byte[]&nbsp;pointTypes,
               int[]&nbsp;offsets)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a set of filled paths.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRect(int, int, int, int, int, int)">drawGradientFilledRect</A></B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height,
                       int&nbsp;startColor,
                       int&nbsp;endColor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws an un-bordered rectangle with a gradient fill, from a provided
 point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRect(int, int, int, int, int, int, boolean)">drawGradientFilledRect</A></B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height,
                       int&nbsp;startColor,
                       int&nbsp;endColor,
                       boolean&nbsp;drawBorder)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a rectangle with a gradient fill, from a provided point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRect(net.rim.device.api.ui.XYRect, int, int)">drawGradientFilledRect</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;rect,
                       int&nbsp;startColor,
                       int&nbsp;endColor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws an un-bordered rectangle with a gradient fill.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRect(net.rim.device.api.ui.XYRect, int, int, boolean)">drawGradientFilledRect</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;rect,
                       int&nbsp;startColor,
                       int&nbsp;endColor,
                       boolean&nbsp;drawBorder)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a rectangle with a gradient fill.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRoundedRect(int, int, int, int, int, int, boolean, int, int)">drawGradientFilledRoundedRect</A></B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height,
                              int&nbsp;startColor,
                              int&nbsp;endColor,
                              boolean&nbsp;drawBorder,
                              int&nbsp;arcWidth,
                              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a fully rounded rectangle with a gradient fill, from a provided
 point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRoundedRect(int, int, int, int, int, int, boolean, int, int, int)">drawGradientFilledRoundedRect</A></B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height,
                              int&nbsp;startColor,
                              int&nbsp;endColor,
                              boolean&nbsp;drawBorder,
                              int&nbsp;roundedCorners,
                              int&nbsp;arcWidth,
                              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a rounded rectangle with a gradient fill, from a provided point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRoundedRect(int, int, int, int, int, int, int, int)">drawGradientFilledRoundedRect</A></B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height,
                              int&nbsp;startColor,
                              int&nbsp;endColor,
                              int&nbsp;arcWidth,
                              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws an un-bordered, fully rounded rectangle with a gradient fill, from
 a provided point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRoundedRect(int, int, int, int, int, int, int, int, int)">drawGradientFilledRoundedRect</A></B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height,
                              int&nbsp;startColor,
                              int&nbsp;endColor,
                              int&nbsp;roundedCorners,
                              int&nbsp;arcWidth,
                              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws an un-bordered rectangle with a gradient fill, from a provided
 point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRoundedRect(net.rim.device.api.ui.XYRect, int, int, boolean, int, int)">drawGradientFilledRoundedRect</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;rect,
                              int&nbsp;startColor,
                              int&nbsp;endColor,
                              boolean&nbsp;drawBorder,
                              int&nbsp;arcWidth,
                              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a fully rounded rectangle with a gradient fill.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRoundedRect(net.rim.device.api.ui.XYRect, int, int, boolean, int, int, int)">drawGradientFilledRoundedRect</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;rect,
                              int&nbsp;startColor,
                              int&nbsp;endColor,
                              boolean&nbsp;drawBorder,
                              int&nbsp;roundedCorners,
                              int&nbsp;arcWidth,
                              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a rounded rectangle with a gradient fill.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRoundedRect(net.rim.device.api.ui.XYRect, int, int, int, int)">drawGradientFilledRoundedRect</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;rect,
                              int&nbsp;startColor,
                              int&nbsp;endColor,
                              int&nbsp;arcWidth,
                              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws an un-bordered, fully rounded rectangle with a gradient fill.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRoundedRect(net.rim.device.api.ui.XYRect, int, int, int, int, int)">drawGradientFilledRoundedRect</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;rect,
                              int&nbsp;startColor,
                              int&nbsp;endColor,
                              int&nbsp;roundedCorners,
                              int&nbsp;arcWidth,
                              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws an un-bordered, rounded rectangle with a gradient fill.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawImage(int, int, int, int, net.rim.device.api.system.EncodedImage, int, int, int)">drawImage</A></B>(int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height,
          <A HREF="../../../../../net/rim/device/api/system/EncodedImage.html" title="class in net.rim.device.api.system">EncodedImage</A>&nbsp;image,
          int&nbsp;frameIndex,
          int&nbsp;left,
          int&nbsp;top)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws an encoded image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawImage(net.rim.device.api.ui.XYRect, net.rim.device.api.system.EncodedImage, int, int, int)">drawImage</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;dest,
          <A HREF="../../../../../net/rim/device/api/system/EncodedImage.html" title="class in net.rim.device.api.system">EncodedImage</A>&nbsp;image,
          int&nbsp;frameIndex,
          int&nbsp;left,
          int&nbsp;top)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws an encoded image on a region specified by an <A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui"><CODE>XYRect</CODE></A> object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawLine(int, int, int, int)">drawLine</A></B>(int&nbsp;x1,
         int&nbsp;y1,
         int&nbsp;x2,
         int&nbsp;y2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a line.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawOutlinedPath(int[], int[], byte[], int[], boolean)">drawOutlinedPath</A></B>(int[]&nbsp;xPts,
                 int[]&nbsp;yPts,
                 byte[]&nbsp;pointTypes,
                 int[]&nbsp;offsets,
                 boolean&nbsp;closed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draw a set of path outlines.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawPathOutline(int[], int[], byte[], int[], boolean)">drawPathOutline</A></B>(int[]&nbsp;xPts,
                int[]&nbsp;yPts,
                byte[]&nbsp;pointTypes,
                int[]&nbsp;offsets,
                boolean&nbsp;closed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use Graphics.drawOutlinedPath(int[],int[],byte[],int[],boolean).</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawPoint(int, int)">drawPoint</A></B>(int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawRGB(int[], int, int, int, int, int, int)">drawRGB</A></B>(int[]&nbsp;data,
        int&nbsp;offset,
        int&nbsp;scanLength,
        int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws raw RGB data from an int array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawRect(int, int, int, int)">drawRect</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawRoundRect(int, int, int, int, int, int)">drawRoundRect</A></B>(int&nbsp;x,
              int&nbsp;y,
              int&nbsp;width,
              int&nbsp;height,
              int&nbsp;arcWidth,
              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a rectangle with rounded edges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawRoundRect(int, int, int, int, int, int, int)">drawRoundRect</A></B>(int&nbsp;x,
              int&nbsp;y,
              int&nbsp;width,
              int&nbsp;height,
              int&nbsp;roundedCorners,
              int&nbsp;arcWidth,
              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws an un-bordered rounded rectangle, from a provided point.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawShadedFilledPath(int[], int[], byte[], int[], int[])">drawShadedFilledPath</A></B>(int[]&nbsp;xPts,
                     int[]&nbsp;yPts,
                     byte[]&nbsp;pointTypes,
                     int[]&nbsp;colors,
                     int[]&nbsp;offsets)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a set of shaded filled paths.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawText(byte[], int, int, int, int, int, int)">drawText</A></B>(byte[]&nbsp;aText,
         int&nbsp;aOffset,
         int&nbsp;aLength,
         int&nbsp;aX,
         int&nbsp;aY,
         int&nbsp;aFlags,
         int&nbsp;aWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws part of the contents of a byte array using the current font,
 clipping to the current clipping region, and using the baseline and
 alignment specified by aFlags and aWidth.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawText(char, int, int, int, int)">drawText</A></B>(char&nbsp;aChar,
         int&nbsp;aX,
         int&nbsp;aY,
         int&nbsp;aFlags,
         int&nbsp;aWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a character using the current font and clipping to the current clipping region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawText(char[], int, int, int, int, int, int)">drawText</A></B>(char[]&nbsp;aText,
         int&nbsp;aOffset,
         int&nbsp;aLength,
         int&nbsp;aX,
         int&nbsp;aY,
         int&nbsp;aFlags,
         int&nbsp;aWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws part of the contents of a char array using the current font,
 clipping to the current clipping region, and using the baseline and
 alignment specified by aFlags and aWidth.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawText(char[], int, int, int, int, net.rim.device.api.ui.DrawTextParam, net.rim.device.api.ui.TextMetrics)">drawText</A></B>(char[]&nbsp;aText,
         int&nbsp;aOffset,
         int&nbsp;aLength,
         int&nbsp;aX,
         int&nbsp;aY,
         <A HREF="../../../../../net/rim/device/api/ui/DrawTextParam.html" title="class in net.rim.device.api.ui">DrawTextParam</A>&nbsp;aParam,
         <A HREF="../../../../../net/rim/device/api/ui/TextMetrics.html" title="class in net.rim.device.api.ui">TextMetrics</A>&nbsp;aMetrics)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws part of the text in a char array using the current font
 and clipping to the current clipping region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawText(java.lang.String, int, int)">drawText</A></B>(<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;aText,
         int&nbsp;aX,
         int&nbsp;aY)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the text in a string using the current font, clipping to the current clipping region
 and using the TOP baseline and LEFT alignment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawText(java.lang.String, int, int, int)">drawText</A></B>(<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;aText,
         int&nbsp;aX,
         int&nbsp;aY,
         int&nbsp;aFlags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the text in a string using the current font, clipping to the current clipping region
 and using the baseline specified by aFlags.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawText(java.lang.String, int, int, int, int)">drawText</A></B>(<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;aText,
         int&nbsp;aX,
         int&nbsp;aY,
         int&nbsp;aFlags,
         int&nbsp;aWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the text in a string using the current font, clipping to the current clipping region,
 and using the baseline and alignment specified by aFlags and aWidth.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawText(java.lang.String, int, int, int, int, int, int)">drawText</A></B>(<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;aText,
         int&nbsp;aOffset,
         int&nbsp;aLength,
         int&nbsp;aX,
         int&nbsp;aY,
         int&nbsp;aFlags,
         int&nbsp;aWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws part of the text in a String using the current font,
 clipping to the current clipping region, and using the baseline and
 alignment specified by aFlags and aWidth.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawText(java.lang.String, int, int, int, int, net.rim.device.api.ui.DrawTextParam, net.rim.device.api.ui.TextMetrics)">drawText</A></B>(<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;aText,
         int&nbsp;aOffset,
         int&nbsp;aLength,
         int&nbsp;aX,
         int&nbsp;aY,
         <A HREF="../../../../../net/rim/device/api/ui/DrawTextParam.html" title="class in net.rim.device.api.ui">DrawTextParam</A>&nbsp;aParam,
         <A HREF="../../../../../net/rim/device/api/ui/TextMetrics.html" title="class in net.rim.device.api.ui">TextMetrics</A>&nbsp;aMetrics)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws part of the text in a String using the current font
 and clipping to the current clipping region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawText(java.lang.StringBuffer, int, int, int, int, int, int)">drawText</A></B>(<A HREF="../../../../../java/lang/StringBuffer.html" title="class in java.lang">StringBuffer</A>&nbsp;aText,
         int&nbsp;aOffset,
         int&nbsp;aLength,
         int&nbsp;aX,
         int&nbsp;aY,
         int&nbsp;aFlags,
         int&nbsp;aWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws part of the text in a StringBuffer using the current font,
 clipping to the current clipping region, and using the baseline and
 alignment specified by aFlags and aWidth.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawText(java.lang.StringBuffer, int, int, int, int, net.rim.device.api.ui.DrawTextParam, net.rim.device.api.ui.TextMetrics)">drawText</A></B>(<A HREF="../../../../../java/lang/StringBuffer.html" title="class in java.lang">StringBuffer</A>&nbsp;aText,
         int&nbsp;aOffset,
         int&nbsp;aLength,
         int&nbsp;aX,
         int&nbsp;aY,
         <A HREF="../../../../../net/rim/device/api/ui/DrawTextParam.html" title="class in net.rim.device.api.ui">DrawTextParam</A>&nbsp;aParam,
         <A HREF="../../../../../net/rim/device/api/ui/TextMetrics.html" title="class in net.rim.device.api.ui">TextMetrics</A>&nbsp;aMetrics)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws part of the text in a StringBuffer using the current font
 and clipping to the current clipping region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawTextOnPath(char[], int, int, int, int, int[], int[], byte[], int[], net.rim.device.api.ui.DrawTextParam, net.rim.device.api.ui.TextMetrics)">drawTextOnPath</A></B>(char[]&nbsp;aText,
               int&nbsp;aOffset,
               int&nbsp;aLength,
               int&nbsp;aOriginX,
               int&nbsp;aOriginY,
               int[]&nbsp;aXPoints,
               int[]&nbsp;aYPoints,
               byte[]&nbsp;aPointTypes,
               int[]&nbsp;aContourStarts,
               <A HREF="../../../../../net/rim/device/api/ui/DrawTextParam.html" title="class in net.rim.device.api.ui">DrawTextParam</A>&nbsp;aParam,
               <A HREF="../../../../../net/rim/device/api/ui/TextMetrics.html" title="class in net.rim.device.api.ui">TextMetrics</A>&nbsp;aMetrics)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws text along a path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawTextOnPath(java.lang.String, int, int, int, int, int[], int[], byte[], int[], net.rim.device.api.ui.DrawTextParam, net.rim.device.api.ui.TextMetrics)">drawTextOnPath</A></B>(<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;aText,
               int&nbsp;aOffset,
               int&nbsp;aLength,
               int&nbsp;aOriginX,
               int&nbsp;aOriginY,
               int[]&nbsp;aXPoints,
               int[]&nbsp;aYPoints,
               byte[]&nbsp;aPointTypes,
               int[]&nbsp;aContourStarts,
               <A HREF="../../../../../net/rim/device/api/ui/DrawTextParam.html" title="class in net.rim.device.api.ui">DrawTextParam</A>&nbsp;aParam,
               <A HREF="../../../../../net/rim/device/api/ui/TextMetrics.html" title="class in net.rim.device.api.ui">TextMetrics</A>&nbsp;aMetrics)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws text along a path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawTextOnPath(java.lang.StringBuffer, int, int, int, int, int[], int[], byte[], int[], net.rim.device.api.ui.DrawTextParam, net.rim.device.api.ui.TextMetrics)">drawTextOnPath</A></B>(<A HREF="../../../../../java/lang/StringBuffer.html" title="class in java.lang">StringBuffer</A>&nbsp;aText,
               int&nbsp;aOffset,
               int&nbsp;aLength,
               int&nbsp;aOriginX,
               int&nbsp;aOriginY,
               int[]&nbsp;aXPoints,
               int[]&nbsp;aYPoints,
               byte[]&nbsp;aPointTypes,
               int[]&nbsp;aContourStarts,
               <A HREF="../../../../../net/rim/device/api/ui/DrawTextParam.html" title="class in net.rim.device.api.ui">DrawTextParam</A>&nbsp;aParam,
               <A HREF="../../../../../net/rim/device/api/ui/TextMetrics.html" title="class in net.rim.device.api.ui">TextMetrics</A>&nbsp;aMetrics)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws text along a path.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawTexturedPath(int[], int[], byte[], int[], int, int, int, int, int, int, net.rim.device.api.system.Bitmap)">drawTexturedPath</A></B>(int[]&nbsp;xPts,
                 int[]&nbsp;yPts,
                 byte[]&nbsp;pointTypes,
                 int[]&nbsp;offsets,
                 int&nbsp;xOrigin,
                 int&nbsp;yOrigin,
                 int&nbsp;dux,
                 int&nbsp;dvx,
                 int&nbsp;duy,
                 int&nbsp;dvy,
                 <A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system">Bitmap</A>&nbsp;textureData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a set of texture-filled paths.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#fillArc(int, int, int, int, int, int)">fillArc</A></B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height,
        int&nbsp;startAngle,
        int&nbsp;arcAngle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills a circular or elliptical arc covering a specified rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#fillEllipse(int, int, int, int, int, int, int, int)">fillEllipse</A></B>(int&nbsp;cx,
            int&nbsp;cy,
            int&nbsp;px,
            int&nbsp;py,
            int&nbsp;qx,
            int&nbsp;qy,
            int&nbsp;startAngle,
            int&nbsp;arcAngle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills an ellipse.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#fillRect(int, int, int, int)">fillRect</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills a rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#fillRoundRect(int, int, int, int, int, int)">fillRoundRect</A></B>(int&nbsp;x,
              int&nbsp;y,
              int&nbsp;width,
              int&nbsp;height,
              int&nbsp;arcWidth,
              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills a rectangle with rounded edges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getAbsoluteClippingRect(net.rim.device.api.ui.XYRect)">getAbsoluteClippingRect</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;clip)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retreives the absolute coordinates of current clipping region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getBackgroundColor()">getBackgroundColor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current background color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getClippingRect()">getClippingRect</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the local coordinates of current clipping region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getColor()">getColor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current foreground drawing color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getContextStackSize()">getContextStackSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the size of the stack of drawing contexts.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getDrawingOffset(net.rim.device.api.ui.XYPoint)">getDrawingOffset</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYPoint.html" title="class in net.rim.device.api.ui">XYPoint</A>&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the absolute coordinates for the current drawing offset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../net/rim/device/api/ui/Font.html" title="class in net.rim.device.api.ui">Font</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getFont()">getFont</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current font for the current graphics context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getGlobalAlpha()">getGlobalAlpha</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current global alpha value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getNearestColor(int)">getNearestColor</A></B>(int&nbsp;color)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the color that will be used if the specified color is requested.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getNumColors()">getNumColors</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use Display.getNumColors();</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getScreenHeight()">getScreenHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use Display.getHeight()</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getScreenHorizontalResolution()">getScreenHorizontalResolution</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use Display.getHorizontalResolution()</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getScreenVerticalResolution()">getScreenVerticalResolution</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use Display.getVerticalResolution()</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getScreenWidth()">getScreenWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use Display.getWidth()</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getStipple()">getStipple</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the current line stippling value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getTranslateX()">getTranslateX</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the horizontal component of the current drawing offset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#getTranslateY()">getTranslateY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the vertical component of the current drawing offset.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#invert(int, int, int, int)">invert</A></B>(int&nbsp;x,
       int&nbsp;y,
       int&nbsp;width,
       int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inverts a region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#invert(net.rim.device.api.ui.XYRect)">invert</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;rect)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inverts a region specified by an XYRect object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#isColor()">isColor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>Use Display.isColor().</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#isDrawingStyleSet(int)">isDrawingStyleSet</A></B>(int&nbsp;drawStyle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines whether the specified drawing style is turned on.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#isRopSupported(int)">isRopSupported</A></B>(int&nbsp;rop)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determines if a raster operation is supported.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#popContext()">popContext</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pops a drawing context off the stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#pushContext(int, int, int, int, int, int)">pushContext</A></B>(int&nbsp;x,
            int&nbsp;y,
            int&nbsp;width,
            int&nbsp;height,
            int&nbsp;xOffset,
            int&nbsp;yOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pushes a clipping region (and optional drawing offset) onto the context
 stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#pushContext(net.rim.device.api.ui.XYRect, int, int)">pushContext</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;clip,
            int&nbsp;xOffset,
            int&nbsp;yOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pushes a clipping region (and optional drawing offset) onto the context
 stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#pushRegion(int, int, int, int, int, int)">pushRegion</A></B>(int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height,
           int&nbsp;xScroll,
           int&nbsp;yScroll)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pushes a drawing region (and optional scroll offset) onto the context
 stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#pushRegion(net.rim.device.api.ui.XYRect)">pushRegion</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;region)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pushes a drawing region onto the context stack, specified by a XYRect
 object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#pushRegion(net.rim.device.api.ui.XYRect, int, int)">pushRegion</A></B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;region,
           int&nbsp;xScroll,
           int&nbsp;yScroll)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pushes a drawing region (and optional scroll offset) onto the context
 stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#rop(int, int, int, int, int, net.rim.device.api.system.Bitmap, int, int)">rop</A></B>(int&nbsp;rop,
    int&nbsp;x,
    int&nbsp;y,
    int&nbsp;width,
    int&nbsp;height,
    <A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system">Bitmap</A>&nbsp;source,
    int&nbsp;left,
    int&nbsp;top)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executes an area raster operation on the specified region.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setBackgroundColor(int)">setBackgroundColor</A></B>(int&nbsp;RGB)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current background color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setColor(int)">setColor</A></B>(int&nbsp;RGB)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setDrawingStyle(int, boolean)">setDrawingStyle</A></B>(int&nbsp;drawStyle,
                boolean&nbsp;on)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current drawing style.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setFont(net.rim.device.api.ui.Font)">setFont</A></B>(<A HREF="../../../../../net/rim/device/api/ui/Font.html" title="class in net.rim.device.api.ui">Font</A>&nbsp;font)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current font for the current graphics context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setGlobalAlpha(int)">setGlobalAlpha</A></B>(int&nbsp;alpha)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current global alpha value for drawing operations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setStipple(int)">setStipple</A></B>(int&nbsp;mask)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current line stippling value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#tileRop(int, int, int, int, int, net.rim.device.api.system.Bitmap, int, int)">tileRop</A></B>(int&nbsp;rop,
        int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height,
        <A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system">Bitmap</A>&nbsp;source,
        int&nbsp;left,
        int&nbsp;top)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executes an area raster operation on the specified region, tiling the
 source bitmap if necessary.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../net/rim/device/api/ui/Graphics.html#translate(int, int)">translate</A></B>(int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Apply a translation to the current drawing offset.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.<A HREF="../../../../../java/lang/Object.html" title="class in java.lang">Object</A></B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="../../../../../java/lang/Object.html#getClass()">getClass</A>, <A HREF="../../../../../java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="../../../../../java/lang/Object.html#notify()">notify</A>, <A HREF="../../../../../java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="../../../../../java/lang/Object.html#toString()">toString</A>, <A HREF="../../../../../java/lang/Object.html#wait()">wait</A>, <A HREF="../../../../../java/lang/Object.html#wait(long)">wait</A>, <A HREF="../../../../../java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<BR>

<BR>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF">
<TH ALIGN="left" COLSPAN="1" CLASS="TableHeadingColor"><FONT SIZE="+0">
Field Detail</FONT></TH>
</TR>
</TABLE>
<A NAME="BLACK"><!-- --></A><H3>
BLACK</H3>
<PRE>
public static final int <B>BLACK</B></PRE>
<DL>
<DD>Black (0x00101010).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.BLACK">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="WHITE"><!-- --></A><H3>
WHITE</H3>
<PRE>
public static final int <B>WHITE</B></PRE>
<DL>
<DD>White (0x00EBEBEB).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.WHITE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FULL_BLACK"><!-- --></A><H3>
FULL_BLACK</H3>
<PRE>
public static final int <B>FULL_BLACK</B></PRE>
<DL>
<DD>Full black (0x00000000).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.FULL_BLACK">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="FULL_WHITE"><!-- --></A><H3>
FULL_WHITE</H3>
<PRE>
public static final int <B>FULL_WHITE</B></PRE>
<DL>
<DD>Full white (0x00ffffff).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.FULL_WHITE">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP_SRC_COPY"><!-- --></A><H3>
ROP_SRC_COPY</H3>
<PRE>
public static final int <B>ROP_SRC_COPY</B></PRE>
<DL>
<DD>Raster operation constant for normal bitmap copy.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP_SRC_COPY">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP_SRCMONOEXPAND_COPY"><!-- --></A><H3>
ROP_SRCMONOEXPAND_COPY</H3>
<PRE>
public static final int <B>ROP_SRCMONOEXPAND_COPY</B></PRE>
<DL>
<DD>Raster operation constant for expanding a monochrome source bitmap with
 the current foreground and background drawing colors.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP_SRCMONOEXPAND_COPY">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP_SRC_ALPHA"><!-- --></A><H3>
ROP_SRC_ALPHA</H3>
<PRE>
public static final int <B>ROP_SRC_ALPHA</B></PRE>
<DL>
<DD>Raster operation constant for normal bitmap copy with an alpha channel.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP_SRC_ALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP_SRCMONOEXPAND_ALPHA"><!-- --></A><H3>
ROP_SRCMONOEXPAND_ALPHA</H3>
<PRE>
public static final int <B>ROP_SRCMONOEXPAND_ALPHA</B></PRE>
<DL>
<DD>Raster operation constant for expanding a monochrome source bitmap
 with current foreground and background drawing colors, respecting
 the alpha channel. The behaves similar to a rubber stamp.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP_SRCMONOEXPAND_ALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP_CONST_GLOBALALPHA"><!-- --></A><H3>
ROP_CONST_GLOBALALPHA</H3>
<PRE>
public static final int <B>ROP_CONST_GLOBALALPHA</B></PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use fillRect instead.</I><DD>Raster operation constant for blending the constant foreground color,
 using a constant global alpha value with destination pixels.

 <p> Set the global alpha value using <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setGlobalAlpha(int)"><CODE>Graphics.setGlobalAlpha(int)</CODE></A>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP_CONST_GLOBALALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP_SRC_GLOBALALPHA"><!-- --></A><H3>
ROP_SRC_GLOBALALPHA</H3>
<PRE>
public static final int <B>ROP_SRC_GLOBALALPHA</B></PRE>
<DL>
<DD>Raster operation constant for blending a source bitmap using a
 constant global alpha value with destination pixels.

 <p> Set the global alpha value using <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setGlobalAlpha(int)"><CODE>Graphics.setGlobalAlpha(int)</CODE></A>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP_SRC_GLOBALALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP_SRC_ALPHA_GLOBALALPHA"><!-- --></A><H3>
ROP_SRC_ALPHA_GLOBALALPHA</H3>
<PRE>
public static final int <B>ROP_SRC_ALPHA_GLOBALALPHA</B></PRE>
<DL>
<DD>Raster operation constant for blending a source bitmap with an
 alpha channel and a constant global alpha value with destination
 pixels.

 <p> Set the global alpha value using <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setGlobalAlpha(int)"><CODE>Graphics.setGlobalAlpha(int)</CODE></A>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP_SRC_ALPHA_GLOBALALPHA">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 4.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_0"><!-- --></A><H3>
ROP2_0</H3>
<PRE>
public static final int <B>ROP2_0</B></PRE>
<DL>
<DD>Binary raster op constant for zeroing out the destination.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_0">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_DSon"><!-- --></A><H3>
ROP2_DSon</H3>
<PRE>
public static final int <B>ROP2_DSon</B></PRE>
<DL>
<DD>Binary raster op constant for ( not ( source or dest ) ).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_DSon">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_DSna"><!-- --></A><H3>
ROP2_DSna</H3>
<PRE>
public static final int <B>ROP2_DSna</B></PRE>
<DL>
<DD>Binary raster op constant for ( ( not source ) and dest ).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_DSna">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_Sn"><!-- --></A><H3>
ROP2_Sn</H3>
<PRE>
public static final int <B>ROP2_Sn</B></PRE>
<DL>
<DD>Binary raster op constant for ( not source ).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_Sn">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_SDna"><!-- --></A><H3>
ROP2_SDna</H3>
<PRE>
public static final int <B>ROP2_SDna</B></PRE>
<DL>
<DD>Binary raster op constant for ( ( not dest ) and source ).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_SDna">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_Dn"><!-- --></A><H3>
ROP2_Dn</H3>
<PRE>
public static final int <B>ROP2_Dn</B></PRE>
<DL>
<DD>Binary raster op constant for invert destination.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_Dn">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_DSx"><!-- --></A><H3>
ROP2_DSx</H3>
<PRE>
public static final int <B>ROP2_DSx</B></PRE>
<DL>
<DD>Binary raster op constant for selective invert ( source xor dest ).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_DSx">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_DSan"><!-- --></A><H3>
ROP2_DSan</H3>
<PRE>
public static final int <B>ROP2_DSan</B></PRE>
<DL>
<DD>Binary raster op constant for ( not ( source and dest ) ).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_DSan">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_DSa"><!-- --></A><H3>
ROP2_DSa</H3>
<PRE>
public static final int <B>ROP2_DSa</B></PRE>
<DL>
<DD>Binary raster op constant for masking ( source and dest ).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_DSa">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_DSxn"><!-- --></A><H3>
ROP2_DSxn</H3>
<PRE>
public static final int <B>ROP2_DSxn</B></PRE>
<DL>
<DD>Binary raster op constant for ( not ( source xor dest ) ).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_DSxn">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_D"><!-- --></A><H3>
ROP2_D</H3>
<PRE>
public static final int <B>ROP2_D</B></PRE>
<DL>
<DD>Binary raster op constant for nop.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_D">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_DSno"><!-- --></A><H3>
ROP2_DSno</H3>
<PRE>
public static final int <B>ROP2_DSno</B></PRE>
<DL>
<DD>Binary raster op constant for ( ( not source ) or dest ).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_DSno">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_S"><!-- --></A><H3>
ROP2_S</H3>
<PRE>
public static final int <B>ROP2_S</B></PRE>
<DL>
<DD>Binary raster op constant for normal source copy.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_S">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_SDno"><!-- --></A><H3>
ROP2_SDno</H3>
<PRE>
public static final int <B>ROP2_SDno</B></PRE>
<DL>
<DD>Binary raster op constant for ( source or ( not dest ) ).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_SDno">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_DSo"><!-- --></A><H3>
ROP2_DSo</H3>
<PRE>
public static final int <B>ROP2_DSo</B></PRE>
<DL>
<DD>Binary raster op constant for ( source or dest ).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_DSo">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="ROP2_1"><!-- --></A><H3>
ROP2_1</H3>
<PRE>
public static final int <B>ROP2_1</B></PRE>
<DL>
<DD>Binary raster op constant for filling dest with 1 values.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ROP2_1">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="DRAWSTYLE_AALINES"><!-- --></A><H3>
DRAWSTYLE_AALINES</H3>
<PRE>
public static final int <B>DRAWSTYLE_AALINES</B></PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use DRAWSTYLE_ANTIALIASED instead</I><DD>Drawing style for anti-aliased rendering of lines, used by
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setDrawingStyle(int, boolean)"><CODE>Graphics.setDrawingStyle(int, boolean)</CODE></A> and <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#isDrawingStyleSet(int)"><CODE>Graphics.isDrawingStyleSet(int)</CODE></A>.

 <p> If this style is set, lines and path outlines may be antialiased.

 <p> This style is off by default.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.DRAWSTYLE_AALINES">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DL>
<HR>

<A NAME="DRAWSTYLE_AAPOLYGONS"><!-- --></A><H3>
DRAWSTYLE_AAPOLYGONS</H3>
<PRE>
public static final int <B>DRAWSTYLE_AAPOLYGONS</B></PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>use DRAWSTYLE_ANTIALIASED instead</I><DD>Drawing style for anti-aliased rendering of polygons, used by
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setDrawingStyle(int, boolean)"><CODE>Graphics.setDrawingStyle(int, boolean)</CODE></A> and <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#isDrawingStyleSet(int)"><CODE>Graphics.isDrawingStyleSet(int)</CODE></A>.

 <p> If this style is set, filled paths and polygons may be antialiased.

 <p> This style is off by default.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.DRAWSTYLE_AAPOLYGONS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DL>
<HR>

<A NAME="DRAWSTYLE_ANTIALIASED"><!-- --></A><H3>
DRAWSTYLE_ANTIALIASED</H3>
<PRE>
public static final int <B>DRAWSTYLE_ANTIALIASED</B></PRE>
<DL>
<DD>Drawing style for anti-aliased rendering of lines and polygons, used by
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setDrawingStyle(int, boolean)"><CODE>Graphics.setDrawingStyle(int, boolean)</CODE></A> and <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#isDrawingStyleSet(int)"><CODE>Graphics.isDrawingStyleSet(int)</CODE></A>.

 <p> If this style is set, lines, path outlines, afilled paths and polygons may be antialiased.

 <p> This style is off by default.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.DRAWSTYLE_ANTIALIASED">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 6.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="DRAWSTYLE_FOCUS"><!-- --></A><H3>
DRAWSTYLE_FOCUS</H3>
<PRE>
public static final int <B>DRAWSTYLE_FOCUS</B></PRE>
<DL>
<DD>This style is set by the framework when painting is being done for focus
 drawing.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.DRAWSTYLE_FOCUS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DL>
<HR>

<A NAME="DRAWSTYLE_SELECT"><!-- --></A><H3>
DRAWSTYLE_SELECT</H3>
<PRE>
public static final int <B>DRAWSTYLE_SELECT</B></PRE>
<DL>
<DD>This style is set by the framework when painting is being done for
 selection drawing.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.DRAWSTYLE_SELECT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DL>
<HR>

<A NAME="CURVEDPATH_END_POINT"><!-- --></A><H3>
CURVEDPATH_END_POINT</H3>
<PRE>
public static final byte <B>CURVEDPATH_END_POINT</B></PRE>
<DL>
<DD>End-point type for drawing paths.

 <p> A curve or line ends on this point. The value of this constant will
 always be 0, so it is possible to just create a points array and set only
 the values of the curves' control points.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.CURVEDPATH_END_POINT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT"><!-- --></A><H3>
CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</H3>
<PRE>
public static final byte <B>CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</B></PRE>
<DL>
<DD>Quadratic bezier control-point type for drawing paths.

 <p> The control point of a quadratic bezier is the single point that
 "stretches" the curve awway from the end points. If a point is a
 quadratic bezier control point, the points preceeding and succeeding it
 must be end points.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT"><!-- --></A><H3>
CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</H3>
<PRE>
public static final byte <B>CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</B></PRE>
<DL>
<DD>Cubic bezier control-point type for drawing paths.

 <p> A control point of a cubic bezier is one of two points that "stretch"
 the curve awway from the end points. Cubic bezier control points must
 come in sets of two, with end points coming before the first control
 point and after the second.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DL>
<HR>

<A NAME="NO_ROUNDED_RECT_CORNERS"><!-- --></A><H3>
NO_ROUNDED_RECT_CORNERS</H3>
<PRE>
public static final int <B>NO_ROUNDED_RECT_CORNERS</B></PRE>
<DL>
<DD>No corners of a drawn rectangle should be rounded.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.NO_ROUNDED_RECT_CORNERS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="TOP_LEFT_ROUNDED_RECT_CORNER"><!-- --></A><H3>
TOP_LEFT_ROUNDED_RECT_CORNER</H3>
<PRE>
public static final int <B>TOP_LEFT_ROUNDED_RECT_CORNER</B></PRE>
<DL>
<DD>Top-left corner of a drawn rectangle should be rounded.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.TOP_LEFT_ROUNDED_RECT_CORNER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="TOP_RIGHT_ROUNDED_RECT_CORNER"><!-- --></A><H3>
TOP_RIGHT_ROUNDED_RECT_CORNER</H3>
<PRE>
public static final int <B>TOP_RIGHT_ROUNDED_RECT_CORNER</B></PRE>
<DL>
<DD>Top-right corner of a drawn rectangle should be rounded.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.TOP_RIGHT_ROUNDED_RECT_CORNER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="BOTTOM_LEFT_ROUNDED_RECT_CORNER"><!-- --></A><H3>
BOTTOM_LEFT_ROUNDED_RECT_CORNER</H3>
<PRE>
public static final int <B>BOTTOM_LEFT_ROUNDED_RECT_CORNER</B></PRE>
<DL>
<DD>Bottom-left corner of a drawn rectangle should be rounded.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.BOTTOM_LEFT_ROUNDED_RECT_CORNER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="BOTTOM_RIGHT_ROUNDED_RECT_CORNER"><!-- --></A><H3>
BOTTOM_RIGHT_ROUNDED_RECT_CORNER</H3>
<PRE>
public static final int <B>BOTTOM_RIGHT_ROUNDED_RECT_CORNER</B></PRE>
<DL>
<DD>Bottom-right corner of a drawn rectangle should be rounded.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.BOTTOM_RIGHT_ROUNDED_RECT_CORNER">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="TOP_ROUNDED_RECT_CORNERS"><!-- --></A><H3>
TOP_ROUNDED_RECT_CORNERS</H3>
<PRE>
public static final int <B>TOP_ROUNDED_RECT_CORNERS</B></PRE>
<DL>
<DD>Both top corners of a drawn rectangle should be rounded.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.TOP_ROUNDED_RECT_CORNERS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="BOTTOM_ROUNDED_RECT_CORNERS"><!-- --></A><H3>
BOTTOM_ROUNDED_RECT_CORNERS</H3>
<PRE>
public static final int <B>BOTTOM_ROUNDED_RECT_CORNERS</B></PRE>
<DL>
<DD>Both bottom corners of a drawn rectangle should be rounded.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.BOTTOM_ROUNDED_RECT_CORNERS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="LEFT_ROUNDED_RECT_CORNERS"><!-- --></A><H3>
LEFT_ROUNDED_RECT_CORNERS</H3>
<PRE>
public static final int <B>LEFT_ROUNDED_RECT_CORNERS</B></PRE>
<DL>
<DD>Both left-side corners of a drawn rectangle should be rounded.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.LEFT_ROUNDED_RECT_CORNERS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="RIGHT_ROUNDED_RECT_CORNERS"><!-- --></A><H3>
RIGHT_ROUNDED_RECT_CORNERS</H3>
<PRE>
public static final int <B>RIGHT_ROUNDED_RECT_CORNERS</B></PRE>
<DL>
<DD>Both right-side corners of a drawn rectangle should be rounded.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.RIGHT_ROUNDED_RECT_CORNERS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="ALL_ROUNDED_RECT_CORNERS"><!-- --></A><H3>
ALL_ROUNDED_RECT_CORNERS</H3>
<PRE>
public static final int <B>ALL_ROUNDED_RECT_CORNERS</B></PRE>
<DL>
<DD>All four corners of a drawn rectangle should be rounded.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../../../constant-values.html#net.rim.device.api.ui.Graphics.ALL_ROUNDED_RECT_CORNERS">Constant Field Values</A><DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DL>
<HR>

<A NAME="SCREEN_HAS_BORDER"><!-- --></A><H3>
SCREEN_HAS_BORDER</H3>
<PRE>
public static final boolean <B>SCREEN_HAS_BORDER</B></PRE>
<DL>
<DD>Does the screen have a lit border around the drawable area of the screen?  Currently, this is false only for
 7100-series and 8700-series devices.
<P>
<DL>
<DT><B>Since:</B></DT><DD>BlackBerry API 4.0.2</DD>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<BR>

<BR>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF">
<TH ALIGN="left" COLSPAN="1" CLASS="TableHeadingColor"><FONT SIZE="+0">
Constructor Detail</FONT></TH>
</TR>
</TABLE>

<A NAME="Graphics(net.rim.device.api.system.Bitmap)"><!-- --></A><H3>
Graphics</H3>
<PRE>
public <B>Graphics</B>(<A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system">Bitmap</A>&nbsp;bitmap)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use the static factory method, <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#create(net.rim.device.api.system.Bitmap)"><CODE>Graphics.create(Bitmap)</CODE></A>, instead.</I>
<P>
<DD>Constructs a Graphics object for drawing directly to a bitmap.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>bitmap</CODE> - Writeable bitmap to draw into; must not be null.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If your provided bitmap is not writeable
 or too large to fit into the drawing cache.</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<BR>

<BR>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF">
<TH ALIGN="left" COLSPAN="1" CLASS="TableHeadingColor"><FONT SIZE="+0">
Method Detail</FONT></TH>
</TR>
</TABLE>

<A NAME="create(net.rim.device.api.system.Bitmap)"><!-- --></A><H3>
create</H3>
<PRE>
public static <A HREF="../../../../../net/rim/device/api/ui/Graphics.html" title="class in net.rim.device.api.ui">Graphics</A> <B>create</B>(<A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system">Bitmap</A>&nbsp;bitmap)</PRE>
<DL>
<DD>Constructs a Graphics object for drawing to a bitmap.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>bitmap</CODE> - Writeable bitmap to draw into. Must not be null and must be
 the default bitmap type for the device.
<DT><B>Returns:</B><DD>Graphics object created from the provided bitmap.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If your provided bitmap is not writeable
 or too large to fit into the drawing chache.<DT><B>Since:</B></DT><DD>BlackBerry API 4.7.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="clear()"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>()</PRE>
<DL>
<DD>Clears the entire graphics area to the current background color.
 Note that global alpha is not applied in this case.
 If the background color contains alpha and the target surface contains alpha,
 the pixels are overwritten with the background color and include alpha; the old
 target surface content is ignored.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clear(int, int, int, int)"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>(int&nbsp;x,
                  int&nbsp;y,
                  int&nbsp;width,
                  int&nbsp;height)</PRE>
<DL>
<DD>Clears a region to the current background color.
 Note that global alpha is not applied in this case.
 If the background color contains alpha and the target surface contains alpha,
 the pixels are overwritten with the background color and include alpha; the old
 target surface content is ignored.

 <p> Use this method to clear only a region within the entire graphics
 area. You specify the region to clear by describing its extent in passed
 parameters. </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Left edge of the region.<DD><CODE>y</CODE> - Top edge of the region.<DD><CODE>width</CODE> - Width of the region.<DD><CODE>height</CODE> - Height of the region.</DL>
</DD>
</DL>
<HR>

<A NAME="clear(net.rim.device.api.ui.XYRect)"><!-- --></A><H3>
clear</H3>
<PRE>
public void <B>clear</B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;region)</PRE>
<DL>
<DD>Clears a region specified by an XYRect object to the current background color.
 Note that global alpha is not applied in this case.
 If the background color contains alpha and the target surface contains alpha,
 the pixels are overwritten with the background color and include alpha; the old
 target surface content is ignored.

 <p> Use this method to clear only a region within the entire graphics
 area. You specify the region to clear with an XYRect that you pass to
 this method. </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>region</CODE> - Rectangular region to clear.</DL>
</DD>
</DL>
<HR>

<A NAME="copyArea(int, int, int, int, int, int)"><!-- --></A><H3>
copyArea</H3>
<PRE>
public boolean <B>copyArea</B>(int&nbsp;x,
                        int&nbsp;y,
                        int&nbsp;width,
                        int&nbsp;height,
                        int&nbsp;dx,
                        int&nbsp;dy)</PRE>
<DL>
<DD>Copies a region of this graphics canvas.

 <p> Use this method to copy a region of the drawing buffer. You specify
 the source region by describing its extent in passed parameters. The
 source region is left intact (i.e. not cleared).

 <p> To paste the copy of the region to the left of or above the drawing
 anchor, specify a negative value for the <code>dx</code> or
 <code>dy</code> parameters.

 <p> If a portion of the source rectangle lies outside the bounds of the
 clipping region, this method does not copy the associated pixels. You can
 refresh the omitted area by invoking <A HREF="../../../../../net/rim/device/api/ui/Field.html#paint(net.rim.device.api.ui.Graphics)"><CODE>paint</CODE></A> on the
 component.

 <p> This method fails in situations where the pixels are not
 available. This can happen when a front buffer screen is obscuring this
 graphics context's screen. In this case, this method returns false; you
 should then prompt a full repaint by invoking
 <A HREF="../../../../../net/rim/device/api/ui/Screen.html#invalidate()"><CODE>invalidate</CODE></A> on the screen.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Left edge of the source region.<DD><CODE>y</CODE> - Top edge of the source region<DD><CODE>width</CODE> - Width of the source region.<DD><CODE>height</CODE> - Height of the source region.<DD><CODE>dx</CODE> - Horizontal distance to move the region.<DD><CODE>dy</CODE> - Vertical distance to move the region.
<DT><B>Returns:</B><DD>True if the copyArea was successful; otherwise, false.</DL>
</DD>
</DL>
<HR>

<A NAME="copyArea(net.rim.device.api.ui.XYRect, int, int)"><!-- --></A><H3>
copyArea</H3>
<PRE>
public boolean <B>copyArea</B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;region,
                        int&nbsp;dx,
                        int&nbsp;dy)</PRE>
<DL>
<DD>Copies a region of this graphics canvas, specified by an <A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui"><CODE>XYRect</CODE></A>.

 <p> Use this method to copy a region of the drawing buffer. You specify
 the source region with an <A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui"><CODE>XYRect</CODE></A> that you pass to this
 method. The source region is left intact (i.e. not cleared).

 <p> To paste the copy of the region to the left of or above the drawing
 anchor, specify a negative value for the <code>dx</code> and
 <code>dy</code> parameters.

 <p> If a portion of the source region lies outside the bounds of the
 clipping region, this method does not copy the associated pixels. You can
 refresh the omitted area by invoking <A HREF="../../../../../net/rim/device/api/ui/Field.html#paint(net.rim.device.api.ui.Graphics)"><CODE>Field.paint(net.rim.device.api.ui.Graphics)</CODE></A> on the component.

 <p> This method fails in situations where the pixels are not
 available. This can happen when a front buffer screen is obscuring this
 graphics context's screen. In this case, this method returns false; you
 should then prompt a full repaint by invoking
 <A HREF="../../../../../net/rim/device/api/ui/Screen.html#invalidate()"><CODE>invalidate</CODE></A> on the screen.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>region</CODE> - Source region to copy.<DD><CODE>dx</CODE> - Horizontal distance to move the region.<DD><CODE>dy</CODE> - Vertical distance to move the region.
<DT><B>Returns:</B><DD>True if the copyArea was successful; otherwise, false.</DL>
</DD>
</DL>
<HR>

<A NAME="drawARGB(int[], int, int, int, int, int, int)"><!-- --></A><H3>
drawARGB</H3>
<PRE>
public void <B>drawARGB</B>(int[]&nbsp;data,
                     int&nbsp;offset,
                     int&nbsp;scanLength,
                     int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height)</PRE>
<DL>
<DD>Similar to drawRGB, but source data also contains alpha.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - <description><DD><CODE>offset</CODE> - <description><DD><CODE>scanLength</CODE> - <description><DD><CODE>x</CODE> - <description><DD><CODE>y</CODE> - <description><DD><CODE>width</CODE> - <description><DD><CODE>height</CODE> - <description><DT><B>Since:</B></DT><DD>BlackBerry API 4.2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawArc(int, int, int, int, int, int)"><!-- --></A><H3>
drawArc</H3>
<PRE>
public void <B>drawArc</B>(int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;width,
                    int&nbsp;height,
                    int&nbsp;startAngle,
                    int&nbsp;arcAngle)</PRE>
<DL>
<DD>Draws an arc through a specified rectangle.

 <p> The center of the drawn arc is the center of a rectangle whose origin
 is <code>(x,y)</code> and whose size is specified by the
 <code>width</code> and <code>height</code> parameters.

 <p> The arc begins at <code>startAngle</code> and extends for
 <code>arcAngle</code> degrees, using the current draw color.  The drawing
 algorithm assumes that the 0 degree position is in the center of the
 right edge of the rectangle. The direction of the arc drawn depends on
 the relative values of <code>startAngle</code> and <code>arcAngle</code>:

 <ul>
 <li>If <code>(startAngle &lt; arcAngle)</code>, this method draws the arc
 in a counterclockwise direction.

 <li>If <code>startAngle &gt; arcAngle</code>, this method draws the arc
 in a clockwise direction.
 </ul>

 <p> The resulting arc covers an area <code>width</code> pixels wide by
 <code>height</code> pixels tall and end points are one pixel outside the
 extent of the rectangle).  If either width or height is less than zero,
 this method draws nothing.

 <p> The angles are specified relative to the non-square extents of the
 bounding rectangle such that 45 degrees always falls on the line from the
 center of the ellipse to the upper right corner of the bounding
 rectangle. As a result, if the bounding rectangle is noticeably longer in
 one axis than the other, the angles to the start and end of the arc
 segment will be skewed farther along the longer axis of the bounds.

 ATTENTION: This method doesn't support transformations specified in the
 setTransformation method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Horizontal coordinate of the arc's starting position.<DD><CODE>y</CODE> - Vertical coordinate of the arc's starting position.<DD><CODE>width</CODE> - Width of rectangle containing the arc.<DD><CODE>height</CODE> - Height of rectangle containing the arc.<DD><CODE>startAngle</CODE> - The angle position at which to commence drawing.<DD><CODE>arcAngle</CODE> - Angular extent of the arc, relative to the
 start angle.</DL>
</DD>
</DL>
<HR>

<A NAME="drawEllipse(int, int, int, int, int, int, int, int)"><!-- --></A><H3>
drawEllipse</H3>
<PRE>
public void <B>drawEllipse</B>(int&nbsp;cx,
                        int&nbsp;cy,
                        int&nbsp;px,
                        int&nbsp;py,
                        int&nbsp;qx,
                        int&nbsp;qy,
                        int&nbsp;startAngle,
                        int&nbsp;arcAngle)</PRE>
<DL>
<DD>Draws an ellipse.

 <p> Draws an ellipse with the specified endpoints P = (px, py) and
 Q = (qx, qy) of two conjugate diameters of the ellipse. The endpoints are
 specified as absolute coordinates.


 <p> This example shows an ellipse with the aligned p and q points.

 <p> <img src="doc-files/aligned_ellipse1.gif">

 <p> This example shows how the p and q points can be used to draw a non-aligned ellipse.

 <p> <img src="doc-files/nonAligned_ellipse1.gif">
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cx</CODE> - X-ordinate of the ellipse centre. cx is one of the coordinates of the center point of the ellipse.<DD><CODE>cy</CODE> - Y-ordinate of the ellipse centre.<DD><CODE>px</CODE> - X-ordinate of the point P. P is one of the coordinates of the tangents of a parallelogram
 that bounds the ellipse.  By convention, if the ellipse is aligned with the screen axes,
 the p point defines the x-axis radius.<DD><CODE>py</CODE> - Y-ordinate of the point P. P is one of the coordinates of the tangents of a parallelogram
 that bounds the ellipse.  By convention, if the ellipse is aligned with the screen axes,
 the p point defines the x-axis radius.<DD><CODE>qx</CODE> - X-ordinate of the point Q. Q is one of the coordinates of the tangents of a parallelogram
 that bounds the ellipse.  By convention, if the ellipse is aligned with the screen axes,
 the q point defines the y-axis radius.<DD><CODE>qy</CODE> - Y-ordinate of the point Q. Q is one of the coordinates of the tangents of a parallelogram
 that bounds the ellipse.  By convention, if the ellipse is aligned with the screen axes,
 the q point defines the y-axis radius.<DD><CODE>startAngle</CODE> - Arc start angle. Drawing starts at the angular position defined by the start angle
 (clockwise with zero degrees being the x-axis and x left, y down) and ends at an angular position
 equal to the start angle plus the arc angle. For example, if you set the start angle to 90 degrees
 and the arc angle to 90 degrees, the  ellipse starts at the y axis and continues to the x axis.<DD><CODE>arcAngle</CODE> - Angular extent of the arc, relative to the start angle.<DT><B>Since:</B></DT><DD>BlackBerry API 4.2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isRopSupported(int)"><!-- --></A><H3>
isRopSupported</H3>
<PRE>
public boolean <B>isRopSupported</B>(int&nbsp;rop)</PRE>
<DL>
<DD>Determines if a raster operation is supported.

 <p> Use this method to query if a particular raster operation is
 supported for the Graphics object. Note that all ROP2s as well as
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP_SRC_COPY"><CODE>Graphics.ROP_SRC_COPY</CODE></A>, <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP_SRCMONOEXPAND_COPY"><CODE>Graphics.ROP_SRCMONOEXPAND_COPY</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP_SRC_ALPHA"><CODE>Graphics.ROP_SRC_ALPHA</CODE></A> and <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP_SRCMONOEXPAND_ALPHA"><CODE>Graphics.ROP_SRCMONOEXPAND_ALPHA</CODE></A> are always
 supported.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rop</CODE> - Constant for the raster operation to query.
<DT><B>Returns:</B><DD>If true, specified raster operation is supported; otherwise,
 false.<DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="rop(int, int, int, int, int, net.rim.device.api.system.Bitmap, int, int)"><!-- --></A><H3>
rop</H3>
<PRE>
public void <B>rop</B>(int&nbsp;rop,
                int&nbsp;x,
                int&nbsp;y,
                int&nbsp;width,
                int&nbsp;height,
                <A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system">Bitmap</A>&nbsp;source,
                int&nbsp;left,
                int&nbsp;top)</PRE>
<DL>
<DD>Executes an area raster operation on the specified region.

 <p> Use this method to run a raster operation with or without a source
 bitmap.

 <p> You must specify the extent of the region to draw to, as well as the
 top left position in the (optional) source bitmap.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rop</CODE> - Constant for the raster operation to execute.<DD><CODE>x</CODE> - Left edge of the destination region.<DD><CODE>y</CODE> - Top edge of the destination region.<DD><CODE>width</CODE> - Width of the destination region.<DD><CODE>height</CODE> - Height of the destination region.<DD><CODE>source</CODE> - Source bitmap to use (may be null for some raster operations)<DD><CODE>left</CODE> - Left edge of region within bitmap to use.<DD><CODE>top</CODE> - Top edge of region within bitmap to use.<DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="tileRop(int, int, int, int, int, net.rim.device.api.system.Bitmap, int, int)"><!-- --></A><H3>
tileRop</H3>
<PRE>
public void <B>tileRop</B>(int&nbsp;rop,
                    int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;width,
                    int&nbsp;height,
                    <A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system">Bitmap</A>&nbsp;source,
                    int&nbsp;left,
                    int&nbsp;top)</PRE>
<DL>
<DD>Executes an area raster operation on the specified region, tiling the
 source bitmap if necessary.

 <p> Use this method to run a raster operation with or without a source
 bitmap.

 <p> You must specify the extent of the region to draw to, as well as the
 top left position in the (optional) source bitmap.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rop</CODE> - Constant for the raster operation to execute.<DD><CODE>x</CODE> - Left edge of the destination region.<DD><CODE>y</CODE> - Top edge of the destination region.<DD><CODE>width</CODE> - Width of the destination region.<DD><CODE>height</CODE> - Height of the destination region.<DD><CODE>source</CODE> - Source bitmap to use (may be null for some raster operations)<DD><CODE>left</CODE> - Left edge of region within bitmap to use.<DD><CODE>top</CODE> - Top edge of region within bitmap to use.<DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawBitmap(net.rim.device.api.ui.XYRect, net.rim.device.api.system.Bitmap, int, int)"><!-- --></A><H3>
drawBitmap</H3>
<PRE>
public void <B>drawBitmap</B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;dest,
                       <A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system">Bitmap</A>&nbsp;bitmap,
                       int&nbsp;left,
                       int&nbsp;top)</PRE>
<DL>
<DD>Draws a bitmap on a region specified by an <A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui"><CODE>XYRect</CODE></A> object.

 <p> Use this method to draw a bitmap. You specify the destination region
 for the bitmap with an XYRect that you pass to this method.

 <p> You must also specify the extent of the bitmap to draw (the top left
 corner of this extent defined by the <code>top</code> and
 <code>left</code> parameters). If a portion of part of the bitmap you
 want to draw falls outside the size of the destination region, this
 method crops to fit.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dest</CODE> - Destination region in which to draw the bitmap.<DD><CODE>bitmap</CODE> - Bitmap to draw.<DD><CODE>left</CODE> - Left edge of region within bitmap to draw.<DD><CODE>top</CODE> - Top edge of region within bitmap to draw.</DL>
</DD>
</DL>
<HR>

<A NAME="drawBitmap(int, int, int, int, net.rim.device.api.system.Bitmap, int, int)"><!-- --></A><H3>
drawBitmap</H3>
<PRE>
public void <B>drawBitmap</B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height,
                       <A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system">Bitmap</A>&nbsp;bitmap,
                       int&nbsp;left,
                       int&nbsp;top)</PRE>
<DL>
<DD>Draws a bitmap.

 <p> Use this method to draw a bitmap. You specify the destination region
 for the bitmap by describing the extent of the region with passed
 parameters.

 <p> You must also specify the extent of the bitmap to draw (the top left
 corner of this extent defined by the <code>top</code> and
 <code>left</code> parameters). If a portion of part of the bitmap you
 want to draw falls outside the size of the destination region, this
 method crops to fit.

 <p> Pixels are drawn exactly as in the Bitmap, with no color transformations.
 To have a monochrome image act like a rubber stamp, use <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#rop(int, int, int, int, int, net.rim.device.api.system.Bitmap, int, int)"><CODE>Graphics.rop(int, int, int, int, int, net.rim.device.api.system.Bitmap, int, int)</CODE></A> with
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP_SRCMONOEXPAND_COPY"><CODE>Graphics.ROP_SRCMONOEXPAND_COPY</CODE></A> or <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP_SRCMONOEXPAND_ALPHA"><CODE>Graphics.ROP_SRCMONOEXPAND_ALPHA</CODE></A>. </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Left edge of the destination region.<DD><CODE>y</CODE> - Top edge of the destination region.<DD><CODE>width</CODE> - Width of the destination region.<DD><CODE>height</CODE> - Height of the destination region.<DD><CODE>bitmap</CODE> - Bitmap to draw.<DD><CODE>left</CODE> - Left edge of region within bitmap to draw.<DD><CODE>top</CODE> - Top edge of region within bitmap to draw.</DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(net.rim.device.api.ui.XYRect, net.rim.device.api.system.EncodedImage, int, int, int)"><!-- --></A><H3>
drawImage</H3>
<PRE>
public void <B>drawImage</B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;dest,
                      <A HREF="../../../../../net/rim/device/api/system/EncodedImage.html" title="class in net.rim.device.api.system">EncodedImage</A>&nbsp;image,
                      int&nbsp;frameIndex,
                      int&nbsp;left,
                      int&nbsp;top)</PRE>
<DL>
<DD>Draws an encoded image on a region specified by an <A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui"><CODE>XYRect</CODE></A> object.

 <p> Use this method to draw an image. You specify the destination region
 for the image with an XYRect that you pass to this method.

 <p> The region to be drawn is decoded, drawn and then thrown away. Thus
 if you plan to draw a full encoded image multiple times it is faster to
 first decode into a <A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system"><CODE>Bitmap</CODE></A> object and draw that.

 <p> You must also specify the extent of the image to draw (the top left
 corner of this extent defined by the <code>top</code> and
 <code>left</code> parameters). If a portion of part of the image you want
 to draw falls outside the size of the destination region, this method
 crops to fit.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>dest</CODE> - Destination region in which to draw the bitmap.<DD><CODE>image</CODE> - Encoded image to draw<DD><CODE>frameIndex</CODE> - The frame to draw<DD><CODE>left</CODE> - Left edge of region within bitmap to draw.<DD><CODE>top</CODE> - Top edge of region within bitmap to draw.<DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(int, int, int, int, net.rim.device.api.system.EncodedImage, int, int, int)"><!-- --></A><H3>
drawImage</H3>
<PRE>
public void <B>drawImage</B>(int&nbsp;x,
                      int&nbsp;y,
                      int&nbsp;width,
                      int&nbsp;height,
                      <A HREF="../../../../../net/rim/device/api/system/EncodedImage.html" title="class in net.rim.device.api.system">EncodedImage</A>&nbsp;image,
                      int&nbsp;frameIndex,
                      int&nbsp;left,
                      int&nbsp;top)</PRE>
<DL>
<DD>Draws an encoded image.

 <p> Use this method to draw an encoded image. You specify the destination
 region for the bitmap by describing the extent of the region with passed
 parameters.

 <p> The region to be drawn is decoded, drawn and then thrown away. Thus
 if you plan to draw a full encoded image multiple times it is faster to
 first decode into a <A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system"><CODE>Bitmap</CODE></A> object and draw that.

 <p> You must also specify the extent of the image to draw (the top left
 corner of this extent defined by the <code>top</code> and
 <code>left</code> parameters). If a portion of part of the image you want
 to draw falls outside the size of the destination region, this method
 crops to fit.

 <p> Pixels are drawn exactly as in the Bitmap, with no color transformations.
 To have a monochrome image act like a rubber stamp, use <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#rop(int, int, int, int, int, net.rim.device.api.system.Bitmap, int, int)"><CODE>Graphics.rop(int, int, int, int, int, net.rim.device.api.system.Bitmap, int, int)</CODE></A> with
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP_SRCMONOEXPAND_COPY"><CODE>Graphics.ROP_SRCMONOEXPAND_COPY</CODE></A> or <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#ROP_SRCMONOEXPAND_ALPHA"><CODE>Graphics.ROP_SRCMONOEXPAND_ALPHA</CODE></A>. </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Left edge of the destination region.<DD><CODE>y</CODE> - Top edge of the destination region.<DD><CODE>width</CODE> - Width of the destination region.<DD><CODE>height</CODE> - Height of the destination region.<DD><CODE>image</CODE> - Encoded image to draw.<DD><CODE>frameIndex</CODE> - The frame to draw<DD><CODE>left</CODE> - Left edge of region within bitmap to draw.<DD><CODE>top</CODE> - Top edge of region within bitmap to draw.<DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawFilledPath(int[], int[], byte[], int[])"><!-- --></A><H3>
drawFilledPath</H3>
<PRE>
public void <B>drawFilledPath</B>(int[]&nbsp;xPts,
                           int[]&nbsp;yPts,
                           byte[]&nbsp;pointTypes,
                           int[]&nbsp;offsets)</PRE>
<DL>
<DD>Draws a set of filled paths.

 <p> Use this method to draw one or more filled non-intersecting paths
 that contain line segments or curves. You specify the x and y coordinates
 and point types of the paths desired.

 <p> The offsets indicate the beginnings of each path in the data
 array. The data in the i<sup>th</sup> path is defined to be the
 (xPts,yPts) values from offsets[i] to offsets[i+1]-1 inclusive.  Thus if
 there are N values in offsets, there are N-1 paths defined, where the
 final value is one greater than the offset where the final point of the
 final path is located in the points data. If offsets is null, the xPts
 and yPts data will be treated as a single path, and these arrays must
 have the same length.

 <p> The xPts and yPts arrays keep track of each vertex in the polygon and
 each value in the xPts array must have a corresponding value at the same
 index in the yPts array, and a corresponding value at the same index in
 the pointTypes array.

 <p> None of the edges in a path may cross any other edge in any of the
 paths (including itself). If edges do cross, the drawing behaviour is
 undefined. A path may be fully contained within another path, e.g. a
 "donut" shape.

 <p> The paths are filled by the "even-odd" rule.  Thus if a ray is drawn
 from any point, the area containing the point will be filled if the ray
 passes through an odd number of edges and will not be filled if is passes
 through an even number of edges.

 <p> Note that each non-null array parameter must be a different array.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xPts</CODE> - Ordered list of x values for each vertex in the paths.<DD><CODE>yPts</CODE> - Ordered list of y values for each vertex in the paths.<DD><CODE>pointTypes</CODE> - One of <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</CODE></A>,
 or <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</CODE></A>.  There must be one of
 these values for each (x,y) point defined. If pointTypes is null, all
 point are assumed to be of type <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>.
 <p> If a point's value is <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>, then a line or
 curve ends on this point.  If a curve control point is next to this
 point, a curve will have this point as an endpoint.  Otherwise, straight
 lines are drawn between successive end points.
 <p> If a point's value is <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</CODE></A>,
 the point is a control point for a quadratic bezier. The control point of
 a quadratic bezier is the single point that "stretches" the curve away
 from the end points. If a point is a quadratic bezier control point, the
 points preceeding and succeeding it must be end points
 (<A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>).
 <p> If a point's value is <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</CODE></A>,
 the point is a control point for a cubic bezier. A cubic bezier has two
 control points that "stretch" the curve away from the end points.  Cubic
 bezier control points must come in sets of two, with end points
 (<A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>) coming before the first control point and
 after the second.<DD><CODE>offsets</CODE> - List defining the beginnings of each path in the xPts/yPts
 data arrays, or null to indicate a single path.  A path that begins at
 point (xPts[offsets[i]],yPts[offsets[i]]) will end at point
 (xPts[offsets[i+1]]-1,yPts[offsets[i+1]]-1).
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If the data is malformed. For example,
 the values in offsets is negative or not in increasing order, there are
 fewer than 2 points in a single path, the values in offsets index outside
 the points arrays, the values in pointTypes are invalid, or offsets is
 null and xPts and yPts are not the same length.<DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawShadedFilledPath(int[], int[], byte[], int[], int[])"><!-- --></A><H3>
drawShadedFilledPath</H3>
<PRE>
public void <B>drawShadedFilledPath</B>(int[]&nbsp;xPts,
                                 int[]&nbsp;yPts,
                                 byte[]&nbsp;pointTypes,
                                 int[]&nbsp;colors,
                                 int[]&nbsp;offsets)</PRE>
<DL>
<DD>Draws a set of shaded filled paths.

 <p> Use this method to draw one or more filled non-intersecting paths
 that contain line segments and curves. You specify the x and y
 coordinates and point types of the paths desired as well as the color
 values of each vertex which will be blended together creating the shading
 effect.

 <p> The offsets indicate the beginnings of each path in the data
 array. The data in the i<sup>th</sup> path is defined to be the
 (xPts,yPts) values from offsets[i] to offsets[i+1]-1 inclusive.  Thus if
 there are N values in offsets, there are N-1 paths defined, where the
 final value is one greater than the offset where the final point of the
 final path is located in the points data. If offsets is null, the xPts
 and yPts data will be treated as a single path, and these arrays must
 have the same length.

 <p> The xPts and yPts arrays keep track of each vertex in the polygon and
 each value in the xPts array must have a corresponding value at the same
 index in the yPts array, and a corresponding value at the same index in
 the pointTypes array. Similarly the color array stores the RGB color of
 each vertex ( in 0x00RRGGBB format ) and its indices must correspond with
 those of both the xPts and yPts arrays.

 <p> None of the edges in a path may cross any other edge in any of the
 paths (including itself). If edges do cross, the drawing behaviour is
 undefined. A path may be fully contained within another path, for
 example, a "donut" shape.

 <p> The paths are filled by the "even-odd" rule.  Thus if a ray is drawn
 from any point, the area containing the point will be filled if the ray
 passes through an odd number of edges and will not be filled if is passes
 through an even number of edges.

 <p> Note that each non-null array parameter must be a different array.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xPts</CODE> - Ordered list of x values for each vertex in the paths.<DD><CODE>yPts</CODE> - Ordered list of y values for each vertex in the paths.<DD><CODE>pointTypes</CODE> - One of <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</CODE></A>,
 or <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</CODE></A>. There must be one of
 these values for each (x,y) point defined. If pointTypes is null, all
 point are assumed to be of type <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>.
 <p> If a point's value is <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>, then a line or
 curve ends on this point.  If a curve control point is next to this
 point, a curve will have this point as an endpoint.  Otherwise, straight
 lines are drawn between successive end points.
 <p> If a point's value is
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</CODE></A>, the point is a
 control point for a quadratic bezier. The control point of a quadratic
 bezier is the single point that "stretches" the curve awway from the end
 points. If a point is a quadratic bezier control point, the points
 preceeding and succeeding it must be end points (<A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>).
 <p> If a point's value is <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</CODE></A>,
 the point is a control point for a cubic bezier. A cubic bezier has two
 control points that "stretch" the curve away from the end points.  Cubic
 bezier control points must come in sets of two, with end points
 (<A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>) coming before the first control point and after
 the second.<DD><CODE>colors</CODE> - Ordered list of color values for each vertex ( 0x00RRGGBB
 format ). If null, a solid filled path will be drawn in the current
 foreground color.<DD><CODE>offsets</CODE> - List defining the beginnings of each path in the xPts/yPts
 data arrays, or null to indicate a single path. A path that begins at
 point (xPts[offsets[i]],yPts[offsets[i]]) will end at point
 (xPts[offsets[i+1]]-1,yPts[offsets[i+1]]-1).
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If the data is malformed.  For example,
 the values in offsets is negative or not in increasing order, there are
 fewer than 2 points in a single path, the values in offsets index outside
 the points arrays, the values in pointTypes are invalid, or offsets is
 null and xPts and yPts are not the same length.<DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawPathOutline(int[], int[], byte[], int[], boolean)"><!-- --></A><H3>
drawPathOutline</H3>
<PRE>
public void <B>drawPathOutline</B>(int[]&nbsp;xPts,
                            int[]&nbsp;yPts,
                            byte[]&nbsp;pointTypes,
                            int[]&nbsp;offsets,
                            boolean&nbsp;closed)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use Graphics.drawOutlinedPath(int[],int[],byte[],int[],boolean).</I>
<P>
<DD>Draw a set of path outlines.

 <p> Use this method to draw a set of path outlines that contains line
 segments and curves.  The xPts and yPts arrays keep track of each vertex
 in the path.  Each value in the xPts array must have corresponding values
 at the same index in the yPts array and the pointTypes array.

 <p> The offsets array keeps track of the locations of each path in the
 set of paths. If offsets is null, the xPts and yPts data will be treated
 as a single path, and these arrays must have the same length.

 <p> Note that each non-null array parameter must be a different array.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xPts</CODE> - Ordered list of x values for each vertex in the paths.<DD><CODE>yPts</CODE> - Ordered list of y values for each vertex in the paths.<DD><CODE>pointTypes</CODE> - One of Graphics.<A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</CODE></A>,
 or <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</CODE></A>. There must be one of
 these values for each (x,y) point defined. If pointTypes is null, all
 point are assumed to be of type <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>.
 <p> If a point's value is <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>, then a line or
 curve ends on this point.  If a curve control point is next to this
 point, a curve will have this point as an endpoint.  Otherwise, straight
 lines are drawn between successive end points.
 <p> If a point's value is <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</CODE></A>,
 the point is a control point for a quadratic bezier. The control point of a
 quadratic bezier is the single point that "stretches" the curve awway
 from the end points.  If a point is a quadratic bezier control point, the
 points preceeding and succeeding it must be end points
 (<A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>).
 <p> If a point's value is <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</CODE></A>,
 the point is a control point for a cubic bezier. A cubic bezier has two
 control points that "stretch" the curve away from the end points.  Cubic
 bezier control points must come in sets of two, with end points
 (<A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>) coming before the first control point and after
 the second.<DD><CODE>offsets</CODE> - List defining the beginnings of each path in the xPts/yPts
 data arrays, or null to indicate a single path. A path that begins at
 point (xPts[offsets[i]],yPts[offsets[i]]) will end at point
 (xPts[offsets[i+1]]-1,yPts[offsets[i+1]]-1).<DD><CODE>closed</CODE> - If this value is true, each path in the set will be closed
 by connecting the final point in the path's data with the first point.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If the data is malformed.  e.g. the
 values in offsets is negative or not in increasing order, there are fewer
 than 2 points in a single path, the values in offsets index outside the
 points arrays, the values in pointTypes are invalid, or offsets is null
 and xPts and yPts are not the same length.<DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawOutlinedPath(int[], int[], byte[], int[], boolean)"><!-- --></A><H3>
drawOutlinedPath</H3>
<PRE>
public void <B>drawOutlinedPath</B>(int[]&nbsp;xPts,
                             int[]&nbsp;yPts,
                             byte[]&nbsp;pointTypes,
                             int[]&nbsp;offsets,
                             boolean&nbsp;closed)</PRE>
<DL>
<DD>Draw a set of path outlines.

 <p> Use this method to draw a set of path outlines that contains line
 segments and curves.  The xPts and yPts arrays keep track of each vertex
 in the path.  Each value in the xPts array must have corresponding values
 at the same index in the yPts array and the pointTypes array.

 <p> The offsets array keeps track of the locations of each path in the
 set of paths. If offsets is null, the xPts and yPts data will be treated
 as a single path, and these arrays must have the same length.

 <p> Note that each non-null array parameter must be a different array.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xPts</CODE> - Ordered list of x values for each vertex in the paths.<DD><CODE>yPts</CODE> - Ordered list of y values for each vertex in the paths.<DD><CODE>pointTypes</CODE> - One of Graphics.<A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</CODE></A>,
 or <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</CODE></A>. There must be one of
 these values for each (x,y) point defined. If pointTypes is null, all
 point are assumed to be of type <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>.
 <p> If a point's value is <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>, then a line or
 curve ends on this point.  If a curve control point is next to this
 point, a curve will have this point as an endpoint.  Otherwise, straight
 lines are drawn between successive end points.
 <p> If a point's value is <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</CODE></A>,
 the point is a control point for a quadratic bezier. The control point of a
 quadratic bezier is the single point that "stretches" the curve awway
 from the end points.  If a point is a quadratic bezier control point, the
 points preceeding and succeeding it must be end points
 (<A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>).
 <p> If a point's value is <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</CODE></A>,
 the point is a control point for a cubic bezier. A cubic bezier has two
 control points that "stretch" the curve away from the end points.  Cubic
 bezier control points must come in sets of two, with end points
 (<A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>) coming before the first control point and after
 the second.<DD><CODE>offsets</CODE> - List defining the beginnings of each path in the xPts/yPts
 data arrays, or null to indicate a single path. A path that begins at
 point (xPts[offsets[i]],yPts[offsets[i]]) will end at point
 (xPts[offsets[i+1]]-1,yPts[offsets[i+1]]-1).<DD><CODE>closed</CODE> - If this value is true, each path in the set will be closed
 by connecting the final point in the path's data with the first point.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If the data is malformed.  e.g. the
 values in offsets is negative or not in increasing order, there are fewer
 than 2 points in a single path, the values in offsets index outside the
 points arrays, the values in pointTypes are invalid, or offsets is null
 and xPts and yPts are not the same length.<DT><B>Since:</B></DT><DD>BlackBerry API 5.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawTexturedPath(int[], int[], byte[], int[], int, int, int, int, int, int, net.rim.device.api.system.Bitmap)"><!-- --></A><H3>
drawTexturedPath</H3>
<PRE>
public void <B>drawTexturedPath</B>(int[]&nbsp;xPts,
                             int[]&nbsp;yPts,
                             byte[]&nbsp;pointTypes,
                             int[]&nbsp;offsets,
                             int&nbsp;xOrigin,
                             int&nbsp;yOrigin,
                             int&nbsp;dux,
                             int&nbsp;dvx,
                             int&nbsp;duy,
                             int&nbsp;dvy,
                             <A HREF="../../../../../net/rim/device/api/system/Bitmap.html" title="class in net.rim.device.api.system">Bitmap</A>&nbsp;textureData)</PRE>
<DL>
<DD>Draws a set of texture-filled paths.

 <p> Use this method to draw one or more texture-filled non-intersecting
 paths that contain line segments or curves. You specify the x and y
 coordinates and point types of the paths desired.

 <p><b>Specifying the positions of the vertices</b>. The xPts and yPts arrays keep
 track of each vertex in the polygon and each value in the xPts array must
 have a corresponding value at the same index in the yPts array.

 <p><b>Specifying the type of each vertex</b>. The pointTypes array
 encodes the type of each point along the textured path: for example, the
 third element in the pointTypes array describes the function of the
 vertex at the position described by the third element in each of the xPts
 and yPts arrays. The values in the pointTypes array match static
 constants in this class, and should be equal to <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</CODE></A>,
 or <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</CODE></A>.

 <p> If a point's value is <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>, then a line or
 curve ends on this point. If a curve control point is next to this point,
 a curve will have this point as an endpoint. Otherwise, straight lines
 are drawn between successive end points. This is the default value for
 points (and if the pointTypes array is null, all points are assumed to be
 end points).

 <p> If a point's value is <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</CODE></A>,
 the point is a control point for a quadratic bezier. The control point
 of a quadratic bezier is the single point that "stretches" the curve away
 from the end points.  If a point is a quadratic bezier control point, the
 points preceeding and succeeding it must be end points.

 <p> If a point's value is <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</CODE></A>,
 the point is a control point for a cubic bezier. A cubic bezier has two
 control points that "stretch" the curve away from the end points.  Cubic
 bezier control points must come in sets of two, with end points coming
 before the first control point and after the second.

 <p><b>Specifying the paths between vertices</b>. The array of offset
 values indicates the beginnings of each path in the data array. The data
 in the i<sup>th</sup> path is defined to be the (xPts,yPts) values from
 offsets[i] to offsets[i+1]-1 inclusive.  Thus if there are N values in
 offsets, there are N-1 paths defined, where the final value is one
 greater than the offset where the final point of the final path is
 located in the points data. If offsets is null, the xPts and yPts data
 will be treated as a single path, and these arrays must have the same
 length.

 <p> None of the edges in a path may cross any other edge in any of the
 paths (including itself). If edges do cross, the drawing behaviour is
 undefined.  A path may be fully contained within another path, e.g. a
 "donut" shape.

 <p> The paths are filled by the "even-odd" rule. Thus if a ray is drawn
 from any point, the area containing the point will be filled if the ray
 passes through an odd number of edges and will not be filled if is passes
 through an even number of edges.

 <p><b>Specifying the texture to draw with</b>. You provide a bitmap to
 indicate the texture to draw with, in the textureData parameter.
 Starting from the texture origin (as specified in local coordinates by
 <code>xOrigin</code> and <code>yOrigin</code>), this method maps the
 texture into the path, tiling as necessary to fill the region.

 <p> You use two walk vectors (<code>dux</code>, <code>dvx</code>) and
 (<code>duy</code>, <code>dvy</code>) to describe the scale and angle the
 method should use to map the texture: u and v are taken to correspond to
 x and y, but in texture-space rather than in
 screen-space. <code>dux</code> and <code>dvx</code> indicate how many u
 and v coordinates to skip in the texture per x coordinate on the
 screen. Likewise, <code>duy</code> and <code>dvy</code> indicate how many
 texture coordinates to skip per y coordinate on the screen. These four
 values are represented in 15.16 fixed point, allowing for eight bits of
 decimal precision. Using these walk vectors it is possible to achieve
 arbitrary rotation, scaling, and skewing on a given texture.

 <p><b>Note</b>: Each non-null array parameter must be a different array.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xPts</CODE> - Ordered list of x values for each vertex in the paths.<DD><CODE>yPts</CODE> - Ordered list of y values for each vertex in the paths.<DD><CODE>pointTypes</CODE> - Ordered list of point types corresponding to the list.<DD><CODE>offsets</CODE> - List defining the beginnings of each path in the
 xPts/yPts data arrays, or null to indicate a single path.  A path that
 begins at point (xPts[offsets[i]],yPts[offsets[i]]) will end at point
 (xPts[offsets[i+1]]-1,yPts[offsets[i+1]]-1).<DD><CODE>xOrigin</CODE> - X component of the texture origin in local screen
 coordinates.<DD><CODE>yOrigin</CODE> - Y component of the texture origin in local screen
 coordinates.<DD><CODE>dux</CODE> - Number of u points to skip in the texture per x point on
 screen (15.16 fixed point).<DD><CODE>dvx</CODE> - Number of v points to skip in the texture per x point on
 screen (15.16 fixed point).<DD><CODE>duy</CODE> - Number of u points to skip in the texture per y point on
 screen (15.16 fixed point).<DD><CODE>dvy</CODE> - Number of v points to skip in the texture per y point on
 screen (15.16 fixed point).<DD><CODE>textureData</CODE> - Non-null bitmap to be used as a texture.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If the data is malformed. For example,
 the values in offsets is negative or not in increasing order, there are
 fewer than 2 points in a single path, the values in offsets index outside
 the points arrays, the values in pointTypes are invalid, or offsets is
 null and xPts and yPts are not the same length.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If texture bitmap is null.
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - If texture bitmap is empty, i.e. width or height is zero.<DT><B>Since:</B></DT><DD>BlackBerry API 4.2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawTextOnPath(java.lang.StringBuffer, int, int, int, int, int[], int[], byte[], int[], net.rim.device.api.ui.DrawTextParam, net.rim.device.api.ui.TextMetrics)"><!-- --></A><H3>
drawTextOnPath</H3>
<PRE>
public int <B>drawTextOnPath</B>(<A HREF="../../../../../java/lang/StringBuffer.html" title="class in java.lang">StringBuffer</A>&nbsp;aText,
                          int&nbsp;aOffset,
                          int&nbsp;aLength,
                          int&nbsp;aOriginX,
                          int&nbsp;aOriginY,
                          int[]&nbsp;aXPoints,
                          int[]&nbsp;aYPoints,
                          byte[]&nbsp;aPointTypes,
                          int[]&nbsp;aContourStarts,
                          <A HREF="../../../../../net/rim/device/api/ui/DrawTextParam.html" title="class in net.rim.device.api.ui">DrawTextParam</A>&nbsp;aParam,
                          <A HREF="../../../../../net/rim/device/api/ui/TextMetrics.html" title="class in net.rim.device.api.ui">TextMetrics</A>&nbsp;aMetrics)</PRE>
<DL>
<DD>Draws text along a path.

 <p> This method draws the text along a path made up of straight line
 segments and curves. The curves are quadratic or cubic Bezier splines. A path
 is made up of one or more separate contours.

 <p> Note that each non-null array parameter must be a different array.

 <p> The coordinates of the path are pixels, relative to a specified origin. To use
 absolute path coordinates supply an origin of (0,0).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>aText</CODE> - The text to draw.<DD><CODE>aOffset</CODE> - The start index of the text.<DD><CODE>aLength</CODE> - The number of characters to draw.<DD><CODE>aOriginX</CODE> - The x part of the origin of the path coordinate system.<DD><CODE>aOriginY</CODE> - The y part of the origin of the path coordinate system.<DD><CODE>aXPoints</CODE> - An array of x coordinates for the path.<DD><CODE>aYPoints</CODE> - An array of y coordinates for the path.<DD><CODE>aPointTypes</CODE> - If non-null, an array of point types. If it is null,
 or if it contains fewer values than the points arrays, missing values
 are taken to be on-curve points. Each point type must be either
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</CODE></A>, or
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</CODE></A>.<DD><CODE>aContourStarts</CODE> - If non-null, an array of indexes of contour (sub-path) starts.
 Each contour contains all the points from aContourStarts[N] to aContourStarts[N+1]-1,
 except for the last contour, which contains all remaining points.<DD><CODE>aParam</CODE> - Text drawing parameters. If null, use default parameters.<DD><CODE>aMetrics</CODE> - If not null, this parameter receives the metrics of the
 text drawn.
<DT><B>Returns:</B><DD>The length of the text drawn along the path, in pixels.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - or NullPointerException.<DT><B>Since:</B></DT><DD>BlackBerry API 6.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawTextOnPath(java.lang.String, int, int, int, int, int[], int[], byte[], int[], net.rim.device.api.ui.DrawTextParam, net.rim.device.api.ui.TextMetrics)"><!-- --></A><H3>
drawTextOnPath</H3>
<PRE>
public int <B>drawTextOnPath</B>(<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;aText,
                          int&nbsp;aOffset,
                          int&nbsp;aLength,
                          int&nbsp;aOriginX,
                          int&nbsp;aOriginY,
                          int[]&nbsp;aXPoints,
                          int[]&nbsp;aYPoints,
                          byte[]&nbsp;aPointTypes,
                          int[]&nbsp;aContourStarts,
                          <A HREF="../../../../../net/rim/device/api/ui/DrawTextParam.html" title="class in net.rim.device.api.ui">DrawTextParam</A>&nbsp;aParam,
                          <A HREF="../../../../../net/rim/device/api/ui/TextMetrics.html" title="class in net.rim.device.api.ui">TextMetrics</A>&nbsp;aMetrics)</PRE>
<DL>
<DD>Draws text along a path.

 <p>This method draws the text along a path made up of straight line
 segments and curves. The curves are quadratic or cubic Bezier splines. A path
 is made up of one or more separate contours.

 <p>Note that each non-null array parameter must be a different array.

 <p>The coordinates of the path are pixels, relative to a specified origin. To use
 absolute path coordinates supply an origin of (0,0).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>aText</CODE> - The text to draw.<DD><CODE>aOffset</CODE> - The start index of the text.<DD><CODE>aLength</CODE> - The number of characters to draw.<DD><CODE>aOriginX</CODE> - The x part of the origin of the path coordinate system.<DD><CODE>aOriginY</CODE> - The y part of the origin of the path coordinate system.<DD><CODE>aXPoints</CODE> - An array of x coordinates for the path.<DD><CODE>aYPoints</CODE> - An array of y coordinates for the path.<DD><CODE>aPointTypes</CODE> - If non-null, an array of point types. If it is null,
 or if it contains fewer values than the points arrays, missing values
 are taken to be on-curve points. Each point type must be either
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</CODE></A>, or
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</CODE></A><DD><CODE>aContourStarts</CODE> - If non-null, an array of indexes of contour (sub-path) starts.
 Each contour contains all the points from aContourStarts[N] to aContourStarts[N + 1] - 1,
 except for the last contour, which contains all remaining points.<DD><CODE>aParam</CODE> - Text drawing parameters. If null, use default parameters.<DD><CODE>aMetrics</CODE> - If non-null, this parameter receives the metrics of the text drawn.
<DT><B>Returns:</B><DD>The length of the text drawn along the path, in pixels.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - or NullPointerException.<DT><B>Since:</B></DT><DD>BlackBerry API 6.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawTextOnPath(char[], int, int, int, int, int[], int[], byte[], int[], net.rim.device.api.ui.DrawTextParam, net.rim.device.api.ui.TextMetrics)"><!-- --></A><H3>
drawTextOnPath</H3>
<PRE>
public int <B>drawTextOnPath</B>(char[]&nbsp;aText,
                          int&nbsp;aOffset,
                          int&nbsp;aLength,
                          int&nbsp;aOriginX,
                          int&nbsp;aOriginY,
                          int[]&nbsp;aXPoints,
                          int[]&nbsp;aYPoints,
                          byte[]&nbsp;aPointTypes,
                          int[]&nbsp;aContourStarts,
                          <A HREF="../../../../../net/rim/device/api/ui/DrawTextParam.html" title="class in net.rim.device.api.ui">DrawTextParam</A>&nbsp;aParam,
                          <A HREF="../../../../../net/rim/device/api/ui/TextMetrics.html" title="class in net.rim.device.api.ui">TextMetrics</A>&nbsp;aMetrics)</PRE>
<DL>
<DD>Draws text along a path.

 <p>This method draws the text along a path made up of straight line
 segments and curves. The curves are quadratic or cubic Bezier splines. A path
 is made up of one or more separate contours.

 <p>Note that each non-null array parameter must be a different array.

 <p>The coordinates of the path are pixels, relative to a specified origin. To use
 absolute path coordinates supply an origin of (0,0).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>aText</CODE> - The text to draw.<DD><CODE>aOffset</CODE> - The start index of the text.<DD><CODE>aLength</CODE> - The number of characters to draw.<DD><CODE>aOriginX</CODE> - The x part of the origin of the path coordinate system.<DD><CODE>aOriginY</CODE> - The y part of the origin of the path coordinate system.<DD><CODE>aXPoints</CODE> - An array of x coordinates for the path.<DD><CODE>aYPoints</CODE> - An array of y coordinates for the path.<DD><CODE>aPointTypes</CODE> - If non-null, an array of point types. If it is null,
 or if it contains fewer values than the points arrays, missing values
 are taken to be on-curve points. Each point type must be either
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_END_POINT"><CODE>Graphics.CURVEDPATH_END_POINT</CODE></A>,
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_QUADRATIC_BEZIER_CONTROL_POINT</CODE></A>, or
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT"><CODE>Graphics.CURVEDPATH_CUBIC_BEZIER_CONTROL_POINT</CODE></A><DD><CODE>aContourStarts</CODE> - If non-null, an array of indexes of contour (sub-path) starts.
 Each contour contains all the points from aContourStarts[N] to aContourStarts[N + 1] - 1,
 except for the last contour, which contains all remaining points.<DD><CODE>aParam</CODE> - Text drawing parameters. If null, use default parameters.<DD><CODE>aMetrics</CODE> - If non-null, this parameter receives the metrics of the text drawn.
<DT><B>Returns:</B><DD>The length of the text drawn along the path, in pixels.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - or NullPointerException.<DT><B>Since:</B></DT><DD>BlackBerry API 6.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawLine(int, int, int, int)"><!-- --></A><H3>
drawLine</H3>
<PRE>
public void <B>drawLine</B>(int&nbsp;x1,
                     int&nbsp;y1,
                     int&nbsp;x2,
                     int&nbsp;y2)</PRE>
<DL>
<DD>Draws a line.

 <p> Use this method to draw a line; you specify coordinates for the
 endpoints of the line.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x1</CODE> - Horizontal position of the line's starting point.<DD><CODE>y1</CODE> - Vertical position of the line's starting point.<DD><CODE>x2</CODE> - Horizontal position of the line's ending point.<DD><CODE>y2</CODE> - Vertical position of the line's ending point.</DL>
</DD>
</DL>
<HR>

<A NAME="drawPoint(int, int)"><!-- --></A><H3>
drawPoint</H3>
<PRE>
public void <B>drawPoint</B>(int&nbsp;x,
                      int&nbsp;y)</PRE>
<DL>
<DD>Draws a point.

 <p> This method draws the pixel located at a coordinate you specify.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Horizontal position of the point to draw.<DD><CODE>y</CODE> - Vertical position of the point to draw.</DL>
</DD>
</DL>
<HR>

<A NAME="drawRect(int, int, int, int)"><!-- --></A><H3>
drawRect</H3>
<PRE>
public void <B>drawRect</B>(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height)</PRE>
<DL>
<DD>Draws a rectangle.

 <p> Use this method to draw a rectangle. You specify the top and left
 edges of the rectangle, and its width and height. This method draws the
 right edge of the rectangle at <code>(x+width-1)</code>, the bottom edge
 at <code>(y+height-1)</code>. The resulting rectangle will thus have an
 area of <code>(width * height)</code>.

 <p> If you pass in a zero or negative value for either the height or
 width, this method draws nothing.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Left edge of the rectangle.<DD><CODE>y</CODE> - Top edge of the rectangle.<DD><CODE>width</CODE> - Width of the rectangle.<DD><CODE>height</CODE> - Height of the rectangle.</DL>
</DD>
</DL>
<HR>

<A NAME="drawRoundRect(int, int, int, int, int, int)"><!-- --></A><H3>
drawRoundRect</H3>
<PRE>
public void <B>drawRoundRect</B>(int&nbsp;x,
                          int&nbsp;y,
                          int&nbsp;width,
                          int&nbsp;height,
                          int&nbsp;arcWidth,
                          int&nbsp;arcHeight)</PRE>
<DL>
<DD>Draws a rectangle with rounded edges.

 <p> Use this method to draw a rectangle with rounded edges. You specify
 the top and left edges of the rectangle, and its width and height. This
 method draws the right edge of the rectangle at <code>(x+width-1)</code>,
 the bottom edge at <code>(y+height-1)</code>. The resulting rectangle
 will thus have an area, assuming no rounded corners, of
 <code>width * height</code>.

 <p> If you pass in a zero or negative value for either the height or
 width, this method draws nothing.

 <p> Use the arcWdith and arcHeight parameters to describe the arcs used
 to round off the four corners.
 
 <p> To apply anti-aliasing to the rounded corners, enable the drawing
 style Graphics.DRAWSTYLE_AALINES (see @setDrawingStyle)
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Left edge of the rectangle.<DD><CODE>y</CODE> - Top edge of the rectangle.<DD><CODE>width</CODE> - Width of the rectangle.<DD><CODE>height</CODE> - Height of the rectangle.<DD><CODE>arcWidth</CODE> - Width of arc used to round the four corners.<DD><CODE>arcHeight</CODE> - Height of arc used to round the four corners.</DL>
</DD>
</DL>
<HR>

<A NAME="drawRoundRect(int, int, int, int, int, int, int)"><!-- --></A><H3>
drawRoundRect</H3>
<PRE>
public void <B>drawRoundRect</B>(int&nbsp;x,
                          int&nbsp;y,
                          int&nbsp;width,
                          int&nbsp;height,
                          int&nbsp;roundedCorners,
                          int&nbsp;arcWidth,
                          int&nbsp;arcHeight)</PRE>
<DL>
<DD>Draws an un-bordered rounded rectangle, from a provided point.

 <p> The home corner coordinates you provide locate the top left corner of
 the rectangle you want to draw.

 <p> If you want to use anti-aliasing for drawing, use
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setDrawingStyle(int, boolean)"><CODE>Graphics.setDrawingStyle(int, boolean)</CODE></A> with <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#DRAWSTYLE_ANTIALIASED"><CODE>Graphics.DRAWSTYLE_ANTIALIASED</CODE></A>.

 <p> You specify the curvature for rounded corners by giving the height
 and width of an ellipical curve's quadrant (the quadrant of the ellipse
 chosen is the associated quadrant of the rectangle to draw--thus the top
 right quadrant of the ellipse gets used as the template for the curve of
 the top right quadrant of the rectangle to draw). If you want the
 rectangle's corner to be evenly rounded, you specify an ellipse with
 equal height and width (i.e. you describe a circle as the curvature template).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Distance from left edge of the rectangle's home corner.<DD><CODE>y</CODE> - Distance from top edge of the rectangle's home corner.<DD><CODE>width</CODE> - Horizontal size of the rectangle; must be greater than one.<DD><CODE>height</CODE> - Vertical size of the rectangle; must be greater than one.<DD><CODE>roundedCorners</CODE> - Rounded corners bitmask value indicating which
 corners to round (mask of the various *_ROUNDED_RECT_CORNER constants).<DD><CODE>arcWidth</CODE> - Width of the ellipse providing the arc segments used to
 round the corners; must be greater than zero and less than the
 rectangle's total width.<DD><CODE>arcHeight</CODE> - Height of the ellipse providing the arc segments used to
 round the corners; must be greater than zero, and less than the rectangle's
 total height.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - Thrown if you provide a width or height
 less than one, or if the provided arc specifications are malformed
 (height or width less than zero or greater than the rect's associated
 dimension).<DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawRGB(int[], int, int, int, int, int, int)"><!-- --></A><H3>
drawRGB</H3>
<PRE>
public void <B>drawRGB</B>(int[]&nbsp;data,
                    int&nbsp;offset,
                    int&nbsp;scanLength,
                    int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;width,
                    int&nbsp;height)</PRE>
<DL>
<DD>Draws raw RGB data from an int array.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - Color data to use, of the form 0x00RRGGBB.<DD><CODE>offset</CODE> - Offset into the data to start drawing from.<DD><CODE>scanLength</CODE> - Width of a scanline within the data.<DD><CODE>x</CODE> - Left edge of rectangle.<DD><CODE>y</CODE> - Top edge of the rectangle.<DD><CODE>width</CODE> - Width of the rectangle.<DD><CODE>height</CODE> - Height of the rectangle.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</A></CODE> - If 'data' is null.
<DD><CODE><A HREF="../../../../../java/lang/ArrayIndexOutOfBoundsException.html" title="class in java.lang">ArrayIndexOutOfBoundsException</A></CODE> - If the data parameters are invalid.<DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawText(char, int, int, int, int)"><!-- --></A><H3>
drawText</H3>
<PRE>
public int <B>drawText</B>(char&nbsp;aChar,
                    int&nbsp;aX,
                    int&nbsp;aY,
                    int&nbsp;aFlags,
                    int&nbsp;aWidth)</PRE>
<DL>
<DD>Draws a character using the current font and clipping to the current clipping region.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>aChar</CODE> - The character to draw.<DD><CODE>aX</CODE> - The horizontal position of the drawing anchor in pixels.<DD><CODE>aY</CODE> - The vertical position of drawing anchor in pixels.<DD><CODE>aFlags</CODE> - A combination of constant drawing position flags.<DD><CODE>aWidth</CODE> - The width in pixels. The text is aligned within this width, and 
 truncated if its inked pixels bounds or x advance exceed aWidth. The value -1 
 causes the actual width of the text to be used, and forces left alignment.
<DT><B>Returns:</B><DD>The linear advance width in pixels of the text drawn, including characters
 falling outside the graphic clip region, but not those truncated by aWidth.
 Note: This can be less than the inked pixels width.</DL>
</DD>
</DL>
<HR>

<A NAME="drawText(java.lang.String, int, int)"><!-- --></A><H3>
drawText</H3>
<PRE>
public int <B>drawText</B>(<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;aText,
                    int&nbsp;aX,
                    int&nbsp;aY)</PRE>
<DL>
<DD>Draws the text in a string using the current font, clipping to the current clipping region
 and using the TOP baseline and LEFT alignment.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>aText</CODE> - The text to draw.<DD><CODE>aX</CODE> - The horizontal position of the drawing anchor in pixels.<DD><CODE>aY</CODE> - The vertical position of drawing anchor in pixels.
<DT><B>Returns:</B><DD>The linear advance width in pixels of the text drawn, including characters
 falling outside the graphic clip region, but not those truncated by aWidth.
 Note: This can be less than the inked pixels width.</DL>
</DD>
</DL>
<HR>

<A NAME="drawText(java.lang.String, int, int, int)"><!-- --></A><H3>
drawText</H3>
<PRE>
public int <B>drawText</B>(<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;aText,
                    int&nbsp;aX,
                    int&nbsp;aY,
                    int&nbsp;aFlags)</PRE>
<DL>
<DD>Draws the text in a string using the current font, clipping to the current clipping region
 and using the baseline specified by aFlags.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>aText</CODE> - The text to draw.<DD><CODE>aX</CODE> - The horizontal position of the drawing anchor in pixels.<DD><CODE>aY</CODE> - The vertical position of drawing anchor in pixels.<DD><CODE>aFlags</CODE> - A combination of constant drawing position flags.
<DT><B>Returns:</B><DD>The linear advance width in pixels of the text drawn, including characters
 falling outside the graphic clip region, but not those truncated by aWidth.
 Note: This can be less than the inked pixels width.</DL>
</DD>
</DL>
<HR>

<A NAME="drawText(java.lang.String, int, int, int, int)"><!-- --></A><H3>
drawText</H3>
<PRE>
public int <B>drawText</B>(<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;aText,
                    int&nbsp;aX,
                    int&nbsp;aY,
                    int&nbsp;aFlags,
                    int&nbsp;aWidth)</PRE>
<DL>
<DD>Draws the text in a string using the current font, clipping to the current clipping region,
 and using the baseline and alignment specified by aFlags and aWidth.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>aText</CODE> - The text to draw.<DD><CODE>aX</CODE> - The horizontal position of the drawing anchor in pixels.<DD><CODE>aY</CODE> - The vertical position of drawing anchor in pixels.<DD><CODE>aFlags</CODE> - A combination of constant drawing position flags.<DD><CODE>aWidth</CODE> - The width in pixels. The text is aligned within this width, and 
 truncated if its inked pixels bounds or x advance exceed aWidth. The value -1 
 causes the actual width of the text to be used, and forces left alignment.
<DT><B>Returns:</B><DD>The linear advance width in pixels of the text drawn, including characters
 falling outside the graphic clip region, but not those truncated by aWidth.
 Note: This can be less than the inked pixels width.</DL>
</DD>
</DL>
<HR>

<A NAME="drawText(byte[], int, int, int, int, int, int)"><!-- --></A><H3>
drawText</H3>
<PRE>
public int <B>drawText</B>(byte[]&nbsp;aText,
                    int&nbsp;aOffset,
                    int&nbsp;aLength,
                    int&nbsp;aX,
                    int&nbsp;aY,
                    int&nbsp;aFlags,
                    int&nbsp;aWidth)</PRE>
<DL>
<DD>Draws part of the contents of a byte array using the current font,
 clipping to the current clipping region, and using the baseline and
 alignment specified by aFlags and aWidth.


 <p>Each byte is a single Unicode code point in the range 0...255. This
 method does not support UTF8 or any other encoding. To draw characters
 outside this range use a drawText method that accepts a char array or
 a String.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>aText</CODE> - The text to draw.<DD><CODE>aOffset</CODE> - The start index of the text.<DD><CODE>aLength</CODE> - The length of the text (number of elements in the array) to draw.<DD><CODE>aX</CODE> - The horizontal position of the drawing anchor in pixels.<DD><CODE>aY</CODE> - The vertical position of drawing anchor in pixels.<DD><CODE>aFlags</CODE> - A combination of constant drawing position flags.<DD><CODE>aWidth</CODE> - The width in pixels. The text is aligned within this width, and 
 truncated if its inked pixels bounds or x advance exceed aWidth. The value -1 
 causes the actual width of the text to be used, and forces left alignment.
<DT><B>Returns:</B><DD>The linear advance width in pixels of the text drawn, including characters
 falling outside the graphic clip region, but not those truncated by aWidth.
 Note: This can be less than the inked pixels width.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</A></CODE> - If the values of aOffset and aLength
 cause an element outside the array aText to be accessed.</DL>
</DD>
</DL>
<HR>

<A NAME="drawText(char[], int, int, int, int, int, int)"><!-- --></A><H3>
drawText</H3>
<PRE>
public int <B>drawText</B>(char[]&nbsp;aText,
                    int&nbsp;aOffset,
                    int&nbsp;aLength,
                    int&nbsp;aX,
                    int&nbsp;aY,
                    int&nbsp;aFlags,
                    int&nbsp;aWidth)</PRE>
<DL>
<DD>Draws part of the contents of a char array using the current font,
 clipping to the current clipping region, and using the baseline and
 alignment specified by aFlags and aWidth.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>aText</CODE> - The text to draw.<DD><CODE>aOffset</CODE> - The start index of the text.<DD><CODE>aLength</CODE> - The length of the text (number of elements in the array) to draw.<DD><CODE>aX</CODE> - The horizontal position of the drawing anchor in pixels.<DD><CODE>aY</CODE> - The vertical position of drawing anchor in pixels.<DD><CODE>aFlags</CODE> - A combination of constant drawing position flags.<DD><CODE>aWidth</CODE> - The width in pixels. The text is aligned within this width, and 
 truncated if its inked pixels bounds or x advance exceed aWidth. The value -1 
 causes the actual width of the text to be used, and forces left alignment.
<DT><B>Returns:</B><DD>The linear advance width in pixels of the text drawn, including characters
 falling outside the graphic clip region, but not those truncated by aWidth.
 Note: This can be less than the inked pixels width.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</A></CODE> - If the values of aOffset and aLength
 cause an element outside the array aText to be accessed.</DL>
</DD>
</DL>
<HR>

<A NAME="drawText(java.lang.String, int, int, int, int, int, int)"><!-- --></A><H3>
drawText</H3>
<PRE>
public int <B>drawText</B>(<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;aText,
                    int&nbsp;aOffset,
                    int&nbsp;aLength,
                    int&nbsp;aX,
                    int&nbsp;aY,
                    int&nbsp;aFlags,
                    int&nbsp;aWidth)</PRE>
<DL>
<DD>Draws part of the text in a String using the current font,
 clipping to the current clipping region, and using the baseline and
 alignment specified by aFlags and aWidth.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>aText</CODE> - The text to draw.<DD><CODE>aOffset</CODE> - The start index of the text.<DD><CODE>aLength</CODE> - The number of characters to draw.<DD><CODE>aX</CODE> - The horizontal position of the drawing anchor in pixels.<DD><CODE>aY</CODE> - The vertical position of drawing anchor in pixels.<DD><CODE>aFlags</CODE> - A combination of constant drawing position flags.<DD><CODE>aWidth</CODE> - The width in pixels. The text is aligned within this width, and 
 truncated if its inked pixels bounds or x advance exceed aWidth. The value -1 
 causes the actual width of the text to be used, and forces left alignment.
<DT><B>Returns:</B><DD>The linear advance width in pixels of the text drawn, including characters
 falling outside the graphic clip region, but not those truncated by aWidth.
 Note: This can be less than the inked pixels width.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</A></CODE> - If the values of aOffset and aLength
 cause an element outside the array aText to be accessed.</DL>
</DD>
</DL>
<HR>

<A NAME="drawText(java.lang.StringBuffer, int, int, int, int, int, int)"><!-- --></A><H3>
drawText</H3>
<PRE>
public int <B>drawText</B>(<A HREF="../../../../../java/lang/StringBuffer.html" title="class in java.lang">StringBuffer</A>&nbsp;aText,
                    int&nbsp;aOffset,
                    int&nbsp;aLength,
                    int&nbsp;aX,
                    int&nbsp;aY,
                    int&nbsp;aFlags,
                    int&nbsp;aWidth)</PRE>
<DL>
<DD>Draws part of the text in a StringBuffer using the current font,
 clipping to the current clipping region, and using the baseline and
 alignment specified by aFlags and aWidth.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>aText</CODE> - The text to draw.<DD><CODE>aOffset</CODE> - The start index of the text.<DD><CODE>aLength</CODE> - The number of characters to draw.<DD><CODE>aX</CODE> - The horizontal position of the drawing anchor in pixels.<DD><CODE>aY</CODE> - The vertical position of drawing anchor in pixels.<DD><CODE>aFlags</CODE> - A combination of constant drawing position flags.<DD><CODE>aWidth</CODE> - The width in pixels. The text is aligned within this width, and 
 truncated if its inked pixels bounds or x advance exceed aWidth. The value -1 
 causes the actual width of the text to be used, and forces left alignment.
<DT><B>Returns:</B><DD>The linear advance width in pixels of the text drawn, including characters
 falling outside the graphic clip region, but not those truncated by aWidth.
 Note: This can be less than the inked pixels width.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</A></CODE> - If the values of aOffset and aLength
 cause an element outside the array aText to be accessed.</DL>
</DD>
</DL>
<HR>

<A NAME="drawText(java.lang.String, int, int, int, int, net.rim.device.api.ui.DrawTextParam, net.rim.device.api.ui.TextMetrics)"><!-- --></A><H3>
drawText</H3>
<PRE>
public int <B>drawText</B>(<A HREF="../../../../../java/lang/String.html" title="class in java.lang">String</A>&nbsp;aText,
                    int&nbsp;aOffset,
                    int&nbsp;aLength,
                    int&nbsp;aX,
                    int&nbsp;aY,
                    <A HREF="../../../../../net/rim/device/api/ui/DrawTextParam.html" title="class in net.rim.device.api.ui">DrawTextParam</A>&nbsp;aParam,
                    <A HREF="../../../../../net/rim/device/api/ui/TextMetrics.html" title="class in net.rim.device.api.ui">TextMetrics</A>&nbsp;aMetrics)</PRE>
<DL>
<DD>Draws part of the text in a String using the current font
 and clipping to the current clipping region.
 Optionally uses parameters supplied in aParam and returns metrics in aMetrics.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>aText</CODE> - The text to draw.<DD><CODE>aOffset</CODE> - The start index of the text.<DD><CODE>aLength</CODE> - The number of characters to draw.<DD><CODE>aX</CODE> - The horizontal position of the drawing anchor in pixels.<DD><CODE>aY</CODE> - The vertical position of drawing anchor in pixels.<DD><CODE>aParam</CODE> - Text drawing parameters. If null, use default parameters.<DD><CODE>aMetrics</CODE> - If non-null, this parameter receives the metrics of the text drawn.
<DT><B>Returns:</B><DD>The linear advance width in pixels of the text drawn, including characters
 falling outside the graphic clip region, but not those truncated by aWidth.
 Note: This can be less than the inked pixels width.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</A></CODE> - If the values of aOffset and aLength
 cause an element outside the array aText to be accessed.<DT><B>Since:</B></DT><DD>BlackBerry API 6.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawText(java.lang.StringBuffer, int, int, int, int, net.rim.device.api.ui.DrawTextParam, net.rim.device.api.ui.TextMetrics)"><!-- --></A><H3>
drawText</H3>
<PRE>
public int <B>drawText</B>(<A HREF="../../../../../java/lang/StringBuffer.html" title="class in java.lang">StringBuffer</A>&nbsp;aText,
                    int&nbsp;aOffset,
                    int&nbsp;aLength,
                    int&nbsp;aX,
                    int&nbsp;aY,
                    <A HREF="../../../../../net/rim/device/api/ui/DrawTextParam.html" title="class in net.rim.device.api.ui">DrawTextParam</A>&nbsp;aParam,
                    <A HREF="../../../../../net/rim/device/api/ui/TextMetrics.html" title="class in net.rim.device.api.ui">TextMetrics</A>&nbsp;aMetrics)</PRE>
<DL>
<DD>Draws part of the text in a StringBuffer using the current font
 and clipping to the current clipping region.
 Optionally uses parameters supplied in aParam and returns metrics in aMetrics.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>aText</CODE> - The text to draw.<DD><CODE>aOffset</CODE> - The start index of the text.<DD><CODE>aLength</CODE> - The number of characters to draw.<DD><CODE>aX</CODE> - The horizontal position of the drawing anchor in pixels.<DD><CODE>aY</CODE> - The vertical position of drawing anchor in pixels.<DD><CODE>aParam</CODE> - Text drawing parameters. If null, use default parameters.<DD><CODE>aMetrics</CODE> - If non-null, this parameter receives the metrics of the text drawn.
<DT><B>Returns:</B><DD>The linear advance width in pixels of the text drawn, including characters
 falling outside the graphic clip region, but not those truncated by aWidth.
 Note: This can be less than the inked pixels width.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</A></CODE> - If the values of aOffset and aLength
 cause an element outside the array aText to be accessed.<DT><B>Since:</B></DT><DD>BlackBerry API 6.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawText(char[], int, int, int, int, net.rim.device.api.ui.DrawTextParam, net.rim.device.api.ui.TextMetrics)"><!-- --></A><H3>
drawText</H3>
<PRE>
public int <B>drawText</B>(char[]&nbsp;aText,
                    int&nbsp;aOffset,
                    int&nbsp;aLength,
                    int&nbsp;aX,
                    int&nbsp;aY,
                    <A HREF="../../../../../net/rim/device/api/ui/DrawTextParam.html" title="class in net.rim.device.api.ui">DrawTextParam</A>&nbsp;aParam,
                    <A HREF="../../../../../net/rim/device/api/ui/TextMetrics.html" title="class in net.rim.device.api.ui">TextMetrics</A>&nbsp;aMetrics)</PRE>
<DL>
<DD>Draws part of the text in a char array using the current font
 and clipping to the current clipping region.
 Optionally uses parameters supplied in aParam and returns metrics in aMetrics.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>aText</CODE> - The text to draw.<DD><CODE>aOffset</CODE> - The start index of the text.<DD><CODE>aLength</CODE> - The length of the text (number of elements in the array) to draw.<DD><CODE>aX</CODE> - The horizontal position of the drawing anchor in pixels.<DD><CODE>aY</CODE> - The vertical position of drawing anchor in pixels.<DD><CODE>aParam</CODE> - Text drawing parameters. If null, use default parameters.<DD><CODE>aMetrics</CODE> - If non-null, this parameter receives the metrics of the text drawn.
<DT><B>Returns:</B><DD>The linear advance width in pixels of the text drawn, including characters
 falling outside the graphic clip region, but not those truncated by aWidth.
 Note: This can be less than the inked pixels width.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</A></CODE> - If the values of aOffset and aLength
 cause an element outside the array aText to be accessed.<DT><B>Since:</B></DT><DD>BlackBerry API 6.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="fillArc(int, int, int, int, int, int)"><!-- --></A><H3>
fillArc</H3>
<PRE>
public void <B>fillArc</B>(int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;width,
                    int&nbsp;height,
                    int&nbsp;startAngle,
                    int&nbsp;arcAngle)</PRE>
<DL>
<DD>Fills a circular or elliptical arc covering a specified rectangle.

 <p> The center of the filled arc is the center of a retangle whose origin
 is <code>(x,y)</code> and whose size is specified by the
 <code>width</code> and <code>height</code> parameters.

 <p> The arc begins at <code>startAngle</code> and extends for
 <code>arcAngle</code> degrees, using the current draw color. The drawing
 algorithm assumes that the 0 degree position is in the center of the
 right edge of the rectangle. The direction of the arc drawn depends on
 the relative values of <code>startAngle</code> and <code>arcAngle</code>:

 <ul>
 <li> If <code>(startAngle &lt; arcAngle)</code>, this method fills the
 arc in a counterclockwise direction.
 <li> If <code>(startAngle &gt; arcAngle)</code>, this method fills the
 arc in a clockwise direction.
 </ul>

 <p> The resulting filled region consist of the wedge bounded by the arc
 segment as if drawn by <code>drawArc()</code>, the radius extending from
 the center to this arc at <code>startAngle</code> degrees, and radius
 extending from the center to this arc at
 <code>(startAngle+arcAngle)</code> degrees.

 <p> If either width or height is less than zero, this method draws
 nothing.

 <p> The angles are specified relative to the non-square extents of the
 bounding rectangle such that 45 degrees always falls on the line from the
 center of the ellipse to the upper right corner of the bounding
 rectangle. As a result, if the bounding rectangle is noticeably longer in
 one axis than the other, the angles to the start and end of the arc
 segment will be skewed farther along the longer axis of the bounds.

 ATTENTION: This method doesn't support transformations specified in the
 setTransformation method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Horizontal coordinate of the arc's starting position.<DD><CODE>y</CODE> - Vertical coordinate of the arc's starting position.<DD><CODE>width</CODE> - Width of rectangle containing the filled arc.<DD><CODE>height</CODE> - Height of rectangle containing the filled arc.<DD><CODE>startAngle</CODE> - Angle position at which to commence drawing the edge of
 the arc.<DD><CODE>arcAngle</CODE> - Angular extent of the arc, relative to the start angle.</DL>
</DD>
</DL>
<HR>

<A NAME="fillEllipse(int, int, int, int, int, int, int, int)"><!-- --></A><H3>
fillEllipse</H3>
<PRE>
public void <B>fillEllipse</B>(int&nbsp;cx,
                        int&nbsp;cy,
                        int&nbsp;px,
                        int&nbsp;py,
                        int&nbsp;qx,
                        int&nbsp;qy,
                        int&nbsp;startAngle,
                        int&nbsp;arcAngle)</PRE>
<DL>
<DD>Fills an ellipse.

 <p> Fills an ellipse with the specified endpoints P = (px, py) and Q =
 (qx, qy) of two conjugate diameters of the ellipse. The endpoints are
 specified as absolute coordinates.


 <p> This example shows an ellipse with the aligned p and q points.

 <p> <img src="doc-files/aligned_ellipse1.gif">

 <p> This example shows how the p and q points can be used to draw a non-aligned ellipse.

 <p> <img src="doc-files/nonAligned_ellipse1.gif">
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cx</CODE> - X-ordinate of the ellipse centre. cx is one of the coordinates of the center point of the ellipse.<DD><CODE>cy</CODE> - Y-ordinate of the ellipse centre. cy is one of the coordinates of the center point of the ellipse.<DD><CODE>px</CODE> - X-ordinate of the point P. P is one of the coordinates of the tangents of a parallelogram
 that bounds the ellipse.  By convention, if the ellipse is aligned with the screen axes,
 the p point defines the x-axis radius.<DD><CODE>py</CODE> - Y-ordinate of the point P. P is one of the coordinates of the tangents of a parallelogram
 that bounds the ellipse.  By convention, if the ellipse is aligned with the screen axes,
 the p point defines the x-axis radius.<DD><CODE>qx</CODE> - X-ordinate of the point Q. Q is one of the coordinates of the tangents of a parallelogram
 that bounds the ellipse.  By convention, if the ellipse is aligned with the screen axes,
 the q point defines the y-axis radius.<DD><CODE>qy</CODE> - Y-ordinate of the point Q. Q is one of the coordinates of the tangents of a parallelogram
 that bounds the ellipse.  By convention, if the ellipse is aligned with the screen axes,
 the q point defines the y-axis radius.<DD><CODE>startAngle</CODE> - Arc start angle. Drawing starts at the angular position defined by the start angle
 (clockwise with zero degrees being the x-axis and x left, y down) and ends at an angular position
 equal to the start angle plus the arc angle. For example, if you set the start angle to 90 degrees
 and the arc angle to 90 degrees, the  ellipse starts at the y axis and continues to the x axis.<DD><CODE>arcAngle</CODE> - Angular extent of the arc, relative to the start angle.<DT><B>Since:</B></DT><DD>BlackBerry API 4.2.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="fillRect(int, int, int, int)"><!-- --></A><H3>
fillRect</H3>
<PRE>
public void <B>fillRect</B>(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height)</PRE>
<DL>
<DD>Fills a rectangle.

 <p> Note that if global alpha is set or if the fill color includes alpha then
 the rectangle color will be blended onto the content on the target surface. </p>

 <p> Use this method to fill a rectangle. You specify the top and left
 edges of the rectangle, and its width and height. This method paints the
 right edge of the rect at <code>(x+width-1)</code>, the bottom edge at
 <code>(y+height-1)</code>. The resulting rectangle will thus have an area
 of <code>width * height</code>.

 <p> If you pass in a zero or negative value for either the height or
 width, this method draws nothing.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Left edge of the rectangle.<DD><CODE>y</CODE> - Top edge of the rectangle.<DD><CODE>width</CODE> - Width of the rectangle.<DD><CODE>height</CODE> - Height of the rectangle.</DL>
</DD>
</DL>
<HR>

<A NAME="fillRoundRect(int, int, int, int, int, int)"><!-- --></A><H3>
fillRoundRect</H3>
<PRE>
public void <B>fillRoundRect</B>(int&nbsp;x,
                          int&nbsp;y,
                          int&nbsp;width,
                          int&nbsp;height,
                          int&nbsp;arcWidth,
                          int&nbsp;arcHeight)</PRE>
<DL>
<DD>Fills a rectangle with rounded edges.

 <p> Use this method to fill a rectangle with rounded edges. You specify
 the top and left edges of the rectangle, and its width and height. This
 method draws the right edge of the filled rectangle at
 <code>(x+width-1)</code>, the bottom edge at
 <code>(y+height-1)</code>. The resulting rectangle will thus have an
 area, assuming no rounded corners, of <code>width * height</code>.

 <p> If you pass in a zero or negative value for either the height or
 width, this method draws nothing.

 <p> Use the <code>arcWidth</code> and <code>arcHeight</code> parameters
 to describe the arcs used to round off the four corners.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Left edge of the rectangle.<DD><CODE>y</CODE> - Top edge of the rectangle.<DD><CODE>width</CODE> - Width of the rectangle.<DD><CODE>height</CODE> - Height of the rectangle.<DD><CODE>arcWidth</CODE> - Width of arc used to round the four corners.<DD><CODE>arcHeight</CODE> - Height of arc used to round the four corners.</DL>
</DD>
</DL>
<HR>

<A NAME="getAbsoluteClippingRect(net.rim.device.api.ui.XYRect)"><!-- --></A><H3>
getAbsoluteClippingRect</H3>
<PRE>
public void <B>getAbsoluteClippingRect</B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;clip)</PRE>
<DL>
<DD>Retreives the absolute coordinates of current clipping region.

 <p> Use this method to retrieve, into a provided XYRect object, the
 absolute coordinates of the current clipping region.

 <p> Since the out parameter contains only a copy of the clipping region,
 altering its contents has no effect on the current clipping region.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>clip</CODE> - Clipping region is returned in this parameter.</DL>
</DD>
</DL>
<HR>

<A NAME="getBackgroundColor()"><!-- --></A><H3>
getBackgroundColor</H3>
<PRE>
public int <B>getBackgroundColor</B>()</PRE>
<DL>
<DD>Retrieves the current background color.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Current color in the form 0x00RRGGBB.</DL>
</DD>
</DL>
<HR>

<A NAME="getClippingRect()"><!-- --></A><H3>
getClippingRect</H3>
<PRE>
public <A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A> <B>getClippingRect</B>()</PRE>
<DL>
<DD>Retrieves the local coordinates of current clipping region.

 <p> The returned <code>XYRect</code> is owned by this graphics object and
 you should <em>not</em> change it. Instead, use this class's various
 <code>push</code> and <code>pop</code> methods to change the extent of
 the current clipping region.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Current clipping rect.</DL>
</DD>
</DL>
<HR>

<A NAME="getContextStackSize()"><!-- --></A><H3>
getContextStackSize</H3>
<PRE>
public int <B>getContextStackSize</B>()</PRE>
<DL>
<DD>Retrieves the size of the stack of drawing contexts.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Number of elements on the context stack.<DT><B>Since:</B></DT><DD>BlackBerry API 4.1.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getColor()"><!-- --></A><H3>
getColor</H3>
<PRE>
public int <B>getColor</B>()</PRE>
<DL>
<DD>Retrieves the current foreground drawing color.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Current color in the form 0x00RRGGBB.</DL>
</DD>
</DL>
<HR>

<A NAME="getDrawingOffset(net.rim.device.api.ui.XYPoint)"><!-- --></A><H3>
getDrawingOffset</H3>
<PRE>
public void <B>getDrawingOffset</B>(<A HREF="../../../../../net/rim/device/api/ui/XYPoint.html" title="class in net.rim.device.api.ui">XYPoint</A>&nbsp;offset)</PRE>
<DL>
<DD>Retrieves the absolute coordinates for the current drawing offset.

 <p> The drawing offset is the point, offset from the top left corner of
 the screen, which drawing operations use as their origin point.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - Drawing offset is returned in this paramater.</DL>
</DD>
</DL>
<HR>

<A NAME="getGlobalAlpha()"><!-- --></A><H3>
getGlobalAlpha</H3>
<PRE>
public int <B>getGlobalAlpha</B>()</PRE>
<DL>
<DD>Retrieves the current global alpha value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Current alpha value in the range 0x00 to 0xff.<DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNearestColor(int)"><!-- --></A><H3>
getNearestColor</H3>
<PRE>
public int <B>getNearestColor</B>(int&nbsp;color)</PRE>
<DL>
<DD>Gets the color that will be used if the specified color is requested.
 For example, in RGB565 or grayscale color space, some information will be lost.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>color</CODE> - the desired color (in 0x00RRGGBB format, the high-order byte is ignored)
<DT><B>Returns:</B><DD>the corresponding color that will be written to this graphics context (in 0x00RRGGBB format)<DT><B>Since:</B></DT><DD>BlackBerry API 5.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getNumColors()"><!-- --></A><H3>
getNumColors</H3>
<PRE>
public static int <B>getNumColors</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use Display.getNumColors();</I>
<P>
<DD>Retrieve the number of colors that the display supports.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Number of colors the screen can display.<DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getStipple()"><!-- --></A><H3>
getStipple</H3>
<PRE>
public int <B>getStipple</B>()</PRE>
<DL>
<DD>Retrieves the current line stippling value.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Current stipple mask.</DL>
</DD>
</DL>
<HR>

<A NAME="getFont()"><!-- --></A><H3>
getFont</H3>
<PRE>
public <A HREF="../../../../../net/rim/device/api/ui/Font.html" title="class in net.rim.device.api.ui">Font</A> <B>getFont</B>()</PRE>
<DL>
<DD>Retrieves the current font for the current graphics context.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Current font used for text drawing operations.</DL>
</DD>
</DL>
<HR>

<A NAME="getScreenHeight()"><!-- --></A><H3>
getScreenHeight</H3>
<PRE>
public static int <B>getScreenHeight</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use Display.getHeight()</I>
<P>
<DD>Retrieves total drawing height of the screen.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Height in pixels of the display's drawable area.</DL>
</DD>
</DL>
<HR>

<A NAME="getScreenHorizontalResolution()"><!-- --></A><H3>
getScreenHorizontalResolution</H3>
<PRE>
public static int <B>getScreenHorizontalResolution</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use Display.getHorizontalResolution()</I>
<P>
<DD>Retrieve screen's horizontal resolution in pixels per meter (PPM).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Horizontal resolution (PPM) of screen.</DL>
</DD>
</DL>
<HR>

<A NAME="getScreenVerticalResolution()"><!-- --></A><H3>
getScreenVerticalResolution</H3>
<PRE>
public static int <B>getScreenVerticalResolution</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use Display.getVerticalResolution()</I>
<P>
<DD>Retrieve screen's vertical resolution in pixels per meter (PPM).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Vertical resolution (PPM) of screen.</DL>
</DD>
</DL>
<HR>

<A NAME="getScreenWidth()"><!-- --></A><H3>
getScreenWidth</H3>
<PRE>
public static int <B>getScreenWidth</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use Display.getWidth()</I>
<P>
<DD>Retrieves total drawing width of the screen.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Width in pixels of the display's drawable area.</DL>
</DD>
</DL>
<HR>

<A NAME="invert(int, int, int, int)"><!-- --></A><H3>
invert</H3>
<PRE>
public void <B>invert</B>(int&nbsp;x,
                   int&nbsp;y,
                   int&nbsp;width,
                   int&nbsp;height)</PRE>
<DL>
<DD>Inverts a region.

 <p> This method performs a one's complement operation on each pixel in
 your specified region.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Left edge of the region.<DD><CODE>y</CODE> - Top edge of the region.<DD><CODE>width</CODE> - Width of the region.<DD><CODE>height</CODE> - Height of the region.</DL>
</DD>
</DL>
<HR>

<A NAME="invert(net.rim.device.api.ui.XYRect)"><!-- --></A><H3>
invert</H3>
<PRE>
public void <B>invert</B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;rect)</PRE>
<DL>
<DD>Inverts a region specified by an XYRect object.

 <p> This method performs a one's complement operation on each pixel in
 your specified region.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rect</CODE> - Region to invert.</DL>
</DD>
</DL>
<HR>

<A NAME="popContext()"><!-- --></A><H3>
popContext</H3>
<PRE>
public void <B>popContext</B>()</PRE>
<DL>
<DD>Pops a drawing context off the stack.

 <p> Use this method to pop off the context stack the last context pushed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="pushRegion(int, int, int, int, int, int)"><!-- --></A><H3>
pushRegion</H3>
<PRE>
public boolean <B>pushRegion</B>(int&nbsp;x,
                          int&nbsp;y,
                          int&nbsp;width,
                          int&nbsp;height,
                          int&nbsp;xScroll,
                          int&nbsp;yScroll)</PRE>
<DL>
<DD>Pushes a drawing region (and optional scroll offset) onto the context
 stack.

 <p> The clipping region is updated by intersecting with the previous
 clipping region. The drawing offset is adjusted by the value of the
 region origin. You can also specify an (optional) additional scroll
 offset with the <code>xScroll</code> and <code>yScroll</code> parameters.

 <p> This method is suitable for pushing a context for drawing into a
 subregion.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Left edge of the region.<DD><CODE>y</CODE> - Top edge of the region.<DD><CODE>width</CODE> - Width of the region.<DD><CODE>height</CODE> - Height of the region.<DD><CODE>xScroll</CODE> - Optional, additional scroll offset.<DD><CODE>yScroll</CODE> - Optional, additional scroll offset.</DL>
</DD>
</DL>
<HR>

<A NAME="pushRegion(net.rim.device.api.ui.XYRect)"><!-- --></A><H3>
pushRegion</H3>
<PRE>
public boolean <B>pushRegion</B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;region)</PRE>
<DL>
<DD>Pushes a drawing region onto the context stack, specified by a XYRect
 object.

 <p> The clipping region is updated by intersecting with the previous
 clipping region. The drawing offset is adjusted by the value of the
 region origin.

 <p> This method is suitable for pushing a context for drawing into a
 subregion.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>region</CODE> - New drawing region rectangle in local coordinates.</DL>
</DD>
</DL>
<HR>

<A NAME="pushRegion(net.rim.device.api.ui.XYRect, int, int)"><!-- --></A><H3>
pushRegion</H3>
<PRE>
public boolean <B>pushRegion</B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;region,
                          int&nbsp;xScroll,
                          int&nbsp;yScroll)</PRE>
<DL>
<DD>Pushes a drawing region (and optional scroll offset) onto the context
 stack.

 <p> This method behaves exactly like <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#pushRegion(net.rim.device.api.ui.XYRect)"><CODE>Graphics.pushRegion(XYRect)</CODE></A>, except
 you can also specify an (optional) additional scroll offset with the
 <code>xScroll</code> and <code>yScroll</code> parameters.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>region</CODE> - New drawing region in local coordinates.<DD><CODE>xScroll</CODE> - Optional, additional horizontal scroll offset.<DD><CODE>yScroll</CODE> - Optional, additional vertical scroll offset.</DL>
</DD>
</DL>
<HR>

<A NAME="pushContext(net.rim.device.api.ui.XYRect, int, int)"><!-- --></A><H3>
pushContext</H3>
<PRE>
public boolean <B>pushContext</B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;clip,
                           int&nbsp;xOffset,
                           int&nbsp;yOffset)</PRE>
<DL>
<DD>Pushes a clipping region (and optional drawing offset) onto the context
 stack.

 <p> This clipping region is updated by intersecting with the previous
 clipping region. Unlike <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#pushRegion(int, int, int, int, int, int)"><CODE>Graphics.pushRegion(int, int, int, int, int, int)</CODE></A>, the drawing offset is
 <em>not</em> adjusted by the value of the region origin. You can also
 specify an additional drawing offset update by using the
 <code>xOffset</code> and <code>yOffset</code> parameters.

 <p> To setup a subregion for local drawing <code>pushRegion</code> should
 be used.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>clip</CODE> - New clipping region in local coordinates.<DD><CODE>xOffset</CODE> - Optional, additional horizontal scroll offset.<DD><CODE>yOffset</CODE> - Optional, additional vertical scroll offset.</DL>
</DD>
</DL>
<HR>

<A NAME="pushContext(int, int, int, int, int, int)"><!-- --></A><H3>
pushContext</H3>
<PRE>
public boolean <B>pushContext</B>(int&nbsp;x,
                           int&nbsp;y,
                           int&nbsp;width,
                           int&nbsp;height,
                           int&nbsp;xOffset,
                           int&nbsp;yOffset)</PRE>
<DL>
<DD>Pushes a clipping region (and optional drawing offset) onto the context
 stack.

 <p> This clipping region is updated by intersecting with the previous
 clipping region. Unlike <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#pushRegion(int, int, int, int, int, int)"><CODE>Graphics.pushRegion(int, int, int, int, int, int)</CODE></A>, the drawing offset is
 <em>not</em> adjusted by the value of the region origin. You can also
 specify an additional drawing offset update by using the
 <code>xOffset</code> and <code>yOffset</code> parameters.

 <p> To setup a subregion for local drawing, <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#pushRegion(int, int, int, int, int, int)"><CODE>Graphics.pushRegion(int, int, int, int, int, int)</CODE></A> should be
 used.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Left edge of clipping region.<DD><CODE>y</CODE> - Top edge of clipping region.<DD><CODE>width</CODE> - Width in pixels of clipping region.<DD><CODE>height</CODE> - Height in pixels of clipping region.<DD><CODE>xOffset</CODE> - Optional, additional horizontal scroll offset.<DD><CODE>yOffset</CODE> - Optional, additional vertical scroll offset.</DL>
</DD>
</DL>
<HR>

<A NAME="translate(int, int)"><!-- --></A><H3>
translate</H3>
<PRE>
public void <B>translate</B>(int&nbsp;x,
                      int&nbsp;y)</PRE>
<DL>
<DD>Apply a translation to the current drawing offset.

 <p> The drawing offset is updated by adding the x and y offsets.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Horizontal offset to add to the current x drawing offset.<DD><CODE>y</CODE> - Vertical offset to add to the current y drawing offset.<DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTranslateX()"><!-- --></A><H3>
getTranslateX</H3>
<PRE>
public int <B>getTranslateX</B>()</PRE>
<DL>
<DD>Retrieves the horizontal component of the current drawing offset.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>X value of drawing offset.<DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTranslateY()"><!-- --></A><H3>
getTranslateY</H3>
<PRE>
public int <B>getTranslateY</B>()</PRE>
<DL>
<DD>Retrieves the vertical component of the current drawing offset.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Y value of drawing offset.<DT><B>Since:</B></DT><DD>BlackBerry API 3.6.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isDrawingStyleSet(int)"><!-- --></A><H3>
isDrawingStyleSet</H3>
<PRE>
public boolean <B>isDrawingStyleSet</B>(int&nbsp;drawStyle)</PRE>
<DL>
<DD>Determines whether the specified drawing style is turned on.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>drawStyle</CODE> - Graphics drawing style to be checked.
<DT><B>Returns:</B><DD>True if the specified style is turned on; otherwise, false.<DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDrawingStyle(int, boolean)"><!-- --></A><H3>
setDrawingStyle</H3>
<PRE>
public void <B>setDrawingStyle</B>(int&nbsp;drawStyle,
                            boolean&nbsp;on)</PRE>
<DL>
<DD>Sets the current drawing style.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>drawStyle</CODE> - Graphics drawing style to turn on or off.<DD><CODE>on</CODE> - True to turn on the specified style, false to turn it off.<DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setColor(int)"><!-- --></A><H3>
setColor</H3>
<PRE>
public void <B>setColor</B>(int&nbsp;RGB)</PRE>
<DL>
<DD>Sets the current color.

 <p> All subsequent rendering will be done in this color (more precisely,
 rendering will be done in a displayable color that is nearest to the
 color you specify).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>RGB</CODE> - Color to use, of the form 0x00RRGGBB.</DL>
</DD>
</DL>
<HR>

<A NAME="setGlobalAlpha(int)"><!-- --></A><H3>
setGlobalAlpha</H3>
<PRE>
public void <B>setGlobalAlpha</B>(int&nbsp;alpha)</PRE>
<DL>
<DD>Sets the current global alpha value for drawing operations.
 It ranges from 0 (fully transparent) to 255 (fully opaque).

 <p> Be sure to reset the global alpha value when appropriate since all
 subsequent operations are done using the value specified. Global alpha
 is stored on the stack so popContext will restore it to the previous
 value.

 <p> Note that <code>alpha</code> will be clamped to the range 0-255.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>alpha</CODE> - Alpha value to use, from 0 (fully transparent) to 255 (fully opaque).<DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setStipple(int)"><!-- --></A><H3>
setStipple</H3>
<PRE>
public void <B>setStipple</B>(int&nbsp;mask)</PRE>
<DL>
<DD>Sets the current line stippling value.

 <p> All subsequent line rendering operations will be done with this
 stipple value.  The stipple value is a 32 bit bitmask where a 1 indicates
 a pixel should be drawn and a 0 indicates the destination pixel should be
 left as is.  The mask is cycled through as the line is drawn.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mask</CODE> - The stipple mask to use for line drawing.</DL>
</DD>
</DL>
<HR>

<A NAME="setBackgroundColor(int)"><!-- --></A><H3>
setBackgroundColor</H3>
<PRE>
public void <B>setBackgroundColor</B>(int&nbsp;RGB)</PRE>
<DL>
<DD>Sets the current background color.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>RGB</CODE> - Color to use, of the form 0x00RRGGBB.</DL>
</DD>
</DL>
<HR>

<A NAME="setFont(net.rim.device.api.ui.Font)"><!-- --></A><H3>
setFont</H3>
<PRE>
public void <B>setFont</B>(<A HREF="../../../../../net/rim/device/api/ui/Font.html" title="class in net.rim.device.api.ui">Font</A>&nbsp;font)</PRE>
<DL>
<DD>Sets the current font for the current graphics context.

 <p> Subsequent text rendering uses this font.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>font</CODE> - New font.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</A></CODE> - If font is null.</DL>
</DD>
</DL>
<HR>

<A NAME="isColor()"><!-- --></A><H3>
isColor</H3>
<PRE>
public static boolean <B>isColor</B>()</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>Use Display.isColor().</I>
<P>
<DD>Determines if the display supports color.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>True if the the display supports color; otherwise, false.<DT><B>Since:</B></DT><DD>BlackBerry API 3.7.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawGradientFilledRect(net.rim.device.api.ui.XYRect, int, int)"><!-- --></A><H3>
drawGradientFilledRect</H3>
<PRE>
public void <B>drawGradientFilledRect</B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;rect,
                                   int&nbsp;startColor,
                                   int&nbsp;endColor)</PRE>
<DL>
<DD>Draws an un-bordered rectangle with a gradient fill.
 
 <p> This is a convenience method wrapping
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRect(net.rim.device.api.ui.XYRect, int, int, boolean)"><CODE>drawGradientFill(rect,startColor,endColor,false)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rect</CODE> - Rectangle to draw; must not be null and must have
 dimensions greater than zero.<DD><CODE>startColor</CODE> - Color to start with.<DD><CODE>endColor</CODE> - Color to end with.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - Thrown if the provided rect is malformed
 (either null, or with a height or width of zero or less).<DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawGradientFilledRect(net.rim.device.api.ui.XYRect, int, int, boolean)"><!-- --></A><H3>
drawGradientFilledRect</H3>
<PRE>
public void <B>drawGradientFilledRect</B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;rect,
                                   int&nbsp;startColor,
                                   int&nbsp;endColor,
                                   boolean&nbsp;drawBorder)</PRE>
<DL>
<DD>Draws a rectangle with a gradient fill.

 <p> The gradient fill is a linear gradient from the top edge of the
 rectangle to the bottom edge.
 
 <p> If you want to use dithered shading, use <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setDrawingStyle(int, boolean)"><CODE>Graphics.setDrawingStyle(int, boolean)</CODE></A>
 with <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#DRAWSTYLE_DITHERED_SHADING"><CODE>Graphics.DRAWSTYLE_DITHERED_SHADING</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rect</CODE> - Dimensions and placement of the rectangle to draw; must not
 be null and must have dimensions greater than zero.<DD><CODE>startColor</CODE> - Color to start with, at the top edge of the rectangle.<DD><CODE>endColor</CODE> - Color to transform into, at the bottom edge of the
 rectangle.<DD><CODE>drawBorder</CODE> - True to draw a bordered rectangle; false to draw the
 rect with no border. The border stroke is one pixel wide; the border
 color is the default foreground color set with <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setColor(int)"><CODE>Graphics.setColor(int)</CODE></A>.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - Thrown if the provided rect is malformed
 (either null, or with a height or width of zero or less).<DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawGradientFilledRect(int, int, int, int, int, int)"><!-- --></A><H3>
drawGradientFilledRect</H3>
<PRE>
public void <B>drawGradientFilledRect</B>(int&nbsp;x,
                                   int&nbsp;y,
                                   int&nbsp;width,
                                   int&nbsp;height,
                                   int&nbsp;startColor,
                                   int&nbsp;endColor)</PRE>
<DL>
<DD>Draws an un-bordered rectangle with a gradient fill, from a provided
 point.

 <p> This is a convenience method wrapping
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRect(int, int, int, int, int, int, boolean)"><CODE>drawGradientFilledRect(x,y,width,height,startColor,endColor,false)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Distance from left edge of the rectangle's home corner.<DD><CODE>y</CODE> - Distance from the top edge of the rectangle's home corner.<DD><CODE>width</CODE> - Horizontal size of the rectangle; must be greater than zero.<DD><CODE>height</CODE> - Vertical size of the rectangle; must be greater than zero.<DD><CODE>startColor</CODE> - Color to start with.<DD><CODE>endColor</CODE> - Color to end with.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - Thrown if you provide a width or height
 of zero or less.<DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawGradientFilledRect(int, int, int, int, int, int, boolean)"><!-- --></A><H3>
drawGradientFilledRect</H3>
<PRE>
public void <B>drawGradientFilledRect</B>(int&nbsp;x,
                                   int&nbsp;y,
                                   int&nbsp;width,
                                   int&nbsp;height,
                                   int&nbsp;startColor,
                                   int&nbsp;endColor,
                                   boolean&nbsp;drawBorder)</PRE>
<DL>
<DD>Draws a rectangle with a gradient fill, from a provided point.

 <p> The home corner coordinates you provide locate the top left corner of
 the rectangle you want to draw.

 <p> The gradient fill is a linear gradient from the top edge of the
 rectangle to the bottom edge.
 
 <p> If you want to use dithered shading, use <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setDrawingStyle(int, boolean)"><CODE>Graphics.setDrawingStyle(int, boolean)</CODE></A>
 with <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#DRAWSTYLE_DITHERED_SHADING"><CODE>Graphics.DRAWSTYLE_DITHERED_SHADING</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Distance from left edge of the rectangle's home corner.<DD><CODE>y</CODE> - Distance from top edge of the rectangle's home corner.<DD><CODE>width</CODE> - Horizontal size of the rectangle; must be greater than zero.<DD><CODE>height</CODE> - Vertical size of the rectangle; must be greater than zero.<DD><CODE>startColor</CODE> - Color to start with, at the top edge of the rectangle.<DD><CODE>endColor</CODE> - Color to transform into, at the bottom edge of the
 rectangle.<DD><CODE>drawBorder</CODE> - True to draw a bordered rectangle; false to draw the
 rect with no border. The border stroke is one pixel wide; the border
 color is the default foreground color set with <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setColor(int)"><CODE>Graphics.setColor(int)</CODE></A>.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - Thrown if you provide a width or height
 of zero or less.<DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawGradientFilledRoundedRect(net.rim.device.api.ui.XYRect, int, int, int, int)"><!-- --></A><H3>
drawGradientFilledRoundedRect</H3>
<PRE>
public void <B>drawGradientFilledRoundedRect</B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;rect,
                                          int&nbsp;startColor,
                                          int&nbsp;endColor,
                                          int&nbsp;arcWidth,
                                          int&nbsp;arcHeight)</PRE>
<DL>
<DD>Draws an un-bordered, fully rounded rectangle with a gradient fill.

 <p> This is a convenience method wrapping
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRoundedRect(net.rim.device.api.ui.XYRect, int, int, boolean, int, int, int)"><CODE>drawGradientFilledRoundedRec(rect,startColor,endColor,false,ALL_ROUNDED_RECT_CORNERS,arcWidth,arcHeight)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rect</CODE> - Rectangle to draw; must not be null and must have dimensions
 greater than zero.<DD><CODE>startColor</CODE> - Color to start with.<DD><CODE>endColor</CODE> - Color to end with.<DD><CODE>arcWidth</CODE> - Width of ellipse for rounding; must be between zero and
 the rect width (inclusive).<DD><CODE>arcHeight</CODE> - Height of ellipse for rounding; must be between zero and
 the rect height (inclusive).
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - Thrown if the provided rect is malformed
 (either null, or with a height or width of zero or less), or if the
 provided arc specifications are malformed (height or width less than zero,
 or greater than the rect's associated dimension).<DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawGradientFilledRoundedRect(net.rim.device.api.ui.XYRect, int, int, boolean, int, int)"><!-- --></A><H3>
drawGradientFilledRoundedRect</H3>
<PRE>
public void <B>drawGradientFilledRoundedRect</B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;rect,
                                          int&nbsp;startColor,
                                          int&nbsp;endColor,
                                          boolean&nbsp;drawBorder,
                                          int&nbsp;arcWidth,
                                          int&nbsp;arcHeight)</PRE>
<DL>
<DD>Draws a fully rounded rectangle with a gradient fill.

 <p> This is a convenience method wrapping
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRoundedRect(net.rim.device.api.ui.XYRect, int, int, boolean, int, int, int)"><CODE>drawGradientFilledRoundedRec(rect,startColor,endColor,drawBorder,ALL_ROUNDED_RECT_CORNERS,arcWidth,arcHeight)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rect</CODE> - Rectangle to draw; must not be null and must have dimensions
 greater than zero.<DD><CODE>startColor</CODE> - Color to start with.<DD><CODE>endColor</CODE> - Color to end with.<DD><CODE>drawBorder</CODE> - True to draw a border; false to draw the rect without a border.<DD><CODE>arcWidth</CODE> - Width of ellipse for rounding; must be between zero and
 the rect width (inclusive).<DD><CODE>arcHeight</CODE> - Height of ellipse for rounding; must be between zero and
 the rect height (inclusive).
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - Thrown if the provided rect is malformed
 (either null, or with a height or width of zero or less), or if the
 provided arc specifications are malformed (height or width less than zero
 or greater than the rect's associated dimension).<DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawGradientFilledRoundedRect(net.rim.device.api.ui.XYRect, int, int, int, int, int)"><!-- --></A><H3>
drawGradientFilledRoundedRect</H3>
<PRE>
public void <B>drawGradientFilledRoundedRect</B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;rect,
                                          int&nbsp;startColor,
                                          int&nbsp;endColor,
                                          int&nbsp;roundedCorners,
                                          int&nbsp;arcWidth,
                                          int&nbsp;arcHeight)</PRE>
<DL>
<DD>Draws an un-bordered, rounded rectangle with a gradient fill.

 <p> This is a convenience method wrapping
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRoundedRect(net.rim.device.api.ui.XYRect, int, int, boolean, int, int, int)"><CODE>drawGradientFilledRoundedRec(rect,startColor,endColor,false,roundedCorners,arcWidth,arcHeight)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rect</CODE> - Rectangle to draw; must not be null and must have dimensions
 greater than zero.<DD><CODE>startColor</CODE> - Color to start with.<DD><CODE>endColor</CODE> - Color to end with.<DD><CODE>roundedCorners</CODE> - Mask of *_ROUNDED_RECT_CORNER constants to mark
 corners to round.<DD><CODE>arcWidth</CODE> - Width of ellipse for rounding; must be between zero and
 the rect width (inclusive).<DD><CODE>arcHeight</CODE> - Height of ellipse for rounding; must be between zero and
 the rect height (inclusive).
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - Thrown if the provided rect is malformed
 (either null, or with a height or width of zero or less), or if the
 provided arc specifications are malformed (height or width of less than zero
 or greater than the rect's associated dimension).<DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawGradientFilledRoundedRect(net.rim.device.api.ui.XYRect, int, int, boolean, int, int, int)"><!-- --></A><H3>
drawGradientFilledRoundedRect</H3>
<PRE>
public void <B>drawGradientFilledRoundedRect</B>(<A HREF="../../../../../net/rim/device/api/ui/XYRect.html" title="class in net.rim.device.api.ui">XYRect</A>&nbsp;rect,
                                          int&nbsp;startColor,
                                          int&nbsp;endColor,
                                          boolean&nbsp;drawBorder,
                                          int&nbsp;roundedCorners,
                                          int&nbsp;arcWidth,
                                          int&nbsp;arcHeight)</PRE>
<DL>
<DD>Draws a rounded rectangle with a gradient fill.

 <p> The gradient fill is a linear gradient from the top edge of the
 rectangle to the bottom edge. If you want to use dithered shading, use
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setDrawingStyle(int, boolean)"><CODE>Graphics.setDrawingStyle(int, boolean)</CODE></A> with <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#DRAWSTYLE_DITHERED_SHADING"><CODE>Graphics.DRAWSTYLE_DITHERED_SHADING</CODE></A>.

 <p> You specify the curvature for rounded corners by giving the height
 and width of an elliptical curve's quadrant (the quadrant of the ellipse
 chosen is the associated quadrant of the rectangle to draw--thus the top
 right quadrant of the ellipse gets used as the template for the curve of
 the top right quadrant of the rectangle to draw). If you want the
 rectangle's corner to be evenly rounded, you specify an ellipse with
 equal height and width (i.e. you describe a circle as the curvature
 template).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rect</CODE> - Dimensions and placement of the rectangle to draw; must not
 be null and must have dimensions greater than zero.<DD><CODE>startColor</CODE> - Color to start with, at the top edge of the rectangle.<DD><CODE>endColor</CODE> - Color to transform into, at the bottom edge of the
 rectangle.<DD><CODE>drawBorder</CODE> - True to draw a bordered rectangle; false to draw the
 rect with no border. The border stroke is one pixel wide; the border
 color is the default foreground color set with <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setColor(int)"><CODE>Graphics.setColor(int)</CODE></A>.<DD><CODE>roundedCorners</CODE> - Rounded corners bitmask value indicating which
 corners to round (mask of the various *_ROUNDED_RECT_CORNER constants).<DD><CODE>arcWidth</CODE> - Width of the ellipse providing the arc segments used to
 round the corners; must be between zero and the rectangle's total width
 (inclusive).<DD><CODE>arcHeight</CODE> - Height of the ellipse providing the arc segments used to
 round the corners; must be between zero and the rectangle's total height
 (inclusive).
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - Thrown if the provided rect is malformed
 (either null, or with a height or width of zero or less), or if the
 provided arc specifications are malformed (height or width less than zero,
 or greater than the rect's associated dimension).<DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawGradientFilledRoundedRect(int, int, int, int, int, int, int, int)"><!-- --></A><H3>
drawGradientFilledRoundedRect</H3>
<PRE>
public void <B>drawGradientFilledRoundedRect</B>(int&nbsp;x,
                                          int&nbsp;y,
                                          int&nbsp;width,
                                          int&nbsp;height,
                                          int&nbsp;startColor,
                                          int&nbsp;endColor,
                                          int&nbsp;arcWidth,
                                          int&nbsp;arcHeight)</PRE>
<DL>
<DD>Draws an un-bordered, fully rounded rectangle with a gradient fill, from
 a provided point.

 <p> This is a convenience method wrapping
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRoundedRect(int, int, int, int, int, int, boolean, int, int, int)"><CODE>drawGradientFilledRoundedRec(x,y,width,height,startColor,endColor,false,ALL_ROUNDED_RECT_CORNERS,arcWidth,arcHeight)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Distance from left edge of the rectangle's home corner.<DD><CODE>y</CODE> - Distance from top edge of the rectangle's home corner.<DD><CODE>width</CODE> - Horizontal size of the rectangle; must be greater than zero.<DD><CODE>height</CODE> - Vertical size of the rectangle; must be greater than zero.<DD><CODE>startColor</CODE> - Color to start with.<DD><CODE>endColor</CODE> - Color to end with.<DD><CODE>arcWidth</CODE> - Width of ellipse for rounding; must be between zero and
 the rect width (inclusive).<DD><CODE>arcHeight</CODE> - Height of ellipse for rounding; must be between zero and
 the rect height (inclusive).
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - Thrown if you provide a width or height
 of zero or less, or if the provided arc specifications are malformed
 (height or width less than zero, or greater than the rect's associated
 dimension).<DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawGradientFilledRoundedRect(int, int, int, int, int, int, boolean, int, int)"><!-- --></A><H3>
drawGradientFilledRoundedRect</H3>
<PRE>
public void <B>drawGradientFilledRoundedRect</B>(int&nbsp;x,
                                          int&nbsp;y,
                                          int&nbsp;width,
                                          int&nbsp;height,
                                          int&nbsp;startColor,
                                          int&nbsp;endColor,
                                          boolean&nbsp;drawBorder,
                                          int&nbsp;arcWidth,
                                          int&nbsp;arcHeight)</PRE>
<DL>
<DD>Draws a fully rounded rectangle with a gradient fill, from a provided
 point.

 <p> This is a convenience method wrapping
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRoundedRect(int, int, int, int, int, int, boolean, int, int, int)"><CODE>drawGradientFilledRoundedRec(x,y,width,height,startColor,endColor,drawBorder,ALL_ROUNDED_RECT_CORNERS,arcWidth,arcHeight)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Distance from left edge of the rectangle's home corner.<DD><CODE>y</CODE> - Distance from top edge of the rectangle's home corner.<DD><CODE>width</CODE> - Horizontal size of the rectangle; must be greater than zero.<DD><CODE>height</CODE> - Vertical size of the rectangle; must be greater than zero.<DD><CODE>startColor</CODE> - Color to start with.<DD><CODE>endColor</CODE> - Color to end with.<DD><CODE>drawBorder</CODE> - True to draw a border; false to draw the rect without a border.<DD><CODE>arcWidth</CODE> - Width of ellipse for rounding; must be between zero and
 the rect width (inclusive).<DD><CODE>arcHeight</CODE> - Height of ellipse for rounding; must be between zero and
 the rect height (inclusive).
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - Thrown if you provide a width or height
 of zero or less, or if the provided arc specifications are malformed
 (height or width less than zero, or greater than the rect's associated
 dimension).<DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawGradientFilledRoundedRect(int, int, int, int, int, int, int, int, int)"><!-- --></A><H3>
drawGradientFilledRoundedRect</H3>
<PRE>
public void <B>drawGradientFilledRoundedRect</B>(int&nbsp;x,
                                          int&nbsp;y,
                                          int&nbsp;width,
                                          int&nbsp;height,
                                          int&nbsp;startColor,
                                          int&nbsp;endColor,
                                          int&nbsp;roundedCorners,
                                          int&nbsp;arcWidth,
                                          int&nbsp;arcHeight)</PRE>
<DL>
<DD>Draws an un-bordered rectangle with a gradient fill, from a provided
 point.

 <p> This is a convenience method wrapping
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#drawGradientFilledRoundedRect(int, int, int, int, int, int, boolean, int, int, int)"><CODE>drawGradientFilledRoundedRec(x,y,width,height,startColor,endColor,false,roundedCorners,arcWidth,arcHeight)</CODE></A>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Distance from left edge of the rectangle's home corner.<DD><CODE>y</CODE> - Distance from top edge of the rectangle's home corner.<DD><CODE>width</CODE> - Horizontal size of the rectangle; must be greater than zero.<DD><CODE>height</CODE> - Vertical size of the rectangle; must be greater than zero.<DD><CODE>startColor</CODE> - Color to start with.<DD><CODE>endColor</CODE> - Color to end with.<DD><CODE>roundedCorners</CODE> - Mask of *_ROUNDED_RECT_CORNER constants to mark
 corners to round.<DD><CODE>arcWidth</CODE> - Width of ellipse for rounding; must be between zero and
 the rect width (inclusive).<DD><CODE>arcHeight</CODE> - Height of ellipse for rounding; must be between zero and
 the rect height (inclusive).
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - Thrown if you provide a width or height
 of zero or less, or if the provided arc specifications are malformed
 (height or width less than zero, or greater than the rect's associated
 dimension).<DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="drawGradientFilledRoundedRect(int, int, int, int, int, int, boolean, int, int, int)"><!-- --></A><H3>
drawGradientFilledRoundedRect</H3>
<PRE>
public void <B>drawGradientFilledRoundedRect</B>(int&nbsp;x,
                                          int&nbsp;y,
                                          int&nbsp;width,
                                          int&nbsp;height,
                                          int&nbsp;startColor,
                                          int&nbsp;endColor,
                                          boolean&nbsp;drawBorder,
                                          int&nbsp;roundedCorners,
                                          int&nbsp;arcWidth,
                                          int&nbsp;arcHeight)</PRE>
<DL>
<DD>Draws a rounded rectangle with a gradient fill, from a provided point.

 <p> The home corner coordinates you provide locate the top left corner of
 the rectnagle you want to draw.

 <p> The gradient fill is a linear gradient from the top edge of the
 rectangle to the bottom edge. If you want to use dithered shading, use
 <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setDrawingStyle(int, boolean)"><CODE>Graphics.setDrawingStyle(int, boolean)</CODE></A> with <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#DRAWSTYLE_DITHERED_SHADING"><CODE>Graphics.DRAWSTYLE_DITHERED_SHADING</CODE></A>.

 <p> You specify the curvature for rounded corners by giving the height
 and width of an elliptical curve's quadrant (the quadrant of the ellipse
 chosen is the associated quadrant of the rectangle to draw--thus the top
 right quadrant of the ellipse gets used as the template for the curve of
 the top right quadrant of the rectangle to draw). If you want the
 rectangle's corner to be evenly rounded, you specify an ellipse with
 equal height and width (i.e. you describe a circle as the curvature
 template).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - Distance from left edge of the rectangle's home corner.<DD><CODE>y</CODE> - Distance from top edge of the rectangle's home corner.<DD><CODE>width</CODE> - Horizontal size of the rectangle; must be greater than zero.<DD><CODE>height</CODE> - Vertical size of the rectangle; must be greater than zero.<DD><CODE>startColor</CODE> - Color to start with, at the top edge of the rectangle.<DD><CODE>endColor</CODE> - Color to transform into, at the bottom edge of the
 rectangle.<DD><CODE>drawBorder</CODE> - True to draw a bordered rectangle; false to draw the
 rect with no border. The border stroke is one pixel wide; the border
 color is the default foreground color set with <A HREF="../../../../../net/rim/device/api/ui/Graphics.html#setColor(int)"><CODE>Graphics.setColor(int)</CODE></A>.<DD><CODE>roundedCorners</CODE> - Rounded corners bitmask value indicating which
 corners to round (mask of the various *_ROUNDED_RECT_CORNER constants).<DD><CODE>arcWidth</CODE> - Width of the ellipse providing the arc segments used to
 round the corners; must be between zero and the rectangle's total width
 (inclusive).<DD><CODE>arcHeight</CODE> - Height of the ellipse providing the arc segments used to
 round the corners; must be between zero and the rectangle's
 total height (inclusive).
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../../java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</A></CODE> - Thrown if you provide a width or height
 of zero or less, or if the provided arc specifications are malformed
 (height or width less than zero, or greater than the rect's associated
 dimension).<DT><B>Since:</B></DT><DD>BlackBerry API 7.0.0</DD>
</DL>
</DD>
</DL>

<BR>

<BR>
<FORM action="https://www.blackberry.com/DocsFeedback/" method="GET" target="_new">
<INPUT type="hidden" name="title" value="API Reference">
<INPUT type="hidden" name="source" value="External">
<INPUT type="hidden" name="version" value="7.1.0">
<INPUT type="hidden" name="classname" value="net.rim.device.api.ui.Graphics">
<INPUT type="submit" value="Submit Feedback" /></FORM>

<BR>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../net/rim/device/api/ui/FontSpec.html" title="class in net.rim.device.api.ui"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../net/rim/device/api/ui/Keypad.html" title="class in net.rim.device.api.ui"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?net/rim/device/api/ui/Graphics.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Graphics.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<font size=-1><p>Copyright 1999-2011 Research In Motion Limited.  295 Phillip Street, Waterloo, Ontario, Canada, N2L 3W8.  All Rights Reserved.<br>Java is a trademark of Oracle America Inc. in the US and other countries.<br><a target='_blank' href='http://www.blackberry.com/legal'>Legal</a></p></font>
</BODY>
</HTML>
