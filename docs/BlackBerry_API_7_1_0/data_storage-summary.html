 <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Mon Jul 28 14:36:56 EDT 2008 -->
<TITLE>
BlackBerry Java SDK 7.0 API Reference: Data Storage
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">
<script type="text/javascript">
<!--
// switchMenu - Expand or collapse a code sample div. Takes two arguments:
// divSample, the id of the div to expand, divList
function switchMenu(divSample, sourceLink) {
	var el = document.getElementById(divSample).style;
	if (el.display == 'none') {
		el.display = 'block';
		sourceLink.className = 'explink_minus';
	} else {
		el.display = 'none';
		sourceLink.className = 'explink_plus';
	}
}

// collapseAll - Collapses all expandable divs and adds the + graphic automatically when the page loads.
// This is done so that users who do not have JS enabled can still see the code samples.
function collapseAll() {
	// Collapse all expandable divs
	var divsOnPage = document.getElementsByTagName('div');
	for (var x = 0; x < divsOnPage.length; x++) {
		if (divsOnPage[x].id.substr(0,3) == "UI_") {
			divsOnPage[x].style.display = 'none';
		}
	}

	// Change all the expand/collapse links to hlink_plus, to show a plus sign beside it
	var linksOnPage = document.getElementsByTagName('a');
	for (var y = 0; y < linksOnPage.length; y++) {
		if (linksOnPage[y].className == "explink") {
			linksOnPage[y].className = "explink_plus";
		}
	}
}
//-->
</script>

</HEAD>
<BODY BGCOLOR="white" onLoad="collapseAll();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV&nbsp;
&nbsp;NEXT</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="data_storage-summary.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->
<HR>
<FORM action="https://www.blackberry.com/DocsFeedback/" method="GET" target="_new">
<INPUT type="hidden" name="title" value="API Reference">
<INPUT type="hidden" name="source" value="External">

<INPUT type="hidden" name="version" value="7.0.0">
<INPUT type="hidden" name="classname" value="Data Storage overview">
<INPUT type="submit" value="Submit Feedback" /></FORM>

<BR>


<h1 align="center">Data Storage<a name="TOP"></a></h1>

<h2>Overview</h2>
<p>
The data storage category contains data storage packages.
<p>You can choose from a variety of approaches for  
storing, sharing, and managing your application data. 
This document is designed to help you choose which data storage option
is best suited for your application and to help you get started 
implementing your data storage solution. 
It provides an overview of data storage options; 
describes each option in more detail; 
and then introduces some data management tools. 

<p>This document includes the following sections:</p>
<ul>
  <li><a href="#Intro">Introduction to data storage</a></li>
  <li><a href="#DS_FileSystem">Storing files in the file system  (FileConnection API)</a></li>
  <li><a href="#DS_SQLite">Storing data in SQLite relational databases  (Database API)</a></li>
  <li><a href="#DS_PStore">Storing objects persistently  (PersistentStore API)</a></li>
  <li><a href="#DS_RMS">Storing data for MIDlets  (MIDP RMS API)</a></li>
  <li><a href="#DS_RStore">Storing objects nonpersistently  (RuntimeStore API)</a></li>
  <li><a href="#DS_SYNC">Backing up data  (Synchronization API)</a></li>
  <li><a href="#Lowmem">Managing low memory  (LowMemory API)</a></li>
  <li><a href="#Clean">Removing sensitive data (MemoryCleaner API)</a></li>
</ul>
<br>
For more information about data storage, see the <a href="http://docs.blackberry.com/en/developers/subcategories/?userType=21&category=Development+Guides">Data Storage Development Guide</a>.

<h2>Introduction to data storage <a name="Intro"></a><a href="#TOP" class="backtotop">[back to top]</a></h2>

<p>Different BlackBerry&reg; devices support different types of memory. 
The following types of memory are possible on BlackBerry devices:
<ul>
<li><b>Application storage</b> is internal to the BlackBerry device. 
It contains the operating system, Java&reg; Virtual Memory (JVM), and an internal file system.
Application storage is also called flash memory and onboard memory. 
Application storage is the only place on a BlackBerry device from which applications can be run. 
All BlackBerry devices have application storage. 

<li><b>External media card storage</b> is a microSD card that 
BlackBerry device users can insert to extend the storage on their device. 
It is optional and removable. 
A File Allocation Table (FAT) file system is mounted on the media card. 
MicroSD cards are supported on all devices running BlackBerry&reg; Device Software 4.2 or later, 
with the exception of the BlackBerry&reg; 8700 Series.

<li><b>Built-in media storage</b> is an embedded multimedia card (eMMC). 
It is not removable. 
A FAT file system is mounted on the built-in media card. 
Built-in media storage is also called internal media memory and on-board device memory. 
Built-in media storage is included on many newer devices. 
</ul>
When you consider where to store essential data, keep in mind that 
microSD cards can be removed.   
Data can be corrupted if the card is removed while data is being written. 
For both external media card storage and built-in media storage, 
data can be corrupted if the battery is removed from the device while data is being written. 
Application storage is more robust in these situations.
<p>There is more latency in writing to application storage than there is in reading from it.
For example, reading from the persistent store is relatively fast while commits are relatively slow.

<h3>Data Storage Options</h3>
<p>The following table lists data storage options across the top, 
and compares some main features.
<p>
<table border=1 cellpadding="4" cellspacing="0">
<tr class="TableHeadingColor" valign="middle">
<th valign="middle">Features</th>
<th valign="middle">File System</th>
<th valign="middle">SQLite&reg;</th>
<th valign="middle">Persistent Store</th>
<th valign="middle">MIDP RMS</th>
<th valign="middle">Runtime Store</th>
</tr>

<tr valign="top">
<td valign="top"><b>Data format that can be stored</b></td>
<td valign="top">Any; but is most useful for large read-only files</td>
<td valign="top">Relational database file</td>
<td valign="top">Java object</td>
<td valign="top">Serialized</td>
<td valign="top">Java object</td>
</tr>

<tr valign="top">
<td valign="top"><b>Storage locations</b></td>
<td valign="top">Might be possible on application storage, external media card, and built-in media storage</td>
<td valign="top">Might be possible on external media card and built-in media storage</td>
<td valign="top">Application storage</td>
<td valign="top">Application storage</td>
<td valign="top">Application storage</td>
</tr>

<tr valign="top">
<td valign="top"><b>Maximum limit</b></td>
<td valign="top">Size of partitions the user has access to</td>
<td valign="top">Size of partitions the user has access to</td>
<td valign="top">Available application storage</td>
<td valign="top">Differs according to version (see <a href="#DS_RMS">details</a>)
<td valign="top">Available application storage</td>
</tr>

<tr valign="top">
<td valign="top"><b>Compatibility (BlackBerry Device Software versions)</b></td>
<td valign="top">FileConnection API: 4.2 and later</td>
<td valign="top">5.0 and later</td>
<td valign="top">All</td>
<td valign="top">All</td>
<td valign="top">3.6 and later</td>
</tr>

<tr valign="top">
<td valign="top"><b>Persist across device restarts?</b></td>
<td valign="top">Yes</td>
<td valign="top">Yes</td>
<td valign="top">Yes</td>
<td valign="top">Yes</td>
<td valign="top">No</td>
</tr>

<tr valign="top">
<td valign="top"><b>Share data between applications?</b></td>
<td valign="top">Yes</td>
<td valign="top">Yes</td>
<td valign="top">Yes</td>
<td valign="top">Yes</td>
<td valign="top">Yes</td>
</tr>
</table>

<br>
<p><b>Considerations for choosing a data storage option</b>
<ul>
<li>The file system is typically the most efficient storage location for large, 
read-only files such as videos or large graphics.
<li>For storing data other than large, read-only files, SQLite provides a 
scalable data storage option.
<li>Memory on wireless devices can be very limited, 
so you should consider not storing everything on the device. 
BlackBerry devices are frequently connected so you can access data when needed.
In many cases, the best approach is to store data across device resets 
only when it is frequently accessed.
<li>The file system and MIDP RMS are standards-based approaches, 
while the persistent store and runtime store are specific to BlackBerry devices. 
If you want your application to run on other Java ME-compatible devices, 
you should consider a standards-based approach.
<li>The JVM includes the Garbage Collector, which runs periodically to 
remove unreferenced and weakly referenced objects from memory. 
Do not call the Garbage Collector directly, but 
release resources by setting their reference to null after use.
</ul>

<h2>Storing files in the file system (FileConnection API) <a name="DS_FileSystem"></a><a href="#TOP" class="backtotop">[back to top]</a></h2>
<p>Packages: <span class="style2">
<a href="net/rim/device/api/io/file/package-summary.html">net.rim.device.api.io.file</a>,
<a href="net/rim/device/api/io/file/package-summary.html">javax.microedition.io.file</a> 
</span></p>

 <p>You can programmatically create and manage the files and folders on BlackBerry devices  
using the FileConnection API. 
The FileConnection API was introduced with BlackBerry Device Software 4.2.
<p>The FileConnection API is defined by JSR 75 and is built on the Generic Connection Framework (GCF). 
It is implemented in <code>javax.microedition.io.file.*</code> and
its main component is the <code>FileConnection</code> class. 
Unlike other GCF connections, <code>FileConnection</code> objects can 
be successfully returned from the <code>Connector.open()</code> method 
without referencing an existing file or folder. 
This behavior allows for the creation of new files and folders on a file system.
<p>RIM provides the following extensions to the FileConnection API. They are in the 
<code>net.rim.device.api.io.file.*</code> package:
<ul>
<li>The <code>FileSystemJournal</code> and <code>FileSystemJournalListener</code> 
classes allow detection of changes to the file system.
<li>The <code>ExtendedFileConnection</code> class allows the encryption and protection of files.
</ul>
<p>
There are two types of storage you can access: internal storage and external media card storage.
<p>Internal storage is application storage or built-in media storage. 
To access internal storage, use the path <code>file:///store</code>. For example,</p>
<p><code>FileConnection fc = (FileConnection)Connector.open("file:///Store")</code>
<p>
You can access external media card storage only on devices with microSD cards.
To access external media card storage, use the path <code>file:///SDCard</code>. For example, 
<p><code>FileConnection fc = (FileConnection)Connector.open("file:///SDCard")</code>

<p>Files created by your application are not automatically removed when your application is removed.
<p>When a BlackBerry device is connected to a computer using USB, 
users can transfer files from  
external media card storage with Mass Storage mode or the BlackBerry&reg; Desktop Manager.
<p>Devices that have built-in media storage have a file system partition called System.
In BlackBerry Device Software 5.0 and later, 
the system partition is reserved for system use and is read-only. 
In BlackBerry Device Software versions earlier than 5.0, the system partition is read/write. 
You can access this partition with the path <code>file:///system</code>.

<p>
<a class="explink" onClick="switchMenu('UI_DisplayVidPath', this);">Click for code sample: Displaying the path to the video folder using System.getProperty()</a></p>
<div id="UI_DisplayVidPath" class="codesample">

<table cellspacing="0" class="codesample" width="75%">
 <tr>
  <td>
   <pre>
import net.rim.device.api.ui.UiApplication;
import net.rim.device.api.ui.component.LabelField;
import net.rim.device.api.ui.container.MainScreen;

public class GetVidDir extends UiApplication
{
    public static void main(String args[])
    {
        GetVidDir app = new GetVidDir();
        app.enterEventDispatcher();
    }
    
    public GetVidDir()
    {
        HomeScreen hs = new HomeScreen();
        pushScreen(hs);
    }
}

class HomeScreen extends MainScreen
{
    public HomeScreen()
    {
        LabelField msg = new LabelField(System.getProperty("fileconn.dir.videos"));
        add(msg);
    }
}
</pre>
  </td>
 </tr>
</table>
</div>

<p>
<a class="explink" onClick="switchMenu('UI_ListMountedRoots', this);">Click for code sample: Retrieving a list of mounted roots</a></p>
<div id="UI_ListMountedRoots" class="codesample">

<table cellspacing="0" class="codesample" width="75%">
 <tr>
  <td>
   <pre>
import java.util.Enumeration;
import javax.microedition.io.file.FileSystemRegistry;
import net.rim.device.api.ui.UiApplication;
import net.rim.device.api.ui.component.LabelField;
import net.rim.device.api.ui.container.MainScreen;

public class ListMountedRoots extends UiApplication 
{
   public static void main(String[] args) 
   {
      ListMountedRoots app = new ListMountedRoots();
      app.enterEventDispatcher();
   }
	
   public ListMountedRoots()
   {
      pushScreen(new HomeScreen());
   }
}

class HomeScreen extends MainScreen
{
    public HomeScreen() {
        StringBuffer msg = new StringBuffer( “The mounted roots are:\n”);
        Enumeration e = FileSystemRegistry.listRoots();
        while (e.hasMoreElements()) {
            msg.append( e.nextElement() );
            msg.append( ‘\n’ );
        }
        add(new LabelField(msg));
    }

}
</pre>
  </td>
 </tr>
</table>
</div>

<p>
<a class="explink" onClick="switchMenu('UI_CreateFile', this);">Click for code sample: Creating a file</a></p>
<div id="UI_CreateFile" class="codesample">

<table cellspacing="0" class="codesample" width="75%">
 <tr>
  <td>
   <pre>import net.rim.device.api.system.Application;
import javax.microedition.io.*;
import javax.microedition.io.file.*;
import java.io.IOException;

public class CreateFileApp extends Application 
{
    public static void main(String[] args) 
    {
        CreateFileApp app = new CreateFileApp();
        app.setAcceptEvents(false);
        try 
        {
             FileConnection fc = (FileConnection)Connector.open("file:///store/home/user/newfile.txt");
             // If no exception is thrown, then the URI is valid, but the file may or may not exist.
             if (!fc.exists())
             {
                 fc.create();  // create the file if it doesn't exist
             }
             fc.close();
         }
         catch (IOException ioe) 
         {
            System.out.println(ioe.getMessage() );
         }
    }
}</pre>
  </td>
 </tr>
</table>
</div>

<p>
<a class="explink" onClick="switchMenu('UI_CreateFolder', this);">Click for code sample: Creating a folder</a></p>
<div id="UI_CreateFolder" class="codesample">

<table cellspacing="0" class="codesample" width="75%">
 <tr>
  <td>
   <pre>import net.rim.device.api.system.Application;
import javax.microedition.io.*;
import javax.microedition.io.file.*;
import java.io.IOException;

public class CreateFolderApp extends Application 
{
    public static void main(String[] args) 
    {
        CreateFolderApp app = new CreateFolderApp();
        app.setAcceptEvents(false);
        try 
        {    // the final slash in the folder path is required
             FileConnection fc = (FileConnection)Connector.open("file:///SDCard/testfolder/");
             // If no exception is thrown, then the URI is valid, but the folder may or may not exist.
             if (!fc.exists())
             {
                 fc.mkdir();  // create the folder if it doesn't exist
             }
             fc.close();
         }
         catch (IOException ioe) 
         {
            System.out.println(ioe.getMessage() );
         }
    }
}</pre>
  </td>
 </tr>
</table>
</div>


<p>
<a class="explink" onClick="switchMenu('UI_AddContent', this);">Click for code sample: Writing text to a file</a></p>
<div id="UI_AddContent" class="codesample">
<table cellspacing="0" class="codesample" width="75%">
 <tr>
  <td>
   <pre>
import net.rim.device.api.system.Application;
import javax.microedition.io.*;
import javax.microedition.io.file.*;
import java.io.IOException;
import java.io.OutputStream;

public class AddFileContent extends Application 
{
    public static void main(String[] args) 
    {
        AddFileContent app = new AddFileContent();
        app.setAcceptEvents(false);
        try 
        {
             FileConnection fc = (FileConnection)Connector.open("file:///store/home/user/newfile.txt");
             // If no exception is thrown, then the URI is valid, but the file may or may not exist.
             if (!fc.exists())
             {
                 fc.create();  // create the file if it doesn't exist
             }
             OutputStream outStream = fc.openOutputStream(); 
             outStream.write("test content".getBytes());
             outStream.close();
             fc.close();
         }
         catch (IOException ioe) 
         {
            System.out.println(ioe.getMessage() );
         }
    }
}
</pre>
  </td>
 </tr>
</table>
</div>


<p><a class="explink" onClick="switchMenu('UI_RandomAccess', this);">Click for code sample: Reading randomly-accessed sections of a file</a></p>
<div id="UI_RandomAccess" class="codesample">

<table cellspacing="0" class="codesample" width="75%">
 <tr>
  <td>
   <pre>
import net.rim.device.api.ui.*;
import net.rim.device.api.io.*;
import javax.microedition.io.file.*;
import javax.microedition.io.*;
import java.io.*;
import net.rim.device.api.ui.component.*;
import net.rim.device.api.ui.container.*;

public class RandomFileAccess extends UiApplication
{
      public static void main(String[] args)
      {
         RandomFileAccess app = new RandomFileAccess();
         app.enterEventDispatcher();
      }
      public RandomFileAccess()
      {
         pushScreen(new HomeScreen());
      }
}

class HomeScreen extends MainScreen
{

      public HomeScreen()
      {
              setTitle("Random File Access Sample");
              try 
              {
                 FileConnection fc = (FileConnection)Connector.open("file:///SDCard/test.gif");
                 boolean bFileExists = fc.exists();
                 if (!bFileExists)
                 {
                   Dialog.alert("Cannot find specified GIF file.");
                   System.exit(0);
                 }
                 DataInputStream in = fc.openDataInputStream();
                 byte[] widthBytes = new byte[2];
                 byte[] heightBytes = new byte[2];
                 
                 if ( in instanceof Seekable ) 
                 {
                    ((Seekable) in).setPosition(6);
                    in.read(widthBytes,0,2);
                 
                    ((Seekable) in).setPosition(8);
                    in.read(heightBytes,0,2);
                 } 
                 
                 int widthPixels  = widthBytes[0]  + 256 * widthBytes[1];
                 int heightPixels = heightBytes[0] + 256 * heightBytes[1];
                 
                 add(new LabelField("Width: " + widthPixels + "\nHeight: " + heightPixels));
                 
                 in.close();
                 fc.close();
             }
             catch (IOException ioe) 
             {
                System.out.println( ioe.getMessage() );
             } 
      } 
}
</pre>
 </td>
 </tr>
</table>
</div>


<h2>Storing data in SQLite relational databases (Database API) <a name="DS_SQLite"></a><a href="#TOP" class="backtotop">[back to top]</a></h2>
<p>Package: <span class="style2">
<a href="net/rim/device/api/database/package-summary.html">net.rim.device.api.database</a>
</span></p>
<p>
The Database API lets you create and use SQLite relational databases. 
The Database API was introduced with BlackBerry Device Software 5.0.
<p>
For more information about the Database API, see the 
<a href="http://docs.blackberry.com/en/developers/subcategories/?userType=21&category=Development+Guides">Data Storage Development Guide</a>.
<p>
BlackBerry Device Software 7.0 uses SQLite version 3.7.2.
<p>Each SQLite database is stored in a single file. 
If you specify only the database name as the parameter value to <code>DatabaseFactory.create()</code>, 
the database file is created on the external media card. 
The default location for the database file is <code>/SDCard/databases/application_name/</code>.
The name of the application that creates the database is included in the path to avoid name collisions. 
You cannot store SQLite databases in application storage.
On devices that support built-in media storage, you can create database files in built-in media storage by specifying 
the path <code>/store/</code>. 
<p>
For more information about SQLite, visit <a href="http://www.sqlite.org" target="_blank">http://www.sqlite.org</a>.
<p> 
 
<p><a class="explink" onClick="switchMenu('UI_CreateDB', this);">Click for code sample: Creating a SQLite database at the root of a media card</a></p>
<div id="UI_CreateDB" class="codesample">

<table cellspacing="0" class="codesample" width="75%">
 <tr>
  <td>
   <pre>
import net.rim.device.api.system.Application;
import net.rim.device.api.database.*;
import net.rim.device.api.io.*;

public class CreateDatabase extends Application
{
    public static void main(String[] args)
    {
        CreateDatabase app = new CreateDatabase();
        try
        {
            URI strURI = URI.create("file:///SDCard/test.db"); 
            DatabaseFactory.create(strURI);
        }
        catch ( Exception e ) 
        {         
            System.out.println( e.getMessage() );
        }  
    } 
}
</pre>
</td>
</tr>
</table>
</div>

<p><a class="explink" onClick="switchMenu('UI_AddTable', this);">Click for code sample: Adding a table to a SQLite database</a></p>
<div id="UI_AddTable" class="codesample">

<table cellspacing="0" class="codesample" width="75%">
 <tr>
  <td>
   <pre>
import net.rim.device.api.database.Database;
import net.rim.device.api.database.DatabaseFactory;
import net.rim.device.api.database.Statement;
import net.rim.device.api.io.URI;
import net.rim.device.api.system.Application;

public class AddDatabaseTable extends Application 
{
   public static void main(String[] args)
   {
      AddDatabaseTable app = new AddDatabaseTable();
      try
      {
         URI myURI = URI.create("/SDCard/test.db"); 
         Database d = DatabaseFactory.open(myURI);
         Statement st = d.createStatement( "CREATE TABLE 'People' ( " +
                                              "'Name' TEXT, " +
                                              "'Age' INTEGER )" );
         st.prepare();
         st.execute();
         st.close();
        }
        catch ( Exception e ) 
        {         
            System.out.println( e.getMessage() );
        }
   }
}
</pre>
</td>
</tr>
</table>
</div>


<p><a class="explink" onClick="switchMenu('UI_AddTableContent', this);">Click for code sample: Adding content to a SQLite table</a></p>
<div id="UI_AddTableContent" class="codesample">

<table cellspacing="0" class="codesample" width="75%">
 <tr>
  <td>
   <pre>
import net.rim.device.api.database.Database;
import net.rim.device.api.database.DatabaseFactory;
import net.rim.device.api.database.Statement;
import net.rim.device.api.io.URI;
import net.rim.device.api.system.Application;

public class AddDatabaseTable extends Application 
{
    public static void main(String[] args)
    {
        AddDatabaseTable app = new AddDatabaseTable();
        try
        {
            URI myURI = URI.create("/SDCard/test.db"); 
            Database d = DatabaseFactory.open(myURI);
            Statement st = d.createStatement("INSERT INTO People(Name,Age) " +
                                             "VALUES ('John',37)");
            st.prepare();
            st.execute();
            st.close();
        }
        catch ( Exception e ) 
        {         
            System.out.println( e.getMessage() );
        }
    }
}
</pre>
</td>
</tr>
</table>
</div>

<h2>Storing objects persistently (PersistentStore API) <a name="DS_PStore"></a><a href="#TOP" class="backtotop">[back to top]</a></h2>
<p>Package: <span class="style2">
<a href="net/rim/device/api/system/package-summary.html">net.rim.device.api.system</a>
</span></p>
<p>
The Persistent Store API lets you save objects to persistent memory. 
The storage for each application is distinct because it uses 64-bit globally unique identifiers (GUIDs). 
The objects are retained in memory after a BlackBerry device restarts. 
The Persistent Store API is provided in all versions of BlackBerry Device Software.
<p>Data is stored as instances of 
<code><a href="net/rim/device/api/system/PersistentObject.html">PersistentObject</a></code>.
The contents of <code>PersistentObject</code> can be any object that 
implements the <code><a href="net/rim/vm/persistable.html">Persistable</a></code> interface.
In addition, the API allows the implicit persistence of classes;  
the following data types automatically implement the <code>Persistable</code> interface and so can be stored:
<ul><code><li>java.lang.Boolean
<li>java.lang.Byte 
<li>java.lang.Character 
<li>java.lang.Integer 
<li>java.lang.Long 
<li>java.lang.Object 
<li>java.lang.Short 
<li>java.lang.String 
<li>java.util.Vector 
<li>java.util.Hashtable</code></ul>

<p>
<b>Cleanup</b>
<p>When an application is uninstalled, persistent objects that are defined 
within the application are automatically deleted. 
This is because each persistent object has a class type that is defined in the application. 
When the application is deleted the class type is deleted, so the persistent objects are deleted.
<p>To ensure cleanup of the persistent storage you use, you
should always store your instances of your own classes or your own extensions of provided classes.

<p><b>Restricting access</b>
<p>If you want to permit only specific, authorized applications to access your application data, 
then you should use the <code>ControlledAccess</code> class in conjunction with 
key generation and a key-signing procedure. 
To restrict access to your data:
<ol><li>Wrap the <code>PersistentObject</code> in a <code>ControlledAccess</code> object  
that is associated with a signing key 
that was created using the BlackBerry® Signing Authority Tool.</li>
<li>Sign applications that you want to allow access to the protected data using the 
same signing key that protects the data.</li>
</ol>
<p>For detailed instructions, see 
<a href="http://supportforums.blackberry.com/t5/Java-Development/Protect-persistent-objects-from-access-by-unauthorized/ta-p/524282"> 
Protect persistent objects from access by unauthorized applications</a>.
<p>
<b>Conserving object handles</b>
<p>
The persistent store's consumption of object handles can negatively affect performance. 
You should consider using the grouping mechanism to persist objects and conserve handles. 
Because it is possible for commits to the persistent store to occur during garbage collection, 
without an explicit call to <code>commit()</code>, grouping of objects should always occur before calls 
to <code>setContents()</code> or <code>commit()</code>. 
See <code><a href="net/rim/device/api/system/ObjectGroup.html">net.rim.device.api.system.ObjectGroup</a></code>.
</p>

<h2>Storing data for MIDlets (MIDP RMS API) <a name="DS_RMS"></a><a href="#TOP" class="backtotop">[back to top]</a></h2>
<p>Package: <span class="style2">
<a href="javax/microedition/rms/package-summary.html">javax.microedition.rms</a>
</span></p>
<p>The Mobile Information Device Profile (MIDP) specification provides persistent storage for MIDlets. 
This persistent storage mechanism is called the MIDP Record Management System (MIDP RMS).
It is modeled after a simple record-oriented database. 
MIDP RMS is the MIDP equivalent of the RIM PersistentStore API. 
MIDP RMS is available on all MIDP devices. 
While designed for MIDlets, this storage method can also be used in BlackBerry applications.

<p>The RMS API lets you store and retrieve byte arrays. 
Each byte array is assigned an integer ID that you use later to retrieve the byte array. 
Retrieval is done by enumerating over the records.
<p>Applications that use the RMS API can either make data private or allow sharing. 
The RMS API is frequently used to share data between applications.
</p> 
<p>
RMS data that an application saves is automatically deleted when the 
application is removed. 
When you upgrade an application that uses MIDP RMS data storage, 
the data is retained. 
</p>
<p>Here are the maximum storage sizes for RMS storage:
<p>
<table border=1 cellpadding="4" cellspacing="0">
<tr class="TableHeadingColor" valign="middle">
<th valign="middle">BlackBerry Device Software version</th>
<th valign="middle">Maximum individual RecordStore size</th>
<th valign="middle">Maximum total RecordStore size (cumulative for all applications)</th>
</tr>

<tr valign="top">
<td valign="top">Earlier than 4.1</td>
<td valign="top">64 KB</td>
<td valign="top">64 KB</td>

</td>
</tr>
<tr valign="top">
<td valign="top">4.1 to 4.5</td>
<td valign="top">64 KB</td>
<td valign="top">Available device memory</td>
</tr>

<tr valign="top">
<td valign="top">4.6 and later</td>
<td valign="top">512 KB</td>
<td valign="top">Available device memory</td>
</tr>
</tbody>
</table>
</p>

<p><a class="explink" onClick="switchMenu('UI_RMSBYTE', this);">Click for code sample: Adding a byte array to the RMS store</a></p>
<div id="UI_RMSBYTE" class="codesample">
<table cellspacing="0" class="codesample" width="75%">
 <tr>
  <td>
<pre>
int authMode = RecordStore.AUTHMODE_ANY;
boolean bWrite = true;

rs = RecordStore.openRecordStore( "rs", true, 
       authMode, bWrite );
  
byte[] pi = new byte[]{ 3, 1, 4, 1, 5, 9 };
int recordID;

recordID = rs.addRecord(pi, 0, pi.length);
</pre>
</td>
</tr>
</table>
</div>

<p><a class="explink" onClick="switchMenu('UI_RMS', this);">Click for code sample: Storing and retrieving data with RMS store</a></p>
<div id="UI_RMS" class="codesample">
This example uses the Record Management System to store and retrieve high scores for a game. 
In the example, high scores are stored in separate records, 
and are sorted when necessary using a RecordEnumeration. 
<p>
<table cellspacing="0" class="codesample" width="75%">
<tr>
 <td>

 <pre>
import javax.microedition.rms.*;
import java.io.DataOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.EOFException;

/**
 * A class used for storing and showing game scores.
 */
public class RMSGameScores
    implements RecordFilter, RecordComparator
{
    /*
     * The RecordStore used for storing the game scores.
     */
    private RecordStore recordStore = null;

    /*
     * The player name to use when filtering.
     */
    public static String playerNameFilter = null;

    /*
     * Part of the RecordFilter interface.
     */
    public boolean matches(byte[] candidate)
        throws IllegalArgumentException
    {
        // If no filter set, nothing can match it.
        if (this.playerNameFilter == null) {
            return false;
        }

        ByteArrayInputStream bais = new ByteArrayInputStream(candidate);
        DataInputStream inputStream = new DataInputStream(bais);
        String name = null;

        try {
            int score = inputStream.readInt();
            name = inputStream.readUTF();
        }
        catch (EOFException eofe) {
            System.out.println(eofe);
            eofe.printStackTrace();
        }
        catch (IOException eofe) {
            System.out.println(eofe);
            eofe.printStackTrace();
        }
        return (this.playerNameFilter.equals(name));
    }

    /*
     * Part of the RecordComparator interface.
     */
    public int compare(byte[] rec1, byte[] rec2)
    {
        // Construct DataInputStreams for extracting the scores from
        // the records.
        ByteArrayInputStream bais1 = new ByteArrayInputStream(rec1);
        DataInputStream inputStream1 = new DataInputStream(bais1);
        ByteArrayInputStream bais2 = new ByteArrayInputStream(rec2);
        DataInputStream inputStream2 = new DataInputStream(bais2);
        int score1 = 0;
        int score2 = 0;
        try {
            // Extract the scores.
            score1 = inputStream1.readInt();
            score2 = inputStream2.readInt();
        }
        catch (EOFException eofe) {
            System.out.println(eofe);
            eofe.printStackTrace();
        }
        catch (IOException eofe) {
            System.out.println(eofe);
            eofe.printStackTrace();
        }

        // Sort by score
        if (score1 < score2) {
            return RecordComparator.PRECEDES;
        }
        else if (score1 > score2) {
            return RecordComparator.FOLLOWS;
        }
        else {
            return RecordComparator.EQUIVALENT;
        }
    }

    /**
     * The constructor opens the underlying record store,
     * creating it if necessary.
     */
    public RMSGameScores()
    {
        //
        // Create a new record store for this example
        //
        try {
            recordStore = RecordStore.openRecordStore("scores", true);
        }
        catch (RecordStoreException rse) {
            System.out.println(rse);
            rse.printStackTrace();
        }
    }

    /**
     * Add a new score to the storage.
     *
     * @param score the score to store.
     * @param playerName the name of the play achieving this score.
     */
    public void addScore(int score, String playerName)
    {
        //
        // Each score is stored in a separate record, formatted with
        // the score, followed by the player name.
        //
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        DataOutputStream outputStream = new DataOutputStream(baos);
        try {
            // Push the score into a byte array.
            outputStream.writeInt(score);
            // Then push the player name.
            outputStream.writeUTF(playerName);
        }
        catch (IOException ioe) {
            System.out.println(ioe);
            ioe.printStackTrace();
        }

        // Extract the byte array
        byte[] b = baos.toByteArray();
        // Add it to the record store
        try {
            recordStore.addRecord(b, 0, b.length);
        }
        catch (RecordStoreException rse) {
            System.out.println(rse);
            rse.printStackTrace();
        }
    }

    /**
     * A helper method for the printScores methods.
     */
    private void printScoresHelper(RecordEnumeration re)
    {
        try {
            while(re.hasNextElement()) {
                int id = re.nextRecordId();
                ByteArrayInputStream bais = new ByteArrayInputStream(recordStore.getRecord(id));
                DataInputStream inputStream = new DataInputStream(bais);
                try {
                    int score = inputStream.readInt();
                    String playerName = inputStream.readUTF();
                    System.out.println(playerName + " = " + score);
                }
                catch (EOFException eofe) {
                    System.out.println(eofe);
                    eofe.printStackTrace();
                }
            }
        }
        catch (RecordStoreException rse) {
            System.out.println(rse);
            rse.printStackTrace();
        }
        catch (IOException ioe) {
            System.out.println(ioe);
            ioe.printStackTrace();
        }
    }

    /**
     * This method prints all of the scores sorted by game score.
     */
    public void printScores()
    {
        try {
            // Enumerate the records using the comparator implemented
            // above to sort by game score.
            RecordEnumeration re = recordStore.enumerateRecords(null, this,
                                                                true);
            printScoresHelper(re);
        }
        catch (RecordStoreException rse) {
            System.out.println(rse);
            rse.printStackTrace();
        }
    }

    /**
     * This method prints all of the scores for a given player,
     * sorted by game score.
     */
    public void printScores(String playerName)
    {
        try {
            // Enumerate the records using the comparator and filter
            // implemented above to sort by game score.
            RecordEnumeration re = recordStore.enumerateRecords(this, this,
                                                                true);
            printScoresHelper(re);
        }
        catch (RecordStoreException rse) {
            System.out.println(rse);
            rse.printStackTrace();
        }
    }

    public static void main(String[] args)
    {
        RMSGameScores rmsgs = new RMSGameScores();
        rmsgs.addScore(100, "Alice");
        rmsgs.addScore(120, "Bill");
        rmsgs.addScore(80, "Candice");
        rmsgs.addScore(40, "Dean");
        rmsgs.addScore(200, "Ethel");
        rmsgs.addScore(110, "Farnsworth");
        rmsgs.addScore(220, "Farnsworth");
        System.out.println("All scores");
        rmsgs.printScores();
        System.out.println("Farnsworth's scores");
        RMSGameScores.playerNameFilter = "Farnsworth";
        rmsgs.printScores("Farnsworth");
    }
}
</pre>
</td>
</tr>
</table>
</div>

<h2>Storing objects nonpersistently (RuntimeStore API) <a name="DS_RStore"></a><a href="#TOP" class="backtotop">[back to top]</a></h2>
<p>Package: <span class="style2">
<a href="net/rim/device/api/system/package-summary.html">net.rim.device.api.system</a> (Class <a href="net/rim/device/api/system/RuntimeStore.html">RuntimeStore</a>)
</span></p>
<p>The runtime store provides a central location for applications to store and share information 
ona BlackBerry device. 
Data in the runtime store is not saved when the BlackBerry device is restarted. 
The RuntimeStore API was introduced with BlackBerry Device Software 3.6.</p>
<p>You can use the runtime store to store any object, and you can retrieve 
the object from a different process or a different application. 
You can also restrict access to data.
<p>Objects are stored using a key-value pair. When you store an object in the runtime store, 
you assign the object a unique ID of type <code>long</code> and later use the ID to retrieve 
the object from the store.
<p>Before you exit your application, remove objects from the
runtime store that your applications no longer require. 
<p>
<table style="background-color:#C0C0C0">
<tr><td style="background-color:#EDF0F4">
<b>Warning:</b> You can create a memory allocation problem if you add an object instance to the 
runtime store and don't remove it. This is a common cause of memory leaks
in BlackBerry applications.
</td></tr>
</table>
</p>
<p>Here are some common uses for the runtime store:</p>
<ul>
<li>Share data between two applications: 
For example, an application suite could be made up of multiple applications, 
all of which use data that is pushed to the device. 
One of the applications receives all the 
push data and shares it with the other applications by temporarily 
storing the data in the runtime store. 
Or the runtime store could be used to 
set up communication between a listener 
(such as a <code>PushListener</code>) and a running application.</li>
<li>Store a reference to an object for later use: 
For example, an application 
that allows a BlackBerry device user to add and remove an 
<code>ApplicationMenuItem</code> could use the runtime store 
to store a reference to an <code>ApplicationMenuItem</code> it has registered. 
After the application is closed and re-opened, the <code>ApplicationMenuItem</code> 
can be accessed and unregistered.</li>
<li>Implement system-wide singletons: An application might require 
one or more singleton objects to be accessed from within the application itself 
or by other applications.
</ul>
<p><a class="explink" onClick="switchMenu('UI_RTStoreSet', this);">
Click for code sample: Storing a String in the runtime store</a></p>
<div id="UI_RTStoreSet" class="codesample">
<p>For simplicity, this example does not show how to create the GUID.<p>
<table cellspacing="0" class="codesample" width="75%">
 <tr>
  <td>

<pre>
import net.rim.device.api.system.Application;
import net.rim.device.api.system.RuntimeStore;

public class RuntimeSet extends Application 
{
   public static void main(String[] args) 
   {
      RuntimeSet app = new RuntimeSet();
      System.exit(0);
   }

   public RuntimeSet()
   {
      RuntimeStore rts = RuntimeStore.getRuntimeStore();
      long ID = 0x60ac754bc0867248L; //just a unique ID - generate any way you want
      rts.put(ID, "Shared Message");
   }
}
   </pre>
  </td>
 </tr>
</table>
</div>


<p><a class="explink" onClick="switchMenu('UI_RTStoreGet', this);">
Click for code sample: Getting a stored String from the runtime store</a></p>
<div id="UI_RTStoreGet" class="codesample">
<p>For simplicity, this example does not show how to create the GUID.<p>
<table cellspacing="0" class="codesample" width="75%">

 <tr>
  <td>

<pre>
import net.rim.device.api.system.RuntimeStore;
import net.rim.device.api.ui.UiApplication;
import net.rim.device.api.ui.component.Dialog;
import net.rim.device.api.ui.component.LabelField;
import net.rim.device.api.ui.container.MainScreen;

public class RuntimeGet extends UiApplication 
{
   public static void main(String[] args) 
   {
      RuntimeGet app = new RuntimeGet();
      app.enterEventDispatcher();
   }
 
   public RuntimeGet()
   {
      RuntimeStore rts = RuntimeStore.getRuntimeStore();
      long ID = 0x60ac754bc0867248L; //just a unique ID - generate any way you want
      String msg = (String)rts.get(ID);
      pushScreen(new HomeScreen(msg));
   }

}

class HomeScreen extends MainScreen
{
   public HomeScreen(String msg)
   {
      add(new LabelField(msg));
   }
}
   </pre>
  </td>
 </tr>
</table>
</div>
<p><a class="explink" onClick="switchMenu('UI_RTStoreSing', this);">
Click for code sample: Creating a singleton by using the RuntimeStore API</a></p>
<div id="UI_RTStoreSing" class="codesample">
<p>The following example creates a singleton using the runtime store. 
In this example, the 
static variable <code>_instance</code> 
is initialized to null for each process running on the system, 
so <code>getInstance()</code> must check the <code>_instance</code> variable 
each time it is invoked.
<p>For simplicity, this example does not show how to create the GUID.<p>
<table cellspacing="0" class="codesample" width="75%">


 <tr>
  <td>
<pre>
import net.rim.device.api.system.*;

class MySingleton {
   private static MySingleton _instance;
   private static final long GUID = 0xab4dd61c5d004c18L;

   // constructor
   MySingleton() {}

   public static MySingleton getInstance() {
      if (_instance == null) {
         _instance = (MySingleton)RuntimeStore.getRuntimeStore().get(GUID);
      if (_instance == null) {
         MySingleton singleton = new MySingleton();

         RuntimeStore.getRuntimeStore().put(GUID, singleton);
         _instance = singleton;
         }
      }

      return _instance;

   }
}
   </pre>
  </td>
 </tr>
</table>
</div>

<h2>Setting up data backup (Synchronization API) <a name="DS_SYNC"></a><a href="#TOP" class="backtotop">[back to top]</a></h2>
<p>Package: <span class="style2">
<a href="net/rim/device/api/synchronization/package-summary.html">net.rim.device.api.synchronization</a>
</span></p>
<p>
With the Synchronization API, you can create applications that integrate with the 
BlackBerry&reg; Desktop Manager or BlackBerry&reg; Enterprise Server 
to back up data from a BlackBerry device.
 
<p>
To enable an application to back up data, implement the following 
Synchronization interfaces and use the 
<code><a href="net/rim/device/api/synchronization/SyncManager.html "target="_blank">
SyncManager</a></code> class to register your application for synchronization.
<p>
<table border=1 cellpadding="4" cellspacing="0">
<tr class="TableHeadingColor" valign="middle">
<th valign="middle">Interface</th>
<th valign="middle">Description</th>
</tr>

<tr valign="top">
<td valign="top"><code><a href="net/rim/device/api/synchronization/SyncConverter.html">SyncConverter</a></code></td>
<td valign="top""><p>Converts data between the <code>SyncObject</code> format 
that is required on the BlackBerry device and the serialized format that is required on the computer</p>

</td>
</tr>
<tr valign="top"><td valign="top"><code><a href="net/rim/device/api/synchronization/SyncCollection.html">SyncCollection</a></code></td>
<td valign="top""><p>Represents the collection of synchronization objects for an application</p>

</td>
</tr>
<tr valign="top"><td valign="top""><code><a href="net/rim/device/api/synchronization/SyncObject.html">SyncObject</a></code>
</td>
<td valign="top""><p>Represents an object that can be backed up and restored</p>

</td>
</tr>
</tbody>
</table>
</p>

<p>To download a sample application that demonstrates how to implement these interfaces, 
see the SyncDemo, OTASyncDemo, and OTABackupRestoreDemo code 
samples that are included with the 
BlackBerry&reg; Java&reg; Development Environment and the BlackBerry&reg; Java&reg; Plug-in for Eclipse&reg;.</p>

<p>
To back up and restore a small amount of data such as application configuration options, 
you do not have to implement all of these interfaces. 
Instead, you can extend the <code>SyncItem</code> class and implement its abstract methods. 
The <code>SyncItem</code> class implements 
the <code>SyncCollection, SyncConverter,</code> and <code>SyncObject</code> interfaces for you. 
See <a href="http://supportforums.blackberry.com/t5/Java-Development/Backup-and-restore-small-amounts-of-data-using-SyncItem/ta-p/444763">Backup and restore small amounts of data using SyncItem</a>.
</p>

<h2>Managing low memory (LowMemory API) <a name="Lowmem"></a><a href="#TOP" class="backtotop">[back to top]</a></h2>
<p>Package: <span class="style2">
<a href="net/rim/device/api/lowmemory/package-summary.html">net.rim.device.api.lowmemory</a>
</span></p>

BlackBerry devices require a minimum amount of memory to function properly. 
When available memory on a BlackBerry device falls below an acceptable threshold, 
the Low Memory Manager (LMM) attempts to provide more available memory resources. 
The LMM 
prioritizes objects in memory and marks the less critical objects for deletion by the JVM.
Opened  messages and older calendar entries are typically deleted first.
</p>
<p>
You should design your application to work with the LMM to make available as much memory 
as possible when the device is low on memory resources. 
To do so, implement the <code>LowMemoryListener</code> interface and 
register it with the LMM by calling the static <code>LowMemoryManager.addLowMemoryListener()</code> method.
The <code>LowMemoryListener</code> interface has a single method, 
<code>freeStaleObject()</code>, that is invoked by the LMM when it needs to make memory available. 
When it invokes <code>freeStaleObject()</code>, the LMM passes a priority parameter  
to indicate that it is initiating a high, medium, or low memory recovery request. 
Be careful to return <code>true</code> from <code>freeStaleObject()</code> 
if you freed any resources and <code>false</code> otherwise. 
This is important because the LMM needs an accurate accounting of the memory freeing progress.
</p>

<p><a class="explink" onClick="switchMenu('UI_LowMemory', this);">Click for code sample: Implementing the <code>freeStaleObject()</code> method</a></p>
<div id="UI_LowMemory" class="codesample">
<table cellspacing="0" class="codesample" width="75%">
 <tr>
  <td>
   <pre>public boolean freeStaleObject( int priority ) 
{
boolean dataFreed = false;
switch( priority ) 
{
   case LowMemoryListener.HIGH_PRIORITY:
      dataFreed = freeVector( _data._high );
      _priority = LowMemoryListener.LOW_PRIORITY;
      break;
   case LowMemoryListener.MEDIUM_PRIORITY:
      dataFreed = freeVector( _data._medium );
      _priority = LowMemoryListener.HIGH_PRIORITY;
      break;
   case LowMemoryListener.LOW_PRIORITY:
      dataFreed = freeVector( _data._low );
      _priority = LowMemoryListener.MEDIUM_PRIORITY;
      break;
}

if( dataFreed ) 
{
   _persist.commit();
}
return dataFreed;
}
/**
* A private method that frees the priority vector.
* @param vector The vector to free.
* @return A boolean that indicates whether any objects were freed by this
* method.
*/
private boolean freeVector( Vector vector ) 
{
   boolean dataFreed = false;
   int size = vector.size();
   for( int i = size - 1; i >= 0; i-- ) 
   {
      Object obj = vector.elementAt( i );
      vector.removeElementAt( i );
      LowMemoryManager.markAsRecoverable( obj );
      dataFreed = true;
   }
return dataFreed;
}
</pre>
</td>
</tr>
</table>
</div>

<h2>Removing Sensitive Data (MemoryCleaner API) <a name="Clean"></a><a href="#TOP" class="backtotop">[back to top]</a></h2>

<p>Package: <span class="style2">
<a href="net/rim/device/api/memorycleaner/package-summary.html">net.rim.device.api.memorycleaner</a>
</span></p>
<p>
The memory cleaner can erase sensitive data that is stored in memory on a BlackBerry device. 
Specific events trigger it to clear various caches and perform secure garbage collection.
The memory cleaner is not on by default. 
To turn it on, on the device click <b>Options > Security Options > Advanced Security Options > Memory Cleaning</b> and set <b>Status</b> to <b>Enabled</b>. 
The memory cleaner is turned on automatically when you enable encryption.
</p>

<p>
Users can configure which events trigger a memory cleaning. 
You can register your application to be notified if one of those events occurs. 
To do so, implement the <code>MemoryCleanerListener</code> interface and register it using 
one of the static methods <code>MemoryCleanerDaemon.addListener()</code> or 
<code>MemoryCleanerDaemon.addWeakListener()</code>. 
The interface has two methods, <code>cleanNow()</code> and <code>getDescription()</code>. 
The  <code>cleanNow()</code> method is called by the memory cleaner when a user configurable event occurs. 
The memory cleaner passes an event parameter when it calls <code>cleanNow()</code> to indicate 
the event that initiated the memory clean request. 
The <code>getDescription()</code> method is invoked by the memory cleaner if it must display information 
about the applications that are registered cleaners. 
This functionality is required, for example, on the Memory Cleaning option screen.
</p>

<p><a class="explink" onClick="switchMenu('UI_MemoryClean', this);">Click for code sample: Implementing and registering the MemoryCleanerListener interface</a></p>
<div id="UI_MemoryClean" class="codesample">

<table cellspacing="0" class="codesample" width="75%">
 <tr>
  <td>
   <pre>
import net.rim.device.api.memorycleaner.*;
import net.rim.device.api.system.Application;
import net.rim.device.api.ui.component.Dialog;


public class MemoryCleaner extends Application implements MemoryCleanerListener
{

   public static void main(String[] args) 
   {
      MemoryCleaner app = new MemoryCleaner();
      app.enterEventDispatcher();
   }

   public MemoryCleaner()
   {
      // if you don't use the second parameter to pass true, the cleaner will start immediately
      MemoryCleanerDaemon.addListener(this,false);
   }

   public boolean cleanNow(int event)
   { 
      switch(event)
      {
         case MemoryCleanerListener.EVENT_DEVICE_LOCK:
            // if you free something
            // return true;
            // if you don't free anything
            return false;

         case MemoryCleanerListener.EVENT_IDLE_TIMEOUT:
            //if you free something
            //return true;
            // if you don't free anything
            return false;

            //add additional cases for any events you want to clean in response to
      }
      return false;
   }

   public String getDescription()
   {
      return "Sample Memory Cleaner";
   }
}
</pre>
</td>
</tr>
</table>
</div>

<HR>
<div id="legalnotice">
<table cellspacing="0" cellpading="0" width="100%" style="border:none;">
<tr>
<td style="border:none;">
<font size=-1>
<P>Copyright 1999-2011 Research In Motion Limited. 295 Phillip Street, Waterloo, Ontario, Canada, N2L 3W8. All Rights Reserved.<br>
Java is a trademark of Oracle America, Inc. in the US and other countries.</p>
</font>
</td>
<td style="text-align:right; border:none;">
<font size=-1><br>
<a href="http://www.blackberry.com/legal" target="_blank">Legal</a>
</font>
</td>
</tr>
</table>
 </div>
</BODY>
</HTML>
