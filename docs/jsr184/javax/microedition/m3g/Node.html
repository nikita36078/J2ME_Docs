<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_08) on Thu Jun 30 13:21:21 EEST 2005 -->
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>
Node (Mobile 3D Graphics API (M3G))
</TITLE>

<META NAME="keywords" CONTENT="javax.microedition.m3g.Node class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Node (Mobile 3D Graphics API (M3G))";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Node.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<EM><B>M3G 1.1 -- Jun 22, 2005</B></EM></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/m3g/MorphingMesh.html" title="class in javax.microedition.m3g"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/m3g/Object3D.html" title="class in javax.microedition.m3g"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Node.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.microedition.m3g</FONT>
<BR>
Class Node</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><A HREF="../../../javax/microedition/m3g/Object3D.html" title="class in javax.microedition.m3g">javax.microedition.m3g.Object3D</A>
      <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><A HREF="../../../javax/microedition/m3g/Transformable.html" title="class in javax.microedition.m3g">javax.microedition.m3g.Transformable</A>
          <IMG SRC="../../../resources/inherit.gif" ALT="extended by"><B>javax.microedition.m3g.Node</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../javax/microedition/m3g/Camera.html" title="class in javax.microedition.m3g">Camera</A>, <A HREF="../../../javax/microedition/m3g/Group.html" title="class in javax.microedition.m3g">Group</A>, <A HREF="../../../javax/microedition/m3g/Light.html" title="class in javax.microedition.m3g">Light</A>, <A HREF="../../../javax/microedition/m3g/Mesh.html" title="class in javax.microedition.m3g">Mesh</A>, <A HREF="../../../javax/microedition/m3g/Sprite3D.html" title="class in javax.microedition.m3g">Sprite3D</A></DD>
</DL>
<HR>
<DL>
<DT>public abstract class <B>Node</B><DT>extends <A HREF="../../../javax/microedition/m3g/Transformable.html" title="class in javax.microedition.m3g">Transformable</A></DL>

<P>
<p>An abstract base class for all scene graph nodes.</p>

<p>There are five different kinds of nodes:</p>

<ul>
<li><A HREF="../../../javax/microedition/m3g/Camera.html" title="class in javax.microedition.m3g"><CODE>Camera</CODE></A> defines the projection from 3D to 2D, as well as
    the position of the viewer in the scene.</li>
<li><A HREF="../../../javax/microedition/m3g/Mesh.html" title="class in javax.microedition.m3g"><CODE>Mesh</CODE></A> defines a 3D object, consisting of triangles with
    associated material properties.</li>
<li><A HREF="../../../javax/microedition/m3g/Sprite3D.html" title="class in javax.microedition.m3g"><CODE>Sprite3D</CODE></A> defines a screen-aligned 2D image with a position
    in 3D space.</li>
<li><A HREF="../../../javax/microedition/m3g/Light.html" title="class in javax.microedition.m3g"><CODE>Light</CODE></A> defines the position, direction, color and other
    attributes of a light source.</li>
<li><A HREF="../../../javax/microedition/m3g/Group.html" title="class in javax.microedition.m3g"><CODE>Group</CODE></A> serves as a root for scene graph branches.</li>
</ul>

<h3>Node transformation</h3>

<p>Each node defines a local coordinate system that can be transformed
relative to the coordinate system of the parent node. The transformation
<i>from</i> the local coordinate system of a node <i>to</i> the coordinate
system of its parent is called the <i>node transformation</i>.</p>

<p>The node transformation consists of four parts: a generic matrix
<b>M</b>, a non-uniform scale <b>S</b>, an orientation <b>R</b> and a
translation <b>T</b>. The bottom row of <b>M</b> must be equal to (0 0
0 1). The methods to manipulate the individual components are defined
in the base class, <A HREF="../../../javax/microedition/m3g/Transformable.html" title="class in javax.microedition.m3g">Transformable</A>.</p>

<p>To transform a point from a node's local coordinates to its
parent's coordinates, the point is multiplied by the transformation
components in the order that they are listed above. Formally, a
homogeneous vector <b>p</b> = (x, y, z, 1), representing a 3D point in
the local coordinate system, is transformed into <b>p</b>' = (x', y',
z', 1) in the parent coordinate system as follows:</p>

<ul>
<b>p</b>' = <b>T </b> <b>R </b> <b>S </b> <b>M </b> <b>p</b>
</ul>

<p>The translation, orientation and scale components of the node
transformation can be animated independently from each other. The
matrix component is not animatable at all; it can only be changed
using the <code>setTransform</code> method.</p>

<h3 class="orphan">Node alignment</h3>

<p>A node may be <i>aligned</i> with respect to a selected <i>reference
node</i> (or nodes). This means that the aligned node is, upon request,
automatically oriented so that its coordinate system matches the reference
node's coordinate system in the specified way. A common use case for node
alignment is to create "billboards" that are always facing the camera;
another is to make the camera always point at a certain object.</p>

<p>When a node is aligned, its original orientation component <b>R</b> is
overwritten with an aligned orientation <b>A</b>. (The aligned orientation
is computed as specified below, in the Implementation Guidelines section.)
The other components of the node transformation are not affected by
alignment. The transformation from the local coordinate system of an
aligned node to its parent node's coordinate system is, therefore,</p>

<ul>
<b>p</b>' = <b>T </b> <b>A </b> <b>S </b> <b>M </b> <b>p</b>
</ul>

<p>The application must explicitly call the <code>align</code> method on
a node (or any of its ancestors) when it requires the alignments of that
node and its descendants to be computed. This is typically done once per
frame, before rendering. Rendering operations do not resolve any alignments;
they simply use whatever orientation each node has at that time. The same
holds true for <code>getTransformTo</code> and any other methods whose
results depend on the orientation.</p>

<p>The alignment reference node(s) and the method of alignment are selected
with <code>setAlignment</code>. This does not yet compute the new aligned
orientation, but merely specifies how that is to be done. Optionally, the
reference node may be left unspecified (null) until when <code>align</code>
is called; the reference node is then supplied as a parameter to
<code>align</code>. This is very useful for billboards, because otherwise
the application would have to call <code>setAlignment</code> separately for
every billboard in the scene whenever the camera is changed.</p>

<h3>Inherited node properties</h3>

<p>Besides the node transformation, there are three node properties
whose effective values are in some manner influenced by the ancestors
of each node. These properties are the alpha factor, the rendering enable
flag, and the picking enable flag.</p>

<p>The <i>alpha factor</i> allows (groups of) Mesh <span
class="new">and Sprite3D</span> objects to be faded in and out in a
convenient way, provided that certain preconditions related to their
Appearance are met. The alpha factor is defined for each Node, and its
value is between [0, 1]. The effective alpha factor for <span
class="new">an object</span> is obtained by multiplying its local
alpha factor with the alpha factors of its ancestors.  The alpha
factor is ignored for <span class="new">Light and Camera</span>
nodes.</p>

<p>When rendering a Mesh, its effective alpha factor is multiplied
with the alpha component of the diffuse color in each of the Material
objects associated with that Mesh.  In absence of a Material object,
the alpha factor is applied to the <span class="new">alpha channel of
the VertexBuffer color array, or if the color array is null, the default
color alpha component.  When rendering a Sprite3D, its effective
alpha factor is multiplied with the alpha channel of the sprite image.
Note that for both meshes and sprites, only the alpha values are ever
modified.  The alpha factor alone is therefore not
sufficient for a fade-in/fade-out effect.  Instead, the texture
blending mode, the framebuffer blending mode, and the alpha threshold
must all be set appropriately.  For meshes, setting texture blending to
<code>MODULATE</code>, framebuffer blending to <code>ALPHA</code>, and
alpha threshold to zero will often produce the desired result.  Sprites
should use a non-zero alpha threshold and <code>ALPHA</code> blending
in CompositingMode.</span></p>

<p>The <i>enable flags</i> for rendering and picking allow (groups of)
mesh and sprite objects to be made "invisible" from the point of view
of rendering and picking, respectively. The effective enable status of
a node is the logical AND of the enable flags on that node and all its
ancestors. Therefore, setting the enable flag of a node to <i>true</i>
does not guarantee that the node will be rendered or picked. Rather, if
any of its ancestors are disabled, the node will be ignored regardless
of its own enable flag.</p>

<p>Note that the scope of a Node is <i>not</i> an inherited property;
see below for more information.</p>

<h3><a name="Scoping">Scoping</a></h3>

<p>The <i>scope</i> of a Node is an integer bitmask that allows scene graph
nodes to form conceptual groups independent of the scene graph hierarchy. In
other words, nodes that are in a particular Group are not necessarily in the
same scope. Formally, two nodes A and B are defined to be in the same scope
if the bitwise AND of their scopes is non-zero:</p>

<ul>
scope<font size="-1"><sub>A</sub></font>&nbsp;&amp;&nbsp;scope<font size="-1"><sub>B</sub></font>&nbsp;!=&nbsp;0
</ul>

<p>Scopes are not hierarchic in any way. In particular, the scope of
a Group or SkinnedMesh node is not propagated to or inherited by its
children. After all, scopes are intended to be separate from the scene
hierarchy.</p>

<p>Scoping serves three purposes:</p>

<ul>
<p><li><b>Visibility culling</b>. Only those objects are rendered
that are in the same scope as the Camera. This gives an additional
means to control the set of visible objects, complementary to the
rendering enable flag.</li></p>

<p><li><b>Lighting</b>. A light source only has an effect on Meshes that are
in the same scope with it. This makes it possible to have a very large
number of light sources in a scene graph without having all the lights
illuminate all meshes. Besides being impractical, that would also be
prohibitively expensive in terms of processing power.</li></p>

<p><li><b>Picking.</b> The scope of the pick ray is given as a parameter to
the <code>pick</code> methods in Group. Again, only those objects can be
picked that are in the same scope as the pick ray; the others are
ignored.</li></p>
</ul>

<p>The default scope is -1, implying that all nodes are in the same scope.
By default, all objects are therefore visible to all cameras, and are lit
by all light sources.</p>

<h3><a name="Instantiation">Instantiation</a></h3>

<p>Node is an abstract class, and therefore has no public constructor.
When a class derived from Node is instantiated, the attributes defined
in Node will have the following default values:</p>

<ul>
<li>parent node : null</li>
<li>rendering enable : <i>true</i></li>
<li>picking enable : <i>true</i></li>
<li>alpha factor : 1.0</li>
<li>scope : -1</li>
<li>alignment : <span class="new">( <code>NONE</code>, null ) for all axes</span></li>
</ul>

<h3>Implementation guidelines</h3>

<p>The alignment rotation <b>A</b> is computed relative to the initial
coordinate system A defined by the <b>T</b> component of the node
transformation alone. All other transformation components of the node
being aligned are ignored.</p>

<p>Conceptually, alignment is composed of two cumulative rotations:
the shortest rotation <b>R</b><sub>z</sub> that takes the initial Z
axis to the Z alignment target vector, followed by the rotation
<b>R</b><sub>y</sub> about the resulting Z vector that minimizes the
angle between the resulting Y axis and the Y alignment target vector.
If alignment is set for one axis only, that rotation is performed like
the initial Z rotation.</p>

<p>Formally, let us denote by <b>t</b><sub>Z</sub> and
<b>t</b><sub>Y</sub> the Z and Y alignment target vectors, transformed
from their respective reference nodes to A; note that axis targets
transform as vectors, and origin targets as points. The axis for the
first rotation <b>R</b><sub>z</sub> is then the cross product of the
local Z axis of A and the target vector:</p>

<ul>
<b>a</b><font size="-1"><sub>Z</sub></font>&nbsp;=&nbsp;(0 0 1)<sup>T</sup>&nbsp;&times;&nbsp;<b>t</b><font size="-1"><sub>Z</sub></font>
</ul>

<p>and the rotation angle can be computed via the dot product of the
two. Rotating by <b>R</b><sub>z</sub> takes us to a new coordinate frame
B where <b>t</b><sub>Y</sub> is expressed as:</p>

<ul>
<b>t</b><font size="-1"><sub>Y</sub></font>'&nbsp;=&nbsp;<b>R</b><font size="-1"><sub>Z</sub><sup>-1</sup></font>&nbsp;&times;&nbsp;<b>t</b><font size="-1"><sub>Y</sub></font>
</ul>

<p>The axis for the second rotation <b>R</b><sub>Y</sub> is the local
Z axis of B, and the angle is the angle between the local Y axis and
the projection of <b>t</b><sub>Y</sub>' on the XY plane.  The final
alignment rotation <b>A</b> is then:</p>

<ul>
<b>A</b>&nbsp;=&nbsp;<b>R</b><font size="-1"><sub>Z</sub></font>&nbsp;<b>R</b><font size="-1"><sub>Y</sub></font>
</ul>

<p>There are two cases where a rotation axis is undefined. Firstly, if
either target vector coincides with the axis that it is a target for,
the respective rotation must be substituted with an identity rotation.
Secondly, if the target vector and the axis are opposite, the exact
rotation path (that is, the resultant direction of the other two axes)
is implementation dependent, but must be deterministic. Note that the
latter only matters for unconstrained (single-axis) alignment.</p>
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><a href="../../../file-format.html#Node">Binary format</a></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#NONE">NONE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies for the <code>setAlignment</code> method that no
 alignment should be done for the specified axis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#ORIGIN">ORIGIN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the origin of the reference node as an orientation 
 reference for the <code>setAlignment</code> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#X_AXIS">X_AXIS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the X axis of the reference node as an orientation
 reference for the <code>setAlignment</code> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#Y_AXIS">Y_AXIS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the Y axis of the reference node as an orientation
 reference for the <code>setAlignment</code> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#Z_AXIS">Z_AXIS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies the Z axis of the reference node as an orientation
 reference for the <code>setAlignment</code> method.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#align(javax.microedition.m3g.Node)">align</A></B>(<A HREF="../../../javax/microedition/m3g/Node.html" title="class in javax.microedition.m3g">Node</A>&nbsp;reference)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Applies alignments to this Node and its descendants.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/microedition/m3g/Node.html" title="class in javax.microedition.m3g">Node</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#getAlignmentReference(int)">getAlignmentReference</A></B>(int&nbsp;axis)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">Returns the alignment reference node for
 the given axis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#getAlignmentTarget(int)">getAlignmentTarget</A></B>(int&nbsp;axis)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="new">Returns the alignment target for the given
 axis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#getAlphaFactor()">getAlphaFactor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the alpha factor of this Node. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/microedition/m3g/Node.html" title="class in javax.microedition.m3g">Node</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#getParent()">getParent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the scene graph parent of this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#getScope()">getScope</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the scope of this Node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#getTransformTo(javax.microedition.m3g.Node, javax.microedition.m3g.Transform)">getTransformTo</A></B>(<A HREF="../../../javax/microedition/m3g/Node.html" title="class in javax.microedition.m3g">Node</A>&nbsp;target,
               <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the composite transformation from this node to the given node.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#isPickingEnabled()">isPickingEnabled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the picking enable flag of this Node. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#isRenderingEnabled()">isRenderingEnabled</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the rendering enable flag of this Node. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#setAlignment(javax.microedition.m3g.Node, int, javax.microedition.m3g.Node, int)">setAlignment</A></B>(<A HREF="../../../javax/microedition/m3g/Node.html" title="class in javax.microedition.m3g">Node</A>&nbsp;zRef,
             int&nbsp;zTarget,
             <A HREF="../../../javax/microedition/m3g/Node.html" title="class in javax.microedition.m3g">Node</A>&nbsp;yRef,
             int&nbsp;yTarget)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets this node to align with the given other node(s), or disables
 alignment. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#setAlphaFactor(float)">setAlphaFactor</A></B>(float&nbsp;alphaFactor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the alpha factor for this Node. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#setPickingEnable(boolean)">setPickingEnable</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the picking enable flag of this Node. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#setRenderingEnable(boolean)">setRenderingEnable</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the rendering enable flag of this Node. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/microedition/m3g/Node.html#setScope(int)">setScope</A></B>(int&nbsp;scope)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the scope of this node. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.microedition.m3g.Transformable"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class javax.microedition.m3g.<A HREF="../../../javax/microedition/m3g/Transformable.html" title="class in javax.microedition.m3g">Transformable</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/microedition/m3g/Transformable.html#getCompositeTransform(javax.microedition.m3g.Transform)">getCompositeTransform</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getOrientation(float[])">getOrientation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getScale(float[])">getScale</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getTransform(javax.microedition.m3g.Transform)">getTransform</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#getTranslation(float[])">getTranslation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#postRotate(float, float, float, float)">postRotate</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#preRotate(float, float, float, float)">preRotate</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#scale(float, float, float)">scale</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setOrientation(float, float, float, float)">setOrientation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setScale(float, float, float)">setScale</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setTransform(javax.microedition.m3g.Transform)">setTransform</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#setTranslation(float, float, float)">setTranslation</A>, <A HREF="../../../javax/microedition/m3g/Transformable.html#translate(float, float, float)">translate</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.microedition.m3g.Object3D"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class javax.microedition.m3g.<A HREF="../../../javax/microedition/m3g/Object3D.html" title="class in javax.microedition.m3g">Object3D</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/microedition/m3g/Object3D.html#addAnimationTrack(javax.microedition.m3g.AnimationTrack)">addAnimationTrack</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#animate(int)">animate</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#duplicate()">duplicate</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#find(int)">find</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getAnimationTrack(int)">getAnimationTrack</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getAnimationTrackCount()">getAnimationTrackCount</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getReferences(javax.microedition.m3g.Object3D[])">getReferences</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getUserID()">getUserID</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#getUserObject()">getUserObject</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#removeAnimationTrack(javax.microedition.m3g.AnimationTrack)">removeAnimationTrack</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#setUserID(int)">setUserID</A>, <A HREF="../../../javax/microedition/m3g/Object3D.html#setUserObject(java.lang.Object)">setUserObject</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="NONE"><!-- --></A><H3>
NONE</H3>
<PRE>
public static final int <B>NONE</B></PRE>
<DL>
<DD><p>Specifies for the <code>setAlignment</code> method that no
 alignment should be done for the specified axis.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Node.NONE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="ORIGIN"><!-- --></A><H3>
ORIGIN</H3>
<PRE>
public static final int <B>ORIGIN</B></PRE>
<DL>
<DD><p>Specifies the origin of the reference node as an orientation 
 reference for the <code>setAlignment</code> method.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Node.ORIGIN">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="X_AXIS"><!-- --></A><H3>
X_AXIS</H3>
<PRE>
public static final int <B>X_AXIS</B></PRE>
<DL>
<DD><p>Specifies the X axis of the reference node as an orientation
 reference for the <code>setAlignment</code> method.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Node.X_AXIS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="Y_AXIS"><!-- --></A><H3>
Y_AXIS</H3>
<PRE>
public static final int <B>Y_AXIS</B></PRE>
<DL>
<DD><p>Specifies the Y axis of the reference node as an orientation
 reference for the <code>setAlignment</code> method.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Node.Y_AXIS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="Z_AXIS"><!-- --></A><H3>
Z_AXIS</H3>
<PRE>
public static final int <B>Z_AXIS</B></PRE>
<DL>
<DD><p>Specifies the Z axis of the reference node as an orientation
 reference for the <code>setAlignment</code> method.</p>
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#javax.microedition.m3g.Node.Z_AXIS">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="setRenderingEnable(boolean)"><!-- --></A><H3>
setRenderingEnable</H3>
<PRE>
public void <B>setRenderingEnable</B>(boolean&nbsp;enable)</PRE>
<DL>
<DD><p>Sets the rendering enable flag of this Node. The effective
 rendering enable status for this node is the logical AND of the
 enable flags on this node and all its ancestors. Therefore, the
 node is disabled if any of its ancestors are. The node's own
 status has an effect only if all the ancestors are enabled.</p>

 <p>If the effective status is <i>true</i>, this node is enabled
 for rendering; otherwise, it is disabled. Sprite3D, Mesh and Light
 nodes are turned on and off with this setting, but on Camera
 nodes it is ignored.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enable</CODE> - <i>true</i> to enable rendering; <i>false</i> to disable</DL>
</DD>
</DL>
<HR>

<A NAME="setPickingEnable(boolean)"><!-- --></A><H3>
setPickingEnable</H3>
<PRE>
public void <B>setPickingEnable</B>(boolean&nbsp;enable)</PRE>
<DL>
<DD><p>Sets the picking enable flag of this Node. The effective
 picking enable status for this node is the logical AND of the
 enable flags on this node and all its ancestors. Therefore, the
 node is disabled if any of its ancestors are. The node's own
 status has an effect only if all the ancestors are enabled.</p>

 <p>If the effective status is <i>true</i>, this node is enabled
 for picking; otherwise, it is disabled. This setting is ignored
 for Lights and Cameras, because they are unpickable in any case.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enable</CODE> - <i>true</i> to enable picking; <i>false</i> to disable</DL>
</DD>
</DL>
<HR>

<A NAME="setScope(int)"><!-- --></A><H3>
setScope</H3>
<PRE>
public void <B>setScope</B>(int&nbsp;scope)</PRE>
<DL>
<DD><p>Sets the scope of this node. The scope is used to limit the
 set of nodes that are taken into account in rendering, lighting
 and picking. See the class description for more information.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scope</CODE> - the new scope for this node<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Node.html#getScope()"><CODE>getScope</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="setAlphaFactor(float)"><!-- --></A><H3>
setAlphaFactor</H3>
<PRE>
public void <B>setAlphaFactor</B>(float&nbsp;alphaFactor)</PRE>
<DL>
<DD><p>Sets the alpha factor for this Node. This can be used to
 fade groups of meshes <span class="new">and sprites</span> in
 and out. The alpha factor has no effect on <span
 class="new">Light and Camera</span> nodes. See the class
 description for more information.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>alphaFactor</CODE> - the new alpha factor for this node; must be [0, 1]
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>alphaFactor</code> is
         negative or greater than 1.0<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Node.html#getAlphaFactor()"><CODE>getAlphaFactor</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isRenderingEnabled()"><!-- --></A><H3>
isRenderingEnabled</H3>
<PRE>
public boolean <B>isRenderingEnabled</B>()</PRE>
<DL>
<DD><p>Retrieves the rendering enable flag of this Node. Note that
 this is not the effective rendering enable status, but only the
 local status of this Node.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the rendering enable flag of this Node<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Node.html#setRenderingEnable(boolean)"><CODE>setRenderingEnable</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="isPickingEnabled()"><!-- --></A><H3>
isPickingEnabled</H3>
<PRE>
public boolean <B>isPickingEnabled</B>()</PRE>
<DL>
<DD><p>Retrieves the picking enable flag of this Node. Note that
 this is not the effective picking enable status, but only the
 local status of this Node.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the picking enable flag of this Node<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Node.html#setPickingEnable(boolean)"><CODE>setPickingEnable</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getScope()"><!-- --></A><H3>
getScope</H3>
<PRE>
public int <B>getScope</B>()</PRE>
<DL>
<DD><p>Retrieves the scope of this Node.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the current scope of this Node<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Node.html#setScope(int)"><CODE>setScope</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAlphaFactor()"><!-- --></A><H3>
getAlphaFactor</H3>
<PRE>
public float <B>getAlphaFactor</B>()</PRE>
<DL>
<DD><p>Retrieves the alpha factor of this Node. Note that this is
 not the effective alpha factor, but only the local alpha factor
 of this Node. To put it another way, the alpha factors of any
 ancestors to this Node are not multiplied in.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the alpha factor of this node; [0, 1]<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Node.html#setAlphaFactor(float)"><CODE>setAlphaFactor</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getParent()"><!-- --></A><H3>
getParent</H3>
<PRE>
public <A HREF="../../../javax/microedition/m3g/Node.html" title="class in javax.microedition.m3g">Node</A> <B>getParent</B>()</PRE>
<DL>
<DD><p>Returns the scene graph parent of this node.</p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>reference to the parent node, or null if there is no parent</DL>
</DD>
</DL>
<HR>

<A NAME="getTransformTo(javax.microedition.m3g.Node, javax.microedition.m3g.Transform)"><!-- --></A><H3>
getTransformTo</H3>
<PRE>
public boolean <B>getTransformTo</B>(<A HREF="../../../javax/microedition/m3g/Node.html" title="class in javax.microedition.m3g">Node</A>&nbsp;target,
                              <A HREF="../../../javax/microedition/m3g/Transform.html" title="class in javax.microedition.m3g">Transform</A>&nbsp;transform)</PRE>
<DL>
<DD><p>Gets the composite transformation from this node to the given node.
 The composite transformation is defined to be such that it transforms
 a point in the local coordinate system of this node to the coordinate
 system of the given node. For example, the composite transformation
 from this node to its parent is equal to the node transformation of
 this node. Similarly, the composite transformation from this node to
 its child is equal to the inverse of the node transformation of the
 child.</p>

 <p>If there is no path from this node to the given node, this method
 returns <i>false</i>. On the other hand, if there is a path but the
 transformation cannot be computed due to a singular transformation,
 an ArithmeticException is thrown. Beware that a transformation that
 is invertible in one implementation may not be invertible in another,
 because of different arithmetic accuracy. To be safe, avoid matrix
 elements with very small or very large absolute values. See also the
 <a href="package-summary.html#NumericRange">package description</a>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>target</CODE> - transformation target node<DD><CODE>transform</CODE> - transform object to receive the transformation; if
        there is no path to the target node, the contents of the object
        are left undefined
<DT><B>Returns:</B><DD><i>true</i> if the returned transformation is valid;
         <i>false</i> if there is no path from this node to the
         target node
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>target</code> is null
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>transform</code> is null
<DD><CODE>java.lang.ArithmeticException</CODE> - if the inverse of a transformation along
         the path is required, but can not be computed</DL>
</DD>
</DL>
<HR>

<A NAME="align(javax.microedition.m3g.Node)"><!-- --></A><H3>
align</H3>
<PRE>
public final void <B>align</B>(<A HREF="../../../javax/microedition/m3g/Node.html" title="class in javax.microedition.m3g">Node</A>&nbsp;reference)</PRE>
<DL>
<DD><p>Applies alignments to this Node and its descendants.</p>

 <p>The aligned orientation for this node and all its descendants
 are calculated in an undefined order. The rare case where there
 are chains of dependencies between aligned objects is therefore
 not necessarily taken into account.</p>

 <p>The orientation component of the node transformation of each
 aligned node is overwritten with the aligned orientation. The
 pre-existing orientation is not preserved.</p>

 <p>A reference node can be passed in to this method, in order to
 allow alignment of objects to a common reference that is determined
 at run time. This is usually used to align items to the active
 camera, for use as billboards or impostors. Since the active
 camera can change, a reference to it cannot be directly encoded in
 the scene graph. Instead, it is passed in as an argument to this
 method.</p>

 <p>See the class description and <code>setAlignment</code> for more
 information on how to set up and apply alignments.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reference</CODE> - a node to serve as a common alignment reference
        for nodes that have no fixed reference in either or both
        axes, or null to use this node as the common reference
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>reference</code>
         is not in the same scene graph as this node
<DD><CODE>java.lang.IllegalStateException</CODE> - if the <code>zRef</code> or
         <code>yRef</code> node of any aligned node is not
         in the same scene graph as the aligned node
<DD><CODE>java.lang.IllegalStateException</CODE> - if any node is aligned to itself
         or its descendant (note: this applies to null alignment
         references, as well)
<DD><CODE>java.lang.ArithmeticException</CODE> - if a transformation required in the
         alignment computations cannot be computed</DL>
</DD>
</DL>
<HR>

<A NAME="setAlignment(javax.microedition.m3g.Node, int, javax.microedition.m3g.Node, int)"><!-- --></A><H3>
setAlignment</H3>
<PRE>
public void <B>setAlignment</B>(<A HREF="../../../javax/microedition/m3g/Node.html" title="class in javax.microedition.m3g">Node</A>&nbsp;zRef,
                         int&nbsp;zTarget,
                         <A HREF="../../../javax/microedition/m3g/Node.html" title="class in javax.microedition.m3g">Node</A>&nbsp;yRef,
                         int&nbsp;yTarget)</PRE>
<DL>
<DD><p>Sets this node to align with the given other node(s), or disables
 alignment. Alignment can be used, for example, for automatic "look at"
 behavior for the camera or a spot light, and to create "billboards"
 that are always facing the active camera directly.</p>

 <p>Alignment can be set or disabled for one or both of the Y and Z axes.
 If it is set for both, the Z alignment is applied first, followed by the
 Y alignment. The Y alignment is constrained by the Z alignment. If
 alignment is set for one axis only, it is unconstrained.</p>

 <p>Alignment can be disabled for either or both axes by setting
 the respective alignment targets to <code>NONE</code>. If both
 alignments are disabled, the orientation is left at its present
 state. The original unaligned orientation is <i>not</i> restored.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>zRef</CODE> - the node to use as reference for aligning the Z axis
        of this node, or null to use instead the reference node
        passed as an argument to the <code>align</code> method<DD><CODE>zTarget</CODE> - the axis of <code>zRef</code> to align the Z axis
        of this node with, or <code>ORIGIN</code> to have the Z
        axis point at the origin of <code>zRef</code>, or
        <code>NONE</code> to not align the Z axis at all<DD><CODE>yRef</CODE> - the Y axis equivalent of <code>zRef</code><DD><CODE>yTarget</CODE> - the Y axis equivalent of <code>zTarget</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>yTarget</code> or
         <code>zTarget</code> is not one of the symbolic constants
         listed above
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>(zRef == yRef) &&
         (zTarget == yTarget != NONE)</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>zRef</code> or
         <code>yRef</code> is this Node<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Node.html#align(javax.microedition.m3g.Node)"><CODE><span class="new">align</span></CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Node.html#getAlignmentTarget(int)"><CODE><span class="new">getAlignmentTarget</span></CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Node.html#getAlignmentReference(int)"><CODE><span class="new">getAlignmentReference</span></CODE></A><DT><b>Example:</b><DD><div class="example_title">Common use cases for node alignment.
 
 </div><pre class="example">setAlignment(<span class="example_literal">null</span>, <span class="example_class">Node</span>.<span class="example_constant">NONE</span>, <span class="example_literal">null</span>, <span class="example_class">Node</span>.<span class="example_constant">NONE</span>);         <span class="example_comment">// Disabled</span>
 setAlignment(<span class="example_literal">null</span>, <span class="example_class">Node</span>.<span class="example_constant">Z_AXIS</span>, <span class="example_literal">null</span>, <span class="example_class">Node</span>.<span class="example_constant">Y_AXIS</span>);     <span class="example_comment">// "Sprite"</span>
 setAlignment(<span class="example_literal">null</span>, <span class="example_class">Node</span>.<span class="example_constant">ORIGIN</span>, world, <span class="example_class">Node</span>.<span class="example_constant">Y_AXIS</span>);    <span class="example_comment">// Billboard</span>
 setAlignment(target, <span class="example_class">Node</span>.<span class="example_constant">ORIGIN</span>, target, <span class="example_class">Node</span>.<span class="example_constant">NONE</span>);   <span class="example_comment">// Target light</span>
 setAlignment(target, <span class="example_class">Node</span>.<span class="example_constant">ORIGIN</span>, world, <span class="example_class">Node</span>.<span class="example_constant">Y_AXIS</span>);  <span class="example_comment">// Target camera</span>
  
 <span class="example_comment">// NOTE 1:</span>
 <span class="example_comment">// The billboard alignment example requires that world space "up"</span>
 <span class="example_comment">// is Y and billboard space "up" is Z, so that the Z alignment is</span>
 <span class="example_comment">// constrained by the Y alignment and not vice versa. Otherwise,</span>
 <span class="example_comment">// the billboard will not stand upright as the camera passes from</span>
 <span class="example_comment">// above or below; instead, it will lean over and eventually lie</span>
 <span class="example_comment">// flat on the ground. The M component of the billboard's node</span>
 <span class="example_comment">// transformation can be used to rotate the billboard into the</span>
 <span class="example_comment">// right orientation; the R component can not, because it gets</span>
 <span class="example_comment">// overwritten by the aligned orientation. Another option is to</span>
 <span class="example_comment">// use an extra Group node.</span>
 
 <span class="example_comment">// NOTE 2:</span>
 <span class="example_comment">// A camera or light is always facing towards its negative Z axis</span>
 <span class="example_comment">// in its local coordinate system. To make the target camera and</span>
 <span class="example_comment">// light alignments work as expected, the Z axis must be made to</span>
 <span class="example_comment">// point in the opposite direction. This can be done by rotating</span>
 <span class="example_comment">// the node 180 degrees about its local Y axis. This, in turn,</span>
 <span class="example_comment">// can be done as described in Note 1 (above), or somewhat more</span>
 <span class="example_comment">// conveniently, using the scale (S) component:</span>
 
 camera.scale(-1, 1, -1);    <span class="example_comment">// rotate 180 degrees about the Y axis</span></pre></DD></DD></DL>
</DD>
</DL>
<HR>

<A NAME="getAlignmentTarget(int)"><!-- --></A><H3>
getAlignmentTarget</H3>
<PRE>
public int <B>getAlignmentTarget</B>(int&nbsp;axis)</PRE>
<DL>
<DD><span class="new">Returns the alignment target for the given
 axis.</span>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>axis</CODE> - <span class="new">the node axis to query the target
 for; one of <code>Y_AXIS</code> and <code>Z_AXIS</code></span>
<DT><B>Returns:</B><DD><span class="new">the alignment target; one of the
 symbolic constants allowed for the <code>zTarget</code> and
 <code>yTarget</code> parameters of <code>setAlignment</code></span>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - <span class="new">if
 <code>axis</code> is not one of the symbolic constants listed
 for <code>axis</code> above</span><DT><B>Since:</B></DT>
  <DD><span class="new">M3G 1.1</span></DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Node.html#setAlignment(javax.microedition.m3g.Node, int, javax.microedition.m3g.Node, int)"><CODE><span class="new">setAlignment</span></CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Node.html#align(javax.microedition.m3g.Node)"><CODE><span class="new">align</span></CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getAlignmentReference(int)"><!-- --></A><H3>
getAlignmentReference</H3>
<PRE>
public <A HREF="../../../javax/microedition/m3g/Node.html" title="class in javax.microedition.m3g">Node</A> <B>getAlignmentReference</B>(int&nbsp;axis)</PRE>
<DL>
<DD><span class="new">Returns the alignment reference node for
 the given axis.</span>

 <p class="new">Note that alignment reference nodes are
 <em>not</em> returned in a call to <code>getReferences</code>.</p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>axis</CODE> - <span class="new">the node axis to query the reference
 node for; one of <code>Y_AXIS</code> and <code>Z_AXIS</code></span>
<DT><B>Returns:</B><DD><span class="new">the alignment reference node</span>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - <span class="new">if
 <code>axis</code> is not one of the symbolic constants listed
 for <code>axis</code> above</span><DT><B>Since:</B></DT>
  <DD><span class="new">M3G 1.1</span></DD>
<DT><B>See Also:</B><DD><A HREF="../../../javax/microedition/m3g/Node.html#setAlignment(javax.microedition.m3g.Node, int, javax.microedition.m3g.Node, int)"><CODE><span class="new">setAlignment</span></CODE></A>, 
<A HREF="../../../javax/microedition/m3g/Node.html#align(javax.microedition.m3g.Node)"><CODE><span class="new">align</span></CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Node.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<EM><B>M3G 1.1 -- Jun 22, 2005</B></EM></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/microedition/m3g/MorphingMesh.html" title="class in javax.microedition.m3g"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/microedition/m3g/Object3D.html" title="class in javax.microedition.m3g"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Node.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<EM>Copyright &copy; 2005 Nokia Corporation. See the <a href="../../../overview-summary.html#Copyright">Copyright Notice</a> for details.</EM>
</BODY>
</HTML>
